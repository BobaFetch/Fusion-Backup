Attribute VB_Name = "DatabaseUtil"
Option Explicit

Public Const DB_VERSION = 192

Public sSaAdmin As String
Public sSaPassword As String
Public sserver As String
Public sDataBase As String
Public sSysCaption As String
Public sProgName As String
Public sDsn As String
Public sConStr As String
'version info
Private oldType As String     'live or test
Private NewType As String
Private oldRelease As Long
Private newRelease As Long
Private OldDbVersion As Integer
Private directory As String
Private newver As Long

Public ES_PARTCOUNT As Long 'Total Customer Part Numbers

Type ModuleErrors
   Number As Long
   Description As String
End Type

Public CurrError As ModuleErrors

' ES/2000 Company Info Datatype

Type CompanyInfo
   Name As String
   Addr(5) As String
   Phone As String
   Fax As String
   GlVerify As Byte
End Type

Global Co As CompanyInfo

Type CurrentSelections
   CurrentPart As String
   CurrentVendor As String
   CurrentCustomer As String
   CurrentShop As String
   CurrentRegion As String
   CurrentGroup As String
   CurrentUser As String
End Type

Public cUR As CurrentSelections
Private ver As Long

Function OpenDBServer(Optional bReStart As Boolean) As Boolean
   'return = True if successful
   
   Dim strWindowDir As String
   Dim strSaAdmin As String
   Dim strSaPassword As String
   Dim strServer As String
   Dim strDBName As String
   Dim strConStr As String
   Dim ErrNum    As Long
   Dim ErrDesc   As String
   
   'Dim RdoCheck As ADODB.Recordset
   Dim b As Byte
   Dim CloseExit As Long
   Dim iTimeOut As Integer
   Dim sWindows As String
   
   
   
   MouseCursor ccHourglass
   'strWindowDir = GetWindowsDir()
   'sserver = UCase$(GetSetting("Esi2000", "System", "ServerId", sserver))
   ' DNS sserver = UCase(GetUserSetting(USERSETTING_ServerName))
   sserver = UCase(GetConfUserSetting(USERSETTING_ServerName))
   
   sSaAdmin = Trim(GetSysLogon(True))
   sSaPassword = Trim(GetSysLogon(False))
   ' GetCurrentDatabase method fills sDatabase
   GetCurrentDatabase
   strDBName = sDataBase
   
   
'Public sSaAdmin As String
'Public sSaPassword As String
'Public sserver As String
   
   Set clsADOCon = New ClassFusionADO
   
'    strConStr = "Provider='sqloledb';Data Source='" & strServer & "';" & _
'        "Initial Catalog='" & strDBName & "';Integrated Security='SSPI';"

   strConStr = "Driver={SQL Server};Provider='sqloledb';UID=" & sSaAdmin & ";PWD=" & _
            sSaPassword & ";SERVER=" & sserver & ";DATABASE=" & strDBName & ";"
   
   'MsgBox strConStr
   
   If clsADOCon.OpenConnection(strConStr, ErrNum, ErrDesc) = False Then
     MsgBox "An error occured while trying to connect to the specified database:" & Chr(13) & Chr(13) & _
            "Error Number = " & CStr(ErrNum) & Chr(13) & _
            "Error Description = " & ErrDesc, vbOKOnly + vbExclamation, "  DB Connection Error"
     GoTo CleanUp
   End If
   
   sConStr = strConStr
   SaveSetting "Esi2000", "System", "CloseSection", ""
   
   Dim TestDatabase As Boolean
   TestDatabase = IsADOTestDatabase()
      
   Dim RdoCheck As ADODB.Recordset
   If bReStart = 0 Then
      'Get Count of Parts to see how combo's are to be handled
      sSql = "SELECT COUNT(PARTREF) FROM PartTable"
      bSqlRows = clsADOCon.GetDataSet(sSql, RdoCheck, ES_FORWARD)
      If bSqlRows Then
         If Not IsNull(RdoCheck.Fields(0)) Then _
                       ES_PARTCOUNT = RdoCheck.Fields(0) Else _
                       ES_PARTCOUNT = 0
      End If
' Mohan Commented
      'GetDataBases
      'UpdateTables
      b = CheckSecuritySettings()
'      'If b = 0 Then GetSectionPermissions
      GetCompany 1
      On Error GoTo modErr1
      GetCustomerPermissions
      MdiSect.Caption = GetSystemCaption
   Else
      'MouseCursor ccArrow
   End If
      
      
   OpenDBServer = True
   Exit Function
   
modErr1:
   Resume modErr2
modErr2:
   'Couldn't open msdb
   For b = 1 To 8
      bCustomerGroups(b) = 1
   Next
   Set clsADOCon = Nothing
   Exit Function

CleanUp:
 'clsADOCon.CleanupRecordset RS
 Set clsADOCon = Nothing

End

End Function

Public Function IsADOTestDatabase() As Boolean
   'returns true if using a test database
   
   
   On Error Resume Next
   clsADOCon.ADOErrNum = 0
   sSql = "select TestDatabase from Version"
   Dim rs As ADODB.Recordset
   Dim TestDatabase As Boolean
   If clsADOCon.GetDataSet(sSql, rs) Then
      If clsADOCon.ADOErrNum = 0 Then
         IsADOTestDatabase = IIf(rs(0) = 1, True, False)
      Else
         clsADOCon.ExecuteSql ("alter table Version add TestDatabase tinyint not null default 0")
      End If
   End If
   
End Function

'Private Function CheckDateVersion(OldDbVersion As Integer, NewDbVersion As Integer) As Boolean
'   'terminates if cannot proceed.
'   'returns false if no update required
'   'returns true if update required and authorized by and admin
'   Err.Clear
'
'   Dim strFulVer As String
'   clsADOCon.ADOErrNum = 0
'   sSql = "select * from Updates" & vbCrLf _
'      & "where UpdateID = (select max(UpdateID) from Updates)"
'   On Error Resume Next
'   Dim rdo As ADODB.Recordset
'   If clsADOCon.GetDataSet(sSql, rdo) Then
'      If clsADOCon.ADOErrNum = 0 Then
'         oldRelease = rdo!newRelease
'      End If
'   Else
'      oldRelease = 0
'   End If
'
'   If IsTestDatabase Then
'      oldType = "Test"
'   Else
'      oldType = "Live"
'   End If
'
'   If App.Minor < 10 Then
'    strFulVer = CStr(App.Major) & "0" & CStr(App.Minor)
'   Else
'    strFulVer = CStr(App.Major) & CStr(App.Minor)
'   End If
'
'   newRelease = CInt(strFulVer)
'
'   If InTestMode() Then
'      NewType = "Test"
'   Else
'      NewType = "Live"
'   End If
'
'   Dim msg As String
'   If oldRelease < newRelease Then
'      msg = "Old release (" & oldRelease & ") < New release (" & newRelease & ")" & vbCrLf
'   ElseIf oldRelease > newRelease Then
'
'      MsgBox "Old release (" & oldRelease & ") > New release (" & newRelease & ")" & vbCrLf _
'         & "You cannot proceed.", vbCritical
'      End
'   End If
'
'   If OldDbVersion < NewDbVersion Then
'      msg = msg & "Old db version (" & OldDbVersion & ") < New db version (" & NewDbVersion & ")" & vbCrLf
'   ElseIf OldDbVersion > NewDbVersion Then
'
'      MsgBox "Old db version (" & OldDbVersion & ") > New db version (" & NewDbVersion & ")" & vbCrLf _
'         & "You cannot proceed.", vbCritical
'      End
'   End If
'
'   If oldType <> NewType Then
'      msg = msg & "Db type (" & oldType & ") <> Application type (" & NewType & ")" & vbCrLf
'   End If
'
'   If msg = "" Then
'      CheckDateVersion = False
'      Exit Function
'
'   Else
'      If Secure.UserAdmn = 0 Then
'         msg = msg & "An administrator must perform an update before you can proceed."
'         MsgBox msg, vbCritical
'         End
'      Else
'         msg = msg & "Do you wish to update the database now?"
'         Select Case MsgBox(msg, vbYesNo + vbQuestion + vbDefaultButton2)
'         Case vbYes
'            CheckDateVersion = True
'         Case Else
'            End
'         End Select
'      End If
'   End If
'
'End Function


Private Sub ExecuteScript(DisplayError As Boolean, SQL As String)
   Err.Clear
   On Error Resume Next

   'display version being updated to
   Dim display As String
   display = "Updating database to version " & newver
   If Left(SysMsgBox.msg, Len(display)) = display Then
      SysMsgBox.msg = SysMsgBox.msg & "."
   Else
      SysMsgBox.msg = display
   End If
   SysMsgBox.Refresh
   DoEvents
   
   Dim saveSql As String
   saveSql = SQL
   
   clsADOCon.ExecuteSql saveSql
   'RdoCon.Execute saveSql
   
   DoEvents

   'display error if required
   'always display a timeout error
   If Err Then
      Debug.Print CStr(Err.Number) & ": " & "  " & Err.Description & vbCrLf & " SQL: " & SQL
      Dim msg As String
      If RunningInIDE() Or DisplayError Or InStr(1, Err.Description, "timeout expired", vbTextCompare) > 0 Then
         msg = "Database version " & ver & " update failed with error " & CStr(Err.Number) & vbCrLf _
            & Err.Description & vbCrLf
         If InStr(1, Err.Description, "timeout expired", vbTextCompare) > 0 Then
            msg = msg & clsADOCon.CommandTimeout & " second timeout occurred performing database update." & vbCrLf
         End If
         msg = msg & "It is important that this information be captured and reported." & vbCrLf & vbCrLf _
            & "SQL: " & SQL
         MsgBox msg, vbCritical, "Critical Database Version " & ver & " Update Failure"
      End If
   End If
End Sub


Private Sub AlterNumericColumn(TableName As String, ColumnName As String, NewType As String)
   'remove default constraint if any, alter column, and add a default of zero
   'example:
   'AlterNumericColumn "RunsTable", "RUNEXP", "decimal(12,4) null"
   
   'drop defaults created by alter table, if any
   ExecuteScript False, "exec DropColumnDefault '" & TableName & "', '" & ColumnName & "'"
   'drop defaults created by sp_binddefault (DEFZERO and DEFBLANK)
   ExecuteScript False, "exec sp_unbindefault '" & TableName & "." & ColumnName & "'"
   'alter the column
   ExecuteScript False, "alter table " & TableName & " alter column " & ColumnName _
      & " " & NewType
   'add a zero constraint back
   ExecuteScript False, "alter table " & TableName & " add constraint DF_" & TableName & "_" _
      & ColumnName & " default 0 for " & ColumnName
   
End Sub

Private Sub AlterStringColumn(TableName As String, ColumnName As String, NewType As String)
   'remove default constraint if any, alter column, and add a default of blank
   'example:
   'AlterStringColumn "RndlTable", "RUNDLSDOCREF", "varchar(30)"
   
   'drop defaults created by alter table, if any
   ExecuteScript False, "exec DropColumnDefault '" & TableName & "', '" & ColumnName & "'"
   'drop defaults created by sp_binddefault (DEFZERO and DEFBLANK)
   ExecuteScript False, "exec sp_unbindefault '" & TableName & "." & ColumnName & "'"
   'alter the column
   ExecuteScript False, "alter table " & TableName & " alter column " & ColumnName _
      & " " & NewType & " NULL"
   'add a blank constraint back
   ExecuteScript False, "alter table " & TableName & " add constraint DF_" & TableName & "_" _
      & ColumnName & " default '' for " & ColumnName
   
End Sub

Private Sub DropColumnDefault(TableName As String, ColumnName As String)
   'remove default constraint, if any, from a column
   
   'drop defaults created by alter table, if any
   ExecuteScript False, "exec DropColumnDefault '" & TableName & "', '" & ColumnName & "'"
   'drop defaults created by sp_binddefault (DEFZERO and DEFBLANK)
   ExecuteScript False, "exec sp_unbindefault '" & TableName & "." & ColumnName & "'"
   
End Sub

Public Function ColumnExists(TableName As String, ColumnName As String) As Boolean
   'returns True if column exists
   
   sSql = "SELECT 1 FROM information_schema.Columns" & vbCrLf _
      & "WHERE COLUMN_NAME = '" & ColumnName & "'" & "AND TABLE_NAME = '" & TableName & "'"
   Dim rdo As ADODB.Recordset
   If clsADOCon.GetDataSet(sSql, rdo) Then
      ColumnExists = True
   End If
End Function

Public Function TableExists(strTableName As String) As Boolean
   'returns True if column exists
   'On Error Resume Next
   Err.Clear
   clsADOCon.ADOErrNum = 0
   sSql = "SELECT * FROM INFORMATION_SCHEMA.TABLES where TABLE_NAME = '" & strTableName & "'"
   Dim rdo As ADODB.Recordset
   bSqlRows = clsADOCon.GetDataSet(sSql, rdo)
   If bSqlRows Then
      TableExists = True
   Else
      TableExists = False
   End If
   Set rdo = Nothing
   'clsADOCon.ADOErrNum = 0
End Function

Public Function StoreProcedureExists(strSPName As String) As Boolean
   'returns True if store procedure exists
   On Error Resume Next
   Err.Clear
   sSql = "Select * From SysObjects Where Type = 'P' and Name='" & strSPName & "'"
   Dim rdo As ADODB.Recordset
   bSqlRows = clsADOCon.GetDataSet(sSql, rdo)
   If bSqlRows Then
      StoreProcedureExists = True
   Else
      StoreProcedureExists = False
   End If
End Function

Public Function GetSysLogon(bGetLogin As Byte) As String
   'get database login info
   'if bGetLogin = 0 then get the password
   'if bGetLogin = 1 then get the login
   
   Dim A As Integer
   Dim iLen As Integer
   Dim sTest As String
   Dim sNewString As String
   Dim sPassword As String
   
   If bGetLogin <> 0 Then
      'GetSysLogon = GetSetting("UserObjects", "System", "NoReg", GetSysLogon)
      ' DNS GetSysLogon = GetUserSetting(USERSETTING_SqlLogin)
      GetSysLogon = GetConfUserSetting(USERSETTING_SqlLogin)
      
      If Trim(GetSysLogon) = "" Then GetSysLogon = "sa"
   Else
      ' DNS sPassword = GetDatabasePassword
      sPassword = GetConfigDBPass
      GetSysLogon = sPassword
   End If
   
End Function

' Calls the windows API to get the windows directory and
' ensures that a trailing dir separator is present
' Returns: The windows directory

Public Function GetWindowsDir()
   Dim intZeroPos As Integer
   Dim gintMAX_SIZE As Integer
   Dim strBuf As String
   gintMAX_SIZE = 255 'Maximum buffer size
   
   strBuf = Space$(gintMAX_SIZE)
   'Get the windows directory and then trim the buffer to the exact length
   'returned and add a dir sep (backslash) if the API didn't return one
   If GetWindowsDirectory(strBuf, gintMAX_SIZE) > 0 Then
      intZeroPos = InStr(strBuf, Chr$(0))
      If intZeroPos > 0 Then strBuf = Left$(strBuf, intZeroPos - 1)
      GetWindowsDir = strBuf
   Else
      GetWindowsDir = ""
   End If
   
End Function

Public Function GetSystemCaption() As String
   If InTestMode() Then
      GetSystemCaption = "TEST MODE "
   End If
   'GetSystemCaption = GetSystemCaption & "ES/2000 ERP"
   If sProgName = "" Then
      GetSystemCaption = GetSystemCaption & "Fusion ERP"
   Else
      GetSystemCaption = GetSystemCaption & sProgName
   End If
   If sDataBase <> "" Then
      GetSystemCaption = GetSystemCaption & " - " & sDataBase
   End If
   
   ' add version
   GetSystemCaption = GetSystemCaption & " - v " & App.Major & "." & App.Minor & "." & App.Revision
End Function

Public Sub GetCurrentDatabase()
'Database
'sDataBase = GetSetting("Esi2000", "System", "CurDatabase", sDataBase)
' DNS sDataBase = GetUserSetting(USERSETTING_DatabaseName)

    sDataBase = GetConfUserSetting(USERSETTING_DatabaseName)
    If Trim(sDataBase = "") Then sDataBase = "Esi2000Db"

End Sub


'Note: Skips over KeySets and Dynamic Cursors

Public Sub ClearResultSet(RdoDataSet As ADODB.Recordset)
   
   ' Don't have Updatable property in ADODV Recordset.
   RdoDataSet.Cancel
'   If Not RdoDataSet.Updatable Then
'      Do While RdoDataSet.MoreResults
'      Loop
'      RdoDataSet.Cancel
'   End If
   
End Sub


Sub GetCompany(Optional bWantAddress As Byte)
   Dim ActRs As ADODB.Recordset
   Dim bByte As Byte
   Dim A As Integer
   Dim b As Integer
   Dim C As Integer
   Dim d As Integer
   Dim sAddress As String
   
   On Error GoTo modErr1
   If bWantAddress Then
      sSql = "SELECT COREF,CONAME,COPHONE,COFAX,COGLVERIFY,COADR FROM ComnTable " _
             & "WHERE COREF=1"
   Else
      sSql = "SELECT COREF,CONAME,COPHONE,COFAX,COGLVERIFY FROM ComnTable " _
             & "WHERE COREF=1"
   End If
   'bSqlRows = GetDataSet(ActRs, ES_STATIC)
   bSqlRows = clsADOCon.GetDataSet(sSql, ActRs, ES_STATIC)
   If bSqlRows Then
      With ActRs
         Co.Name = "" & Trim(!CONAME)
         Co.Phone = "" & Trim(!COPHONE)
         Co.Fax = "" & Trim(!COFAX)
         Co.GlVerify = !COGLVERIFY
         If bWantAddress Then sAddress = "" & Trim(!COADR)
      End With
   End If
   'have to parse CfLf if we want address. Crystal Reports formulae only
   If bWantAddress Then
      On Error Resume Next
      A = InStr(1, sAddress, Chr(13) & Chr(10))
      Co.Addr(1) = Left(sAddress, A - 1)
      
      sAddress = Right(sAddress, Len(sAddress) - (A + 1))
      b = InStr(1, sAddress, Chr(13) & Chr(10))
      If b = 0 Then
         bByte = 1
         b = Len(sAddress)
         Co.Addr(2) = Left(sAddress, b)
      Else
         Co.Addr(2) = Left(sAddress, b - 1)
      End If
      
      If bByte = 0 Then
         sAddress = Right(sAddress, Len(sAddress) - (b + 1))
         C = InStr(1, sAddress, Chr(13) & Chr(10))
         If C = 0 Then
            bByte = 1
            C = Len(sAddress)
            Co.Addr(3) = Left(sAddress, C)
         Else
            Co.Addr(3) = Left(sAddress, C - 1)
         End If
      End If
      
      If bByte = 0 Then
         sAddress = Right(sAddress, Len(sAddress) - (C + 1))
         d = InStr(1, sAddress, Chr(13) & Chr(10))
         If d = 0 Then
            bByte = 1
            d = Len(sAddress)
            Co.Addr(4) = Left(sAddress, d)
         Else
            Co.Addr(4) = Left(sAddress, d - 1)
         End If
      End If
   End If
   sFacility = Co.Name
   Set ActRs = Nothing
   Exit Sub
   
modErr1:
   Resume modErr2
modErr2:
   On Error GoTo 0
   
End Sub




'Make sure that the user's DSN is pointed to the
'correct server. If none is registered, then build it

'Public Function RegisterSqlDsn(sDataSource As String) As String
'   Dim sAttribs As String
'   If sDataSource = "" Then sDataSource = "ESI2000"
'   sAttribs = "Description=" _
'              & "ES/2000ERP SQL Server Data " _
'              & vbCrLf & "OemToAnsi=No" _
'              & vbCrLf & "SERVER=" & sserver _
'              & vbCrLf & "Database=" & sDataBase
'   'Create new DSN or revise registered DSN.
'   rdoEngine.rdoRegisterDataSource sDataSource, _
'      "SQL Server", True, sAttribs
'   RegisterSqlDsn = sDataSource
'   Exit Function
'
'modErr1:
'   On Error GoTo 0
'   RegisterSqlDsn = sDataSource
'
'End Function
'


'Code  GETSERVERDATETIME() = Format(GetServerDateTime,"mm/dd/yy") etal
'11/21/06 Revised for clarity

Public Function GetServerDateTime() As Variant
   Dim RdoTme As ADODB.Recordset
   On Error GoTo modErr1
   sSql = "SELECT GETDATE() AS ServerTime"
   bSqlRows = clsADOCon.GetDataSet(sSql, RdoTme, ES_FORWARD)
   If bSqlRows Then
      GetServerDateTime = RdoTme!ServerTime
   Else
      Dim cs As String
      cs = clsADOCon.ConnectionString
      clsADOCon.CleanupConnection clsADOCon.conConnection
      clsADOCon.CheckConnection

      GetServerDateTime = Now
   End If
   Set RdoTme = Nothing
   Exit Function
   
modErr1:
   GetServerDateTime = Format(Now, "mm/dd/yy")
   
End Function

Public Function GetServerDate() As Variant
   Dim RdoTme As ADODB.Recordset
   On Error Resume Next
   GetServerDate = Format(Now, "mm/dd/yy")
   sSql = "select getdate() AS ServerTime"
   If clsADOCon.GetDataSet(sSql, RdoTme, ES_FORWARD) Then
      GetServerDate = Format(RdoTme!ServerTime, "mm/dd/yy")
   Else
      Dim cs As String
      cs = clsADOCon.ConnectionString
      clsADOCon.CleanupConnection clsADOCon.conConnection
      clsADOCon.CheckConnection

      GetServerDate = Format(Now, "mm/dd/yy")
   End If
End Function

Private Sub AddNonNullColumnWithDefault(TableName As String, ColumnName As String, _
   TypeName As String, DefaultValue As String)

   'if column already exists, just return
   If ColumnExists(TableName, ColumnName) Then
      Exit Sub
   End If
   
   'add a non-null column and do the gyrations to give it a default
   ExecuteScript True, "ALTER TABLE " & TableName & " ADD " & ColumnName & " " & TypeName & " NULL"
   ExecuteScript True, "UPDATE " & TableName & " SET " & ColumnName & " = " & DefaultValue
   ExecuteScript True, "ALTER TABLE " & TableName & " ALTER COLUMN " & ColumnName & " " & TypeName & " NOT NULL"
   ExecuteScript True, "ALTER TABLE " & TableName & " ADD CONSTRAINT DF_" & TableName & "_" & ColumnName & " DEFAULT " & DefaultValue & " FOR " & ColumnName


End Sub

Sub ExecSQL(SQL As String)
    Err.Clear
    On Error Resume Next
    clsADOCon.ExecuteSql SQL
    Err.Clear
End Sub

Public Function IsTestDatabase() As Boolean
   'returns true if using a test database
   
   On Error Resume Next
   clsADOCon.ADOErrNum = 0
   sSql = "select TestDatabase from Version"
   Dim rdo As ADODB.Recordset
   Dim TestDatabase As Boolean
   If clsADOCon.GetDataSet(sSql, rdo) Then
      If clsADOCon.ADOErrNum = 0 Then
         IsTestDatabase = IIf(rdo.Fields(0) = 1, True, False)
      Else
         clsADOCon.ExecuteSql "alter table Version add TestDatabase tinyint not null default 0"
      End If
   End If
   
End Function

Private Sub DropIndex(TableName As String, IndexName As String)
   'drop index that works with SQL2000, SQL2005, and SQL2008
   
      ExecuteScript False, "DROP INDEX " & TableName & "." & IndexName & " -- SQL2000"
      ExecuteScript False, "DROP INDEX " & IndexName & " ON " & TableName & " -- SQL2005 & SQL2008"
End Sub

Public Function CrystalDate(dt As Variant) As String
   'returns date in format suitable for Crystal Reports SQL
   CrystalDate = " Date(" & Format(dt, "yyyy,mm,dd") & ") "
End Function


Public Sub UpdateDatabase()
   
   Dim rdo As ADODB.Recordset
   
   'if no version table, create it and set it to version 0
   'sSql = "select max(Version) as Version from Version"
   sSql = "select Version from Version"
   On Error Resume Next 'need to attempt all steps even if they fail
   
   bSqlRows = clsADOCon.GetDataSet(sSql, rdo)
   If Err.Number <> 0 Then
      bSqlRows = False
      Err.Clear
   End If
   If bSqlRows Then
      OldDbVersion = rdo!Version
      ver = rdo!Version
   Else
      ExecuteScript False, ("create table Version ( Version  int )")
      ExecuteScript False, ("insert Version ( Version ) values ( 0 )")
      ver = 0
   End If
   Set rdo = Nothing
   
   'Continue if:
   '1. Update required and user is an admin
   '2. User is a developer running in VB IDE (to debug db updates)
   Dim UpdateReqd As Boolean
   If IsUpdateRequired(OldDbVersion, DB_VERSION) Then
      UpdateReqd = True
   Else
      'If Not RunningInIDE Then
         Exit Sub
      'End If
   End If
   
   Err.Clear
   On Error Resume Next
   
   MouseCursor ccHourglass
   SysMsgBox.tmr1.enabled = False
   SysMsgBox.msg = "Updating database."
   SysMsgBox.Show
   
   'allow really long timeouts (normal limit is 60 sec)
   Dim timeout As Integer
   'TODO: get the query timeout
   'timeout = RdoCon.QueryTimeout
   'RdoCon.QueryTimeout = 1200    '20 minutes

   '9/27/2010
   'UpdateDatabase16
   
   UpdateDatabase1
   
   UpdateDatabase2
   
   '11/22/2010
   UpdateDatabase3
   
   UpdateDatabase4
   
   UpdateDatabase5
   
   UpdateDatabase6
   
   
   ' BBS 12/21/2010 Change datagbase version from 80 to 81 for Ticket # 42352
   UpdateDatabase7
   
   ' MM 1/4/2010 Added new table EsReportPickExpedite for Pick Expedite report
   UpdateDatabase8
   
   ' BBS 1/17/2011 Added new Fields to ComnTable for registration logic (Ticket #38600)
   UpdateDatabase9
   
   'BBS 1/25/2011 Added for Ticket #44709
   UpdateDatabase10
   
   'BBS 3/09/2011 Added for Ticket #43221
   UpdateDatabase11
   
   ' BBS 4/5/2011 Changed database version from 85 to 86 for Ticket #46178
   UpdateDatabase12
   
   ' BBS 4/20/2011 Changed database version from 86 to 87 for Ticket #59852
   UpdateDatabase13
   
   ' MM 6/13/2011 Changed database version from 87 to 88
   UpdateDatabase14
   
   ' MM 6/26/2011
   UpdateDatabase15
   
   'BBS 7/20/2011
   UpdateDatabase16
   
   'BBS 7/26/2011
   UpdateDatabase17
   
   'BBS 09/06/2011
   UpdateDatabase18
   
   'MM 09/11/2011
   UpdateDatabase19
   
   'MM 09/13/2011
   UpdateDatabase20
   
   'BBS 09/14/2011
   UpdateDatabase21
   
   'BBS 09/15/2011
   UpdateDatabase22
   
   UpdateDatabase23
   
   ' Build to changes in Time module
   UpdateDatabase24
   
   ' Build - 11/17/2011
   UpdateDatabase25

   ' Build - 12/6/2011
   UpdateDatabase26

      ' Build - 12/6/2011
   UpdateDatabase27

      ' Build - 12/6/2011
   UpdateDatabase28

   ' New build 1/22/2012 - 12.1
   UpdateDatabase29

   ' New build 1/29/2012 - 12.1
   UpdateDatabase30
   
   ' New build 2/8/2012 - 12.1
   UpdateDatabase31
   
   ' New build 2/27/2012 - 12.0
   UpdateDatabase32
   '02/29/2012
   UpdateDatabase33
   
   '3/10/2012
   UpdateDatabase34
   
   '3/29/2012
   UpdateDatabase35

   '04/3/2012
   UpdateDatabase36
   
   '04/22/2012
   UpdateDatabase37
   
   '5/14/2012
   UpdateDatabase38
   
   '7/22/2012
   UpdateDatabase39
   
   '7/22/2012
   UpdateDatabase40
   
   '7/22/2012
   UpdateDatabase41
   
   '9/9/2012
   UpdateDatabase42
   
   '9/24/2012
   UpdateDatabase43
   
   '9/30/2012
   UpdateDatabase44
   
   '10/7/2012
   UpdateDatabase45
   
   '10/28/2012
   UpdateDatabase46
   
   '10/30/2012
   UpdateDatabase47
   
   '11/04/2012
   UpdateDatabase48
   
   '12/27/2012
   UpdateDatabase49
   
   
   '1/1/2013
   UpdateDatabase50
   
   '1/3/2013
   UpdateDatabase51
   
   '1/10/2013
   UpdateDatabase52
   
      '2/03/2013
   UpdateDatabase53
   
   '3/12/2013
   UpdateDatabase54
   
   '4/21/2013
   UpdateDatabase55

   '5/29/2013
   UpdateDatabase56

   '7/7/2013
   UpdateDatabase57
   
   '8/16/2013
   UpdateDatabase58
   
   '10/11/2013
   UpdateDatabase59
   
   '11/16/2013
   UpdateDatabase60
   
   '12/24/2013
   UpdateDatabase61
   
   '1/13/2014
   UpdateDatabase62
   
   '2/09/2014
   UpdateDatabase63
   
   '3/31/2014
   UpdateDatabase64
   
   '4/16/2014
   UpdateDatabase65
   
   ' 5/3/2014
   UpdateDatabase66
   
   ' 7/1/2014
   UpdateDatabase67
   
   ' 8/3/2014
   UpdateDatabase68
   
   ' 9/21/2014
   UpdateDatabase69
   
   ' 2/19/2015
   UpdateDatabase70
   
   ' 3/5/2015
   UpdateDatabase71
   
   ' 4/21/2015
   UpdateDatabase72
   
   ' 6/23/2015
   UpdateDatabase73
   
   ' 7/1/2015 - Terry
   UpdateDatabase74
   
   ' 7/5/2015
   UpdateDatabase75
   
   ' 8/3/2015
   UpdateDatabase76
   
   ' 8/24/2015 - Terry
   UpdateDatabase77
   
   ' 11/07/2016
   UpdateDatabase78
   
   ' 1/5/2017 - Terry
   UpdateDatabase79
   
   ' v 17.4.0 3/15/2017 - Terry
   UpdateDatabase80
   
   ' v 17.5.1 4/11/2017 - Terry
   UpdateDatabase81
   
   ' v 17.5.4 4/?/2017 - Terry - update WC Queue Status stored procedures
   UpdateDatabase82
   
   ' v 17.5.5 5/?/2017 - Terry
   UpdateDatabase83
   
   ' v 17.5.6 5/18/2017 - Terry
   UpdateDatabase84
   
   ' v 17.5.8 6/24/2017 - Terry
   UpdateDatabase85
   
   ' v 17.5.9 - Terry
   UpdateDatabase86
   
   ' v 17.6.0 - Terry
   UpdateDatabase87
   
   ' v 17.6.1 - Terry
   UpdateDatabase88
   
   ' v 17.6.2 - Terry
   UpdateDatabase89
   
   ' v 17.6.3 9/18/17 - Terry
   UpdateDatabase90
   
   ' v 17.6.4 db v 166 9/21/17 - Terry
   UpdateDatabase91
   
   ' v 17.6.4 db v 167 9/28/17 - Terry
   UpdateDatabase92
   
   ' v 17.6.5 db v 168 10/17/17 - Terry
   UpdateDatabase93
   
   ' v 17.6.6 db v 169 10/23/17 - Terry
   UpdateDatabase94
   
   ' v 17.7.0 db v 170 11/13/17 - Terry
   UpdateDatabase95
   
   ' v 17.17.1 db v 171 12/?/17 - Terry
   UpdateDatabase96
   
   ' v 17.17.2 db v 172 12/15/17 - Terry
   UpdateDatabase97
   
   ' v 18.0.1 db v 173 1/23/2018 - Terry
   UpdateDatabase98
   
   ' v 18.0.2 db v 174 2/6/2018 - Terry
   UpdateDatabase99
   
   ' v 18.0.3 db v 175 2/24/2018 - Terry
   UpdateDatabase100
   
   ' v 18.0.4 db v 176 3/?/2018 - Terry
   UpdateDatabase101
   
   ' v 18.0.5 db v 177 4/25/2018 - Terry
   UpdateDatabase102
   
   ' v 18.0.6 db v 178 6/25/2018 - Terry
   UpdateDatabase103
   
   ' v 18.0.7 db v 179 7/18/2018 - Terry
   UpdateDatabase104
   
   ' v 18.0.8 db v 180 8/8/2018 - Terry
   UpdateDatabase105
   
   ' v 18.1.0,1,2,3 db v 181, 182, 183 11/1/2018 - Terry
   UpdateDatabase106
   
   ' v 19.0..0 11/4/2019 - Terry
   UpdateDatabase107
   
   ' v 19.0.1 1/27/2018 - Terry
   UpdateDatabase108
   
   ' v 19.0.3 3/14/2018 - Terry
   UpdateDatabase109
   
   ' v 19.0.4/5 3/19/19 & 3/21/19 - Terry
   UpdateDatabase110
   
   ' v 19.1.0 5/17/19 - Terry
   UpdateDatabase111
   
   ' v 19.1.1 6/12/19 - Terry
   UpdateDatabase112
   
   ' v 19.1.2 6/?/19 - Terry
   UpdateDatabase113
   
   'record update
   'don't do this if running in VB IDE and no update was required
   If UpdateReqd Then
      sSql = "insert Updates" & vbCrLf _
         & "(AppDirectory,OldRelease,NewRelease,UserInitials," & vbCrLf _
         & "OldDbVersion, NewDbVersion,OldDbType,NewDbType)" & vbCrLf _
         & "values('" & App.Path & "'," & oldRelease & "," & newRelease & ",'" & sInitials & "'," & vbCrLf _
         & OldDbVersion & "," & DB_VERSION & ",'" & oldType & "','" & NewType & "')"
         
      ExecuteScript True, sSql
      
      'update test/live indicator if necessary
      If oldType <> NewType Then
         sSql = "update Version set TestDatabase = " & IIf(NewType = "Live", 0, 1)
         ExecuteScript True, sSql
      End If
   End If
   
   Unload SysMsgBox
   MouseCursor ccDefault

End Sub

Private Function UpdateDatabase1()
    Dim i As Integer
    Dim sConstraintName As String
    
    
   newver = 75
   If ver < newver Then
       ver = newver
       
      
'First lets find and drop all constraints related to the wip fields
    For i = 1 To 4
        sConstraintName = GetConstraintNme("ComnTable", "DF__ComnTable__WIPCR")
        If sConstraintName <> "" Then ExecuteScript False, "ALTER Table [dbo].[ComnTable] DROP CONSTRAINT " & sConstraintName
    Next i
    For i = 1 To 4
        sConstraintName = GetConstraintNme("ComnTable", "DF__ComnTable__WIPDR")
        If sConstraintName <> "" Then ExecuteScript False, "ALTER Table [dbo].[ComnTable] DROP CONSTRAINT " & sConstraintName
    Next i
    
    'Now rename the first four columns to the new column names
    If ColumnExists("ComnTable", "WIPCRLABACCT") Then ExecuteScript False, "Exec sp_rename 'ComnTable.WIPCRLABACCT', 'WIPLABACCT', 'COLUMN'"
    If ColumnExists("ComnTable", "WIPCRMATACCT") Then ExecuteScript False, "Exec sp_rename 'ComnTable.WIPCRMATACCT', 'WIPMATACCT', 'COLUMN'"
    If ColumnExists("ComnTable", "WIPCREXPACCT") Then ExecuteScript False, "Exec sp_rename 'ComnTable.WIPCREXPACCT', 'WIPEXPACCT', 'COLUMN'"
    If ColumnExists("ComnTable", "WIPCROHDACCT") Then ExecuteScript False, "Exec sp_rename 'ComnTable.WIPCROHDACCT', 'WIPOHDACCT', 'COLUMN'"
     
    'Now drop the other four unused columns
    If ColumnExists("ComnTable", "WIPDRLABACCT") Then ExecuteScript False, "ALTER TABLE [dbo].[ComnTable] DROP COLUMN WIPDRLABACCT"
    If ColumnExists("ComnTable", "WIPDRMATACCT") Then ExecuteScript False, "ALTER TABLE [dbo].[ComnTable] DROP COLUMN WIPDRMATACCT"
    If ColumnExists("ComnTable", "WIPDREXPACCT") Then ExecuteScript False, "ALTER TABLE [dbo].[ComnTable] DROP COLUMN WIPDREXPACCT"
    If ColumnExists("ComnTable", "WIPDROHDACCT") Then ExecuteScript False, "ALTER TABLE [dbo].[ComnTable] DROP COLUMN WIPDROHDACCT"
     
    'Last but not least, add the constraints back for the new fields with consistent meaningful names
    ExecuteScript False, "ALTER TABLE ComnTable ADD CONSTRAINT DF_ComnTable_WIPLABACCT DEFAULT ('') FOR WIPLABACCT"
    ExecuteScript False, "ALTER TABLE ComnTable ADD CONSTRAINT DF_ComnTable_WIPMATACCT DEFAULT ('') FOR WIPMATACCT"
    ExecuteScript False, "ALTER TABLE ComnTable ADD CONSTRAINT DF_ComnTable_WIPEXPACCT DEFAULT ('') FOR WIPEXPACCT"
    ExecuteScript False, "ALTER TABLE ComnTable ADD CONSTRAINT DF_ComnTable_WIPOHDACCT DEFAULT ('') FOR WIPOHDACCT"
     
    'set version
    ExecuteScript False, "UPDATE Version set Version = " & newver
   End If
End Function



Private Function UpdateDatabase2()
    
   newver = 76
   If ver < newver Then
       ver = newver
    
       ExecuteScript False, "IF INDEXPROPERTY ( OBJECT_ID('dbo.CihdTable') , 'InvNo' , 'IndexID' ) IS NULL CREATE INDEX InvNo ON CihdTable (INVNO)"
   
       ExecuteScript False, "IF INDEXPROPERTY ( OBJECT_ID('dbo.InvaTable') , 'INAQTY' , 'IndexID' ) IS NULL CREATE INDEX InaQty ON InvaTable (INAQTY)"
       ExecuteScript False, "IF INDEXPROPERTY ( OBJECT_ID('dbo.LoitTable') , 'LOIPSITEM' , 'IndexID' ) IS NULL CREATE INDEX LoiPSItem ON LoitTable (LOIPSITEM)"
       ExecuteScript False, "IF INDEXPROPERTY ( OBJECT_ID('dbo.LoitTable') , 'LoiQuantity' , 'IndexID' ) IS NULL CREATE INDEX LoiQuantity ON LoitTable (LOIQUANTITY)"
       ExecuteScript False, "IF INDEXPROPERTY ( OBJECT_ID('dbo.PartTable') , 'PaClass' , 'IndexID' ) IS NULL CREATE INDEX PaClass ON PartTable (PACLASS)"
       ExecuteScript False, "IF INDEXPROPERTY ( OBJECT_ID('dbo.PartTable') , 'PaProdCode' , 'IndexID' ) IS NULL CREATE INDEX  PaProdCode ON PartTable (PAPRODCODE)"
       ExecuteScript False, "IF INDEXPROPERTY ( OBJECT_ID('dbo.PshdTable') , 'PSNumber' , 'IndexID' ) IS NULL CREATE INDEX PSNumber ON PshdTable (PSNUMBER)"
       ExecuteScript False, "IF INDEXPROPERTY ( OBJECT_ID('dbo.PsitTable') , 'PISONumber' , 'IndexID' ) IS NULL CREATE INDEX PISONumber PsitTable ON (PISONUMBER)"
       ExecuteScript False, "IF INDEXPROPERTY ( OBJECT_ID('dbo.PsitTable') , 'PISORev' , 'IndexID' ) IS NULL CREATE INDEX PISORev ON PsitTable (PISOREV)"
       ExecuteScript False, "IF INDEXPROPERTY ( OBJECT_ID('dbo.PsitTable') , 'PIITNo' , 'IndexID' ) IS NULL CREATE INDEX PIITNo ON PsitTable (PIITNO)"
       ExecuteScript False, "IF INDEXPROPERTY ( OBJECT_ID('dbo.SohdTable') , 'SOSalesman' , 'IndexID' ) IS NULL CREATE INDEX SOSalesman ON SohdTable (SOSALESMAN)"
       ExecuteScript False, "IF INDEXPROPERTY ( OBJECT_ID('dbo.SoitTable') , 'ITSO' , 'IndexID' ) IS NULL CREATE INDEX ITSO ON SoitTable (ITSO)"
       ExecuteScript False, "IF INDEXPROPERTY ( OBJECT_ID('dbo.SoitTable') , 'ITRevAcct' , 'IndexID' ) IS NULL CREATE INDEX ITRevAcct ON SoitTable (ITREVACCT)"
       
       'set version
       ExecuteScript False, "UPDATE Version set Version = " & newver
    
    End If

End Function


Private Function UpdateDatabase3()
    
   newver = 77
   If ver < newver Then
       ver = newver
    
      If StoreProcedureExists("TrialBalanceGLPost") Then
          sSql = "DROP PROCEDURE TrialBalanceGLPost"
          ExecuteScript False, sSql
      End If
      
      'Create the procedure
      sSql = "CREATE PROCEDURE [dbo].[TrialBalanceGLPost]" & vbCrLf
      sSql = sSql & "    @StartDate as Varchar(16), @EndDate as varchar(16)," & vbCrLf
      sSql = sSql & "    @StartAcc as Varchar(16), @EndAcc as varchar(16)" & vbCrLf
      sSql = sSql & "    AS " & vbCrLf
      sSql = sSql & "   BEGIN " & vbCrLf
      sSql = sSql & "      declare @GLDESCR as varchar(40)" & vbCrLf
      sSql = sSql & "      declare @GJPOST as varchar(16)" & vbCrLf
      sSql = sSql & "      declare @JINAME as varchar(12)" & vbCrLf
      sSql = sSql & "      declare @JIACCOUNT as varchar(12)" & vbCrLf
      sSql = sSql & "     declare @JIDEB as decimal(13,2)" & vbCrLf
      sSql = sSql & "     declare @JICRD as decimal(13,2)" & vbCrLf
      sSql = sSql & "     declare @JR_DCDEBIT as decimal(13,2)" & vbCrLf
      sSql = sSql & "     declare @JR_DCCREDIT as decimal(13,2)" & vbCrLf
      sSql = sSql & "     declare @JR_TotBal as decimal(13,2)" & vbCrLf
      sSql = sSql & "     declare @Acc_StartBal as decimal(13,2)" & vbCrLf
      sSql = sSql & "     declare @MJTYPE as varchar(2)" & vbCrLf
      sSql = sSql & "     declare @MJDESCRIPTION as varchar(30)" & vbCrLf
      sSql = sSql & "     declare @StrAcc as varchar (30)" & vbCrLf
      sSql = sSql & "     declare @iStartAcc as integer" & vbCrLf
      sSql = sSql & "     declare @iEndAcc as integer" & vbCrLf
      sSql = sSql & "     " & vbCrLf
      sSql = sSql & "     IF (@StartAcc = 'ALL')" & vbCrLf
      sSql = sSql & "        SET @iStartAcc = 1" & vbCrLf
      sSql = sSql & "     Else " & vbCrLf
      sSql = sSql & "        SET @iStartAcc = COnvert(int, @StartAcc) " & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "     IF (@EndAcc  = 'ALL') " & vbCrLf
      sSql = sSql & "        SET @iEndAcc = 10000 " & vbCrLf
      sSql = sSql & "     Else " & vbCrLf
      sSql = sSql & "        SET @iEndAcc = COnvert(int, @EndAcc ) " & vbCrLf
      sSql = sSql & "      " & vbCrLf
      sSql = sSql & "      CREATE TABLE #tempGLPost " & vbCrLf
      sSql = sSql & "      ( " & vbCrLf
      sSql = sSql & "                 tGLDESCR varchar(40) NULL , " & vbCrLf
      sSql = sSql & "                 tGJPOST varchar(16) NULL , " & vbCrLf
      sSql = sSql & "                 tJINAME varchar(12) NULL , " & vbCrLf
      sSql = sSql & "                 tJIACCOUNT varchar(12) NULL , " & vbCrLf
      sSql = sSql & "               tAcc_StartBal decimal (13,2) NULL, " & vbCrLf
      sSql = sSql & "                 tJIDEB decimal(13,2) NULL , " & vbCrLf
      sSql = sSql & "                 tJICRD decimal(13,2) NULL , " & vbCrLf
      sSql = sSql & "                 tJR_DCDEBIT decimal(13,2) NULL , " & vbCrLf
      sSql = sSql & "                 tJR_DCCREDIT decimal(13,2)NULL , " & vbCrLf
      sSql = sSql & "                 tJR_TotBal decimal(13,2) NULL , " & vbCrLf
      sSql = sSql & "                 tGJ_TotBal decimal(13,2) NULL , " & vbCrLf
      sSql = sSql & "                 tMJTYPE varchar(2) NULL , " & vbCrLf
      sSql = sSql & "                 tMJDESCRIPTION varchar(30) NULL, " & vbCrLf
      sSql = sSql & "             ) " & vbCrLf
               
      sSql = sSql & "               DECLARE curGJ CURSOR " & vbCrLf
      sSql = sSql & "               LOCAL " & vbCrLf
      sSql = sSql & "               Scroll " & vbCrLf
      sSql = sSql & "               FOR " & vbCrLf
      sSql = sSql & "                  SELECT DISTINCT GLDESCR, GJPOST, " & vbCrLf
      sSql = sSql & "                     JINAME , JIACCOUNT " & vbCrLf
      sSql = sSql & "                      From GjitTable, GlacTable, GjhdTable " & vbCrLf
      sSql = sSql & "                   Where JIACCOUNT = GLACCTREF " & vbCrLf
      sSql = sSql & "                     AND GJNAME = JINAME " & vbCrLf
      sSql = sSql & "                     AND GJPOST BETWEEN @StartDate AND @EndDate " & vbCrLf
      sSql = sSql & "                     AND  JIACCOUNT BETWEEN @iStartAcc AND @iEndAcc " & vbCrLf
      sSql = sSql & "                  order by JINAME " & vbCrLf
         
      sSql = sSql & "          " & vbCrLf
      sSql = sSql & "             OPEN curGJ " & vbCrLf
      sSql = sSql & "             FETCH NEXT FROM curGJ INTO @GLDESCR,@GJPOST,@JINAME,@JIACCOUNT " & vbCrLf
      sSql = sSql & "             WHILE (@@FETCH_STATUS <> -1) " & vbCrLf
      sSql = sSql & "             BEGIN " & vbCrLf
      sSql = sSql & "                 IF (@@FETCH_STATUS <> -2) " & vbCrLf
      sSql = sSql & "                 BEGIN " & vbCrLf
         
      sSql = sSql & "                  SELECT @Acc_StartBal = ABS(SUM(JIDEB) - SUM(JICRD)) " & vbCrLf
      sSql = sSql & "                      From GjitTable, GlacTable, GjhdTable " & vbCrLf
      sSql = sSql & "                   Where JIACCOUNT = GLACCTREF And " & vbCrLf
      sSql = sSql & "                        GJNAME = JINAME " & vbCrLf
      sSql = sSql & "                        AND JIACCOUNT = @JIACCOUNT " & vbCrLf
      sSql = sSql & "                        AND GJPOST < @StartDate " & vbCrLf
         
      sSql = sSql & "                  SELECT @JIDEB = ABS(SUM(JIDEB)), @JICRD = ABS(SUM(JICRD)) " & vbCrLf
      sSql = sSql & "                      From GjitTable, GlacTable " & vbCrLf
      sSql = sSql & "                   Where JIACCOUNT = GLACCTREF And " & vbCrLf
      sSql = sSql & "                        JINAME = @JINAME " & vbCrLf
      sSql = sSql & "                        AND JIACCOUNT = @JIACCOUNT " & vbCrLf
      sSql = sSql & "          " & vbCrLf
                  
      sSql = sSql & "                  SELECT @JR_DCDEBIT = SUM(DCDEBIT) , @JR_DCCREDIT = SUM(DCCREDIT), " & vbCrLf
      sSql = sSql & "                      @JR_TotBal = ABS(SUM(DCDEBIT) - SUM(DCCREDIT)), " & vbCrLf
      sSql = sSql & "                     @MJTYPE = MJTYPE, @MJDESCRIPTION = MJDESCRIPTION " & vbCrLf
      sSql = sSql & "                  From jritTable, jrhdtable " & vbCrLf
      sSql = sSql & "                  Where MJGLJRNL = DCHEAD And " & vbCrLf
      sSql = sSql & "                     DCHEAD = @JINAME " & vbCrLf
      sSql = sSql & "                     AND DCACCTNO = @JIACCOUNT " & vbCrLf
      sSql = sSql & "                  GROUP BY DCHEAD,DCACCTNO,MJTYPE, MJDESCRIPTION " & vbCrLf
         
      sSql = sSql & "                  INSERT INTO #tempGLPost(tGLDESCR, tGJPOST, tJINAME, tJIACCOUNT, tAcc_StartBal, tJIDEB, tJICRD, " & vbCrLf
      sSql = sSql & "                     tJR_DCDEBIT,tJR_DCCREDIT, tJR_TotBal, tGJ_TotBal, tMJTYPE, tMJDESCRIPTION ) " & vbCrLf
      sSql = sSql & "                  VALUES (@GLDESCR, @GJPOST, @JINAME, @JIACCOUNT, @Acc_StartBal, @JIDEB, @JICRD, " & vbCrLf
      sSql = sSql & "                     @JR_DCDEBIT, @JR_DCCREDIT, @JR_TotBal, ABS(@JIDEB - @JICRD), @MJTYPE, @MJDESCRIPTION) " & vbCrLf
      sSql = sSql & "               End " & vbCrLf
         
      sSql = sSql & "               FETCH NEXT FROM curGJ INTO @GLDESCR,@GJPOST,@JINAME,@JIACCOUNT " & vbCrLf
      sSql = sSql & "            End " & vbCrLf
            
      sSql = sSql & "            SELECT tGLDESCR GLDESCR, tGJPOST GJPOST, tJINAME JINAME, " & vbCrLf
      sSql = sSql & "               tJIACCOUNT JIACCOUNT, tAcc_StartBal AS StartingBalance, tJIDEB AS GL_JIDEB, " & vbCrLf
      sSql = sSql & "               tJICRD AS GL_JICRD, tJR_DCDEBIT JR_DCDEBIT, " & vbCrLf
      sSql = sSql & "               tJR_DCCREDIT JR_DCCREDIT, tGJ_TotBal GJ_TotBal, " & vbCrLf
      sSql = sSql & "               tJR_TotBal JR_TotBal, tMJTYPE MJTYPE, " & vbCrLf
      sSql = sSql & "               tMJDESCRIPTION MJDESCRIPTION " & vbCrLf
      sSql = sSql & "            FROM #tempGLPost order by tGLDESCR " & vbCrLf
           
      sSql = sSql & "            DROP table #tempGLPost " & vbCrLf
         
      sSql = sSql & "             CLOSE curGJ   --// close the cursor " & vbCrLf
      sSql = sSql & "             DEALLOCATE curGJ " & vbCrLf
      sSql = sSql & "         End "
      
      ExecuteScript False, sSql

       
       'set version
       ExecuteScript False, "UPDATE Version set Version = " & newver
    
    End If

End Function


Private Function UpdateDatabase4()
   
   newver = 78
   If ver < newver Then
       ver = newver
    
       ExecuteScript False, "ALTER TABLE CihdTable ALTER COLUMN INVSTADR VARCHAR(300) "
   
       'set version
       ExecuteScript False, "UPDATE Version set Version = " & newver
    
    End If
    
End Function

Private Function UpdateDatabase5()
   
   newver = 79
   If ver < newver Then
       ver = newver
        If Not ColumnExists("EsReportCustSh01", "MOStartDte") Then ExecuteScript False, "ALTER TABLE EsReportCustSh01 ADD MOStartDte CHAR(8) NULL "
       
       'set version
       ExecuteScript False, "UPDATE Version set Version = " & newver
    
    End If
    
End Function

Private Function UpdateDatabase6()
   newver = 80
   If ver < newver Then
        ver = newver
        If Not ColumnExists("PartTable", "PAINTERNALCMT") Then ExecuteScript False, "ALTER TABLE PartTable ADD PAINTERNALCMT VARCHAR(MAX) NULL "
      
        ExecuteScript False, "Update Version Set Version = " & newver
   End If
End Function


Private Function UpdateDatabase7()
   newver = 81
   If ver < newver Then
      ver = newver
        
      If Not ColumnExists("Log_PartNo", "EsReportClosedRunsLog") Then ExecuteScript False, "ALTER TABLE EsReportClosedRunsLog ADD Log_PartNo CHAR(30) NULL "
      If Not ColumnExists("Log_RunNo", "EsReportClosedRunsLog") Then ExecuteScript False, "ALTER TABLE EsReportClosedRunsLog ADD Log_RunNo INT "
      If Not ColumnExists("Log_Closed", "EsReportClosedRunsLog") Then ExecuteScript False, "ALTER TABLE EsReportClosedRunsLog ADD Log_Closed TINYINT DEFAULT(0) "
      
      ExecuteScript False, "Update StCodeTable SET STATUS_REF = LTRIM(STATUS_REF) WHERE LEFT(STATUS_REF,1)=' '"

      sSql = " SELECT * FROM StatCdType " & vbCrLf _
         & " WHERE STATCODE_TYPE_REF = 'MO' AND STATCODE_TYPE_NAME = 'Manufacturing Order' " & vbCrLf _
         & " AND STATCODE_TYPE_UNIQUE_KEY = '3' " & vbCrLf _
      
      If Not (CheckSeedDataExits(sSql)) Then
         sSql = " INSERT INTO StatCdType " & vbCrLf _
            & "    (STATCODE_TYPE_REF, STATCODE_TYPE_NAME, STATCODE_TYPE_UNIQUE_KEY) " & vbCrLf _
            & "  VALUES('MO', 'Manufacturing Order', 3)"
         ' Insert MO ID
         ExecuteScript True, sSql
      End If
      
      sSql = " SELECT * FROM StatCdType " & vbCrLf _
         & " WHERE STATCODE_TYPE_REF = 'MOI' AND STATCODE_TYPE_NAME = 'MO Item' " & vbCrLf _
         & " AND STATCODE_TYPE_UNIQUE_KEY = '3' " & vbCrLf _
      
      If Not (CheckSeedDataExits(sSql)) Then
         sSql = " INSERT INTO StatCdType " & vbCrLf _
            & "    (STATCODE_TYPE_REF, STATCODE_TYPE_NAME, STATCODE_TYPE_UNIQUE_KEY) " & vbCrLf _
            & "  VALUES('MOI', 'MO Item', 3)"
         ' Insert MO ID
         ExecuteScript True, sSql
      End If
      
      ExecuteScript False, "ALTER Table dbo.StCmtTable DROP CONSTRAINT PK_StCmtTable_1"
      ExecuteScript False, "ALTER TABLE dbo.StCmtTable ALTER COLUMN STATUS_CMT_REF VARCHAR(30)NOT NULL"
      sSql = " ALTER Table dbo.StCmtTable ADD CONSTRAINT [PK_StCmtTable_1] PRIMARY KEY CLUSTERED" & vbCrLf _
               & " ([STATUS_CMT_REF] ASC," & vbCrLf _
               & " [STATUS_CMT_REF1] ASC," & vbCrLf _
               & " [STATUS_CMT_REF2] ASC," & vbCrLf _
               & " [STATUS_REF] ASC," & vbCrLf _
               & " [STATCODE_TYPE_REF] Asc) ON [PRIMARY]"
      
      ExecuteScript True, sSql


      sSql = "ALTER PROCEDURE [dbo].[Qry_AddInternStatCode]" & vbCrLf
            sSql = sSql & "  (@StatCmtRef varchar(30),@StatCmtRef1 int, @StatCmtRef2 varchar(20)," & vbCrLf
            sSql = sSql & "    @StatRef varchar(4), @StatCodeTypeRef varchar(3), @user varchar(50)," & vbCrLf
            sSql = sSql & "  @comments as varchar(1024), @ActStat as int)" & vbCrLf
            sSql = sSql & "  AS " & vbCrLf
            sSql = sSql & "  BEGIN " & vbCrLf
            sSql = sSql & "     declare @StatCdTypeKey as int" & vbCrLf
            sSql = sSql & "     declare @curDate as datetime" & vbCrLf
            sSql = sSql & "     declare @count as integer" & vbCrLf
            sSql = sSql & "                                        " & vbCrLf
            sSql = sSql & "       SET @StatCdTypeKey = 0" & vbCrLf
            sSql = sSql & "       SELECT @StatCdTypeKey = ISNULL(STATCODE_TYPE_UNIQUE_KEY, 0) FROM StatCdType" & vbCrLf
            sSql = sSql & "           WHERE STATCODE_TYPE_REF = @StatCodeTypeRef" & vbCrLf
            sSql = sSql & "                                   " & vbCrLf
            sSql = sSql & "       SET @curDate = GetDATE()" & vbCrLf
            sSql = sSql & "                                   " & vbCrLf
            sSql = sSql & "       IF @StatCdTypeKey = 1" & vbCrLf
            sSql = sSql & "       BEGIN" & vbCrLf
            sSql = sSql & "           SET @StatCmtRef1 = 0" & vbCrLf
            sSql = sSql & "           SET @StatCmtRef2 = ''" & vbCrLf
            sSql = sSql & "                                   " & vbCrLf
            sSql = sSql & "           SELECT @count = COunt(*) FROM StCmtTable WHERE" & vbCrLf
            sSql = sSql & "           STATUS_REF = @StatRef AND STATCODE_TYPE_REF = @StatCodeTypeRef" & vbCrLf
            sSql = sSql & "           AND STATUS_CMT_REF = @StatCmtRef" & vbCrLf
            sSql = sSql & "  End" & vbCrLf
            sSql = sSql & "  IF @StatCdTypeKey = 3" & vbCrLf
            sSql = sSql & "  BEGIN" & vbCrLf
            sSql = sSql & "      SELECT @count = COunt(*) FROM StCmtTable WHERE" & vbCrLf
            sSql = sSql & "      STATUS_REF = @StatRef AND STATCODE_TYPE_REF = @StatCodeTypeRef" & vbCrLf
            sSql = sSql & "      AND STATUS_CMT_REF = @StatCmtRef" & vbCrLf
            sSql = sSql & "      AND STATUS_CMT_REF1 = @StatCmtRef1  AND STATUS_CMT_REF2 = @StatCmtRef2" & vbCrLf
            sSql = sSql & "  End" & vbCrLf
            sSql = sSql & "                " & vbCrLf
            sSql = sSql & "  IF  @count = 0" & vbCrLf
            sSql = sSql & "      INSERT INTO StCmtTable (STATUS_REF, STATCODE_TYPE_REF, STATUS_CMT_REF," & vbCrLf
            sSql = sSql & "      STATUS_CMT_REF1, STATUS_CMT_REF2, STATUS_ORG_USER, STATUS_ORG_DATE," & vbCrLf
            sSql = sSql & "      COMMENT, STATUS_CUR_USER, STATUS_CUR_DATE, STATUS_ACT_STATE)" & vbCrLf
            sSql = sSql & "      VALUES (@StatRef, @StatCodeTypeRef, @StatCmtRef, @StatCmtRef1, @StatCmtRef2," & vbCrLf
            sSql = sSql & "      @user, @curDate,@comments, @user, @curDate, @ActStat)" & vbCrLf
            sSql = sSql & "  Else" & vbCrLf
            sSql = sSql & "      UPDATE StCmtTable SET STATUS_CUR_USER = @user, STATUS_CUR_DATE = @curDate," & vbCrLf
            sSql = sSql & "          COMMENT = @comments, STATUS_ACT_STATE = @ActStat" & vbCrLf
            sSql = sSql & "          WHERE STATUS_REF = @StatRef AND STATCODE_TYPE_REF = @StatCodeTypeRef" & vbCrLf
            sSql = sSql & "          AND STATUS_CMT_REF = @StatCmtRef" & vbCrLf
            sSql = sSql & "          AND STATUS_CMT_REF1 = @StatCmtRef1" & vbCrLf
            sSql = sSql & "          AND STATUS_CMT_REF2 = @StatCmtRef2" & vbCrLf
            sSql = sSql & "                                              " & vbCrLf
            sSql = sSql & "  SELECT @@ROWCOUNT" & vbCrLf
            sSql = sSql & "  End"
      
      ' Change the Internal Status Code procedure
      ExecuteScript True, sSql


      ExecuteScript False, "Update Version Set Version = " & newver
   End If
End Function

Private Function UpdateDatabase8()
   newver = 82
   If ver < newver Then
      ver = newver

      If (Not TableExists("EsReportPickExpedite")) Then
      
         sSql = "CREATE TABLE [dbo].[EsReportPickExpedite](" & vbCrLf _
            & "  [tPKPARTREF] [char](30) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf _
            & "  [tPKMOPART] [char](30) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf _
            & "  [tPKMORUN] [int] NULL," & vbCrLf _
            & "  [tPKMORUNOP] [int] NULL," & vbCrLf _
            & "  [tPKPQTY] [decimal](12, 3) NULL," & vbCrLf _
            & "  [tPKAQTY] [decimal](12, 3) NULL," & vbCrLf _
            & "  [tMOPicked] [tinyint] NULL" & vbCrLf _
            & "   ) ON [PRIMARY]"
          
          ' ExecuteScript to create the table
          ExecuteScript True, sSql
      End If

      ExecuteScript False, "Update Version Set Version = " & newver
   End If
End Function

Private Function UpdateDatabase9()
    newver = 83
    If ver < newver Then
        ver = newver
    
        If Not ColumnExists("ComnTable", "REGID") Then ExecuteScript False, "ALTER TABLE ComnTable ADD REGID INT NULL"
        If Not ColumnExists("ComnTable", "PRODUCTKEY") Then ExecuteScript False, "ALTER TABLE ComnTable ADD PRODUCTKEY varchar(25) NULL"
    
        ExecuteScript False, "Update Version Set Version = " & newver
    End If
End Function


Private Function UpdateDatabase10()
    newver = 84
    If ver < newver Then
        ver = newver
    
         If Not ColumnExists("PartTable", "PAINTERNALCMT") Then
             ExecuteScript False, "ALTER TABLE PartTable ADD PAINTERNALCMT VARCHAR(4096) NULL"
         Else
             ExecuteScript False, "ALTER TABLE PartTable ALTER COLUMN PAINTERNALCMT VARCHAR(4096) NULL"
         End If
    
         sSql = "ALTER PROCEDURE [dbo].[TrialBalanceGLPost]" & vbCrLf
         sSql = sSql & "    @StartDate as Varchar(16), @EndDate as varchar(16)," & vbCrLf
         sSql = sSql & "    @StartAcc as Varchar(16), @EndAcc as varchar(16)," & vbCrLf
         sSql = sSql & "   @IncludeInActiveAcc as varchar(2)" & vbCrLf
         sSql = sSql & "    AS" & vbCrLf
         sSql = sSql & "   BEGIN" & vbCrLf
         sSql = sSql & "   declare @GLDESCR as varchar(40)" & vbCrLf
         sSql = sSql & "   declare @Inv_GLDESCR as varchar(40)" & vbCrLf
         sSql = sSql & "   declare @GJPOST as varchar(16)" & vbCrLf
         sSql = sSql & "   declare @JINAME as varchar(12)" & vbCrLf
         sSql = sSql & "   declare @JIACCOUNT as varchar(12)" & vbCrLf
         sSql = sSql & "   declare @Inv_JIACCOUNT as varchar(12)" & vbCrLf
         sSql = sSql & "   declare @JIDEB as decimal(13,2)" & vbCrLf
         sSql = sSql & "   declare @JICRD as decimal(13,2)" & vbCrLf
         sSql = sSql & "   declare @JR_DCDEBIT as decimal(13,2)" & vbCrLf
         sSql = sSql & "   declare @JR_DCCREDIT as decimal(13,2)" & vbCrLf
         sSql = sSql & "   declare @JR_TotBal as decimal(13,2)" & vbCrLf
         sSql = sSql & "   declare @Acc_StartBal as decimal(13,2)" & vbCrLf
         sSql = sSql & "   declare @Acc_StartBal_Inv as decimal(13,2)" & vbCrLf
         sSql = sSql & "   declare @MJTYPE as varchar(2)" & vbCrLf
         sSql = sSql & "   declare @MJDESCRIPTION as varchar(30)" & vbCrLf
         sSql = sSql & "   declare @StrAcc as varchar (30)" & vbCrLf
         sSql = sSql & "   declare @iStartAcc as varchar(16)" & vbCrLf
         sSql = sSql & "   declare @iEndAcc as varchar(16)" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "     " & vbCrLf
         sSql = sSql & "   IF (@StartAcc = 'ALL')" & vbCrLf
         sSql = sSql & "      SET @iStartAcc = '1'" & vbCrLf
         sSql = sSql & "   Else" & vbCrLf
         sSql = sSql & "      SET @iStartAcc = @StartAcc" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "   IF (@EndAcc  = 'ALL')" & vbCrLf
         sSql = sSql & "      SET @iEndAcc = '9999'" & vbCrLf
         sSql = sSql & "   Else" & vbCrLf
         sSql = sSql & "      SET @iEndAcc = @EndAcc" & vbCrLf
         sSql = sSql & "      " & vbCrLf
         sSql = sSql & "   CREATE TABLE #tempGLPost" & vbCrLf
         sSql = sSql & "   (" & vbCrLf
         sSql = sSql & "      tGLDESCR varchar(40) NULL ," & vbCrLf
         sSql = sSql & "      tGJPOST varchar(16) NULL ," & vbCrLf
         sSql = sSql & "      tJINAME varchar(12) NULL ," & vbCrLf
         sSql = sSql & "      tJIACCOUNT varchar(12) NULL ," & vbCrLf
         sSql = sSql & "      tAcc_StartBal decimal (13,2) NULL," & vbCrLf
         sSql = sSql & "      tJIDEB decimal(13,2) NULL ," & vbCrLf
         sSql = sSql & "      tJICRD decimal(13,2) NULL ," & vbCrLf
         sSql = sSql & "      tJR_DCDEBIT decimal(13,2) NULL ," & vbCrLf
         sSql = sSql & "      tJR_DCCREDIT decimal(13,2)NULL ," & vbCrLf
         sSql = sSql & "      tJR_TotBal decimal(13,2) NULL ," & vbCrLf
         sSql = sSql & "      tGJ_TotBal decimal(13,2) NULL ," & vbCrLf
         sSql = sSql & "      tMJTYPE varchar(2) NULL ," & vbCrLf
         sSql = sSql & "      tMJDESCRIPTION varchar(30) NULL," & vbCrLf
         sSql = sSql & "   )" & vbCrLf
         sSql = sSql & "   IF (@IncludeInActiveAcc = '1')" & vbCrLf
         sSql = sSql & "      DECLARE curGJ CURSOR" & vbCrLf
         sSql = sSql & "      LOCAL" & vbCrLf
         sSql = sSql & "      Scroll" & vbCrLf
         sSql = sSql & "      FOR" & vbCrLf
         sSql = sSql & "         SELECT DISTINCT GLDESCR, GJPOST," & vbCrLf
         sSql = sSql & "          JINAME , JIACCOUNT" & vbCrLf
         sSql = sSql & "           From GjitTable, GlacTable, GjhdTable" & vbCrLf
         sSql = sSql & "         Where JIACCOUNT = GLACCTREF" & vbCrLf
         sSql = sSql & "          AND GJNAME = JINAME" & vbCrLf
         sSql = sSql & "          AND GJPOST BETWEEN @StartDate AND @EndDate" & vbCrLf
         sSql = sSql & "          AND  JIACCOUNT BETWEEN @iStartAcc AND @iEndAcc" & vbCrLf
         sSql = sSql & "   Else" & vbCrLf
         sSql = sSql & "      DECLARE curGJ CURSOR" & vbCrLf
         sSql = sSql & "      LOCAL" & vbCrLf
         sSql = sSql & "      Scroll" & vbCrLf
         sSql = sSql & "      FOR" & vbCrLf
         sSql = sSql & "         SELECT DISTINCT GLDESCR, GJPOST," & vbCrLf
         sSql = sSql & "          JINAME , JIACCOUNT" & vbCrLf
         sSql = sSql & "           From GjitTable, GlacTable, GjhdTable" & vbCrLf
         sSql = sSql & "         Where JIACCOUNT = GLACCTREF" & vbCrLf
         sSql = sSql & "          AND GJNAME = JINAME" & vbCrLf
         sSql = sSql & "          AND GLINACTIVE = 0" & vbCrLf
         sSql = sSql & "          AND GJPOST BETWEEN @StartDate AND @EndDate" & vbCrLf
         sSql = sSql & "          AND  JIACCOUNT BETWEEN @iStartAcc AND @iEndAcc" & vbCrLf
         sSql = sSql & "     OPEN curGJ" & vbCrLf
         sSql = sSql & "     FETCH NEXT FROM curGJ INTO @GLDESCR,@GJPOST,@JINAME,@JIACCOUNT" & vbCrLf
         sSql = sSql & "     WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
         sSql = sSql & "     BEGIN" & vbCrLf
         sSql = sSql & "         IF (@@FETCH_STATUS <> -2)" & vbCrLf
         sSql = sSql & "         BEGIN" & vbCrLf
         sSql = sSql & "          SELECT @Acc_StartBal = SUM(JIDEB) - SUM(JICRD)" & vbCrLf
         sSql = sSql & "              From GjitTable, GlacTable, GjhdTable" & vbCrLf
         sSql = sSql & "           Where JIACCOUNT = GLACCTREF And" & vbCrLf
         sSql = sSql & "                GJNAME = JINAME And (GJPOSTED = 1)" & vbCrLf
         sSql = sSql & "                AND JIACCOUNT = @JIACCOUNT" & vbCrLf
         sSql = sSql & "                AND GJPOST < @StartDate" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "          SELECT @JIDEB = SUM(JIDEB), @JICRD = SUM(JICRD)" & vbCrLf
         sSql = sSql & "              From GjitTable, GlacTable" & vbCrLf
         sSql = sSql & "           Where JIACCOUNT = GLACCTREF And" & vbCrLf
         sSql = sSql & "                JINAME = @JINAME" & vbCrLf
         sSql = sSql & "                AND JIACCOUNT = @JIACCOUNT" & vbCrLf
         sSql = sSql & "  " & vbCrLf
         sSql = sSql & "          SELECT @JR_DCDEBIT = SUM(DCDEBIT) , @JR_DCCREDIT = SUM(DCCREDIT)," & vbCrLf
         sSql = sSql & "              @JR_TotBal = SUM(DCDEBIT) - SUM(DCCREDIT)," & vbCrLf
         sSql = sSql & "             @MJTYPE = MJTYPE, @MJDESCRIPTION = MJDESCRIPTION" & vbCrLf
         sSql = sSql & "          From jritTable, jrhdtable" & vbCrLf
         sSql = sSql & "          Where MJGLJRNL = DCHEAD And" & vbCrLf
         sSql = sSql & "             DCHEAD = @JINAME" & vbCrLf
         sSql = sSql & "             AND DCACCTNO = @JIACCOUNT" & vbCrLf
         sSql = sSql & "          GROUP BY DCHEAD,DCACCTNO,MJTYPE, MJDESCRIPTION" & vbCrLf
         sSql = sSql & "          " & vbCrLf
         sSql = sSql & "        INSERT INTO #tempGLPost(tGLDESCR, tGJPOST, tJINAME, tJIACCOUNT, tAcc_StartBal, tJIDEB, tJICRD," & vbCrLf
         sSql = sSql & "             tJR_DCDEBIT,tJR_DCCREDIT, tJR_TotBal, tGJ_TotBal, tMJTYPE, tMJDESCRIPTION )" & vbCrLf
         sSql = sSql & "          VALUES (@GLDESCR, @GJPOST, @JINAME, @JIACCOUNT, @Acc_StartBal, @JIDEB, @JICRD," & vbCrLf
         sSql = sSql & "             @JR_DCDEBIT, @JR_DCCREDIT, @JR_TotBal, @JIDEB - @JICRD, @MJTYPE, @MJDESCRIPTION)" & vbCrLf
         sSql = sSql & "       End" & vbCrLf
         sSql = sSql & "       FETCH NEXT FROM curGJ INTO @GLDESCR,@GJPOST,@JINAME,@JIACCOUNT" & vbCrLf
         sSql = sSql & "    End" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "   CLOSE curGJ   --// close the cursor" & vbCrLf
         sSql = sSql & "   DEALLOCATE curGJ" & vbCrLf
         sSql = sSql & "   " & vbCrLf
         sSql = sSql & "   --// Now all the un balanced accounts" & vbCrLf
         sSql = sSql & "   IF (@IncludeInActiveAcc = '1')" & vbCrLf
         sSql = sSql & "      DECLARE curInActiveAcc CURSOR" & vbCrLf
         sSql = sSql & "      LOCAL" & vbCrLf
         sSql = sSql & "      Scroll" & vbCrLf
         sSql = sSql & "      FOR" & vbCrLf
         sSql = sSql & "         SELECT DISTINCT GLDESCR, JIACCOUNT" & vbCrLf
         sSql = sSql & "           From GjitTable, GlacTable, GjhdTable" & vbCrLf
         sSql = sSql & "         Where JIACCOUNT = GLACCTREF" & vbCrLf
         sSql = sSql & "          AND GJNAME = JINAME" & vbCrLf
         sSql = sSql & "          AND (JIACCOUNT IN (SELECT DISTINCT JIACCOUNT" & vbCrLf
         sSql = sSql & "                  From GjitTable, GlacTable, GjhdTable" & vbCrLf
         sSql = sSql & "                  Where JIACCOUNT = GLACCTREF And" & vbCrLf
         sSql = sSql & "                  GJNAME = JINAME And (GJPOSTED = 1)" & vbCrLf
         sSql = sSql & "                  AND GJPOST < @StartDate" & vbCrLf
         sSql = sSql & "                  GROUP BY JIACCOUNT" & vbCrLf
         sSql = sSql & "                  HAVING (SUM(JIDEB) - SUM(JICRD)) <> 0))" & vbCrLf
         sSql = sSql & "         AND JIACCOUNT NOT IN" & vbCrLf
         sSql = sSql & "         (" & vbCrLf
         sSql = sSql & "         SELECT DISTINCT  JIACCOUNT" & vbCrLf
         sSql = sSql & "         From GjitTable, GlacTable, GjhdTable" & vbCrLf
         sSql = sSql & "         Where JIACCOUNT = GLACCTREF" & vbCrLf
         sSql = sSql & "          AND GJNAME = JINAME" & vbCrLf
         sSql = sSql & "          AND GJPOST BETWEEN @StartDate AND @EndDate" & vbCrLf
         sSql = sSql & "          AND  JIACCOUNT BETWEEN @iStartAcc AND @iEndAcc" & vbCrLf
         sSql = sSql & "         )" & vbCrLf
         sSql = sSql & "         AND  JIACCOUNT BETWEEN @iStartAcc AND @iEndAcc" & vbCrLf
         sSql = sSql & "         order by JIACCOUNT" & vbCrLf
         sSql = sSql & "   Else" & vbCrLf
         sSql = sSql & "      DECLARE curInActiveAcc CURSOR" & vbCrLf
         sSql = sSql & "      LOCAL" & vbCrLf
         sSql = sSql & "      Scroll" & vbCrLf
         sSql = sSql & "      FOR" & vbCrLf
         sSql = sSql & "         SELECT DISTINCT GLDESCR, JIACCOUNT" & vbCrLf
         sSql = sSql & "           From GjitTable, GlacTable, GjhdTable" & vbCrLf
         sSql = sSql & "         Where JIACCOUNT = GLACCTREF" & vbCrLf
         sSql = sSql & "          AND GJNAME = JINAME" & vbCrLf
         sSql = sSql & "          AND (JIACCOUNT IN (SELECT DISTINCT JIACCOUNT" & vbCrLf
         sSql = sSql & "                  From GjitTable, GlacTable, GjhdTable" & vbCrLf
         sSql = sSql & "                  Where JIACCOUNT = GLACCTREF And" & vbCrLf
         sSql = sSql & "                  GJNAME = JINAME And (GJPOSTED = 1)" & vbCrLf
         sSql = sSql & "                  AND GJPOST < @StartDate" & vbCrLf
         sSql = sSql & "                  GROUP BY JIACCOUNT" & vbCrLf
         sSql = sSql & "                  HAVING (SUM(JIDEB) - SUM(JICRD)) <> 0))" & vbCrLf
         sSql = sSql & "         AND JIACCOUNT NOT IN" & vbCrLf
         sSql = sSql & "         (" & vbCrLf
         sSql = sSql & "         SELECT DISTINCT  JIACCOUNT" & vbCrLf
         sSql = sSql & "         From GjitTable, GlacTable, GjhdTable" & vbCrLf
         sSql = sSql & "         Where JIACCOUNT = GLACCTREF" & vbCrLf
         sSql = sSql & "          AND GJNAME = JINAME" & vbCrLf
         sSql = sSql & "          AND GJPOST BETWEEN @StartDate AND @EndDate" & vbCrLf
         sSql = sSql & "          AND  JIACCOUNT BETWEEN @iStartAcc AND @iEndAcc" & vbCrLf
         sSql = sSql & "         )" & vbCrLf
         sSql = sSql & "         AND  JIACCOUNT BETWEEN @iStartAcc AND @iEndAcc" & vbCrLf
         sSql = sSql & "         order by JIACCOUNT" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "     OPEN curInActiveAcc" & vbCrLf
         sSql = sSql & "     FETCH NEXT FROM curInActiveAcc INTO @Inv_GLDESCR, @Inv_JIACCOUNT" & vbCrLf
         sSql = sSql & "     WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
         sSql = sSql & "     BEGIN" & vbCrLf
         sSql = sSql & "         IF (@@FETCH_STATUS <> -2)" & vbCrLf
         sSql = sSql & "         BEGIN" & vbCrLf
         sSql = sSql & "          SELECT @Acc_StartBal_Inv = SUM(JIDEB) - SUM(JICRD)" & vbCrLf
         sSql = sSql & "              From GjitTable, GlacTable, GjhdTable" & vbCrLf
         sSql = sSql & "           Where JIACCOUNT = GLACCTREF And" & vbCrLf
         sSql = sSql & "                GJNAME = JINAME And (GJPOSTED = 1)" & vbCrLf
         sSql = sSql & "                AND JIACCOUNT = @Inv_JIACCOUNT" & vbCrLf
         sSql = sSql & "                AND GJPOST < @StartDate" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "          " & vbCrLf
         sSql = sSql & "        INSERT INTO #tempGLPost(tGLDESCR, tJIACCOUNT, tAcc_StartBal )" & vbCrLf
         sSql = sSql & "          VALUES (@Inv_GLDESCR, @Inv_JIACCOUNT , @Acc_StartBal_Inv)" & vbCrLf
         sSql = sSql & "       End" & vbCrLf
         sSql = sSql & "      FETCH NEXT FROM curInActiveAcc INTO @Inv_GLDESCR, @Inv_JIACCOUNT" & vbCrLf
         sSql = sSql & "    End" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "   CLOSE curInActiveAcc   --// close the cursor" & vbCrLf
         sSql = sSql & "   DEALLOCATE curInActiveAcc" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "   SELECT tGLDESCR GLDESCR, tGJPOST GJPOST, tJINAME JINAME," & vbCrLf
         sSql = sSql & "      tJIACCOUNT JIACCOUNT, tAcc_StartBal AS StartingBalance, tJIDEB AS GL_JIDEB," & vbCrLf
         sSql = sSql & "      tJICRD AS GL_JICRD, tJR_DCDEBIT JR_DCDEBIT," & vbCrLf
         sSql = sSql & "      tJR_DCCREDIT JR_DCCREDIT, tGJ_TotBal GJ_TotBal," & vbCrLf
         sSql = sSql & "      tJR_TotBal JR_TotBal, tMJTYPE MJTYPE," & vbCrLf
         sSql = sSql & "      tMJDESCRIPTION MJDESCRIPTION" & vbCrLf
         sSql = sSql & "   FROM #tempGLPost order by tGLDESCR" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "   DROP table #tempGLPost" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "End" & vbCrLf

         ' Change the Trail balance store procedure.
         ExecuteScript True, sSql


         sSql = " ALTER PROCEDURE [dbo].[InventoryExcessReport] " & vbCrLf
         sSql = sSql & "          @BeginDate as varchar(16), @EndDate as varchar(16), @PartClass as Varchar(16), " & vbCrLf
         sSql = sSql & "          @PartCode as varchar(8), @InclZQty as Integer, @PartType1 as Integer, " & vbCrLf
         sSql = sSql & "          @PartType2 as Integer, @PartType3 as Integer, @PartType4 as Integer " & vbCrLf
         sSql = sSql & "      AS                                    " & vbCrLf
         sSql = sSql & "      BEGIN                                 " & vbCrLf
         sSql = sSql & "                                            " & vbCrLf
         sSql = sSql & "          declare @sqlZQty as varchar(12)   " & vbCrLf
         sSql = sSql & "                                            " & vbCrLf
         sSql = sSql & "          IF (@PartClass = 'ALL')           " & vbCrLf
         sSql = sSql & "          BEGIN                             " & vbCrLf
         sSql = sSql & "              SET @PartClass = ''           " & vbCrLf
         sSql = sSql & "          End                               " & vbCrLf
         sSql = sSql & "          IF (@PartCode = 'ALL')            " & vbCrLf
         sSql = sSql & "          BEGIN                             " & vbCrLf
         sSql = sSql & "              SET @PartCode = ''            " & vbCrLf
         sSql = sSql & "          End                               " & vbCrLf
         sSql = sSql & "                                            " & vbCrLf
         sSql = sSql & "          IF (@PartType1 = 1)               " & vbCrLf
         sSql = sSql & "              SET @PartType1 = 1            " & vbCrLf
         sSql = sSql & "          Else                              " & vbCrLf
         sSql = sSql & "              SET @PartType1 = 0            " & vbCrLf
         sSql = sSql & "                                            " & vbCrLf
         sSql = sSql & "          IF (@PartType2 = 1)               " & vbCrLf
         sSql = sSql & "              SET @PartType2 = 2            " & vbCrLf
         sSql = sSql & "     Else                              " & vbCrLf
         sSql = sSql & "        SET @PartType2 = 0                " & vbCrLf
         sSql = sSql & "                                          " & vbCrLf
         sSql = sSql & "    IF (@PartType3 = 1)                   " & vbCrLf
         sSql = sSql & "        SET @PartType3 = 3                " & vbCrLf
         sSql = sSql & "    Else                                  " & vbCrLf
         sSql = sSql & "        SET @PartType3 = 0                " & vbCrLf
         sSql = sSql & "                                          " & vbCrLf
         sSql = sSql & "    IF (@PartType4 = 1)                   " & vbCrLf
         sSql = sSql & "        SET @PartType4 = 4                " & vbCrLf
         sSql = sSql & "    Else                                  " & vbCrLf
         sSql = sSql & "        SET @PartType4 = 0                " & vbCrLf
         sSql = sSql & "                                          " & vbCrLf
         sSql = sSql & "    CREATE TABLE #tempExRpt               " & vbCrLf
         sSql = sSql & "    (                                     " & vbCrLf
         sSql = sSql & "        PACLASS varchar(4) NULL ,         " & vbCrLf
         sSql = sSql & "        PAPRODCODE varchar(6) NULL ,      " & vbCrLf
         sSql = sSql & "        PALEVEL tinyint NULL ,            " & vbCrLf
         sSql = sSql & "        PADESC varchar(30) NULL ,         " & vbCrLf
         sSql = sSql & "        PAEXTDESC varchar(3072) NULL ,    " & vbCrLf
         sSql = sSql & "        INPART varchar(30) NULL ,         " & vbCrLf
         sSql = sSql & "        INNUMBER int NULL ,               " & vbCrLf
         sSql = sSql & "        INTYPE int NULL ,                 " & vbCrLf
         sSql = sSql & "        INAMT decimal(12,4) NULL ,        " & vbCrLf
         sSql = sSql & "        LOTUNITCOST decimal(12,4) NULL ,  " & vbCrLf
         sSql = sSql & "        LOTNUMBER varchar(15) NULL,       " & vbCrLf
         sSql = sSql & "        LOTUSERLOTID varchar(40) NULL,       " & vbCrLf
         sSql = sSql & "        LOIQUANTITY decimal(12,4) NULL ,      " & vbCrLf
         sSql = sSql & "        LOTREMAININGQTY decimal(12,4) NULL ,  " & vbCrLf
         sSql = sSql & "        INADATE smalldatetime NULL ,          " & vbCrLf
         sSql = sSql & "        LOTADATE smalldatetime NULL ,         " & vbCrLf
         sSql = sSql & "        LOIMOPARTREF varchar(30) NULL         " & vbCrLf
         sSql = sSql & "    )                                          " & vbCrLf
         sSql = sSql & "                                              " & vbCrLf
         sSql = sSql & "    IF (@InclZQty = 1)                        " & vbCrLf
         sSql = sSql & "                                              " & vbCrLf
         sSql = sSql & "        INSERT INTO #tempExRpt (PACLASS, PAPRODCODE, PALEVEL,                             " & vbCrLf
         sSql = sSql & "            PADESC, PAEXTDESC, INPART , INNUMBER, INTYPE, INAMT,                          " & vbCrLf
         sSql = sSql & "            LOTUNITCOST, LOTNUMBER, LOTUSERLOTID, LOIQUANTITY,                            " & vbCrLf
         sSql = sSql & "            LOTREMAININGQTY, INADATE, LOTADATE, LOIMOPARTREF)                             " & vbCrLf
         sSql = sSql & "        SELECT PACLASS, PAPRODCODE, PALEVEL, PADESC, PAEXTDESC, a.INPART , a.INNUMBER,    " & vbCrLf
         sSql = sSql & "            a.INTYPE, a.INAMT, LOTUNITCOST, LOTNUMBER, LOTUSERLOTID,                      " & vbCrLf
         sSql = sSql & "            LOIQUANTITY , LOTREMAININGQTY, a.INADATE, LOTADATE, LOIMOPARTREF              " & vbCrLf
         sSql = sSql & "        FROM invaTable a, LoitTable, ViewLohdPartTable                                    " & vbCrLf
         sSql = sSql & "        Where a.INPART = LoitTable.LOIPARTREF                                             " & vbCrLf
         sSql = sSql & "            AND ViewLohdPartTable.partref = a.INPART                                      " & vbCrLf
         sSql = sSql & "            AND LoitTable.LOIPARTREF = ViewLohdPartTable.partref                          " & vbCrLf
         sSql = sSql & "            AND ViewLohdPartTable.LOTNUMBER = LoitTable.LOINUMBER                         " & vbCrLf
         sSql = sSql & "            AND a.INNUMBER = LoitTable.LOIACTIVITY                                        " & vbCrLf
         sSql = sSql & "            AND ViewLohdPartTable.PACLASS LIKE '%' + @PartClass + '%'                     " & vbCrLf
         sSql = sSql & "            AND ViewLohdPartTable.PAPRODCODE LIKE '%' + @PartCode + '%'                       " & vbCrLf
         sSql = sSql & "            AND ViewLohdPartTable.PALEVEL IN (@PartType1, @PartType2, @PartType3, @PartType4)  " & vbCrLf
         sSql = sSql & "            AND a.INPART NOT IN                          " & vbCrLf
         sSql = sSql & "                (SELECT INPART FROM invaTable b          " & vbCrLf
         sSql = sSql & "                Where a.INPART = b.INPART                " & vbCrLf
         sSql = sSql & "                    AND INADATE BETWEEN @BeginDate and @EndDate  " & vbCrLf
         sSql = sSql & "                    AND INTYPE IN (1, 3, 4, 6, 7, 9, 10, 11,15,17,19,23,25,26,32))   " & vbCrLf
         sSql = sSql & "        AND a.INADATE <=                                  " & vbCrLf
         sSql = sSql & "                (SELECT MAX(INADATE) FROM invaTable c    " & vbCrLf
         sSql = sSql & "                Where C.INPART = a.INPART                " & vbCrLf
         sSql = sSql & "                    AND c.INADATE < DATEADD(dd, -1 , @BeginDate)     " & vbCrLf
         sSql = sSql & "                Group by c.INPART)                       " & vbCrLf
         sSql = sSql & "        order by a.INPART                                " & vbCrLf
         sSql = sSql & "    Else                                                 " & vbCrLf
         sSql = sSql & "        INSERT INTO #tempExRpt (PACLASS, PAPRODCODE, PALEVEL,PADESC, PAEXTDESC,  " & vbCrLf
         sSql = sSql & "            INPART, INNUMBER, INTYPE, INAMT, LOTUNITCOST, LOTNUMBER,             " & vbCrLf
         sSql = sSql & "            LOTUSERLOTID, LOIQUANTITY, LOTREMAININGQTY, INADATE,                 " & vbCrLf
         sSql = sSql & "            LOTADATE, LOIMOPARTREF)                                              " & vbCrLf
         sSql = sSql & "        SELECT PACLASS, PAPRODCODE, PALEVEL, PADESC, PAEXTDESC, a.INPART , a.INNUMBER,   " & vbCrLf
         sSql = sSql & "            a.INTYPE, a.INAMT, LOTUNITCOST, LOTNUMBER, LOTUSERLOTID,            " & vbCrLf
         sSql = sSql & "            LOIQUANTITY , LOTREMAININGQTY, a.INADATE, LOTADATE, LOIMOPARTREF     " & vbCrLf
         sSql = sSql & "        FROM invaTable a, LoitTable, ViewLohdPartTable                           " & vbCrLf
         sSql = sSql & "        Where a.INPART = LoitTable.LOIPARTREF                                    " & vbCrLf
         sSql = sSql & "            AND ViewLohdPartTable.partref = a.INPART                             " & vbCrLf
         sSql = sSql & "            AND LoitTable.LOIPARTREF = ViewLohdPartTable.partref                 " & vbCrLf
         sSql = sSql & "            AND ViewLohdPartTable.LOTNUMBER = LoitTable.LOINUMBER                " & vbCrLf
         sSql = sSql & "            AND a.INNUMBER = LoitTable.LOIACTIVITY                               " & vbCrLf
         sSql = sSql & "            AND ViewLohdPartTable.PACLASS LIKE '%' + @PartClass + '%'            " & vbCrLf
         sSql = sSql & "            AND ViewLohdPartTable.PAPRODCODE LIKE '%' + @PartCode + '%'          " & vbCrLf
         sSql = sSql & "            AND ViewLohdPartTable.PALEVEL IN (@PartType1, @PartType2, @PartType3, @PartType4)    " & vbCrLf
         sSql = sSql & "            AND a.INPART NOT IN                                      " & vbCrLf
         sSql = sSql & "                (SELECT INPART FROM invaTable b                      " & vbCrLf
         sSql = sSql & "                Where a.INPART = b.INPART                            " & vbCrLf
         sSql = sSql & "                    AND INADATE BETWEEN @BeginDate and @EndDate      " & vbCrLf
         sSql = sSql & "                    AND INTYPE IN (1, 3, 4, 6, 7, 9, 10, 11,15,17,19,23,25,26,32))   " & vbCrLf
         sSql = sSql & "        AND a.INADATE <=                                              " & vbCrLf
         sSql = sSql & "                (SELECT MAX(INADATE) FROM invaTable c                " & vbCrLf
         sSql = sSql & "                Where C.INPART = a.INPART                            " & vbCrLf
         sSql = sSql & "                    AND c.INADATE < DATEADD(dd, -1 , @BeginDate)     " & vbCrLf
         sSql = sSql & "                Group by c.INPART)                                   " & vbCrLf
         sSql = sSql & "        AND a.INAQTY > 0                                             " & vbCrLf
         sSql = sSql & "            order by a.INPART                                        " & vbCrLf
         sSql = sSql & "                                                                     " & vbCrLf
         sSql = sSql & "    SELECT PACLASS, PAPRODCODE, PALEVEL, PADESC, PAEXTDESC, INPART,  " & vbCrLf
         sSql = sSql & "        INPART, INNUMBER, INTYPE, INAMT, LOTUNITCOST,                " & vbCrLf
         sSql = sSql & "        LOTNUMBER, LOTUSERLOTID, LOIQUANTITY,                        " & vbCrLf
         sSql = sSql & "        LOTREMAININGQTY , INADATE, LOTADATE, LOIMOPARTREF            " & vbCrLf
         sSql = sSql & "    FROM #tempExRpt                                                  " & vbCrLf
         sSql = sSql & "        WHERE INPART NOT IN                                          " & vbCrLf
         sSql = sSql & "                (SELECT DISTINCT mrp_Partref FROM dbo.MrplTable      " & vbCrLf
         sSql = sSql & "         WHERE mrp_type IN (2, 3, 4, 11, 12, 17)              " & vbCrLf
         sSql = sSql & "                        AND mrp_partDateRQD < DATEADD(dd, +1 , @EndDate))    " & vbCrLf
         sSql = sSql & "    DROP table #tempExRpt                                                    " & vbCrLf
         sSql = sSql & " End                                                                          " & vbCrLf
 
         ' Change the Inventory balance SP.
         ExecuteScript True, sSql

        'BBS Added this to this database update to handle older systems on 2/24/2011
        If Not TableExists("BitImage") Then
            ExecuteScript False, "CREATE TABLE [dbo].[BitImage]([ImageRecord] [int] NULL, [ImageStored] [image] NULL) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]"
        End If

        ExecuteScript False, "Update Version Set Version = " & newver
    End If
End Function



Private Function UpdateDatabase11()
   newver = 85
   If ver < newver Then
      ver = newver
    
      sSql = "INSERT INTO StatCdType (STATCODE_TYPE_REF, STATCODE_TYPE_NAME, STATCODE_TYPE_UNIQUE_KEY) VALUES ('PO','Purchase Order', 3)"
      clsADOCon.ExecuteSql sSql 'rdExecDirect
      
      sSql = "INSERT INTO StatCdType (STATCODE_TYPE_REF, STATCODE_TYPE_NAME, STATCODE_TYPE_UNIQUE_KEY) VALUES ('POI','Purchase Order Item', 3)"
      clsADOCon.ExecuteSql sSql 'rdExecDirect
      
      sSql = "ALTER TABLE EsReportBOMTable ALTER COLUMN BomSortKey varchar(80) null"
      clsADOCon.ExecuteSql sSql 'rdExecDirect

      ExecuteScript False, "drop view Vw_Sales"

      sSql = " CREATE VIEW [dbo].[Vw_Sales] " & vbCrLf
      sSql = sSql & "    AS " & vbCrLf
      sSql = sSql & "SELECT DISTINCT    " & vbCrLf
      sSql = sSql & "      TOP 100 PERCENT dbo.CihdTable.INVCANCELED, dbo.CihdTable.INVTYPE, dbo.CihdTable.INVPRE, dbo.CihdTable.INVNO," & vbCrLf
      sSql = sSql & "      dbo.LoitTable.LOICUSTINVNO, dbo.CihdTable.INVCUST, dbo.CustTable.CUNUMBER, dbo.CustTable.CUNAME, dbo.CihdTable.INVDATE," & vbCrLf
      sSql = sSql & "      dbo.CihdTable.INVPIF, dbo.PshdTable.PSCANCELED, dbo.PshdTable.PSTYPE, dbo.PsitTable.PIPACKSLIP, dbo.PsitTable.PIITNO," & vbCrLf
      sSql = sSql & "      dbo.InvaTable.INPSNUMBER, dbo.InvaTable.INPSITEM, dbo.LoitTable.LOIPSNUMBER, dbo.LoitTable.LOIPSITEM, dbo.SoitTable.ITPSSHIPPED," & vbCrLf
      sSql = sSql & "      dbo.SohdTable.SOSALESMAN AS PSSoSalesman, SohdTable_1.SOSALESMAN AS SOSoSlsmn, dbo.SohdTable.SOPO AS PSSoPo," & vbCrLf
      sSql = sSql & "      SohdTable_1.SOPO AS SOSoPo, dbo.SohdTable.SODIVISION AS PSSoDiv, SohdTable_1.SODIVISION AS SOSoDiv," & vbCrLf
      sSql = sSql & "      dbo.SohdTable.SOREGION AS PSSoReg, SohdTable_1.SOREGION AS SOSoReg, dbo.SohdTable.SOBUSUNIT AS PSSoBu," & vbCrLf
      sSql = sSql & "      SohdTable_1.SOBUSUNIT AS SOSoBu, dbo.SprsTable.SPLAST AS PSSlsmnLast, SprsTable_1.SPLAST AS SOSlsmnLast," & vbCrLf
      sSql = sSql & "      dbo.SprsTable.SPFIRST AS PSSlsmnFirst, SprsTable_1.SPFIRST AS SOSlsmnFirst, dbo.SprsTable.SPMIDD AS PSSlsmnInit," & vbCrLf
      sSql = sSql & "      SprsTable_1.SPMIDD AS SOSlsmnInit, dbo.SohdTable.SOTYPE AS SOSoType, SohdTable_1.SOTYPE AS PSSoType, dbo.SoitTable.ITSO," & vbCrLf
      sSql = sSql & "      dbo.SoitTable.ITNUMBER, dbo.SoitTable.ITREV, dbo.SoitTable.ITPART, dbo.PartTable.PARTNUM, dbo.PartTable.PADESC, dbo.PartTable.PALEVEL," & vbCrLf
      sSql = sSql & "      dbo.PartTable.PALOTTRACK, dbo.PartTable.PAUSEACTUALCOST, dbo.PartTable.PAUNITS, dbo.PartTable.PAMAKEBUY, dbo.PartTable.PAFAMILY," & vbCrLf
      sSql = sSql & "      dbo.PartTable.PAPRODCODE, dbo.PcodTable.PCDESC, dbo.PartTable.PACLASS, dbo.PclsTable.CCDESC, dbo.SoitTable.ITQTY," & vbCrLf
      sSql = sSql & "      dbo.SoitTable.ITDOLLARS, dbo.SoitTable.ITADJUST, dbo.SoitTable.ITDISCAMOUNT, dbo.SoitTable.ITCOMMISSION, dbo.SoitTable.ITBOOKDATE," & vbCrLf
      sSql = sSql & "      dbo.SoitTable.ITSCHED, dbo.SoitTable.ITACTUAL, dbo.SoitTable.ITCANCELDATE, dbo.SoitTable.ITCANCELED, dbo.SoitTable.ITREVACCT," & vbCrLf
      sSql = sSql & "      dbo.GlacTable.GLACCTNO AS RevAcct, dbo.GlacTable.GLDESCR AS RevAcctDesc, dbo.SoitTable.ITCGSACCT, dbo.SoitTable.ITDISACCT," & vbCrLf
      sSql = sSql & "      dbo.SoitTable.ITSTATE, dbo.SoitTable.ITTAXCODE, dbo.InvaTable.INTYPE, dbo.InvaTable.INAQTY, dbo.InvaTable.INAMT, dbo.InvaTable.INTOTLABOR," & vbCrLf
      sSql = sSql & "      dbo.InvaTable.INTOTMATL, dbo.InvaTable.INTOTEXP, dbo.InvaTable.INTOTOH, dbo.PartTable.PASTDCOST, dbo.PartTable.PATOTCOST," & vbCrLf
      sSql = sSql & "      dbo.PartTable.PATOTLABOR, dbo.PartTable.PATOTMATL, dbo.PartTable.PATOTEXP, dbo.PartTable.PATOTOH, dbo.InvaTable.INDRLABACCT," & vbCrLf
      sSql = sSql & "      dbo.InvaTable.INDRMATACCT, dbo.InvaTable.INDREXPACCT, dbo.InvaTable.INDROHDACCT, dbo.InvaTable.INCRLABACCT," & vbCrLf
      sSql = sSql & "      dbo.InvaTable.INCRMATACCT, dbo.InvaTable.INCREXPACCT, dbo.InvaTable.INCROHDACCT, dbo.LoitTable.LOITYPE, dbo.LoitTable.LOINUMBER," & vbCrLf
      sSql = sSql & "      dbo.LoitTable.LOIRECORD, dbo.LoitTable.LOIQUANTITY, dbo.LoitTable.LOIADATE, dbo.LohdTable.LOTNUMBER, dbo.LohdTable.LOTUSERLOTID," & vbCrLf
      sSql = sSql & "      dbo.LohdTable.LOTPARTREF, dbo.LohdTable.LOTDATECOSTED, dbo.LohdTable.LOTTOTLABOR, dbo.LohdTable.LOTTOTMATL," & vbCrLf
      sSql = sSql & "      dbo.LohdTable.LOTTOTEXP , dbo.LohdTable.LOTTOTOH, dbo.LohdTable.LOTUNITCOST, dbo.LoitTable.LOIACTIVITY" & vbCrLf
      sSql = sSql & "  FROM  dbo.GlacTable RIGHT OUTER JOIN" & vbCrLf
      sSql = sSql & "      dbo.SprsTable RIGHT OUTER JOIN" & vbCrLf
      sSql = sSql & "      dbo.SoitTable LEFT OUTER JOIN" & vbCrLf
      sSql = sSql & "      dbo.SohdTable ON dbo.SoitTable.ITSO = dbo.SohdTable.SONUMBER ON" & vbCrLf
      sSql = sSql & "      dbo.SprsTable.SPNUMBER = dbo.SohdTable.SOSALESMAN RIGHT OUTER JOIN" & vbCrLf
      sSql = sSql & "      dbo.CustTable RIGHT OUTER JOIN" & vbCrLf
      sSql = sSql & "      dbo.CihdTable ON dbo.CustTable.CUREF = dbo.CihdTable.INVCUST ON dbo.SoitTable.ITINVOICE = dbo.CihdTable.INVNO LEFT OUTER JOIN" & vbCrLf
      sSql = sSql & "      dbo.SprsTable AS SprsTable_1 RIGHT OUTER JOIN" & vbCrLf
      sSql = sSql & "      dbo.SohdTable AS SohdTable_1 ON SprsTable_1.SPNUMBER = SohdTable_1.SOSALESMAN ON" & vbCrLf
      sSql = sSql & "      dbo.CihdTable.INVSO = SohdTable_1.SONUMBER LEFT OUTER JOIN" & vbCrLf
      sSql = sSql & "      dbo.PcodTable RIGHT OUTER JOIN" & vbCrLf
      sSql = sSql & "      dbo.PclsTable RIGHT OUTER JOIN" & vbCrLf
      sSql = sSql & "      dbo.PartTable ON dbo.PclsTable.CCREF = dbo.PartTable.PACLASS ON dbo.PcodTable.PCREF = dbo.PartTable.PAPRODCODE ON" & vbCrLf
      sSql = sSql & "      dbo.SoitTable.ITPART = dbo.PartTable.PARTREF ON dbo.GlacTable.GLACCTREF = dbo.SoitTable.ITREVACCT LEFT OUTER JOIN" & vbCrLf
      sSql = sSql & "      dbo.PshdTable RIGHT OUTER JOIN" & vbCrLf
      sSql = sSql & "      dbo.PsitTable ON dbo.PshdTable.PSNUMBER = dbo.PsitTable.PIPACKSLIP LEFT OUTER JOIN" & vbCrLf
      sSql = sSql & "      dbo.InvaTable LEFT OUTER JOIN" & vbCrLf
      sSql = sSql & "      dbo.LoitTable INNER JOIN" & vbCrLf
      sSql = sSql & "      dbo.LohdTable ON dbo.LoitTable.LOINUMBER = dbo.LohdTable.LOTNUMBER ON dbo.InvaTable.INAQTY = dbo.LoitTable.LOIQUANTITY AND" & vbCrLf
      sSql = sSql & "      dbo.InvaTable.INPSNUMBER = dbo.LoitTable.LOIPSNUMBER AND dbo.InvaTable.INPSITEM = dbo.LoitTable.LOIPSITEM ON" & vbCrLf
      sSql = sSql & "      dbo.PsitTable.PIPACKSLIP = dbo.InvaTable.INPSNUMBER AND dbo.PsitTable.PIITNO = dbo.InvaTable.INPSITEM ON" & vbCrLf
      sSql = sSql & "      dbo.SoitTable.ITSO = dbo.PsitTable.PISONUMBER AND dbo.SoitTable.ITNUMBER = dbo.PsitTable.PISOITEM AND" & vbCrLf
      sSql = sSql & "      dbo.SoitTable.ITREV = dbo.PsitTable.PISOREV" & vbCrLf
      sSql = sSql & " ORDER BY dbo.CihdTable.INVDATE, dbo.CihdTable.INVNO, dbo.InvaTable.INPSNUMBER, dbo.InvaTable.INPSITEM, dbo.SoitTable.ITSO," & vbCrLf
      sSql = sSql & "      dbo.SoitTable.ITNUMBER , dbo.SoitTable.ITREV"

      ' Change the slaes view for top/bottom report.
      ExecuteScript True, sSql

      ExecuteScript False, "Update Version Set Version = " & newver
   End If
End Function



Private Function UpdateDatabase12()
   newver = 86
   If ver < newver Then
      ver = newver
      If Not ColumnExists("PartTable", "PALASTROLT") Then
        sSql = "ALTER TABLE PartTable ADD PALASTROLT decimal(12,4) null"
        clsADOCon.ExecuteSql sSql 'rdExecDirect
      End If
      ExecuteScript False, "Update Version Set Version = " & newver
   End If
End Function

Private Function UpdateDatabase13()
   newver = 87
   If ver < newver Then
      ver = newver

      If NormalizeConstraintNme("SoitTable", "DF__SOITTABLE__ITCUS", "DF_SoitTable_ITCUSTITEMNO") Then
        
            sSql = "ALTER TABLE dbo.SoitTable" & vbCrLf
            sSql = sSql & " DROP CONSTRAINT DF_SoitTable_ITCUSTITEMNO" & vbCrLf
            ExecuteScript False, sSql
        
            sSql = "ALTER TABLE dbo.SoitTable ALTER COLUMN ITCUSTITEMNO VARCHAR(15)" & vbCrLf
            ExecuteScript False, sSql
           
            'sSql = "ALTER TABLE dbo.SohdTable ADD CONSTRAINT" & vbCrLf
            'sSql = sSql & " DF_SoitTable_ITCUSTITEMNO DEFAULT ('') FOR ITCUSTITEMNO" & vbCrLf
            'ExecuteScript False, sSql
      End If
      
      
      If TableExists("EsReportPartsAvailable") Then
        If ColumnExists("EsReportPartsAvailable", "CUSTITEMNO") Then
            sSql = "ALTER TABLE EsReportPartsAvailable ALTER COLUMN CUSTITEMNO VARCHAR(15)"
            ExecuteScript False, sSql
        End If
      End If
      
      
      ExecuteScript False, "DROP view viewLotCostsByMoDetails"

      sSql = " CREATE VIEW [dbo].[viewLotCostsByMoDetails]" & vbCrLf
      sSql = sSql & " AS " & vbCrLf
      sSql = sSql & " SELECT DISTINCT dbo.LoitTable.LOITYPE, RTRIM(dbo.LoitTable.LOIMOPARTREF) AS MoPart," & vbCrLf
      sSql = sSql & "      dbo.LoitTable.LOIMORUNNO AS MoRun, RTRIM(dbo.LohdTable.LOTPARTREF) AS Part," & vbCrLf
      sSql = sSql & "      - dbo.LoitTable.LOIQUANTITY AS Quantity, dbo.LohdTable.LOTUNITCOST AS UnitCost," & vbCrLf
      sSql = sSql & "    CAST(- (dbo.LohdTable.LOTUNITCOST * dbo.LoitTable.LOIQUANTITY) AS decimal(15, 4)) AS TotalCost," & vbCrLf
      sSql = sSql & "      dbo.LohdTable.LOTNUMBER, RTRIM(dbo.LohdTable.LOTUSERLOTID) AS LotUserID," & vbCrLf
      sSql = sSql & "      dbo.LohdTable.LOTMAINTCOSTED , dbo.LohdTable.LOTDATECOSTED, dbo.LoitTable.LOIADATE" & vbCrLf
      sSql = sSql & " FROM dbo.LohdTable INNER JOIN" & vbCrLf
      sSql = sSql & "      dbo.LoitTable ON dbo.LohdTable.LOTNUMBER = dbo.LoitTable.LOINUMBER" & vbCrLf
      sSql = sSql & "      AND dbo.LoitTable.LOITYPE = 10 INNER JOIN" & vbCrLf
      sSql = sSql & "    dbo.PartTable ON dbo.LohdTable.LOTPARTREF = dbo.PartTable.PARTREF" & vbCrLf
      sSql = sSql & "      AND dbo.PartTable.PALEVEL < 5 AND dbo.PartTable.PALOTTRACK = 1"
      
      ' Changed the view to include the loiAdate to show both MO ALLOC and PICKED .
      ExecuteScript True, sSql
      
      
      ExecuteScript False, "Update Version Set Version = " & newver
      
   End If
End Function


Private Function UpdateDatabase14()
   newver = 88
   If ver < newver Then
      ver = newver

      sSql = "ALTER PROCEDURE [dbo].[TrialBalanceGLPost]" & vbCrLf
      sSql = sSql & "    @StartDate as Varchar(16), @EndDate as varchar(16)," & vbCrLf
      sSql = sSql & "    @StartAcc as Varchar(16), @EndAcc as varchar(16)," & vbCrLf
      sSql = sSql & "   @IncludeInActiveAcc as varchar(2)" & vbCrLf
      sSql = sSql & "    AS                              " & vbCrLf
      sSql = sSql & "   BEGIN " & vbCrLf
      sSql = sSql & "   declare @GLDESCR as varchar(40)" & vbCrLf
      sSql = sSql & "   declare @Inv_GLDESCR as varchar(40)" & vbCrLf
      sSql = sSql & "   declare @GJPOST as varchar(16)" & vbCrLf
      sSql = sSql & "   declare @JINAME as varchar(12)" & vbCrLf
      sSql = sSql & "   declare @JIACCOUNT as varchar(12)" & vbCrLf
      sSql = sSql & "   declare @Inv_JIACCOUNT as varchar(12)" & vbCrLf
      sSql = sSql & "   declare @JIDEB as decimal(13,2)" & vbCrLf
      sSql = sSql & "   declare @JICRD as decimal(13,2)" & vbCrLf
      sSql = sSql & "   declare @JR_DCDEBIT as decimal(13,2)" & vbCrLf
      sSql = sSql & "   declare @JR_DCCREDIT as decimal(13,2)" & vbCrLf
      sSql = sSql & "   declare @JR_TotBal as decimal(13,2)" & vbCrLf
      sSql = sSql & "   declare @Acc_StartBal as decimal(13,2)" & vbCrLf
      sSql = sSql & "   declare @Acc_StartBal_Inv as decimal(13,2)" & vbCrLf
      sSql = sSql & "   declare @MJTYPE as varchar(2)" & vbCrLf
      sSql = sSql & "   declare @MJDESCRIPTION as varchar(30)" & vbCrLf
      sSql = sSql & "   declare @StrAcc as varchar (30)" & vbCrLf
      sSql = sSql & "   declare @iStartAcc as varchar(16)" & vbCrLf
      sSql = sSql & "   declare @iEndAcc as varchar(16)" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   IF (@StartAcc = 'ALL')" & vbCrLf
      sSql = sSql & "      SET @iStartAcc = '1'" & vbCrLf
      sSql = sSql & "   Else" & vbCrLf
      sSql = sSql & "      SET @iStartAcc = @StartAcc" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   IF (@EndAcc  = 'ALL')" & vbCrLf
      sSql = sSql & "      SET @iEndAcc = '9999'" & vbCrLf
      sSql = sSql & "   Else" & vbCrLf
      sSql = sSql & "      SET @iEndAcc = @EndAcc" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   CREATE TABLE #tempGLPost" & vbCrLf
      sSql = sSql & "   (                       " & vbCrLf
      sSql = sSql & "      tGLDESCR varchar(40) NULL ," & vbCrLf
      sSql = sSql & "      tGJPOST varchar(16) NULL ," & vbCrLf
      sSql = sSql & "      tJINAME varchar(12) NULL ," & vbCrLf
      sSql = sSql & "      tJIACCOUNT varchar(12) NULL ," & vbCrLf
      sSql = sSql & "      tAcc_StartBal decimal (13,2) NULL," & vbCrLf
      sSql = sSql & "      tJIDEB decimal(13,2) NULL ," & vbCrLf
      sSql = sSql & "      tJICRD decimal(13,2) NULL ," & vbCrLf
      sSql = sSql & "      tJR_DCDEBIT decimal(13,2) NULL ," & vbCrLf
      sSql = sSql & "      tJR_DCCREDIT decimal(13,2)NULL ," & vbCrLf
      sSql = sSql & "      tJR_TotBal decimal(13,2) NULL ," & vbCrLf
      sSql = sSql & "      tGJ_TotBal decimal(13,2) NULL ," & vbCrLf
      sSql = sSql & "      tMJTYPE varchar(2) NULL ," & vbCrLf
      sSql = sSql & "      tMJDESCRIPTION varchar(30) NULL," & vbCrLf
      sSql = sSql & "   )" & vbCrLf
      sSql = sSql & "   IF (@IncludeInActiveAcc = '1')" & vbCrLf
      sSql = sSql & "      DECLARE curGJ CURSOR" & vbCrLf
      sSql = sSql & "      LOCAL" & vbCrLf
      sSql = sSql & "      Scroll " & vbCrLf
      sSql = sSql & "      FOR" & vbCrLf
      sSql = sSql & "         SELECT DISTINCT GLDESCR, GJPOST," & vbCrLf
      sSql = sSql & "          JINAME , JIACCOUNT" & vbCrLf
      sSql = sSql & "           From GjitTable, GlacTable, GjhdTable" & vbCrLf
      sSql = sSql & "         Where JIACCOUNT = GLACCTREF" & vbCrLf
      sSql = sSql & "          AND GJNAME = JINAME AND (GJPOSTED = 1)" & vbCrLf
      sSql = sSql & "          AND GJPOST BETWEEN @StartDate AND @EndDate" & vbCrLf
      sSql = sSql & "          AND  JIACCOUNT BETWEEN @iStartAcc AND @iEndAcc" & vbCrLf
      sSql = sSql & "   Else" & vbCrLf
      sSql = sSql & "      DECLARE curGJ CURSOR" & vbCrLf
      sSql = sSql & "      LOCAL" & vbCrLf
      sSql = sSql & "      Scroll " & vbCrLf
      sSql = sSql & "      FOR" & vbCrLf
      sSql = sSql & "         SELECT DISTINCT GLDESCR, GJPOST," & vbCrLf
      sSql = sSql & "          JINAME , JIACCOUNT" & vbCrLf
      sSql = sSql & "           From GjitTable, GlacTable, GjhdTable" & vbCrLf
      sSql = sSql & "         Where JIACCOUNT = GLACCTREF" & vbCrLf
      sSql = sSql & "          AND GJNAME = JINAME" & vbCrLf
      sSql = sSql & "          AND GLINACTIVE = 0  AND (GJPOSTED = 1)" & vbCrLf
      sSql = sSql & "          AND GJPOST BETWEEN @StartDate AND @EndDate" & vbCrLf
      sSql = sSql & "          AND  JIACCOUNT BETWEEN @iStartAcc AND @iEndAcc" & vbCrLf
      sSql = sSql & "     OPEN curGJ" & vbCrLf
      sSql = sSql & "     FETCH NEXT FROM curGJ INTO @GLDESCR,@GJPOST,@JINAME,@JIACCOUNT" & vbCrLf
      sSql = sSql & "     WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "     BEGIN " & vbCrLf
      sSql = sSql & "         IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "         BEGIN " & vbCrLf
      sSql = sSql & "          SELECT @Acc_StartBal = SUM(JIDEB) - SUM(JICRD)" & vbCrLf
      sSql = sSql & "              From GjitTable, GlacTable, GjhdTable" & vbCrLf
      sSql = sSql & "           Where JIACCOUNT = GLACCTREF And " & vbCrLf
      sSql = sSql & "                GJNAME = JINAME And (GJPOSTED = 1)" & vbCrLf
      sSql = sSql & "                AND JIACCOUNT = @JIACCOUNT" & vbCrLf
      sSql = sSql & "                AND GJPOST < @StartDate" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "          SELECT @JIDEB = SUM(JIDEB), @JICRD = SUM(JICRD)" & vbCrLf
      sSql = sSql & "              From GjitTable, GlacTable" & vbCrLf
      sSql = sSql & "           Where JIACCOUNT = GLACCTREF And " & vbCrLf
      sSql = sSql & "                JINAME = @JINAME" & vbCrLf
      sSql = sSql & "                AND JIACCOUNT = @JIACCOUNT" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "          SELECT @JR_DCDEBIT = SUM(DCDEBIT) , @JR_DCCREDIT = SUM(DCCREDIT)," & vbCrLf
      sSql = sSql & "              @JR_TotBal = SUM(DCDEBIT) - SUM(DCCREDIT)," & vbCrLf
      sSql = sSql & "             @MJTYPE = MJTYPE, @MJDESCRIPTION = MJDESCRIPTION" & vbCrLf
      sSql = sSql & "          From jritTable, jrhdtable" & vbCrLf
      sSql = sSql & "          Where MJGLJRNL = DCHEAD And " & vbCrLf
      sSql = sSql & "             DCHEAD = @JINAME" & vbCrLf
      sSql = sSql & "             AND DCACCTNO = @JIACCOUNT" & vbCrLf
      sSql = sSql & "          GROUP BY DCHEAD,DCACCTNO,MJTYPE, MJDESCRIPTION" & vbCrLf
      sSql = sSql & "          " & vbCrLf
      sSql = sSql & "        INSERT INTO #tempGLPost(tGLDESCR, tGJPOST, tJINAME, tJIACCOUNT, tAcc_StartBal, tJIDEB, tJICRD," & vbCrLf
      sSql = sSql & "             tJR_DCDEBIT,tJR_DCCREDIT, tJR_TotBal, tGJ_TotBal, tMJTYPE, tMJDESCRIPTION )" & vbCrLf
      sSql = sSql & "          VALUES (@GLDESCR, @GJPOST, @JINAME, @JIACCOUNT, @Acc_StartBal, @JIDEB, @JICRD," & vbCrLf
      sSql = sSql & "             @JR_DCDEBIT, @JR_DCCREDIT, @JR_TotBal, @JIDEB - @JICRD, @MJTYPE, @MJDESCRIPTION)" & vbCrLf
      sSql = sSql & "       End" & vbCrLf
      sSql = sSql & "       FETCH NEXT FROM curGJ INTO @GLDESCR,@GJPOST,@JINAME,@JIACCOUNT" & vbCrLf
      sSql = sSql & "    End" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   CLOSE curGJ   --// close the cursor" & vbCrLf
      sSql = sSql & "   DEALLOCATE curGJ" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   --// Now all the un balanced accounts" & vbCrLf
      sSql = sSql & "   IF (@IncludeInActiveAcc = '1')" & vbCrLf
      sSql = sSql & "      DECLARE curInActiveAcc CURSOR" & vbCrLf
      sSql = sSql & "      LOCAL" & vbCrLf
      sSql = sSql & "      Scroll " & vbCrLf
      sSql = sSql & "      FOR" & vbCrLf
      sSql = sSql & "         SELECT DISTINCT GLDESCR, JIACCOUNT" & vbCrLf
      sSql = sSql & "           From GjitTable, GlacTable, GjhdTable" & vbCrLf
      sSql = sSql & "         Where JIACCOUNT = GLACCTREF" & vbCrLf
      sSql = sSql & "          AND GJNAME = JINAME" & vbCrLf
      sSql = sSql & "          AND (JIACCOUNT IN (SELECT DISTINCT JIACCOUNT" & vbCrLf
      sSql = sSql & "                  From GjitTable, GlacTable, GjhdTable" & vbCrLf
      sSql = sSql & "                  Where JIACCOUNT = GLACCTREF And " & vbCrLf
      sSql = sSql & "                  GJNAME = JINAME And (GJPOSTED = 1)" & vbCrLf
      sSql = sSql & "                  AND GJPOST < @StartDate" & vbCrLf
      sSql = sSql & "                  GROUP BY JIACCOUNT" & vbCrLf
      sSql = sSql & "                  HAVING (SUM(JIDEB) - SUM(JICRD)) <> 0))" & vbCrLf
      sSql = sSql & "         AND JIACCOUNT NOT IN" & vbCrLf
      sSql = sSql & "         (" & vbCrLf
      sSql = sSql & "         SELECT DISTINCT  JIACCOUNT" & vbCrLf
      sSql = sSql & "         From GjitTable, GlacTable, GjhdTable" & vbCrLf
      sSql = sSql & "         Where JIACCOUNT = GLACCTREF" & vbCrLf
      sSql = sSql & "          AND GJNAME = JINAME" & vbCrLf
      sSql = sSql & "          AND GJPOST BETWEEN @StartDate AND @EndDate" & vbCrLf
      sSql = sSql & "          AND  JIACCOUNT BETWEEN @iStartAcc AND @iEndAcc" & vbCrLf
      sSql = sSql & "         )" & vbCrLf
      sSql = sSql & "         AND  JIACCOUNT BETWEEN @iStartAcc AND @iEndAcc" & vbCrLf
      sSql = sSql & "         order by JIACCOUNT" & vbCrLf
      sSql = sSql & "   Else" & vbCrLf
      sSql = sSql & "      DECLARE curInActiveAcc CURSOR" & vbCrLf
      sSql = sSql & "      LOCAL" & vbCrLf
      sSql = sSql & "      Scroll " & vbCrLf
      sSql = sSql & "      FOR" & vbCrLf
      sSql = sSql & "         SELECT DISTINCT GLDESCR, JIACCOUNT" & vbCrLf
      sSql = sSql & "           From GjitTable, GlacTable, GjhdTable" & vbCrLf
      sSql = sSql & "         Where JIACCOUNT = GLACCTREF" & vbCrLf
      sSql = sSql & "          AND GJNAME = JINAME" & vbCrLf
      sSql = sSql & "          AND (JIACCOUNT IN (SELECT DISTINCT JIACCOUNT" & vbCrLf
      sSql = sSql & "                  From GjitTable, GlacTable, GjhdTable" & vbCrLf
      sSql = sSql & "                  Where JIACCOUNT = GLACCTREF And " & vbCrLf
      sSql = sSql & "                  GJNAME = JINAME And (GJPOSTED = 1)" & vbCrLf
      sSql = sSql & "                  AND GJPOST < @StartDate" & vbCrLf
      sSql = sSql & "                  GROUP BY JIACCOUNT" & vbCrLf
      sSql = sSql & "                  HAVING (SUM(JIDEB) - SUM(JICRD)) <> 0))" & vbCrLf
      sSql = sSql & "         AND JIACCOUNT NOT IN" & vbCrLf
      sSql = sSql & "         (" & vbCrLf
      sSql = sSql & "         SELECT DISTINCT  JIACCOUNT" & vbCrLf
      sSql = sSql & "         From GjitTable, GlacTable, GjhdTable" & vbCrLf
      sSql = sSql & "         Where JIACCOUNT = GLACCTREF" & vbCrLf
      sSql = sSql & "          AND GJNAME = JINAME" & vbCrLf
      sSql = sSql & "          AND GJPOST BETWEEN @StartDate AND @EndDate" & vbCrLf
      sSql = sSql & "          AND  JIACCOUNT BETWEEN @iStartAcc AND @iEndAcc" & vbCrLf
      sSql = sSql & "         )" & vbCrLf
      sSql = sSql & "         AND  JIACCOUNT BETWEEN @iStartAcc AND @iEndAcc" & vbCrLf
      sSql = sSql & "         order by JIACCOUNT" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "     OPEN curInActiveAcc" & vbCrLf
      sSql = sSql & "     FETCH NEXT FROM curInActiveAcc INTO @Inv_GLDESCR, @Inv_JIACCOUNT" & vbCrLf
      sSql = sSql & "     WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "     BEGIN " & vbCrLf
      sSql = sSql & "         IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "         BEGIN " & vbCrLf
      sSql = sSql & "          SELECT @Acc_StartBal_Inv = SUM(JIDEB) - SUM(JICRD)" & vbCrLf
      sSql = sSql & "              From GjitTable, GlacTable, GjhdTable" & vbCrLf
      sSql = sSql & "           Where JIACCOUNT = GLACCTREF And " & vbCrLf
      sSql = sSql & "                GJNAME = JINAME And (GJPOSTED = 1)" & vbCrLf
      sSql = sSql & "                AND JIACCOUNT = @Inv_JIACCOUNT" & vbCrLf
      sSql = sSql & "                AND GJPOST < @StartDate" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "        INSERT INTO #tempGLPost(tGLDESCR, tJIACCOUNT, tAcc_StartBal )" & vbCrLf
      sSql = sSql & "          VALUES (@Inv_GLDESCR, @Inv_JIACCOUNT , @Acc_StartBal_Inv)" & vbCrLf
      sSql = sSql & "       End" & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM curInActiveAcc INTO @Inv_GLDESCR, @Inv_JIACCOUNT" & vbCrLf
      sSql = sSql & "    End" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   CLOSE curInActiveAcc   --// close the cursor" & vbCrLf
      sSql = sSql & "   DEALLOCATE curInActiveAcc" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   SELECT tGLDESCR GLDESCR, tGJPOST GJPOST, tJINAME JINAME," & vbCrLf
      sSql = sSql & "      tJIACCOUNT JIACCOUNT, tAcc_StartBal AS StartingBalance, tJIDEB AS GL_JIDEB," & vbCrLf
      sSql = sSql & "      tJICRD AS GL_JICRD, tJR_DCDEBIT JR_DCDEBIT," & vbCrLf
      sSql = sSql & "      tJR_DCCREDIT JR_DCCREDIT, tGJ_TotBal GJ_TotBal," & vbCrLf
      sSql = sSql & "      tJR_TotBal JR_TotBal, tMJTYPE MJTYPE," & vbCrLf
      sSql = sSql & "      tMJDESCRIPTION MJDESCRIPTION" & vbCrLf
      sSql = sSql & "   FROM #tempGLPost order by tGLDESCR" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   DROP table #tempGLPost" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "End"
   
      ' Changed the store procedure for trial balance..
      ExecuteScript True, sSql
      
      If TableExists("MrpbaTable") Then
            sSql = "DROP TABLE [dbo].[MrpbaTable]"
            ExecuteScript False, sSql
      End If
      
      ' Create table for MRP open reports
      sSql = "CREATE TABLE [dbo].[MrpbaTable](" & vbCrLf
      sSql = sSql & "   [MRPBOM_ORDER] [smallint] NOT NULL, " & vbCrLf
      sSql = sSql & "   [MRPBOM_ROOTPARTREF] [char](30) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "   [MRPBOM_PARTREF] [char](30) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "   [MRPBOM_USEDON] [char](30) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "   [MRPBOM_LEVEL] [tinyint] NULL," & vbCrLf
      sSql = sSql & "   [MRPBOM_QTYREQD] [decimal](12, 4) NULL" & vbCrLf
      sSql = sSql & ") ON [PRIMARY]"
      
      Debug.Print sSql
      
      ExecuteScript True, sSql
     
     ' For Customer credit limit field
     If Not ColumnExists("ComnTable", "CUWARNCREDITLMT") Then
         sSql = "ALTER TABLE ComnTable ADD CUWARNCREDITLMT decimal(13,2) NULL"
         ExecuteScript False, sSql
         
         sSql = "UPDATE ComnTable SET CUWARNCREDITLMT = 50000 WHERE COREF=1"
         ExecuteScript False, sSql

     End If
   
   
      ExecuteScript False, "Update Version Set Version = " & newver
      
   End If
End Function


Private Function UpdateDatabase15()
   newver = 89
   If ver < newver Then
      ver = newver


     ' For Customer credit limit field
     If Not ColumnExists("sfcdTable", "SFADDRT") Then
         sSql = "ALTER TABLE dbo.sfcdTable ADD SFADDRT decimal(7,2) NULL"
         ExecuteScript False, sSql
     End If
   
    ExecuteScript False, "Update Version Set Version = " & newver
      
   End If
End Function

Private Function UpdateDatabase16()
   newver = 90
   If ver < newver Then
      ver = newver


     If Not ColumnExists("EmplTable", "PREMCOMMENT") Then
         sSql = "ALTER TABLE dbo.EmplTable ADD PREMCOMMENT VARCHAR(3072) NULL"
         ExecuteScript False, sSql
     End If
   
     ' Allow to add SO item from PS
     If Not ColumnExists("ComnTable", "COALLOWPSNEWSOITEM") Then
         sSql = "ALTER TABLE ComnTable ADD COALLOWPSNEWSOITEM tinyint default 0"
         ExecuteScript False, sSql
     End If
   
     ' allow Invoice Num and PS numbers same
     If Not ColumnExists("ComnTable", "COALLOWINVNUMPS") Then
         sSql = "ALTER TABLE ComnTable ADD COALLOWINVNUMPS tinyint default 0"
         ExecuteScript False, sSql
     End If
   
   
      ExecuteScript False, "Update Version Set Version = " & newver
      
   End If
End Function

Private Function UpdateDatabase17()
   newver = 91
   If ver < newver Then
      ver = newver

      sSql = "ALTER TABLE dbo.InvaTable ALTER COLUMN INREF2 VARCHAR(50) NULL"
      ExecuteScript False, sSql
      
      
      ExecuteScript False, "Update Version Set Version = " & newver
      
   End If
End Function

Private Function UpdateDatabase18()
   newver = 92
   If ver < newver Then
      ver = newver

      sSql = "ALTER TABLE dbo.CustTable ADD CUPRINTKANBAN TINYINT NULL"
      ExecuteScript False, sSql
   
   
   
      If Not ColumnExists("soitTable", "BINNUM") Then
          sSql = "ALTER Table soitTable Add BINNUM varchar(30)"
          ExecuteScript False, sSql
      End If
      
      If Not ColumnExists("soitTable", "PULLNUM") Then
          sSql = "ALTER Table soitTable Add PULLNUM varchar(30)"
          ExecuteScript False, sSql
      End If
      
      If Not ColumnExists("PshdTable", "PSCARRIERNUM") Then
          sSql = "ALTER Table PshdTable Add PSCARRIERNUM varchar(20)"
          ExecuteScript False, sSql
      End If
      
      
      If TableExists("ASNInfoTable") Then
            sSql = "DROP TABLE [dbo].[ASNInfoTable]"
            ExecuteScript False, sSql
      End If
      
      sSql = "CREATE TABLE [dbo].[ASNInfoTable](" & vbCrLf
      sSql = sSql & "   [SHPTOIDCODE] [nvarchar](9) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "   [SHPTOCODEQUAL] [nvarchar](2) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "   [SHPFRMIDCODE] [nvarchar](9) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "   [SHPFRMCODEQUAL] [nvarchar](2) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "   [CUREF] [nchar](10) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "   [SHPREF] [nvarchar](6) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "   [SHPDETAIL] [nvarchar](9) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "   [SHPADDRS] [nvarchar](35) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "   [BUYERCODE] [varchar](2) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "   [POLETTERREF] [varchar](1) COLLATE SQL_Latin1_General_CP1_CI_AS NULL" & vbCrLf
      sSql = sSql & ") ON [PRIMARY]"
      
      ExecuteScript False, sSql
      
      If TableExists("Inhd862_EDI") Then
            sSql = "DROP TABLE [dbo].[Inhd862_EDI]"
            ExecuteScript False, sSql
      End If

      sSql = "CREATE TABLE [dbo].[Inhd862_EDI](" & vbCrLf
      sSql = sSql & "      [SHIPCODE] [varchar](15) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "      [PONUMBER] [varchar](22) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "      [BUYERID] [varchar](2) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "      [PARTNUM] [varchar](30) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "      [PAUNITS] [varchar](2) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "      [SHIPNAME] [varchar](35) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "      [N1_HEADER] [varchar](70) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "      [SHIPADDRESS1] [varchar](35) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "      [SHIPADDRESS2] [varchar](35) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "      [N2_HEADER] [varchar](70) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "      [SHIPPERSON] [varchar](35) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "      [PLANTLOCATION] [varchar](9) COLLATE SQL_Latin1_General_CP1_CI_AS NULL" & vbCrLf
      sSql = sSql & "   ) ON [PRIMARY]"
      
      ExecuteScript False, sSql
      
   
      If TableExists("Inhd830_EDI") Then
            sSql = "DROP TABLE [dbo].[Inhd830_EDI]"
            ExecuteScript False, sSql
      End If
      
      sSql = "CREATE TABLE [dbo].[Inhd830_EDI](" & vbCrLf
      sSql = sSql & "   [EDISENDERCODE] [varchar](15) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "   [EDIRECEIVERCODE] [varchar](15) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "   [SHIPTO1] [varchar](35) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "   [SHIPTO2] [varchar](35) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "   [SHIPTO3] [varchar](35) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "   [SHIPTO4] [varchar](35) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "   [SHIPTO5] [varchar](35) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "   [CUSTCONTACT] [varchar](35) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "   [PONUMBER] [varchar](22) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "   [STOCKTYPE] [varchar](22) COLLATE SQL_Latin1_General_CP1_CI_AS NULL" & vbCrLf
      sSql = sSql & ") ON [PRIMARY]"
      ExecuteScript False, sSql
      
      If TableExists("Init830_EDI") Then
            sSql = "DROP TABLE [dbo].[Init830_EDI]"
            ExecuteScript False, sSql
      End If

      sSql = "CREATE TABLE [dbo].[Init830_EDI](" & vbCrLf
      sSql = sSql & "   [PONUMBER] [varchar](22) COLLATE SQL_Latin1_General_CP1_CI_AS NULL, " & vbCrLf
      sSql = sSql & "   [POITEM] [int] NULL," & vbCrLf
      sSql = sSql & "   [POPART] [varchar](30) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "   [POPARTDESC] [varchar](30) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "   [POPAUNIT] [varchar](2) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "   [POQTY] [decimal](12, 4) NULL," & vbCrLf
      sSql = sSql & "   [POREQDT] [smalldatetime] NULL," & vbCrLf
      sSql = sSql & "   [POAMT] [decimal](12, 4) NULL" & vbCrLf
      sSql = sSql & ") ON [PRIMARY]"
      ExecuteScript False, sSql
      
      If TableExists("ProEdiFormat") Then
            sSql = "DROP TABLE [dbo].[ProEdiFormat]"
            ExecuteScript False, sSql
      End If

      sSql = "CREATE TABLE [dbo].[ProEdiFormat](" & vbCrLf
      sSql = sSql & "   [IMPORTTYPE] [varchar](4) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "   [HEADER] [varchar](4) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "   [FIELDNAME] [varchar](55) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "   [NUMCHARS] [int] NULL," & vbCrLf
      sSql = sSql & "   [FORATORDER] [int] NULL," & vbCrLf
      sSql = sSql & "   [EDISTD] [varchar](8) COLLATE SQL_Latin1_General_CP1_CI_AS NULL" & vbCrLf
      sSql = sSql & ") ON [PRIMARY]"
      ExecuteScript False, sSql
      
      If TableExists("Init862_EDI") Then
            sSql = "DROP TABLE [dbo].[Init862_EDI]"
            ExecuteScript False, sSql
      End If
      
      sSql = "CREATE TABLE [dbo].[Init862_EDI](" & vbCrLf
      sSql = sSql & "   [EDI_ELEMENTTYPE] [varchar](4) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "   [SHIPCODE] [varchar](15) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "   [PARTNUM] [varchar](30) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "   [PAUNITS] [varchar](2) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "   [PARTCOUNT] [varchar](10) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "   [PONUMBER] [varchar](22) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "   [PORELEASE] [varchar](10) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "   [SHPQTY] [varchar](10) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "   [DUEDATE] [varchar](10) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "   [SHPDATE] [varchar](10) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "   [LASTQTYRECV] [varchar](10) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "   [LASTQTYRECVDATE] [varchar](10) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "   [YTDQTYRECV] [varchar](10) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "   [YTDQTYSTARTDT] [varchar](10) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "   [YTDQTYENDDT] [varchar](10) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "   [PULLNUM] [varchar](30) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "   [BINNUM] [varchar](30) COLLATE SQL_Latin1_General_CP1_CI_AS NULL" & vbCrLf
      sSql = sSql & ") ON [PRIMARY]"
      ExecuteScript False, sSql
      
      
      If TableExists("Inhd830_850EDI") Then
            sSql = "DROP TABLE [dbo].[Inhd830_850EDI]"
            ExecuteScript False, sSql
      End If
         
      sSql = "CREATE TABLE [dbo].[Inhd830_850EDI](" & vbCrLf
      sSql = sSql & "   [EDISENDERCODE] [varchar](15) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "   [TRANPURPOSE] [varchar](2) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "   [SEQNUM] [varchar](6) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "   [FORCASTTYPE] [varchar](2) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "   [FORCASTQYTQUAL] [varchar](1) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "   [STARTDATE] [varchar](6) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "   [ENDDATE] [varchar](6) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "   [RUNDATE] [varchar](6) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "   [SHIPNAME] [varchar](35) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "   [SHIPNAME1] [varchar](35) COLLATE SQL_Latin1_General_CP1_CI_AS NULL" & vbCrLf
      sSql = sSql & ") ON [PRIMARY]"
      
      ExecuteScript False, sSql
      
      
      If TableExists("Init830_850EDI") Then
            sSql = "DROP TABLE [dbo].[Init830_850EDI]"
            ExecuteScript False, sSql
      End If
      
      sSql = "CREATE TABLE [dbo].[Init830_850EDI](" & vbCrLf
      sSql = sSql & "   [EDISENDERCODE] [varchar](15) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "   [PARTNUM] [varchar](19) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "   [PARTQUAL] [varchar](2) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "   [VENDORPARTNUM] [varchar](19) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "   [BLANK] [varchar](85) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "   [FSTQTY] [varchar](10) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "   [FORCASTSCHED] [varchar](2) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "   [DUEDATE] [varchar](6) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "   [QTYQUAL] [varchar](2) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "   [LASTSHPQTY] [varchar](10) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "   [LASTRECVEDDATE] [varchar](6) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "   [SHPYTDQTY] [varchar](10) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "   [YTDBEGINDATE] [varchar](6) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "   [YTDENDDATE] [varchar](6) COLLATE SQL_Latin1_General_CP1_CI_AS NULL" & vbCrLf
      sSql = sSql & ") ON [PRIMARY]"
      ExecuteScript False, sSql
      
      
      ExecuteScript False, "Update Version Set Version = " & newver
      
   End If
End Function

Private Function UpdateDatabase19()
   newver = 93
   If ver < newver Then
      ver = newver

      sSql = "ALTER Table ASNInfoTable ALTER COLUMN POLETTERREF varchar(4)"
      ExecuteScript False, sSql
      
      ExecuteScript False, "Update Version Set Version = " & newver
      
   End If
End Function

Private Function UpdateDatabase20()
   newver = 94
   If ver < newver Then
      ver = newver

      sSql = "ALTER Table Init830_EDI ALTER COLUMN POREQDT varchar(6)"
      ExecuteScript False, sSql
      
      ' ASNInfo Table change
      If Not ColumnExists("ASNInfoTable", "LASTASNNUM") Then
          sSql = "ALTER Table ASNInfoTable ADD LASTASNNUM int NULL"
          ExecuteScript False, sSql
      End If
      
      If Not ColumnExists("ASNInfoTable", "PACCARDPART") Then
          sSql = "ALTER Table ASNInfoTable ADD PACCARDPART tinyint NULL"
          ExecuteScript False, sSql
      End If
      
      If Not ColumnExists("ASNInfoTable", "TRUCKPLANT") Then
          sSql = "ALTER Table ASNInfoTable ADD TRUCKPLANT tinyint NULL"
          ExecuteScript False, sSql
      End If
      
      ' 862 change
      If Not ColumnExists("Init862_EDI", "BUILDSTATION") Then
          sSql = "ALTER TABLE Init862_EDI ADD BUILDSTATION varchar(2)"
          ExecuteScript False, sSql
      End If
      
      If Not ColumnExists("Init862_EDI", "ECNUMBER") Then
          sSql = "ALTER TABLE Init862_EDI ADD ECNUMBER varchar(30)"
          ExecuteScript False, sSql
      End If
      
      ' SoitTable change
      If Not ColumnExists("soitTable", "BUILDSTATION") Then
          sSql = "ALTER TABLE soitTable ADD BUILDSTATION varchar(2)"
          ExecuteScript False, sSql
      End If
      
      If Not ColumnExists("soitTable", "ECNUMBER") Then
          sSql = "ALTER TABLE soitTable ADD ECNUMBER varchar(30)"
          ExecuteScript False, sSql
      End If
      
      If Not ColumnExists("ASNInfoTable", "LASTASNNUM") Then
          sSql = "ALTER Table ASNInfoTable ADD  LASTASNNUM int NULL"
          ExecuteScript False, sSql
      End If
      
      ' Update the version
      ExecuteScript False, "Update Version Set Version = " & newver
      
   End If
End Function

Private Function UpdateDatabase21()
   newver = 95
   If ver < newver Then
      ver = newver

      If Not ColumnExists("CustTable", "CUPRINTPACCAR") Then
          sSql = "ALTER TABLE dbo.CustTable ADD CUPRINTPACCAR TINYINT NULL"
          ExecuteScript False, sSql
      End If
      If Not TableExists("PsibTable") Then
          sSql = "CREATE Table PsibTable (PIBPACKSLIP char(8) NOT NULL, PIBBOXNO int NULL, PIBWEIGHT decimal(7,2) NULL, PIBPIECES decimal(7,2) NULL) ON [PRIMARY]"
          ExecuteScript False, sSql
      End If
      
      ExecuteScript False, "Update Version Set Version = " & newver
   End If
End Function

Private Function UpdateDatabase22()
   newver = 96
   If ver < newver Then
      ver = newver

      If Not ColumnExists("ComnTable", "COCUSTOMSHIPLABEL") Then
          sSql = "ALTER Table dbo.ComnTable ADD COCUSTOMSHIPLABEL TINYINT NULL "
          ExecuteScript False, sSql
      End If
      
      ExecuteScript False, "Update Version Set Version = " & newver
      
   End If
End Function

Private Function UpdateDatabase23()
   newver = 97
   
   If ver < newver Then
      ver = newver


      If Not StoreProcedureExists("RptVendorDelPerformance") Then
          sSql = "CREATE PROCEDURE [dbo].[RptVendorDelPerformance]" & vbCrLf
          sSql = sSql & "  @sVendorRef as VARCHAR(10)," & vbCrLf
          sSql = sSql & "  @sBeginDate as VARCHAR(10), " & vbCrLf
          sSql = sSql & "  @sEndDate as VARCHAR(10)," & vbCrLf
          sSql = sSql & "  @iAllowDaysEarly as INTEGER," & vbCrLf
          sSql = sSql & "  @iAllowDaysLate as INTEGER," & vbCrLf
          sSql = sSql & "  @iUseOriginalShipDate as INTEGER" & vbCrLf
          sSql = sSql & "AS" & vbCrLf
          sSql = sSql & "BEGIN" & vbCrLf
          sSql = sSql & " -- SET NOCOUNT ON added to prevent extra result sets from" & vbCrLf
          sSql = sSql & " -- interfering with SELECT statements." & vbCrLf
          sSql = sSql & " SET NOCOUNT ON;" & vbCrLf
          sSql = sSql & "" & vbCrLf
          sSql = sSql & " IF (UPPER(@sVendorRef) = 'ALL') Or (UPPER(@sVendorRef) = '<ALL>')" & vbCrLf
          sSql = sSql & "    BEGIN" & vbCrLf
          sSql = sSql & "       SET @sVendorRef = ''" & vbCrLf
          sSql = sSql & "    END" & vbCrLf
          sSql = sSql & "    IF (@iAllowDaysEarly > 0) " & vbCrLf
          sSql = sSql & "    BEGIN" & vbCrLf
          sSql = sSql & "       SET @iAllowDaysEarly = @iAllowDaysEarly * -1" & vbCrLf
          sSql = sSql & "    END" & vbCrLf
          sSql = sSql & "    -- Insert statements for procedure here" & vbCrLf
          sSql = sSql & " SELECT VEREF, VEBNAME, PINUMBER, PIRELEASE, PIITEM, PIREV, PIPART, PARTNUM, PIADATE, PIPDATE, PIPQTY, PIAQTY, PIONDOCKINSPDATE," & vbCrLf
          sSql = sSql & "           PIINSDATE, PIRECEIVED, PIONDOCKINSPECTED, PIODDELDATE, PIPORIGDATE, PIONDOCKQTYACC, PIONDOCKQTYREJ, PIODDELQTY, PIREJECTED, PIWASTE, PIONDOCKQTYWASTE, " & vbCrLf
          sSql = sSql & "           PIESTUNIT, ISNULL(INPQTY,0.0000) AS INPQTY, ISNULL(INAQTY,0.0000) AS INAQTY, ISNULL(INAMT,0.0000) AS INAMT, ISNULL(INPOITEM,0) AS INPOITEM," & vbCrLf
          sSql = sSql & "           ISNULL(INPOREV,'') AS INPOREV, ISNULL(INPONUMBER,0) AS INPONUMBER, ISNULL(INPORELEASE,0) AS INPORELEASE, ISNULL(INTYPE,0) AS INTYPE," & vbCrLf
          sSql = sSql & "        CASE WHEN ISNULL(PIODDELDATE, '')>'' THEN PIODDELDATE" & vbCrLf
          sSql = sSql & "        WHEN ISNULL(PIONDOCKINSPDATE,'')>'' THEN PIONDOCKINSPDATE" & vbCrLf
          sSql = sSql & "        ELSE PIADATE END AS 'DELIVERYDATE'," & vbCrLf
          sSql = sSql & "           CASE WHEN (ISNULL(PIRECEIVED,'')='') AND (ISNULL(PIINSDATE,'')='') AND (ISNULL(PIODDELDATE,'')='') THEN 'PO'" & vbCrLf
          sSql = sSql & "                WHEN (ISNULL(PIRECEIVED,'')='') AND (ISNULL(PIINSDATE,'')='') THEN 'DEL'" & vbCrLf
          sSql = sSql & "                WHEN (ISNULL(PIRECEIVED,'')='') THEN 'DOCK'" & vbCrLf
          sSql = sSql & "                WHEN PIRECEIVED > '01/01/1900' THEN 'REC' ELSE '' END AS 'STATUS'," & vbCrLf
          sSql = sSql & "           CASE WHEN (@iUseOriginalShipDate=0) AND (ISNULL(PIPORIGDATE,''))='' THEN PIPDATE" & vbCrLf
          sSql = sSql & "                WHEN (@iUseOriginalShipDate=0) THEN PIPORIGDATE" & vbCrLf
          sSql = sSql & "                ELSE PIPDATE END AS 'DUEDATE'" & vbCrLf
          sSql = sSql & "    FROM VndrTable " & vbCrLf
          sSql = sSql & "    INNER JOIN PoitTable ON VEREF=PIVENDOR" & vbCrLf
          sSql = sSql & "    LEFT OUTER JOIN InvaTable ON INPONUMBER=PINUMBER AND INPORELEASE=PIRELEASE AND INPOREV=PIREV AND INPOITEM=PIITEM" & vbCrLf
          sSql = sSql & "    LEFT OUTER JOIN PartTable ON PARTREF=PIPART" & vbCrLf
          sSql = sSql & " WHERE" & vbCrLf
          sSql = sSql & "    VEREF LIKE @sVendorRef + '%'" & vbCrLf
          sSql = sSql & "    AND" & vbCrLf
          sSql = sSql & "    ((PIADATE IS NOT NULL) OR (PIODDELDATE IS NOT NULL) OR (PIONDOCKINSPDATE IS NOT NULL))" & vbCrLf
          sSql = sSql & " AND" & vbCrLf
          sSql = sSql & " (" & vbCrLf
          sSql = sSql & "     (PIADATE IS NOT NULL AND PIADATE BETWEEN DateAdd(day, @iAllowDaysEarly, Cast(@sBeginDate AS DateTime)) AND DateAdd(day, @iAllowDaysLate, Cast(@sEndDate AS DateTime)))" & vbCrLf
          sSql = sSql & "     OR" & vbCrLf
          sSql = sSql & "     (PIODDELDATE IS NOT NULL AND PIODDELDATE BETWEEN DateAdd(day, @iAllowDaysEarly, Cast(@sBeginDate AS DateTime)) AND DateAdd(day, @iAllowDaysLate,Cast(@sEndDate AS DateTime)))" & vbCrLf
          sSql = sSql & "     OR" & vbCrLf
          sSql = sSql & "     (PIONDOCKINSPDATE IS NOT NULL AND PIONDOCKINSPDATE BETWEEN DateAdd(day, @iAllowDaysEarly, Cast(@sBeginDate AS DateTime)) AND DateAdd(day, @iAllowDaysLate,Cast(@sEndDate AS DateTime)))" & vbCrLf
          sSql = sSql & " )" & vbCrLf
          sSql = sSql & "END"
          
         ExecuteScript False, sSql
      End If


      If Not ColumnExists("sfcdTable", "SFOVERLAP") Then
          sSql = "ALTER TABLE sfcdTable ADD SFOVERLAP int"
          ExecuteScript False, sSql
          
          sSql = "UPDATE sfcdTable SET SFOVERLAP = 0 WHERE SFOVERLAP = NULL"
          ExecuteScript False, sSql
      End If
     

      If Not ColumnExists("SfempTable", "SFREFSUN") Then
          
         sSql = "ALTER table SfempTable ADD SFREFSUN varchar(6)"
         ExecuteScript False, sSql
         sSql = "ALTER table SfempTable ADD SFREFMON varchar(6)"
         ExecuteScript False, sSql
         sSql = "ALTER table SfempTable ADD SFREFTUE varchar(6)"
         ExecuteScript False, sSql
         sSql = "ALTER table SfempTable ADD SFREFWED varchar(6)"
         ExecuteScript False, sSql
         sSql = "ALTER table SfempTable ADD SFREFTHU varchar(6)"
         ExecuteScript False, sSql
         sSql = "ALTER table SfempTable ADD SFREFFRI varchar(6)"
         ExecuteScript False, sSql
         sSql = "ALTER table SfempTable ADD SFREFSAT varchar(6)"
         ExecuteScript False, sSql
      End If
     
      If Not ColumnExists("VihdTable", "VICHKACCT") Then
         sSql = "ALTER TABLE VihdTable ADD VICHKACCT char(12)"
         ExecuteScript False, sSql
      
         sSql = "UPDATE VihdTable set VICHKACCT = chkacct " & _
                     "FROM ChksTable, VihdTable b WHERE b.VICHECKNO = chknumber"
         ExecuteScript False, sSql
      End If

      If Not ColumnExists("jritTable", "DCCHKACCT") Then
         sSql = "ALTER TABLE jritTable ADD DCCHKACCT char(12)"
         ExecuteScript False, sSql
      
         sSql = "UPDATE jritTable set DCCHKACCT = chkacct" & _
                  "FROM ChksTable, jritTable b WHERE b.DCCHECKNO = chknumber"
         ExecuteScript False, sSql
      End If
      
      If Not ColumnExists("EsReportVendorStmt", "CHKACCT") Then
         sSql = "ALTER TABLE EsReportVendorStmt ADD CHKACCT Char(12)"
         ExecuteScript False, sSql
      End If


      If Not TableExists("EsReportBomROLTTable") Then
         sSql = "CREATE TABLE [dbo].[EsReportBomROLTTable](" & vbCrLf
         sSql = sSql & "   [BomParentPartRef] [char](30)," & vbCrLf
         sSql = sSql & "   [BomUser] [varchar](4) DEFAULT ('')," & vbCrLf
         sSql = sSql & "   [BomRow] [int] NULL  DEFAULT ((0))," & vbCrLf
         sSql = sSql & "   [BomLevel] [tinyint] NULL  DEFAULT ((0))," & vbCrLf
         sSql = sSql & "   [BomAssembly] [char](30)  DEFAULT ('')," & vbCrLf
         sSql = sSql & "   [BomPartRef] [char](30)  DEFAULT ('')," & vbCrLf
         sSql = sSql & "   [BomRevision] [char](4)  DEFAULT ('')," & vbCrLf
         sSql = sSql & "   [BomQuantity] [decimal](15, 4) NULL  DEFAULT ((0))," & vbCrLf
         sSql = sSql & "   [BomUnits] [char](2)  DEFAULT ('')," & vbCrLf
         sSql = sSql & "   [BomConversion] [smallint] NULL DEFAULT ((0))," & vbCrLf
         sSql = sSql & "   [BomSequence] [smallint] NULL DEFAULT ((0))," & vbCrLf
         sSql = sSql & "   [BomSortKey] [varchar](120)  DEFAULT ('')," & vbCrLf
         sSql = sSql & "   [ExplodedQty] [decimal](15, 4) NULL DEFAULT ((0))," & vbCrLf
         sSql = sSql & "   [MostRecentCost] [decimal](15, 4) NULL DEFAULT ((0))," & vbCrLf
         sSql = sSql & "   [iPartdays] [decimal](15, 4) NULL," & vbCrLf
         sSql = sSql & "   [sumAssmdays] [decimal](15, 4) NULL," & vbCrLf
         sSql = sSql & "   [iPartMakeDays ] [decimal](15, 4) NULL," & vbCrLf
         sSql = sSql & "   [SumPartMakeDays] [decimal](15, 4) NULL," & vbCrLf
         sSql = sSql & "   [MaxAssmDays] [decimal](15, 4) NULL," & vbCrLf
         sSql = sSql & "   [paleadtime] [decimal](12, 4) NULL," & vbCrLf
         sSql = sSql & "   [paflowtime] [decimal](12, 4) NULL," & vbCrLf
         sSql = sSql & "   [rtQueuehrs] [decimal](9, 4) NULL," & vbCrLf
         sSql = sSql & "   [rtmovehrs] [decimal](9, 4) NULL," & vbCrLf
         sSql = sSql & "   [rtsetuphrs] [decimal](9, 4) NULL," & vbCrLf
         sSql = sSql & "   [rtunithrs] [decimal](9, 4) NULL" & vbCrLf
         sSql = sSql & ") ON [PRIMARY]"
         
         ExecuteScript False, sSql
      End If

      If Not StoreProcedureExists("RptROLT") Then
         
         sSql = "CREATE PROCEDURE [dbo].[RptROLT] " & vbCrLf
         sSql = sSql & "   @ParentAssyPart as varchar(30), " & vbCrLf
         sSql = sSql & "   @User as varchar(4) " & vbCrLf
         sSql = sSql & "AS " & vbCrLf
         sSql = sSql & "BEGIN " & vbCrLf & vbCrLf
         sSql = sSql & "   declare @AsspartRef as varchar(30) " & vbCrLf
         sSql = sSql & "   declare @SumDays as decimal(15,4) " & vbCrLf
         sSql = sSql & "   declare @MaxPartDays as decimal(15,4) " & vbCrLf
         sSql = sSql & "   declare @SumParttoMake as decimal(15,4)" & vbCrLf
         sSql = sSql & "   declare @AvgWrkWk as decimal(15,2) " & vbCrLf
         sSql = sSql & "   declare @calSunHrs as decimal(15,2) " & vbCrLf
         sSql = sSql & "   declare @calMonHrs as decimal(15,2) " & vbCrLf
         sSql = sSql & "   declare @calTueHrs as decimal(15,2) " & vbCrLf
         sSql = sSql & "   declare @calWedHrs as decimal(15,2) " & vbCrLf
         sSql = sSql & "   declare @calThuHrs as decimal(15,2) " & vbCrLf
         sSql = sSql & "   declare @calFriHrs as decimal(15,2) " & vbCrLf
         sSql = sSql & "   declare @calSatHrs as decimal(15,2) " & vbCrLf
         sSql = sSql & "   declare @TotDays as Integer " & vbCrLf
         sSql = sSql & "   declare @level as Integer " & vbCrLf
   
         sSql = sSql & "   INSERT INTO EsReportBomROLTTable " & vbCrLf
         sSql = sSql & "      (BomUser,BomParentPartRef, BomLevel,BomAssembly,BomPartRef,BomRevision, " & vbCrLf
         sSql = sSql & "      BomQuantity , BomUnits, BomConversion, BomSequence, BomSortKey, " & vbCrLf
         sSql = sSql & "      ExplodedQty, MostRecentCost) " & vbCrLf
         sSql = sSql & "   SELECT TOP 1 @User,@ParentAssyPart,0,@ParentAssyPart,@ParentAssyPart,'', " & vbCrLf
         sSql = sSql & "         1,'',0,0,'',1,ISNULL(LOTUNITCOST,0) " & vbCrLf
         sSql = sSql & "   From parttable " & vbCrLf
         sSql = sSql & "      LEFT JOIN LohdTable on LOTPARTREF = PARTREF " & vbCrLf
         sSql = sSql & "   WHERE PARTREF = @ParentAssyPart " & vbCrLf
         sSql = sSql & "   ORDER BY LOTADATE DESC " & vbCrLf & vbCrLf

         sSql = sSql & "   set @level = 0 " & vbCrLf & vbCrLf

         sSql = sSql & "   WHILE (@level <= 10 ) " & vbCrLf
         sSql = sSql & "   BEGIN " & vbCrLf & vbCrLf
      
         sSql = sSql & "      INSERT INTO EsReportBomROLTTable " & vbCrLf
         sSql = sSql & "         (BomUser,BomParentPartRef,BomLevel,BomAssembly,BomPartRef,BomRevision, " & vbCrLf
         sSql = sSql & "         BomQuantity , BomUnits, BomConversion, BomSequence, BomSortKey, " & vbCrLf
         sSql = sSql & "         ExplodedQty, MostRecentCost) " & vbCrLf
         sSql = sSql & "      SELECT @User,@ParentAssyPart,@level + 1,BMASSYPART,BMPARTREF,BMPARTREV, " & vbCrLf
         sSql = sSql & "         BMQTYREQD , RTrim(BMUNITS), BMCONVERSION, BMSEQUENCE, " & vbCrLf
         sSql = sSql & "         BomSortKey " & vbCrLf
         sSql = sSql & "         + left(parttable.partref,20) " & vbCrLf
         sSql = sSql & "          + cast(BMSEQUENCE as varchar(5)) " & vbCrLf
         sSql = sSql & "          + cast( " & vbCrLf
         sSql = sSql & "          (select count(*) FROM BmplTable b, EsReportBomROLTTable, PartTable " & vbCrLf
         sSql = sSql & "            where b.BMASSYPART = BomPartRef " & vbCrLf
         sSql = sSql & "               AND b.BMREV = BomRevision " & vbCrLf
         sSql = sSql & "               AND BomLevel = 0 " & vbCrLf
         sSql = sSql & "               AND PARTREF = b.BMPARTREF " & vbCrLf
         sSql = sSql & "               AND b.BMPARTREF <= a.BMPARTREF " & vbCrLf
         sSql = sSql & "               --AND b.BMSEQUENCE <= a.BMSEQUENCE " & vbCrLf
         sSql = sSql & "               AND BomUser = @User) as varchar(5)),cast(ExplodedQty * BMQTYREQD as DECIMAL(15,4)), " & vbCrLf
         sSql = sSql & "         CASE WHEN PAUSEACTUALCOST = 0 THEN PASTDCOST " & vbCrLf
         sSql = sSql & "         ELSE ISNULL((SELECT TOP 1 LOTUNITCOST FROM LohdTable " & vbCrLf
         sSql = sSql & "      WHERE LOTPARTREF = BMPARTREF ORDER BY LOTADATE DESC),0) END " & vbCrLf
         sSql = sSql & "      FROM BmplTable a " & vbCrLf
         sSql = sSql & "         JOIN EsReportBomROLTTable on a.BMASSYPART = BomPartRef " & vbCrLf
         sSql = sSql & "         AND a.BMREV = BomRevision AND BomLevel = @level " & vbCrLf
         sSql = sSql & "         JOIN PartTable on PARTREF = BMPARTREF " & vbCrLf
         sSql = sSql & "      WHERE BomUser = @User " & vbCrLf
         sSql = sSql & "      ORDER BY BMSEQUENCE,BMPARTREF " & vbCrLf & vbCrLf

         sSql = sSql & "      SET @level = @level + 1 " & vbCrLf & vbCrLf
         sSql = sSql & "   End " & vbCrLf & vbCrLf

         sSql = sSql & "   SELECT @calSunHrs = (CALSUNHR1 + CALSUNHR2 + CALSUNHR3 + CALSUNHR4), " & vbCrLf
         sSql = sSql & "      @calMonHrs = (CALMONHR1 + CALMONHR2 + CALMONHR3 + CALMONHR4), " & vbCrLf
         sSql = sSql & "      @calTueHrs = (CALTUEHR1 + CALTUEHR2 + CALTUEHR3 + CALTUEHR4), " & vbCrLf
         sSql = sSql & "      @calWedHrs = (CALWEDHR1 + CALWEDHR2 + CALWEDHR3 + CALWEDHR4), " & vbCrLf
         sSql = sSql & "      @calThuHrs = (CALTHUHR1 + CALTHUHR2 + CALTHUHR3 + CALTHUHR4), " & vbCrLf
         sSql = sSql & "      @calFriHrs = (CALFRIHR1 + CALFRIHR2 + CALFRIHR3 + CALFRIHR4), " & vbCrLf
         sSql = sSql & "      @calSatHrs = (CALSATHR1 + CALSATHR2 + CALSATHR3 + CALSATHR4) " & vbCrLf
         sSql = sSql & "   From CctmTable " & vbCrLf

         sSql = sSql & "   SELECT @TotDays = " & vbCrLf
         sSql = sSql & "      CASE"
         sSql = sSql & "         WHEN (CALSUNHR1 + CALSUNHR2 + CALSUNHR3 + CALSUNHR4) > 0 THEN 1 ELSE 0 " & vbCrLf
         sSql = sSql & "      END + " & vbCrLf
         sSql = sSql & "      Case " & vbCrLf
         sSql = sSql & "         WHEN (CALMONHR1 + CALMONHR2 + CALMONHR3 + CALMONHR4) > 0 THEN 1 ELSE 0 " & vbCrLf
         sSql = sSql & "      END + " & vbCrLf
         sSql = sSql & "      Case " & vbCrLf
         sSql = sSql & "         WHEN (CALMONHR1 + CALMONHR2 + CALMONHR3 + CALMONHR4) > 0 THEN 1 ELSE 0 " & vbCrLf
         sSql = sSql & "      END + " & vbCrLf
         sSql = sSql & "      Case " & vbCrLf
         sSql = sSql & "         WHEN (CALTUEHR1 + CALTUEHR2 + CALTUEHR3 + CALTUEHR4) > 0 THEN 1 ELSE 0 " & vbCrLf
         sSql = sSql & "      END + " & vbCrLf
         sSql = sSql & "      Case " & vbCrLf
         sSql = sSql & "         WHEN (CALWEDHR1 + CALWEDHR2 + CALWEDHR3 + CALWEDHR4) > 0 THEN 1 ELSE 0 " & vbCrLf
         sSql = sSql & "      END + " & vbCrLf
         sSql = sSql & "      Case " & vbCrLf
         sSql = sSql & "         WHEN (CALTHUHR1 + CALTHUHR2 + CALTHUHR3 + CALTHUHR4) > 0 THEN 1 ELSE 0 " & vbCrLf
         sSql = sSql & "      END + " & vbCrLf
         sSql = sSql & "      Case " & vbCrLf
         sSql = sSql & "         WHEN (CALFRIHR1 + CALFRIHR2 + CALFRIHR3 + CALFRIHR4) > 0 THEN 1 ELSE 0 " & vbCrLf
         sSql = sSql & "      END + " & vbCrLf
         sSql = sSql & "      Case " & vbCrLf
         sSql = sSql & "         WHEN (CALSATHR1 + CALSATHR2 + CALSATHR3 + CALSATHR4) > 0 THEN 1 ELSE 0 " & vbCrLf
         sSql = sSql & "      End " & vbCrLf
         sSql = sSql & "   From CctmTable " & vbCrLf

         sSql = sSql & "   SET @AvgWrkWk = (@calSunHrs + @calMonHrs + @calTueHrs + @calWedHrs + @calThuHrs + @calFriHrs + @calSatHrs) /  @TotDays " & vbCrLf
   
         sSql = sSql & "   --// Update Individual Days to make the part " & vbCrLf
         sSql = sSql & "   UPDATE EsReportBomROLTTable set iPartDays = " & vbCrLf
         sSql = sSql & "      (((parttable.paleadtime + Isnull(RthdTable.rtQueueHrs,0) + " & vbCrLf
         sSql = sSql & "         Isnull(RthdTable.rtMoveHrs,0) + Isnull(RthdTable.rtSetupHrs, 0)) /24) + " & vbCrLf
         sSql = sSql & "      (isnull(RthdTable.rtUnitHrs, 0) / @AvgWrkWk)) , iPartMakeDays = "
         sSql = sSql & "            (((Isnull(RthdTable.rtQueueHrs,0) + " & vbCrLf
         sSql = sSql & "               Isnull(RthdTable.rtMoveHrs,0) + Isnull(RthdTable.rtSetupHrs, 0)) /24) + " & vbCrLf
         sSql = sSql & "            (isnull(RthdTable.rtUnitHrs, 0) / @AvgWrkWk))" & vbCrLf
         sSql = sSql & "      ,EsReportBomROLTTable.paleadtime = parttable.paleadtime " & vbCrLf
         sSql = sSql & "      , EsReportBomROLTTable.paflowtime = parttable.paflowtime " & vbCrLf
         sSql = sSql & "      , EsReportBomROLTTable.rtQueueHrs = RthdTable.rtQueueHrs " & vbCrLf
         sSql = sSql & "      , EsReportBomROLTTable.rtMoveHrs = RthdTable.rtMoveHrs " & vbCrLf
         sSql = sSql & "      , EsReportBomROLTTable.rtSetupHrs = RthdTable.rtSetupHrs " & vbCrLf
         sSql = sSql & "      , EsReportBomROLTTable.rtUnitHrs = RthdTable.rtUnitHrs " & vbCrLf
         sSql = sSql & "      from parttable inner join EsReportBomROLTTable on partref = BomPartRef " & vbCrLf
         sSql = sSql & "         left outer join RthdTable on Parouting  = rtref " & vbCrLf
         sSql = sSql & "   where bomuser = @User " & vbCrLf & vbCrLf

         sSql = sSql & "   set @level = 10 " & vbCrLf
         sSql = sSql & "   WHILE (@level >= 0 ) " & vbCrLf
         sSql = sSql & "   BEGIN " & vbCrLf & vbCrLf

         sSql = sSql & "      DECLARE curAssSum CURSOR  FOR " & vbCrLf
         sSql = sSql & "         Select BomAssembly,MAX(Isnull(iPartDays,0) + isnull(SumAssmDays, 0)) as sum, " & vbCrLf
         sSql = sSql & "            MAX(IsNull(iPartMakeDays, 0) + IsNull(SumPartMakeDays, 0)) As sum1 " & vbCrLf
         sSql = sSql & "         From (Select DISTINCT b.BomAssembly, b.BompartRef,b.iPartDays, b.SumAssmDays, b.iPartMakeDays, b.SumPartMakeDays " & vbCrLf
         sSql = sSql & "          from EsReportBomROLTTable b " & vbCrLf
         sSql = sSql & "         where bomlevel = @level) as foo " & vbCrLf
         sSql = sSql & "         group by BomAssembly " & vbCrLf & vbCrLf

         sSql = sSql & "      OPEN curAssSum " & vbCrLf
         sSql = sSql & "      FETCH NEXT FROM curAssSum INTO @AsspartRef, @SumDays,@SumParttoMake " & vbCrLf
         sSql = sSql & "      WHILE (@@FETCH_STATUS <> -1) " & vbCrLf
         sSql = sSql & "      BEGIN " & vbCrLf
         sSql = sSql & "         IF (@@FETCH_STATUS <> -2) " & vbCrLf
         sSql = sSql & "         BEGIN " & vbCrLf
         sSql = sSql & "            UPDATE EsReportBomROLTTable SET SumAssmDays = @SumDays, " & vbCrLf
         sSql = sSql & "                  SumPartMakeDays = @SumParttoMake " & vbCrLf
         sSql = sSql & "            WHERE bomlevel = (@level -1) AND BomPartRef = @AsspartRef " & vbCrLf
         sSql = sSql & "               AND BomParentPartRef = @ParentAssyPart " & vbCrLf
         sSql = sSql & "         End " & vbCrLf
         sSql = sSql & "         FETCH NEXT FROM curAssSum INTO @AsspartRef, @SumDays,@SumParttoMake " & vbCrLf
         sSql = sSql & "      End " & vbCrLf
         sSql = sSql & "      Close curAssSum " & vbCrLf
         sSql = sSql & "      DEALLOCATE curAssSum " & vbCrLf

         sSql = sSql & "      SET @level = @level - 1 " & vbCrLf

         sSql = sSql & "   End " & vbCrLf
         sSql = sSql & "   --// Display the data " & vbCrLf
         sSql = sSql & "   SELECT BomUser,BomParentPartRef,BomAssembly, BomPartRef,BomLevel,iPartDays, " & vbCrLf
         sSql = sSql & "      SumAssmDays, iPartMakeDays,SumPartMakeDays, MaxAssmDays, paleadtime, paflowtime, rtQueueHrs, rtMoveHrs, " & vbCrLf
         sSql = sSql & "      rtSetupHrs , rtUnitHrs, BomQuantity, BomSequence, BomSortKey, " & vbCrLf
         sSql = sSql & "      ExplodedQty , MostRecentCost FROM EsReportBomROLTTable" & vbCrLf
         sSql = sSql & "         WHERE BomUser = @User" & vbCrLf
         sSql = sSql & "   order by BomSortKey" & vbCrLf
         sSql = sSql & "End" & vbCrLf

         ExecuteScript True, sSql
      End If

    
    ExecuteScript False, "Update Version Set Version = " & newver
   End If
End Function


Private Function UpdateDatabase24()
   newver = 98
   If ver < newver Then
      ver = newver

      If Not ColumnExists("TchdTable", "TMSTARTORIG") Then
          sSql = "ALTER TABLE TchdTable ADD TMSTARTORIG char(6)"
          ExecuteScript True, sSql
          
          sSql = "ALTER TABLE TchdTable ADD TMSTOPORIG char(6)"
          ExecuteScript True, sSql
          
          sSql = "ALTER TABLE TchdTable ADD TMSFCODEAPPLD smallint"
          ExecuteScript True, sSql
      End If
      
      ExecuteScript False, "Update Version Set Version = " & newver
      
   End If
End Function


Private Function UpdateDatabase25()
   newver = 99
   If ver < newver Then
      ver = newver

      If Not ColumnExists("ComnTable", "COLABOROHTOGL") Then
          sSql = "ALTER TABLE ComnTable ADD COLABOROHTOGL tinyint"
          ExecuteScript True, sSql
      End If
      
      If Not ColumnExists("ComnTable", "COALLOWDELSHORTQTY") Then
          sSql = "ALTER TABLE ComnTable ADD COALLOWDELSHORTQTY tinyint"
          ExecuteScript True, sSql
      End If
      
      ExecuteScript False, "Update Version Set Version = " & newver
      
   End If
End Function

Private Function UpdateDatabase26()
   newver = 100
   If ver < newver Then
      sSql = "ALTER TABLE dbo.TohdTable ALTER COLUMN TOOL_LOCATION char(10) NULL"
      ExecuteScript False, sSql
        
      If Not ColumnExists("TohdTable", "TOOL_SERIALNO") Then
         sSql = "ALTER TABLE TohdTable ADD TOOL_SERIALNO varchar(15) NULL"
         ExecuteScript False, sSql
      End If
        
        
      If Not TableExists("ExoStarXMLMap") Then
         sSql = "CREATE TABLE [dbo].[ExoStarXMLMap](" & vbCrLf
         sSql = sSql & "   [SUPPLYCHAIN_ORG_ID] [int] NULL," & vbCrLf
         sSql = sSql & "   [SUPPLYCHAIN_TYPE_ID] [int] NULL," & vbCrLf
         sSql = sSql & "   [XML_TYPE] [nvarchar](10) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
         sSql = sSql & "   [SO_VARIABLE] [nvarchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
         sSql = sSql & "   [ELEMENT_NAME] [varchar](48) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
         sSql = sSql & "   [XML_ELEMENT_PATH] [nvarchar](512) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
         sSql = sSql & "   [NODE_NAME] [varchar](48) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
         sSql = sSql & "   [NODE_TYPE] [varchar](12) COLLATE SQL_Latin1_General_CP1_CI_AS NULL" & vbCrLf
         sSql = sSql & ") ON [PRIMARY]"
         
         ExecuteScript False, sSql
      End If
        
      If Not TableExists("ExohdImport") Then
         sSql = "CREATE TABLE [dbo].[ExohdImport](" & vbCrLf
         sSql = sSql & "   [SOPO_BUYERORDNUM] [nvarchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
         sSql = sSql & "   [EXOSTART_IMPORT_TYPE] [nvarchar](16) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
         sSql = sSql & "   [BUYER_PARTY_ADDR_NAME1] [nvarchar](64) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
         sSql = sSql & "   [CONTACT_NAME] [nvarchar](48) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
         sSql = sSql & "   [CONTACT_NUMBER] [nvarchar](24) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
         sSql = sSql & "   [CONTACT_TYPE] [nvarchar](24) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
         sSql = sSql & "   [SHPTO_PARTY_ADDRNAME1] [nvarchar](64) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
         sSql = sSql & "   [SHPTO_PARTY_ADDRNAME2] [nvarchar](64) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
         sSql = sSql & "   [SHPTO_PARTY_ADDRSTREET] [nvarchar](64) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
         sSql = sSql & "   [SHPTO_PARTY_ADDRSTRSUP1] [nvarchar](64) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
         sSql = sSql & "   [SHPTO_PARTY_ADDRSTRSUP2] [nvarchar](64) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
         sSql = sSql & "   [SHPTO_PARTY_POSTCODE] [nvarchar](24) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
         sSql = sSql & "   [SHPTO_PARTY_CITY] [nvarchar](48) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
         sSql = sSql & "   [SHPTO_PARTY_REGCODE] [nvarchar](24) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
         sSql = sSql & "   [ORDDET_SHPTO_LOC_ADDRNAME1] [nvarchar](64) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
         sSql = sSql & "   [ORDDET_SHPTO_LOC_ADDRNAME2] [nvarchar](64) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
         sSql = sSql & "   [ORDDET_SHPTO_LOC_ADDRSTREET] [nvarchar](64) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
         sSql = sSql & "   [ORDDET_SHPTO_LOC_ADDRSTRSUP1] [nvarchar](64) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
         sSql = sSql & "   [ORDDET_SHPTO_LOC_ADDRSTRSUP2] [nvarchar](64) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
         sSql = sSql & "   [ORDDET_SHPTO_LOC_POSTCODE] [nvarchar](64) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
         sSql = sSql & "   [ORDDET_SHPTO_LOC_CITY] [nvarchar](48) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
         sSql = sSql & "   [ORDDET_SHPTO_LOC_REGCODE] [nvarchar](24) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
         sSql = sSql & "   [REFTYPE_CODE] [nvarchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
         sSql = sSql & "   [REF_PRIMARY_REFNUM] [nvarchar](256) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
         sSql = sSql & "   [REF_SUPPORT_REFNUM] [nvarchar](256) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
         sSql = sSql & "   [REF_DESCRIPTION] [nvarchar](256) COLLATE SQL_Latin1_General_CP1_CI_AS NULL" & vbCrLf
         sSql = sSql & ") ON [PRIMARY]"
         
         ExecuteScript False, sSql
      End If
        
      If Not TableExists("ExoitImport") Then
         sSql = "CREATE TABLE [dbo].[ExoitImport](" & vbCrLf
         sSql = sSql & "   [SOPO_BUYERORDNUM] [nvarchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
         sSql = sSql & "   [EXOSTART_IMPORT_TYPE] [nvarchar](12) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
         sSql = sSql & "   [ORDDET_SHPTO_LOC_ADDRNAME1] [nvarchar](48) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
         sSql = sSql & "   [INDEX_NUM] [int] NULL," & vbCrLf
         sSql = sSql & "   [BUYER_LINEITEM_NUM] [nvarchar](36) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
         sSql = sSql & "   [PART_ID] [nvarchar](36) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
         sSql = sSql & "   [TOT_QTY] [decimal](18, 0) NULL," & vbCrLf
         sSql = sSql & "   [UNIT_PRICE] [decimal](18, 0) NULL," & vbCrLf
         sSql = sSql & "   [REQ_DELDATE] [varchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
         sSql = sSql & "   [SCHED_QTY_VALUE] [decimal](18, 0) NULL," & vbCrLf
         sSql = sSql & "   [SCHED_LINE_ID] [nvarchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL" & vbCrLf
         sSql = sSql & ") ON [PRIMARY]"
         
         ExecuteScript False, sSql
      End If
        
      If Not ColumnExists("EstiTable", "BIDQTYFROM7") Then
         
         sSql = "ALTER TABLE EstiTable ADD BIDQTYFROM7 int NULL DEFAULT 0.00 WITH VALUES," & vbCrLf
         sSql = sSql & "   BIDQTYFROM8 int NULL DEFAULT 0.00 WITH VALUES," & vbCrLf
         sSql = sSql & "   BIDQTYFROM9 int NULL DEFAULT 0.00 WITH VALUES," & vbCrLf
         sSql = sSql & "   BIDQTYFROM10 int NULL DEFAULT 0.00 WITH VALUES," & vbCrLf
         sSql = sSql & "   BIDQTYFROM11 int NULL DEFAULT 0.00 WITH VALUES," & vbCrLf
         sSql = sSql & "   BIDQTYFROM12 int NULL DEFAULT 0.00 WITH VALUES"
         
         ExecuteScript False, sSql
      End If

      If Not ColumnExists("EstiTable", "BIDQTYTO7") Then
         
         sSql = "ALTER TABLE EstiTable ADD BIDQTYTO7 int  NULL DEFAULT 0.00 WITH VALUES," & vbCrLf
         sSql = sSql & "   BIDQTYTO8 int NULL DEFAULT 0.00 WITH VALUES," & vbCrLf
         sSql = sSql & "   BIDQTYTO9 int NULL DEFAULT 0.00 WITH VALUES," & vbCrLf
         sSql = sSql & "   BIDQTYTO10 int NULL DEFAULT 0.00 WITH VALUES," & vbCrLf
         sSql = sSql & "   BIDQTYTO11 int NULL DEFAULT 0.00 WITH VALUES," & vbCrLf
         sSql = sSql & "   BIDQTYTO12 int NULL DEFAULT 0.00 WITH VALUES"
         
         ExecuteScript False, sSql
      End If

      If Not ColumnExists("EstiTable", "BIDQTYPRICE7") Then
         
         sSql = "ALTER TABLE EstiTable ADD BIDQTYPRICE7 decimal(12,4) NULL DEFAULT 0.0000 WITH VALUES," & vbCrLf
         sSql = sSql & "   BIDQTYPRICE8 decimal(12,4) NULL DEFAULT 0.0000 WITH VALUES," & vbCrLf
         sSql = sSql & "   BIDQTYPRICE9 decimal(12,4) NULL DEFAULT 0.0000 WITH VALUES," & vbCrLf
         sSql = sSql & "   BIDQTYPRICE10 decimal(12,4) NULL DEFAULT 0.0000 WITH VALUES," & vbCrLf
         sSql = sSql & "   BIDQTYPRICE11 decimal(12,4) NULL DEFAULT 0.0000 WITH VALUES," & vbCrLf
         sSql = sSql & "   BIDQTYPRICE12 decimal(12,4) NULL DEFAULT 0.0000 WITH VALUES"
         
         ExecuteScript False, sSql
      End If

      If Not ColumnExists("EstiTable", "BIDQTYDISC7") Then
         
         sSql = "ALTER TABLE EstiTable ADD BIDQTYDISC7 decimal(12,4) NULL DEFAULT 0.0000 WITH VALUES," & vbCrLf
         sSql = sSql & "   BIDQTYDISC8  decimal(12,4) NULL DEFAULT 0.0000 WITH VALUES," & vbCrLf
         sSql = sSql & "   BIDQTYDISC9  decimal(12,4) NULL DEFAULT 0.0000 WITH VALUES," & vbCrLf
         sSql = sSql & "   BIDQTYDISC10  decimal(12,4) NULL DEFAULT 0.0000 WITH VALUES," & vbCrLf
         sSql = sSql & "   BIDQTYDISC11  decimal(12,4) NULL DEFAULT 0.0000 WITH VALUES," & vbCrLf
         sSql = sSql & "   BIDQTYDISC12  decimal(12,4) NULL DEFAULT 0.0000 WITH VALUES"
         
         ExecuteScript False, sSql
      End If

        
      ExecuteScript False, "Update Version Set Version = " & newver
   End If
    
End Function

Private Function UpdateDatabase27()
   newver = 101
   If ver < newver Then
        
      If TableExists("EsReportTmpBomTable") Then
         sSql = "DROP TABLE EsReportTmpBomTable"
         ExecuteScript False, sSql
      End If
      
      sSql = "CREATE TABLE [dbo].[EsReportTmpBomTable](" & vbCrLf
      sSql = sSql & "   [BomParent] [varchar](30) DEFAULT ('')," & vbCrLf
      sSql = sSql & "   [BomAssembly] [varchar](30)   DEFAULT ('')," & vbCrLf
      sSql = sSql & "   [BomPartRef] [varchar](30)  DEFAULT ('')," & vbCrLf
      sSql = sSql & "   [BomLevel] smallint  DEFAULT ('')," & vbCrLf
      sSql = sSql & "   [BomQuantity] [decimal](13, 4) NULL," & vbCrLf
      sSql = sSql & "   [BomSequence] smallint NULL," & vbCrLf
      sSql = sSql & "   [BomSortKey] [varchar](240)  DEFAULT ('')," & vbCrLf
      sSql = sSql & ") ON [PRIMARY]"
      
      ExecuteScript False, sSql
        
      If TableExists("EsReportProFormIncStat") Then
         sSql = "DROP TABLE EsReportProFormIncStat"
         ExecuteScript False, sSql
      End If
      
      sSql = "CREATE TABLE [dbo].[EsReportProFormIncStat](" & vbCrLf
      sSql = sSql & "   [GLACCTREF] [char](12) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL CONSTRAINT [DF__EsReportP__GLACC__58FA1606]  DEFAULT ('')," & vbCrLf
      sSql = sSql & "   [GLACCTNO] [char](12) COLLATE SQL_Latin1_General_CP1_CI_AS NULL CONSTRAINT [DF__EsReportP__GLACC__59EE3A3F]  DEFAULT ('')," & vbCrLf
      sSql = sSql & "   [GLDESCR] [char](100) COLLATE SQL_Latin1_General_CP1_CI_AS NULL CONSTRAINT [DF__EsReportP__GLDES__5AE25E78]  DEFAULT ('')," & vbCrLf
      sSql = sSql & "   [GLMASTER] [char](12) COLLATE SQL_Latin1_General_CP1_CI_AS NULL CONSTRAINT [DF__EsReportP__GLMAS__5BD682B1]  DEFAULT ('')," & vbCrLf
      sSql = sSql & "   [GLTYPE] [int] NULL CONSTRAINT [DF__EsReportP__GLTYP__5CCAA6EA]  DEFAULT ((0))," & vbCrLf
      sSql = sSql & "   [GLINACTIVE] [tinyint] NULL CONSTRAINT [DF__EsReportP__GLINA__5DBECB23]  DEFAULT ((0))," & vbCrLf
      sSql = sSql & "   [GLFSLEVEL] [tinyint] NULL CONSTRAINT [DF__EsReportP__GLFSL__5EB2EF5C]  DEFAULT ((0))," & vbCrLf
      sSql = sSql & "   [SUMBUDCURBAL] [decimal](13, 2) NULL," & vbCrLf
      sSql = sSql & "   [BUDCURBAL] [decimal](13, 2) NULL," & vbCrLf
      sSql = sSql & "   [SUMBUDYTD] [decimal](13, 2) NULL," & vbCrLf
      sSql = sSql & "   [BUDYTD] [decimal](13, 2) NULL," & vbCrLf
      sSql = sSql & "   [SUMCURBAL] [decimal](13, 2) NULL," & vbCrLf
      sSql = sSql & "   [CURBAL] [decimal](13, 2) NULL," & vbCrLf
      sSql = sSql & "   [SORTKEYLEVEL] [tinyint] NULL," & vbCrLf
      sSql = sSql & "   [GLACCSORTKEY] [varchar](512) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "   [GLTOPMaster] [int] NULL" & vbCrLf
      sSql = sSql & ") ON [PRIMARY]"
      
      ExecuteScript False, sSql
      
      
      If TableExists("EsReportIncStatement") Then
         sSql = "DROP TABLE EsReportIncStatement"
         ExecuteScript False, sSql
      End If
      
      sSql = "CREATE TABLE [dbo].[EsReportIncStatement](" & vbCrLf
      sSql = sSql & "   [GLACCTREF] [char](12) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL CONSTRAINT [DF__EsReportG__GLACC__7B3295CE]  DEFAULT ('')," & vbCrLf
      sSql = sSql & "   [GLACCTNO] [char](12) COLLATE SQL_Latin1_General_CP1_CI_AS NULL CONSTRAINT [DF__EsReportG__GLACC__7C26BA07]  DEFAULT ('')," & vbCrLf
      sSql = sSql & "   [GLDESCR] [char](100) COLLATE SQL_Latin1_General_CP1_CI_AS NULL CONSTRAINT [DF__EsReportG__GLDES__7D1ADE40]  DEFAULT ('')," & vbCrLf
      sSql = sSql & "   [GLMASTER] [char](12) COLLATE SQL_Latin1_General_CP1_CI_AS NULL CONSTRAINT [DF__EsReportG__GLMAS__7E0F0279]  DEFAULT ('')," & vbCrLf
      sSql = sSql & "   [GLTYPE] [int] NULL CONSTRAINT [DF__EsReportG__GLTYP__7F0326B2]  DEFAULT ((0))," & vbCrLf
      sSql = sSql & "   [GLINACTIVE] [tinyint] NULL CONSTRAINT [DF__EsReportG__GLINA__7FF74AEB]  DEFAULT ((0))," & vbCrLf
      sSql = sSql & "   [GLFSLEVEL] [tinyint] NULL CONSTRAINT [DF__EsReportG__GLFSL__00EB6F24]  DEFAULT ((0))," & vbCrLf
      sSql = sSql & "   [SUMCURBAL] [decimal](13, 2) NULL," & vbCrLf
      sSql = sSql & "   [CurrentBal] [decimal](13, 2) NULL," & vbCrLf
      sSql = sSql & "   [SUMYTD] [decimal](13, 2) NULL," & vbCrLf
      sSql = sSql & "   [YTD] [decimal](13, 2) NULL," & vbCrLf
      sSql = sSql & "   [SUMPREVBAL] [decimal](13, 2) NULL," & vbCrLf
      sSql = sSql & "   [PreviousBal] [decimal](13, 2) NULL," & vbCrLf
      sSql = sSql & "   [SORTKEYLEVEL] [tinyint] NULL," & vbCrLf
      sSql = sSql & "   [GLACCSORTKEY] [varchar](512) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "   [GLTOPMaster] [int] NULL" & vbCrLf
      sSql = sSql & ") ON [PRIMARY]"
   
      ExecuteScript False, sSql
      
      
      If TableExists("EsReportBalanceSheet") Then
         sSql = "DROP TABLE EsReportBalanceSheet"
         ExecuteScript False, sSql
      End If
      
      sSql = "CREATE TABLE [dbo].[EsReportBalanceSheet](" & vbCrLf
      sSql = sSql & "   [GLACCTREF] [char](12) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL CONSTRAINT [DF__EsReportB__GLACC__355F3763]  DEFAULT ('')," & vbCrLf
      sSql = sSql & "   [GLACCTNO] [char](12) COLLATE SQL_Latin1_General_CP1_CI_AS NULL CONSTRAINT [DF__EsReportB__GLACC__36535B9C]  DEFAULT ('')," & vbCrLf
      sSql = sSql & "   [GLDESCR] [char](100) COLLATE SQL_Latin1_General_CP1_CI_AS NULL CONSTRAINT [DF__EsReportB__GLDES__37477FD5]  DEFAULT ('')," & vbCrLf
      sSql = sSql & "   [GLMASTER] [char](12) COLLATE SQL_Latin1_General_CP1_CI_AS NULL CONSTRAINT [DF__EsReportB__GLMAS__383BA40E]  DEFAULT ('')," & vbCrLf
      sSql = sSql & "   [GLTYPE] [int] NULL CONSTRAINT [DF__EsReportB__GLTYP__392FC847]  DEFAULT ((0))," & vbCrLf
      sSql = sSql & "   [GLINACTIVE] [tinyint] NULL CONSTRAINT [DF__EsReportB__GLINA__3A23EC80]  DEFAULT ((0))," & vbCrLf
      sSql = sSql & "   [GLFSLEVEL] [tinyint] NULL CONSTRAINT [DF__EsReportB__GLFSL__3B1810B9]  DEFAULT ((0))," & vbCrLf
      sSql = sSql & "   [SUMCURBAL] [decimal](13, 2) NULL," & vbCrLf
      sSql = sSql & "   [CurrentBal] [decimal](13, 2) NULL," & vbCrLf
      sSql = sSql & "   [SUMYTD] [decimal](13, 2) NULL," & vbCrLf
      sSql = sSql & "   [YTD] [decimal](13, 2) NULL," & vbCrLf
      sSql = sSql & "   [SUMPREVBAL] [decimal](13, 2) NULL," & vbCrLf
      sSql = sSql & "   [PreviousBal] [decimal](13, 2) NULL," & vbCrLf
      sSql = sSql & "   [SORTKEYLEVEL] [tinyint] NULL," & vbCrLf
      sSql = sSql & "   [GLACCSORTKEY] [varchar](512) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
      sSql = sSql & "   [GLTOPMaster] [int] NULL," & vbCrLf
      sSql = sSql & "   [GLTOPMASTERDESC] [varchar](30) COLLATE SQL_Latin1_General_CP1_CI_AS NULL" & vbCrLf
      sSql = sSql & ") ON [PRIMARY]"
   
      ExecuteScript False, sSql
      
      If StoreProcedureExists("RptROLT") Then
         sSql = "DROP PROCEDURE RptROLT"
         ExecuteScript False, sSql
      End If
      
      sSql = "CREATE PROCEDURE [dbo].[RptROLT]" & vbCrLf
      sSql = sSql & "   @ParentAssyPart as varchar(30)," & vbCrLf
      sSql = sSql & "   @User as varchar(4)" & vbCrLf
      sSql = sSql & "AS" & vbCrLf
      sSql = sSql & "BEGIN" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   declare @AsspartRef as varchar(30)" & vbCrLf
      sSql = sSql & "   declare @SumDays as decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @MaxPartDays as decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @SumParttoMake as decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @AvgWrkWk as decimal(15,2)" & vbCrLf
      sSql = sSql & "   declare @calSunHrs as decimal(15,2)" & vbCrLf
      sSql = sSql & "   declare @calMonHrs as decimal(15,2)" & vbCrLf
      sSql = sSql & "   declare @calTueHrs as decimal(15,2)" & vbCrLf
      sSql = sSql & "   declare @calWedHrs as decimal(15,2)" & vbCrLf
      sSql = sSql & "   declare @calThuHrs as decimal(15,2)" & vbCrLf
      sSql = sSql & "   declare @calFriHrs as decimal(15,2)" & vbCrLf
      sSql = sSql & "   declare @calSatHrs as decimal(15,2)" & vbCrLf
      sSql = sSql & "   declare @TotDays as Integer" & vbCrLf
      sSql = sSql & "   declare @level as Integer" & vbCrLf
      sSql = sSql & "   INSERT INTO EsReportBomROLTTable" & vbCrLf
      sSql = sSql & "      (BomUser,BomParentPartRef, BomLevel,BomAssembly,BomPartRef,BomRevision," & vbCrLf
      sSql = sSql & "      BomQuantity , BomUnits, BomConversion, BomSequence, BomSortKey," & vbCrLf
      sSql = sSql & "      ExplodedQty, MostRecentCost)" & vbCrLf
      sSql = sSql & "   SELECT TOP 1 @User,@ParentAssyPart,0,@ParentAssyPart,@ParentAssyPart,''," & vbCrLf
      sSql = sSql & "         1,'',0,0,'',1,ISNULL(LOTUNITCOST,0)" & vbCrLf
      sSql = sSql & "   From parttable" & vbCrLf
      sSql = sSql & "      LEFT JOIN LohdTable on LOTPARTREF = PARTREF" & vbCrLf
      sSql = sSql & "   WHERE PARTREF = @ParentAssyPart" & vbCrLf
      sSql = sSql & "   ORDER BY LOTADATE DESC" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   set @level = 0" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   WHILE (@level <= 10 )" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "      INSERT INTO EsReportBomROLTTable" & vbCrLf
      sSql = sSql & "         (BomUser,BomParentPartRef,BomLevel,BomAssembly,BomPartRef,BomRevision," & vbCrLf
      sSql = sSql & "         BomQuantity , BomUnits, BomConversion, BomSequence, BomSortKey," & vbCrLf
      sSql = sSql & "         ExplodedQty, MostRecentCost)" & vbCrLf
      sSql = sSql & "      SELECT @User,@ParentAssyPart,@level + 1,BMASSYPART,BMPARTREF,BMPARTREV," & vbCrLf
      sSql = sSql & "         BMQTYREQD , RTrim(BMUNITS), BMCONVERSION, BMSEQUENCE," & vbCrLf
      sSql = sSql & "         BomSortKey" & vbCrLf
      sSql = sSql & "         + left(parttable.partref,20)" & vbCrLf
      sSql = sSql & "          + cast(BMSEQUENCE as varchar(5))" & vbCrLf
      sSql = sSql & "          + cast(" & vbCrLf
      sSql = sSql & "          (select count(*) FROM BmplTable b, EsReportBomROLTTable, PartTable" & vbCrLf
      sSql = sSql & "            Where b.BMASSYPART = BomPartRef" & vbCrLf
      sSql = sSql & "               AND b.BMREV = BomRevision" & vbCrLf
      sSql = sSql & "               AND BomLevel = 0" & vbCrLf
      sSql = sSql & "               AND PARTREF = b.BMPARTREF" & vbCrLf
      sSql = sSql & "               AND b.BMPARTREF <= a.BMPARTREF" & vbCrLf
      sSql = sSql & "               --AND b.BMSEQUENCE <= a.BMSEQUENCE" & vbCrLf
      sSql = sSql & "               AND BomUser = @User) as varchar(5)),cast(ExplodedQty * BMQTYREQD as DECIMAL(15,4))," & vbCrLf
      sSql = sSql & "         CASE WHEN PAUSEACTUALCOST = 0 THEN PASTDCOST" & vbCrLf
      sSql = sSql & "         ELSE ISNULL((SELECT TOP 1 LOTUNITCOST FROM LohdTable" & vbCrLf
      sSql = sSql & "      WHERE LOTPARTREF = BMPARTREF ORDER BY LOTADATE DESC),0) END" & vbCrLf
      sSql = sSql & "      FROM BmplTable a" & vbCrLf
      sSql = sSql & "         JOIN EsReportBomROLTTable on a.BMASSYPART = BomPartRef" & vbCrLf
      sSql = sSql & "         AND a.BMREV = BomRevision AND BomLevel = @level" & vbCrLf
      sSql = sSql & "         JOIN PartTable on PARTREF = BMPARTREF" & vbCrLf
      sSql = sSql & "      WHERE BomUser = @User" & vbCrLf
      sSql = sSql & "      ORDER BY BMSEQUENCE,BMPARTREF" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "      SET @level = @level + 1" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   SELECT @calSunHrs = (CALSUNHR1 + CALSUNHR2 + CALSUNHR3 + CALSUNHR4)," & vbCrLf
      sSql = sSql & "      @calMonHrs = (CALMONHR1 + CALMONHR2 + CALMONHR3 + CALMONHR4)," & vbCrLf
      sSql = sSql & "      @calTueHrs = (CALTUEHR1 + CALTUEHR2 + CALTUEHR3 + CALTUEHR4)," & vbCrLf
      sSql = sSql & "      @calWedHrs = (CALWEDHR1 + CALWEDHR2 + CALWEDHR3 + CALWEDHR4)," & vbCrLf
      sSql = sSql & "      @calThuHrs = (CALTHUHR1 + CALTHUHR2 + CALTHUHR3 + CALTHUHR4)," & vbCrLf
      sSql = sSql & "      @calFriHrs = (CALFRIHR1 + CALFRIHR2 + CALFRIHR3 + CALFRIHR4)," & vbCrLf
      sSql = sSql & "      @calSatHrs = (CALSATHR1 + CALSATHR2 + CALSATHR3 + CALSATHR4)" & vbCrLf
      sSql = sSql & "   From CctmTable" & vbCrLf
      sSql = sSql & "   SELECT @TotDays =" & vbCrLf
      sSql = sSql & "      CASE         WHEN (CALSUNHR1 + CALSUNHR2 + CALSUNHR3 + CALSUNHR4) > 0 THEN 1 ELSE 0" & vbCrLf
      sSql = sSql & "      END +" & vbCrLf
      sSql = sSql & "      Case" & vbCrLf
      sSql = sSql & "         WHEN (CALMONHR1 + CALMONHR2 + CALMONHR3 + CALMONHR4) > 0 THEN 1 ELSE 0" & vbCrLf
      sSql = sSql & "      END +" & vbCrLf
      sSql = sSql & "      Case" & vbCrLf
      sSql = sSql & "         WHEN (CALMONHR1 + CALMONHR2 + CALMONHR3 + CALMONHR4) > 0 THEN 1 ELSE 0" & vbCrLf
      sSql = sSql & "      END +" & vbCrLf
      sSql = sSql & "      Case" & vbCrLf
      sSql = sSql & "         WHEN (CALTUEHR1 + CALTUEHR2 + CALTUEHR3 + CALTUEHR4) > 0 THEN 1 ELSE 0" & vbCrLf
      sSql = sSql & "      END +" & vbCrLf
      sSql = sSql & "      Case" & vbCrLf
      sSql = sSql & "         WHEN (CALWEDHR1 + CALWEDHR2 + CALWEDHR3 + CALWEDHR4) > 0 THEN 1 ELSE 0" & vbCrLf
      sSql = sSql & "      END +" & vbCrLf
      sSql = sSql & "      Case" & vbCrLf
      sSql = sSql & "         WHEN (CALTHUHR1 + CALTHUHR2 + CALTHUHR3 + CALTHUHR4) > 0 THEN 1 ELSE 0" & vbCrLf
      sSql = sSql & "      END +" & vbCrLf
      sSql = sSql & "      Case" & vbCrLf
      sSql = sSql & "         WHEN (CALFRIHR1 + CALFRIHR2 + CALFRIHR3 + CALFRIHR4) > 0 THEN 1 ELSE 0" & vbCrLf
      sSql = sSql & "      END +" & vbCrLf
      sSql = sSql & "      Case" & vbCrLf
      sSql = sSql & "         WHEN (CALSATHR1 + CALSATHR2 + CALSATHR3 + CALSATHR4) > 0 THEN 1 ELSE 0" & vbCrLf
      sSql = sSql & "      End" & vbCrLf
      sSql = sSql & "   From CctmTable" & vbCrLf
      sSql = sSql & "   SET @AvgWrkWk = (@calSunHrs + @calMonHrs + @calTueHrs + @calWedHrs + @calThuHrs + @calFriHrs + @calSatHrs) /  @TotDays" & vbCrLf
      sSql = sSql & "   --// Update Individual Days to make the part" & vbCrLf
      sSql = sSql & "   UPDATE EsReportBomROLTTable set iPartDays = (parttable.paleadtime +" & vbCrLf
      sSql = sSql & "      ((Isnull(RthdTable.rtQueueHrs,0) + Isnull(RthdTable.rtMoveHrs,0) + Isnull(RthdTable.rtSetupHrs, 0)) /24) +" & vbCrLf
      sSql = sSql & "      (isnull(RthdTable.rtUnitHrs, 0) / @AvgWrkWk)) , iPartMakeDays =  (((Isnull(RthdTable.rtQueueHrs,0) +" & vbCrLf
      sSql = sSql & "               Isnull(RthdTable.rtMoveHrs,0) + Isnull(RthdTable.rtSetupHrs, 0)) /24) +" & vbCrLf
      sSql = sSql & "            (isnull(RthdTable.rtUnitHrs, 0) / @AvgWrkWk))" & vbCrLf
      sSql = sSql & "      ,EsReportBomROLTTable.paleadtime = parttable.paleadtime" & vbCrLf
      sSql = sSql & "      , EsReportBomROLTTable.paflowtime = parttable.paflowtime" & vbCrLf
      sSql = sSql & "      , EsReportBomROLTTable.rtQueueHrs = RthdTable.rtQueueHrs" & vbCrLf
      sSql = sSql & "      , EsReportBomROLTTable.rtMoveHrs = RthdTable.rtMoveHrs" & vbCrLf
      sSql = sSql & "      , EsReportBomROLTTable.rtSetupHrs = RthdTable.rtSetupHrs" & vbCrLf
      sSql = sSql & "      , EsReportBomROLTTable.rtUnitHrs = RthdTable.rtUnitHrs" & vbCrLf
      sSql = sSql & "      from parttable inner join EsReportBomROLTTable on partref = BomPartRef" & vbCrLf
      sSql = sSql & "         left outer join RthdTable on Parouting  = rtref" & vbCrLf
      sSql = sSql & "   where bomuser = @User" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   set @level = 10" & vbCrLf
      sSql = sSql & "   WHILE (@level >= 0 )" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "      DECLARE curAssSum CURSOR  FOR" & vbCrLf
      sSql = sSql & "         Select BomAssembly,MAX(Isnull(iPartDays,0) + isnull(SumAssmDays, 0)) as sum," & vbCrLf
      sSql = sSql & "            MAX(IsNull(iPartMakeDays, 0) + IsNull(SumPartMakeDays, 0)) As sum1" & vbCrLf
      sSql = sSql & "         From (Select DISTINCT b.BomAssembly, b.BompartRef,b.iPartDays, b.SumAssmDays, b.iPartMakeDays, b.SumPartMakeDays" & vbCrLf
      sSql = sSql & "          from EsReportBomROLTTable b" & vbCrLf
      sSql = sSql & "         where bomlevel = @level) as foo" & vbCrLf
      sSql = sSql & "         group by BomAssembly" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "      OPEN curAssSum" & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM curAssSum INTO @AsspartRef, @SumDays,@SumParttoMake" & vbCrLf
      sSql = sSql & "      WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "      BEGIN" & vbCrLf
      sSql = sSql & "         IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "         BEGIN" & vbCrLf
      sSql = sSql & "            UPDATE EsReportBomROLTTable SET SumAssmDays = @SumDays," & vbCrLf
      sSql = sSql & "                  SumPartMakeDays = @SumParttoMake" & vbCrLf
      sSql = sSql & "            WHERE bomlevel = (@level -1) AND BomPartRef = @AsspartRef" & vbCrLf
      sSql = sSql & "               AND BomParentPartRef = @ParentAssyPart" & vbCrLf
      sSql = sSql & "         End" & vbCrLf
      sSql = sSql & "         FETCH NEXT FROM curAssSum INTO @AsspartRef, @SumDays,@SumParttoMake" & vbCrLf
      sSql = sSql & "      End" & vbCrLf
      sSql = sSql & "      Close curAssSum" & vbCrLf
      sSql = sSql & "      DEALLOCATE curAssSum" & vbCrLf
      sSql = sSql & "      SET @level = @level - 1" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "   --// Display the data" & vbCrLf
      sSql = sSql & "   SELECT BomUser,BomParentPartRef,BomAssembly, BomPartRef,BomLevel,iPartDays," & vbCrLf
      sSql = sSql & "      SumAssmDays, iPartMakeDays,SumPartMakeDays, MaxAssmDays, paleadtime, paflowtime, rtQueueHrs, rtMoveHrs," & vbCrLf
      sSql = sSql & "      rtSetupHrs , rtUnitHrs, BomQuantity, BomSequence, BomSortKey," & vbCrLf
      sSql = sSql & "      ExplodedQty , MostRecentCost FROM EsReportBomROLTTable" & vbCrLf
      sSql = sSql & "         WHERE BomUser = @User" & vbCrLf
      sSql = sSql & "order by BomSortKey" & vbCrLf
      sSql = sSql & "End"
      
      ' Create the store procedure
      ExecuteScript False, sSql
      
      If StoreProcedureExists("RptAcctBalanceSheet") Then
         sSql = "DROP PROCEDURE RptAcctBalanceSheet"
         ExecuteScript False, sSql
      End If
      
      
      sSql = "CREATE PROCEDURE [dbo].[RptAcctBalanceSheet]" & vbCrLf
      sSql = sSql & "   @StartDate as varchar(12),@EndDate as varchar(12)," & vbCrLf
      sSql = sSql & "   @InclInAcct as varchar(1)" & vbCrLf
      sSql = sSql & "AS" & vbCrLf
      sSql = sSql & "BEGIN" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   declare @glAcctRef as varchar(10)" & vbCrLf
      sSql = sSql & "   declare @glMsAcct as varchar(10)" & vbCrLf
      sSql = sSql & "   declare @SumCurBal decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @SumPrevBal as decimal(15,4)" & vbCrLf

      sSql = sSql & "   declare @level as Integer" & vbCrLf
      sSql = sSql & "   declare @TopLevelDesc as varchar(30)" & vbCrLf
   
      sSql = sSql & "   DELETE FROM EsReportBalanceSheet" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   if (@InclInAcct = '1')" & vbCrLf
      sSql = sSql & "      SET @InclInAcct = ''" & vbCrLf
      sSql = sSql & "   Else" & vbCrLf
      sSql = sSql & "      SET @InclInAcct = '0'" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   DECLARE balAcctStruc CURSOR  FOR" & vbCrLf
      sSql = sSql & "      SELECT COASSTACCT, COASSTDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      Union All" & vbCrLf
      sSql = sSql & "      SELECT COLIABACCT, COLIABDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      Union All" & vbCrLf
      sSql = sSql & "      SELECT COINCMACCT, COINCMDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      Union All" & vbCrLf
      sSql = sSql & "      SELECT COEQTYACCT, COEQTYDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      Union All" & vbCrLf
      sSql = sSql & "      SELECT COCOGSACCT, COCOGSDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      Union All" & vbCrLf
      sSql = sSql & "      SELECT COEXPNACCT, COEXPNDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      Union All" & vbCrLf
      sSql = sSql & "      SELECT COOINCACCT, COOINCDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      Union All" & vbCrLf
      sSql = sSql & "      SELECT COFDTXACCT, COFDTXDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   OPEN balAcctStruc" & vbCrLf
      sSql = sSql & "   FETCH NEXT FROM balAcctStruc INTO @level, @TopLevelDesc" & vbCrLf
      sSql = sSql & "   WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "      IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "      BEGIN" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "         With cte" & vbCrLf
      sSql = sSql & "         as" & vbCrLf
      sSql = sSql & "         (select GLACCTREF, GLDESCR, GLMASTER, GLFSLEVEL, 0 as level," & vbCrLf
      sSql = sSql & "            cast(cast(@level as varchar(4))+ char(36)+ GLACCTREF as varchar(max)) as SortKey" & vbCrLf
      sSql = sSql & "         From GlacTable" & vbCrLf
      sSql = sSql & "         where GLMASTER = cast(@level as varchar(4)) AND GLINACTIVE LIKE @InclInAcct" & vbCrLf
      sSql = sSql & "         Union All" & vbCrLf
      sSql = sSql & "         select a.GLACCTREF, a.GLDESCR, a.GLMASTER, a.GLFSLEVEL, level + 1," & vbCrLf
      sSql = sSql & "          cast(COALESCE(SortKey,'') + char(36) + COALESCE(a.GLACCTREF,'') as varchar(max))as SortKey" & vbCrLf
      sSql = sSql & "         From cte" & vbCrLf
      sSql = sSql & "            inner join GlacTable a" & vbCrLf
      sSql = sSql & "               on cte.GLACCTREF = a.GLMASTER" & vbCrLf
      sSql = sSql & "            WHERE GLINACTIVE LIKE @InclInAcct" & vbCrLf
      sSql = sSql & "         )" & vbCrLf
      sSql = sSql & "         INSERT INTO EsReportBalanceSheet (GLTOPMaster, GLTOPMASTERDESC, GLACCTREF, GLDESCR, GLMASTER, GLFSLEVEL,SORTKEYLEVEL,GLACCSORTKEY)" & vbCrLf
      sSql = sSql & "         select @level, @TopLevelDesc, GLACCTREF, GLDESCR, GLMASTER, GLFSLEVEL, level, SortKey" & vbCrLf
      sSql = sSql & "         from cte order by SortKey" & vbCrLf
      sSql = sSql & "         " & vbCrLf
      sSql = sSql & "      End" & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM balAcctStruc INTO @level, @TopLevelDesc" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "   Close balAcctStruc" & vbCrLf
      sSql = sSql & "   DEALLOCATE balAcctStruc" & vbCrLf
      sSql = sSql & " " & vbCrLf

      sSql = sSql & "   UPDATE EsReportBalanceSheet SET CurrentBal = foo.Balance--, SUMCURBAL = foo.Balance" & vbCrLf
      sSql = sSql & "   From" & vbCrLf
      sSql = sSql & "       (SELECT SUM(GjitTable.JIDEB) - SUM(GjitTable.JICRD) as Balance, JIACCOUNT" & vbCrLf
      sSql = sSql & "         FROM GjhdTable INNER JOIN GjitTable ON GJNAME = JINAME" & vbCrLf
      sSql = sSql & "      WHERE GJPOST BETWEEN @StartDate AND @EndDate" & vbCrLf
      sSql = sSql & "         AND GjhdTable.GJPOSTED = 1" & vbCrLf
      sSql = sSql & "      GROUP BY JIACCOUNT) as foo" & vbCrLf
      sSql = sSql & "   Where foo.JIACCOUNT = GLACCTREF" & vbCrLf

      sSql = sSql & "   UPDATE EsReportBalanceSheet SET PreviousBal = foo.Balance--, SUMPREVBAL = foo.Balance" & vbCrLf
      sSql = sSql & "   From" & vbCrLf
      sSql = sSql & "      (SELECT JIACCOUNT,SUM(GjitTable.JIDEB) - SUM(GjitTable.JICRD) AS Balance" & vbCrLf
      sSql = sSql & "         FROM GjhdTable INNER JOIN GjitTable ON GJNAME = JINAME" & vbCrLf
      sSql = sSql & "      WHERE (GJPOST  <  @EndDate)" & vbCrLf
      sSql = sSql & "         AND GjhdTable.GJPOSTED = 1" & vbCrLf
      sSql = sSql & "      GROUP BY JIACCOUNT) as foo" & vbCrLf
      sSql = sSql & "   Where foo.JIACCOUNT = GLACCTREF" & vbCrLf

      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   set @level = 9" & vbCrLf
      sSql = sSql & "   WHILE (@level >= 1 )" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "      DECLARE curAcctStruc CURSOR  FOR" & vbCrLf
      sSql = sSql & "      SELECT GLMASTER, SUM(ISNULL(SUMCURBAL,0) + (ISNULL(CurrentBal,0))) ," & vbCrLf
      sSql = sSql & "         Sum (IsNull(SUMPREVBAL, 0) + (IsNull(PreviousBal, 0)))" & vbCrLf
      sSql = sSql & "      From" & vbCrLf
      sSql = sSql & "         (SELECT DISTINCT GLACCTREF, GLDESCR, GLMASTER," & vbCrLf
      sSql = sSql & "         CurrentBal , PreviousBal, SUMCURBAL, SUMPREVBAL" & vbCrLf
      sSql = sSql & "         FROM EsReportBalanceSheet WHERE GLFSLEVEL = @level) as foo" & vbCrLf
      sSql = sSql & "      group by GLMASTER" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "      OPEN curAcctStruc" & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM curAcctStruc INTO @glMsAcct, @SumCurBal, @SumPrevBal" & vbCrLf
      sSql = sSql & "      WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "      BEGIN" & vbCrLf
      sSql = sSql & "         IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "         BEGIN" & vbCrLf
      sSql = sSql & "            UPDATE EsReportBalanceSheet SET SUMCURBAL = @SumCurBal," & vbCrLf
      sSql = sSql & "               SUMPREVBAL = @SumPrevBal, GLDESCR = 'TOTAL ' + LTRIM(GLDESCR)" & vbCrLf
      sSql = sSql & "            WHERE GLACCTREF = @glMsAcct" & vbCrLf
      sSql = sSql & "         End" & vbCrLf
      sSql = sSql & "         FETCH NEXT FROM curAcctStruc INTO @glMsAcct, @SumCurBal, @SumPrevBal" & vbCrLf
      sSql = sSql & "      End" & vbCrLf
      sSql = sSql & "            " & vbCrLf
      sSql = sSql & "      Close curAcctStruc" & vbCrLf
      sSql = sSql & "      DEALLOCATE curAcctStruc" & vbCrLf
      sSql = sSql & "      " & vbCrLf
      sSql = sSql & "      SET @level = @level - 1" & vbCrLf
      sSql = sSql & "   End" & vbCrLf

      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   UPDATE EsReportBalanceSheet SET SUMCURBAL = CurrentBal WHERE SUMCURBAL IS NULL" & vbCrLf
      sSql = sSql & "   UPDATE EsReportBalanceSheet SET SUMPREVBAL = PreviousBal WHERE SUMPREVBAL IS NULL" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   SELECT GLTOPMaster, GLTOPMASTERDESC, GLACCTREF, GLACCTNO, GLDESCR, GLMASTER, GLTYPE,GLINACTIVE, GLFSLEVEL," & vbCrLf
      sSql = sSql & "      SUMCURBAL , CurrentBal, SUMPREVBAL, PreviousBal, SORTKEYLEVEL, GLACCSORTKEY" & vbCrLf
      sSql = sSql & "   FROM EsReportBalanceSheet ORDER BY GLTOPMASTER, GLACCSORTKEY, SortKeyLevel" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "End" & vbCrLf
      
      ' create the store procedure
      ExecuteScript False, sSql
      
      If StoreProcedureExists("RptIncomeStatement") Then
         sSql = "DROP PROCEDURE RptIncomeStatement"
         ExecuteScript False, sSql
      End If
      
      
      sSql = "CREATE PROCEDURE [dbo].[RptIncomeStatement]" & vbCrLf
      sSql = sSql & "   @StartDate as varchar(12),@EndDate as varchar(12)," & vbCrLf
      sSql = sSql & "   @YearBeginDate as varchar(12), @InclIncAcct as varchar(1)" & vbCrLf
      sSql = sSql & "AS " & vbCrLf
      sSql = sSql & "BEGIN" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   declare @glAcctRef as varchar(10)" & vbCrLf
      sSql = sSql & "   declare @glMsAcct as varchar(10)" & vbCrLf
      sSql = sSql & "   declare @SumCurBal decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @SumYTD decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @SumPrevBal as decimal(15,4)" & vbCrLf
   
      sSql = sSql & "   declare @level as Integer" & vbCrLf
      sSql = sSql & "   declare @InclInAcct as Integer" & vbCrLf

      sSql = sSql & "   DELETE FROM EsReportIncStatement" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   if (@InclIncAcct = '1')" & vbCrLf
      sSql = sSql & "      SET @InclInAcct = ''" & vbCrLf
      sSql = sSql & "   Else" & vbCrLf
      sSql = sSql & "      SET @InclInAcct = '0'" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   set @level =4" & vbCrLf

      sSql = sSql & "   WHILE (@level <= 9 )" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "      With cte" & vbCrLf
      sSql = sSql & "      as " & vbCrLf
      sSql = sSql & "      (select GLACCTREF, GLDESCR, GLMASTER, GLFSLEVEL, 0 as level," & vbCrLf
      sSql = sSql & "         cast(cast(@level as varchar(4))+ char(36)+ GLACCTREF as varchar(max)) as SortKey" & vbCrLf
      sSql = sSql & "      From GlacTable" & vbCrLf
      sSql = sSql & "      where GLMASTER = cast(@level as varchar(4)) AND GLINACTIVE LIKE @InclInAcct" & vbCrLf
      sSql = sSql & "      Union All" & vbCrLf
      sSql = sSql & "      select a.GLACCTREF, a.GLDESCR, a.GLMASTER, a.GLFSLEVEL, level + 1," & vbCrLf
      sSql = sSql & "       cast(COALESCE(SortKey,'') + char(36) + COALESCE(a.GLACCTREF,'') as varchar(max))as SortKey" & vbCrLf
      sSql = sSql & "      From cte" & vbCrLf
      sSql = sSql & "         inner join GlacTable a" & vbCrLf
      sSql = sSql & "            on cte.GLACCTREF = a.GLMASTER" & vbCrLf
      sSql = sSql & "         WHERE GLINACTIVE LIKE @InclInAcct" & vbCrLf
      sSql = sSql & "      )" & vbCrLf
      sSql = sSql & "      INSERT INTO EsReportIncStatement(GLTOPMaster, GLACCTREF, GLDESCR, GLMASTER, GLFSLEVEL,SORTKEYLEVEL,GLACCSORTKEY)" & vbCrLf
      sSql = sSql & "      select @level, GLACCTREF, GLDESCR, GLMASTER, GLFSLEVEL, level, SortKey" & vbCrLf
      sSql = sSql & "      from cte order by SortKey" & vbCrLf
      
      sSql = sSql & "      SET @level = @level + 1" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   UPDATE EsReportIncStatement SET CurrentBal = foo.Balance--, SUMCURBAL = foo.Balance" & vbCrLf
      sSql = sSql & "   From" & vbCrLf
      sSql = sSql & "       (SELECT SUM(GjitTable.JICRD) - SUM(GjitTable.JIDEB) as Balance, JIACCOUNT" & vbCrLf
      sSql = sSql & "         FROM GjhdTable INNER JOIN GjitTable ON GJNAME = JINAME" & vbCrLf
      sSql = sSql & "      WHERE GJPOST BETWEEN @StartDate AND @EndDate" & vbCrLf
      sSql = sSql & "         AND GjhdTable.GJPOSTED = 1" & vbCrLf
      sSql = sSql & "      GROUP BY JIACCOUNT) as foo" & vbCrLf
      sSql = sSql & "   Where foo.JIACCOUNT = GLACCTREF" & vbCrLf
      sSql = sSql & " " & vbCrLf

      sSql = sSql & "   UPDATE EsReportIncStatement SET YTD = foo.Balance--, SUMYTD = foo.Balance" & vbCrLf
      sSql = sSql & "   From" & vbCrLf
      sSql = sSql & "      (SELECT JIACCOUNT,SUM(GjitTable.JICRD) - SUM(GjitTable.JIDEB) AS Balance" & vbCrLf
      sSql = sSql & "         FROM GjhdTable INNER JOIN GjitTable ON GJNAME = JINAME" & vbCrLf
      sSql = sSql & "      WHERE (GJPOST BETWEEN @YearBeginDate AND @EndDate)" & vbCrLf
      sSql = sSql & "         AND GjhdTable.GJPOSTED = 1" & vbCrLf
      sSql = sSql & "      GROUP BY JIACCOUNT) as foo" & vbCrLf
      sSql = sSql & "   Where foo.JIACCOUNT = GLACCTREF" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   UPDATE EsReportIncStatement SET PreviousBal = foo.Balance--, SUMPREVBAL = foo.Balance" & vbCrLf
      sSql = sSql & "   From" & vbCrLf
      sSql = sSql & "      (SELECT JIACCOUNT,SUM(GjitTable.JICRD) - SUM(GjitTable.JIDEB) AS Balance" & vbCrLf
      sSql = sSql & "         FROM GjhdTable INNER JOIN GjitTable ON GJNAME = JINAME" & vbCrLf
      sSql = sSql & "      WHERE (GJPOST BETWEEN DATEADD(year, -1, @YearBeginDate) AND DATEADD(year, -1, @EndDate))" & vbCrLf
      sSql = sSql & "         AND GjhdTable.GJPOSTED = 1" & vbCrLf
      sSql = sSql & "      GROUP BY JIACCOUNT) as foo" & vbCrLf
      sSql = sSql & "   Where foo.JIACCOUNT = GLACCTREF" & vbCrLf
      sSql = sSql & " " & vbCrLf

      sSql = sSql & "   set @level = 9" & vbCrLf
      sSql = sSql & "   WHILE (@level >= 0 )" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "      DECLARE curAcctStruc CURSOR  FOR" & vbCrLf
      sSql = sSql & "      SELECT GLMASTER, SUM(ISNULL(SUMCURBAL,0) + (ISNULL(CurrentBal,0))) ," & vbCrLf
      sSql = sSql & "         Sum (IsNull(SUMYTD, 0) + (IsNull(YTD, 0))), Sum(IsNull(SUMPREVBAL, 0) + (IsNull(PreviousBal, 0)))" & vbCrLf
      sSql = sSql & "      From" & vbCrLf
      sSql = sSql & "         (SELECT DISTINCT GLACCTREF, GLDESCR, GLMASTER," & vbCrLf
      sSql = sSql & "         CurrentBal , YTD, PreviousBal, SUMCURBAL, SUMYTD, SUMPREVBAL" & vbCrLf
      sSql = sSql & "         FROM EsReportIncStatement WHERE GLFSLEVEL = @level) as foo" & vbCrLf
      sSql = sSql & "      group by GLMASTER" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "      OPEN curAcctStruc" & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM curAcctStruc INTO @glMsAcct, @SumCurBal, @SumYTD, @SumPrevBal" & vbCrLf
      sSql = sSql & "      WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "      BEGIN" & vbCrLf
      sSql = sSql & "         IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "         BEGIN" & vbCrLf
      sSql = sSql & "            UPDATE EsReportIncStatement SET SUMCURBAL = @SumCurBal, SUMYTD = @SumYTD," & vbCrLf
      sSql = sSql & "               SUMPREVBAL = @SumPrevBal, GLDESCR = 'TOTAL ' + LTRIM(GLDESCR)" & vbCrLf
      sSql = sSql & "            WHERE GLACCTREF = @glMsAcct" & vbCrLf
      sSql = sSql & "         End" & vbCrLf
      sSql = sSql & "         FETCH NEXT FROM curAcctStruc INTO @glMsAcct, @SumCurBal, @SumYTD, @SumPrevBal" & vbCrLf
      sSql = sSql & "      End" & vbCrLf
            
      sSql = sSql & "      Close curAcctStruc" & vbCrLf
      sSql = sSql & "      DEALLOCATE curAcctStruc" & vbCrLf
      
      sSql = sSql & "      SET @level = @level - 1" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & " " & vbCrLf
   
      sSql = sSql & "   UPDATE EsReportIncStatement SET SUMCURBAL = CurrentBal WHERE SUMCURBAL IS NULL" & vbCrLf
      sSql = sSql & "   UPDATE EsReportIncStatement SET SUMPREVBAL = PreviousBal WHERE SUMPREVBAL IS NULL" & vbCrLf
      sSql = sSql & "   UPDATE EsReportIncStatement SET SUMYTD = YTD  WHERE SUMYTD IS NULL" & vbCrLf

      sSql = sSql & "   SELECT GLTOPMaster, GLACCTREF, GLACCTNO, GLDESCR, GLMASTER, GLTYPE,GLINACTIVE, GLFSLEVEL," & vbCrLf
      sSql = sSql & "      SUMCURBAL , CurrentBal, SUMYTD, YTD, SUMPREVBAL, PreviousBal, SORTKEYLEVEL, GLACCSORTKEY" & vbCrLf
      sSql = sSql & "   FROM EsReportIncStatement ORDER BY GLTOPMASTER, GLACCSORTKEY desc, SortKeyLevel" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "End"
      
      ExecuteScript False, sSql
      
      
      If StoreProcedureExists("RptProFormaIncStatement") Then
         sSql = "DROP PROCEDURE RptProFormaIncStatement"
         ExecuteScript False, sSql
      End If
      
      sSql = "CREATE PROCEDURE [dbo].[RptProFormaIncStatement]" & vbCrLf
      sSql = sSql & "   @StartDate as varchar(12),@EndDate as varchar(12)," & vbCrLf
      sSql = sSql & "   @Year as varchar(4), @Period1 as integer, @Period2 as integer," & vbCrLf
      sSql = sSql & "   @InclInAcct as varchar(1)" & vbCrLf
      sSql = sSql & "AS" & vbCrLf
      sSql = sSql & "BEGIN" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   declare @glAcctRef as varchar(10)" & vbCrLf
      sSql = sSql & "   declare @glMsAcct as varchar(10)" & vbCrLf
      sSql = sSql & "   declare @SumCurBal decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @SumBUDYTD decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @SumBUDCur as decimal(15,4)" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   declare @level as Integer" & vbCrLf
      sSql = sSql & "   declare @TopLevelDesc as varchar(30)" & vbCrLf
      sSql = sSql & "   declare @loop as integer" & vbCrLf
      sSql = sSql & "   declare @SQLBud as varchar(1024)" & vbCrLf
      sSql = sSql & "   declare @SQL as varchar(1024)" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   DELETE FROM EsReportProFormIncStat" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   if (@InclInAcct = '1')" & vbCrLf
      sSql = sSql & "      SET @InclInAcct = ''" & vbCrLf
      sSql = sSql & "   Else" & vbCrLf
      sSql = sSql & "      SET @InclInAcct = '0'" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   DECLARE balAcctStruc CURSOR  FOR" & vbCrLf
      sSql = sSql & "      SELECT COINCMACCT, COINCMDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      Union All" & vbCrLf
      sSql = sSql & "      SELECT COCOGSACCT, COCOGSDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      Union All" & vbCrLf
      sSql = sSql & "      SELECT COEXPNACCT, COEXPNDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      Union All" & vbCrLf
      sSql = sSql & "      SELECT COOINCACCT, COOINCDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      Union All" & vbCrLf
      sSql = sSql & "      SELECT COOEXPACCT, COOEXPDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      Union All" & vbCrLf
      sSql = sSql & "      SELECT COFDTXACCT, COFDTXDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   OPEN balAcctStruc" & vbCrLf
      sSql = sSql & "   FETCH NEXT FROM balAcctStruc INTO @level, @TopLevelDesc" & vbCrLf
      sSql = sSql & "   WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "      IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "      BEGIN" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "         With cte" & vbCrLf
      sSql = sSql & "         as" & vbCrLf
      sSql = sSql & "         (select GLACCTREF, GLDESCR, GLMASTER, GLFSLEVEL, 0 as level," & vbCrLf
      sSql = sSql & "            cast(cast(@level as varchar(4))+ char(36)+ GLACCTREF as varchar(max)) as SortKey" & vbCrLf
      sSql = sSql & "         From GlacTable" & vbCrLf
      sSql = sSql & "         where GLMASTER = cast(@level as varchar(4)) AND GLINACTIVE LIKE @InclInAcct" & vbCrLf
      sSql = sSql & "         Union All" & vbCrLf
      sSql = sSql & "         select a.GLACCTREF, a.GLDESCR, a.GLMASTER, a.GLFSLEVEL, level + 1," & vbCrLf
      sSql = sSql & "          cast(COALESCE(SortKey,'') + char(36) + COALESCE(a.GLACCTREF,'') as varchar(max))as SortKey" & vbCrLf
      sSql = sSql & "         From cte" & vbCrLf
      sSql = sSql & "            inner join GlacTable a" & vbCrLf
      sSql = sSql & "               on cte.GLACCTREF = a.GLMASTER" & vbCrLf
      sSql = sSql & "            WHERE GLINACTIVE LIKE @InclInAcct" & vbCrLf
      sSql = sSql & "         )" & vbCrLf
      sSql = sSql & "         INSERT INTO EsReportProFormIncStat(GLTOPMaster, GLACCTREF, GLDESCR, GLMASTER," & vbCrLf
      sSql = sSql & "               GLFSLEVEL,SORTKEYLEVEL,GLACCSORTKEY)" & vbCrLf
      sSql = sSql & "         select @level, GLACCTREF, GLDESCR, GLMASTER, GLFSLEVEL, level, SortKey" & vbCrLf
      sSql = sSql & "         from cte order by SortKey" & vbCrLf
      sSql = sSql & "      " & vbCrLf
      sSql = sSql & "      End" & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM balAcctStruc INTO @level, @TopLevelDesc" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "   Close balAcctStruc" & vbCrLf
      sSql = sSql & "   DEALLOCATE balAcctStruc" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   UPDATE EsReportProFormIncStat SET CURBAL = foo.Balance" & vbCrLf
      sSql = sSql & "   From" & vbCrLf
      sSql = sSql & "      (SELECT JIACCOUNT,SUM(GjitTable.JICRD) - SUM(GjitTable.JIDEB) AS Balance" & vbCrLf
      sSql = sSql & "         FROM GjhdTable INNER JOIN GjitTable ON GJNAME = JINAME" & vbCrLf
      sSql = sSql & "      WHERE (GJPOST BETWEEN @StartDate AND @EndDate)" & vbCrLf
      sSql = sSql & "         AND GjhdTable.GJPOSTED = 1" & vbCrLf
      sSql = sSql & "      GROUP BY JIACCOUNT) as foo" & vbCrLf
      sSql = sSql & "   Where foo.JIACCOUNT = GLACCTREF" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   set @loop = 1" & vbCrLf
      sSql = sSql & "   SET @SQLBud = '(SELECT GLACCTREF,'" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   WHILE (@loop <= @Period1 )" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "      IF @loop <> @Period1" & vbCrLf
      sSql = sSql & "         SET @SQLBud = @SQLBud +  'BUDPER' + Convert(varchar(2), @loop) + ' + '" & vbCrLf
      sSql = sSql & "      Else" & vbCrLf
      sSql = sSql & "         SET @SQLBud = @SQLBud +  'BUDPER' + Convert(varchar(2), @loop) + ' AS BUDGETYTD '" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "      SET @loop = @loop + 1" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   SET @SQLBud = @SQLBud +  'FROM BdgtTable RIGHT OUTER JOIN  GlacTable ON BdgtTable.BUDACCT = GlacTable.GLACCTREF ' +" & vbCrLf
      sSql = sSql & "               ' WHERE BUDFY = ''' +  @Year + ''') as foo '" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   SET @SQL = 'UPDATE EsReportProFormIncStat SET EsReportProFormIncStat.BUDYTD = foo.BUDGETYTD FROM '" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   SET @SQL = @SQL + @SQLBud" & vbCrLf
      sSql = sSql & "   SET @SQL = @SQL + 'WHERE foo.GLACCTREF = EsReportProFormIncStat.GLACCTREF '" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "Print 'SQLStatement:' + @SQL" & vbCrLf
      sSql = sSql & "   EXEC(@SQL)" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   --// Current Budget calculation" & vbCrLf
      sSql = sSql & "   SET @SQL = ''" & vbCrLf
      sSql = sSql & "   SET @SQLBud = ''" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   set @loop = @Period1" & vbCrLf
      sSql = sSql & "   SET @SQLBud = '(SELECT GLACCTREF,'" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   WHILE (@loop <= @Period2 )" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "      IF @loop <> @Period2" & vbCrLf
      sSql = sSql & "         SET @SQLBud = @SQLBud +  'BUDPER' + Convert(varchar(2), @loop) + ' + '" & vbCrLf
      sSql = sSql & "      Else" & vbCrLf
      sSql = sSql & "         SET @SQLBud = @SQLBud +  'BUDPER' + Convert(varchar(2), @loop) + ' AS BUDGETCUR '" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "      SET @loop = @loop + 1" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   SET @SQLBud = @SQLBud +  'FROM BdgtTable RIGHT OUTER JOIN  GlacTable ON BdgtTable.BUDACCT = GlacTable.GLACCTREF ' +" & vbCrLf
      sSql = sSql & "               ' WHERE BUDFY = ''' +  @Year + ''') as foo '" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   SET @SQL = 'UPDATE EsReportProFormIncStat SET EsReportProFormIncStat.BUDCURBAL = foo.BUDGETCUR FROM '" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   SET @SQL = @SQL + @SQLBud" & vbCrLf
      sSql = sSql & "   SET @SQL = @SQL + 'WHERE foo.GLACCTREF = EsReportProFormIncStat.GLACCTREF '" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   EXEC(@SQL)" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   set @level = 9" & vbCrLf
      sSql = sSql & "   WHILE (@level >= 0 )" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "      DECLARE curAcctStruc CURSOR  FOR" & vbCrLf
      sSql = sSql & "      SELECT GLMASTER, SUM(ISNULL(SUMCURBAL,0) + (ISNULL(CURBAL,0))) ," & vbCrLf
      sSql = sSql & "         Sum (IsNull(SUMBUDYTD, 0) + (IsNull(BUDYTD, 0))), Sum(IsNull(SUMBUDCURBAL, 0) + (IsNull(BUDCURBAL, 0)))" & vbCrLf
      sSql = sSql & "      From" & vbCrLf
      sSql = sSql & "         (SELECT DISTINCT GLACCTREF, GLDESCR, GLMASTER," & vbCrLf
      sSql = sSql & "         CURBAL , BUDYTD, BUDCURBAL, SUMCURBAL, SUMBUDYTD, SUMBUDCURBAL" & vbCrLf
      sSql = sSql & "         FROM EsReportProFormIncStat WHERE GLFSLEVEL = @level) as foo" & vbCrLf
      sSql = sSql & "      group by GLMASTER" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "      OPEN curAcctStruc" & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM curAcctStruc INTO @glMsAcct, @SumCurBal, @SumBUDYTD, @SumBUDCur" & vbCrLf
      sSql = sSql & "      WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "      BEGIN" & vbCrLf
      sSql = sSql & "         IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "         BEGIN" & vbCrLf
      sSql = sSql & "            UPDATE EsReportProFormIncStat SET SUMCURBAL = @SumCurBal, SUMBUDYTD = @SumBUDYTD," & vbCrLf
      sSql = sSql & "               SUMBUDCURBAL = @SumBUDCur, GLDESCR = 'TOTAL ' + LTRIM(GLDESCR)" & vbCrLf
      sSql = sSql & "            WHERE GLACCTREF = @glMsAcct" & vbCrLf
      sSql = sSql & "         End" & vbCrLf
      sSql = sSql & "         FETCH NEXT FROM curAcctStruc INTO @glMsAcct, @SumCurBal, @SumBUDYTD, @SumBUDCur" & vbCrLf
      sSql = sSql & "      End" & vbCrLf
      sSql = sSql & "            " & vbCrLf
      sSql = sSql & "      Close curAcctStruc" & vbCrLf
      sSql = sSql & "      DEALLOCATE curAcctStruc" & vbCrLf
      sSql = sSql & "      " & vbCrLf
      sSql = sSql & "      SET @level = @level - 1" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   UPDATE EsReportProFormIncStat SET SUMCURBAL = CURBAL WHERE SUMCURBAL IS NULL" & vbCrLf
      sSql = sSql & "   UPDATE EsReportProFormIncStat SET SUMBUDYTD = BUDYTD WHERE SUMBUDYTD IS NULL" & vbCrLf
      sSql = sSql & "   UPDATE EsReportProFormIncStat SET SUMBUDCURBAL = BUDCURBAL  WHERE SUMBUDCURBAL IS NULL" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   SELECT GLTOPMaster, GLACCTREF, GLACCTNO, GLDESCR, GLMASTER, GLTYPE,GLINACTIVE, GLFSLEVEL," & vbCrLf
      sSql = sSql & "      SUMCURBAL , CURBAL, SUMBUDYTD, BUDYTD, SUMBUDCURBAL, BUDCURBAL, SORTKEYLEVEL, GLACCSORTKEY" & vbCrLf
      sSql = sSql & "   FROM EsReportProFormIncStat ORDER BY GLTOPMASTER, GLACCSORTKEY desc, SortKeyLevel" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "End"
      
      ' create the store procedure
      ExecuteScript False, sSql
      
      If StoreProcedureExists("RptChartOfAccount") Then
         sSql = "DROP PROCEDURE RptChartOfAccount"
         ExecuteScript False, sSql
      End If
      
      sSql = "CREATE PROCEDURE [dbo].[RptChartOfAccount] " & vbCrLf
      sSql = sSql & "    @InclIncAcct as varchar(1)" & vbCrLf
      sSql = sSql & "AS " & vbCrLf
      sSql = sSql & "BEGIN " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   declare @glAcctRef as varchar(10) " & vbCrLf
      sSql = sSql & "   declare @glMsAcct as varchar(10) " & vbCrLf
      sSql = sSql & "   declare @TopLevelDesc as varchar(30)" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   declare @level as Integer" & vbCrLf
      sSql = sSql & "   declare @InclInAcct as Integer" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   if (@InclIncAcct = '1')" & vbCrLf
      sSql = sSql & "      SET @InclInAcct = ''" & vbCrLf
      sSql = sSql & "   else" & vbCrLf
      sSql = sSql & "      SET @InclInAcct = '0'" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   CREATE TABLE #tempChartOfAcct(   " & vbCrLf
      sSql = sSql & "   [TOPLEVEL] [int] NULL,  " & vbCrLf
      sSql = sSql & "   [TOPLEVELDESC] [varchar](30) NULL, " & vbCrLf
      sSql = sSql & "   [GLACCTREF] [varchar](112) NULL,         " & vbCrLf
      sSql = sSql & "   [GLDESCR] [varchar](120) NULL,  " & vbCrLf
      sSql = sSql & "   [GLMASTER] [varchar](12) NULL,   " & vbCrLf
      sSql = sSql & "   [GLFSLEVEL] [INT] NULL," & vbCrLf
      sSql = sSql & "   [GLINACTIVE] [int] NULL," & vbCrLf
      sSql = sSql & "   [SORTKEYLEVEL] [int] NULL,           " & vbCrLf
      sSql = sSql & "   [GLACCSORTKEY] [varchar](512) NULL           " & vbCrLf
      sSql = sSql & ")                             " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   DECLARE balAcctStruc CURSOR  FOR " & vbCrLf
      sSql = sSql & "      SELECT COASSTACCT, COASSTDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      UNION ALL" & vbCrLf
      sSql = sSql & "      SELECT COLIABACCT, COLIABDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      UNION ALL" & vbCrLf
      sSql = sSql & "      SELECT COINCMACCT, COINCMDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      UNION ALL " & vbCrLf
      sSql = sSql & "      SELECT COEQTYACCT, COEQTYDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      UNION ALL" & vbCrLf
      sSql = sSql & "      SELECT COCOGSACCT, COCOGSDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      UNION ALL" & vbCrLf
      sSql = sSql & "      SELECT COEXPNACCT, COEXPNDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      UNION ALL" & vbCrLf
      sSql = sSql & "      SELECT COOINCACCT, COOINCDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      UNION ALL" & vbCrLf
      sSql = sSql & "      SELECT COFDTXACCT, COFDTXDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   OPEN balAcctStruc" & vbCrLf
      sSql = sSql & "   FETCH NEXT FROM balAcctStruc INTO @level, @TopLevelDesc" & vbCrLf
      sSql = sSql & "   WHILE (@@FETCH_STATUS <> -1) " & vbCrLf
      sSql = sSql & "   BEGIN " & vbCrLf
      sSql = sSql & "      IF (@@FETCH_STATUS <> -2) " & vbCrLf
      sSql = sSql & "      BEGIN " & vbCrLf
      sSql = sSql & "         " & vbCrLf
      sSql = sSql & "         INSERT INTO #tempChartOfAcct(TOPLEVEL, TOPLEVELDESC, GLACCTREF, GLDESCR, GLMASTER, GLFSLEVEL,GLINACTIVE, SORTKEYLEVEL,GLACCSORTKEY)" & vbCrLf
      sSql = sSql & "         select @level as TopLevel, @TopLevelDesc as TopLevelDesc, @level as GLACCTREF, " & vbCrLf
      sSql = sSql & "            @TopLevelDesc as GLDESCR, '' as GLMASTER, 0 as GLFSLEVEL, 0,0 as level, @level as SortKey" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "         with cte" & vbCrLf
      sSql = sSql & "         as" & vbCrLf
      sSql = sSql & "         (select GLACCTREF, GLDESCR, GLMASTER, GLFSLEVEL, GLINACTIVE, 0 as level," & vbCrLf
      sSql = sSql & "            cast(cast(@level as varchar(4))+ char(36)+ GLACCTREF as varchar(max)) as SortKey" & vbCrLf
      sSql = sSql & "         from GlacTable" & vbCrLf
      sSql = sSql & "         where GLMASTER = cast(@level as varchar(4)) AND GLINACTIVE LIKE @InclInAcct" & vbCrLf
      sSql = sSql & "         union all" & vbCrLf
      sSql = sSql & "         select a.GLACCTREF, a.GLDESCR, a.GLMASTER, a.GLFSLEVEL, a.GLINACTIVE, level + 1," & vbCrLf
      sSql = sSql & "          cast(COALESCE(SortKey,'') + char(36) + COALESCE(a.GLACCTREF,'') as varchar(max))as SortKey" & vbCrLf
      sSql = sSql & "         from cte" & vbCrLf
      sSql = sSql & "            inner join GlacTable a" & vbCrLf
      sSql = sSql & "               on cte.GLACCTREF = a.GLMASTER" & vbCrLf
      sSql = sSql & "            WHERE a.GLINACTIVE LIKE @InclInAcct" & vbCrLf
      sSql = sSql & "         )" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "         INSERT INTO #tempChartOfAcct(TOPLEVEL, TOPLEVELDESC, GLACCTREF, GLDESCR, GLMASTER, GLFSLEVEL,GLINACTIVE, SORTKEYLEVEL,GLACCSORTKEY)" & vbCrLf
      sSql = sSql & "         select @level as TopLevel, @TopLevelDesc as TopLevelDesc, " & vbCrLf
      sSql = sSql & "               Replicate('  ', level) + GLACCTREF as GLACCTREF, " & vbCrLf
      sSql = sSql & "               Replicate('  ', level) + GLDESCR as GLDESCR, GLMASTER, " & vbCrLf
      sSql = sSql & "               GLFSLEVEL, GLINACTIVE,level, SortKey" & vbCrLf
      sSql = sSql & "         from cte order by SortKey" & vbCrLf
      sSql = sSql & "         " & vbCrLf
      sSql = sSql & "      END" & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM balAcctStruc INTO @level, @TopLevelDesc" & vbCrLf
      sSql = sSql & "   END         " & vbCrLf
      sSql = sSql & "   CLOSE balAcctStruc" & vbCrLf
      sSql = sSql & "   DEALLOCATE balAcctStruc" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   SELECT TOPLEVEL, TOPLEVELDESC, GLACCTREF, GLDESCR, GLMASTER, " & vbCrLf
      sSql = sSql & "      GLFSLEVEL,GLINACTIVE, SORTKEYLEVEL,GLACCSORTKEY " & vbCrLf
      sSql = sSql & "   FROM #tempChartOfAcct ORDER BY GLACCSORTKEY" & vbCrLf
      sSql = sSql & "                                           " & vbCrLf
      sSql = sSql & "   DROP table #tempChartOfAcct            " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "End" & vbCrLf
      
      ' create the store procedure
      ExecuteScript False, sSql
      
      ExecuteScript False, "Update Version Set Version = " & newver
   End If
    
End Function

Private Function UpdateDatabase28()
   newver = 102
   If ver < newver Then

      If Not ColumnExists("VndrTable", "VEACCTNO") Then
          sSql = "ALTER TABLE [dbo].[VndrTable] ADD VEACCTNO varchar(30) NULL "
          ExecuteScript False, sSql
      End If
      
      If Not ColumnExists("ComnTable", "CODOCLOK") Then
         sSql = "ALTER TABLE [dbo].[ComnTable] ADD CODOCLOK tinyint NULL "
         ExecuteScript False, sSql
      End If
          
      ExecuteScript False, "Update Version Set Version = " & newver
   End If
    
End Function


Private Function UpdateDatabase29()
   newver = 103
   If ver < newver Then

      If Not ColumnExists("ComnTable", "COROUTSEC") Then
          sSql = "ALTER TABLE ComnTable ADD COROUTSEC tinyint, COBOMSEC tinyint, CODOCLSTSEC tinyint"
          ExecuteScript False, sSql
      End If

      If Not ColumnExists("BmhdTable", "BMAPPBY") Then
          sSql = "ALTER TABLE BmhdTable ADD BMAPPBY char(20), BMAPPDATE smalldatetime, BMREVNOTES varchar(1020)"
          ExecuteScript False, sSql
      End If

      If Not TableExists("DlsthdTable") Then
         sSql = "CREATE TABLE DlsthdTable (DLSTREF char(30) not null, DLSTREV char(6) not null," & vbCrLf
         sSql = sSql & "      DLSTYPE tinyint, DLSTAPPBY char(20), DLSTAPPDATE smalldatetime, DLSTREVNOTES varchar(1020))"
         ExecuteScript False, sSql
      End If

      
      If Not ColumnExists("EsReportBalanceSheet", "SortKeyRev") Then
          sSql = "ALTER TABLE dbo.EsReportBalanceSheet ADD SortKeyRev varchar(256),HASCHILD integer"
          ExecuteScript False, sSql
      End If

      If Not ColumnExists("EsReportIncStatement", "GLTOPMASTERDESC") Then
          sSql = "ALTER TABLE dbo.EsReportIncStatement ADD GLTOPMASTERDESC varchar(30),SortKeyRev varchar(256),HASCHILD integer"
          ExecuteScript False, sSql
      End If

      If Not ColumnExists("EsReportProFormIncStat", "GLTOPMASTERDESC") Then
          sSql = "ALTER TABLE dbo.EsReportProFormIncStat ADD GLTOPMASTERDESC varchar(30), SortKeyRev varchar(256),HASCHILD integer"
          ExecuteScript False, sSql
      End If
      
      If StoreProcedureExists("RptAcctBalanceSheet") Then
         sSql = "DROP PROCEDURE RptAcctBalanceSheet"
         ExecuteScript False, sSql
      End If
      
      sSql = "CREATE PROCEDURE [dbo].[RptAcctBalanceSheet]" & vbCrLf
      sSql = sSql & "   @StartDate as varchar(12),@EndDate as varchar(12)," & vbCrLf
      sSql = sSql & "   @InclInAcct as varchar(1)" & vbCrLf
      sSql = sSql & "AS" & vbCrLf
      sSql = sSql & "BEGIN " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   declare @glAcctRef as varchar(10)" & vbCrLf
      sSql = sSql & "   declare @glMsAcct as varchar(10)" & vbCrLf
      sSql = sSql & "   declare @SumCurBal decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @SumPrevBal as decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @level as integer" & vbCrLf
      sSql = sSql & "   declare @TopLevelDesc as varchar(30)" & vbCrLf
      sSql = sSql & "   declare @TopLevAcct as varchar(20)" & vbCrLf
      sSql = sSql & ""
      sSql = sSql & "   declare @PrevMaster as varchar(10)" & vbCrLf
      sSql = sSql & "   declare @RowCount as integer" & vbCrLf
      sSql = sSql & "   declare @GlMasterAcc as varchar(10)" & vbCrLf
      sSql = sSql & "   declare @GlChildAcct as varchar(10)" & vbCrLf
      sSql = sSql & "   declare @ChildKey as varchar(1024)" & vbCrLf
      sSql = sSql & "   declare @GLSortKey as varchar(1024)" & vbCrLf
      sSql = sSql & "   declare @SortKey as varchar(1024)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   DELETE FROM EsReportBalanceSheet" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   if (@InclInAcct = '1')" & vbCrLf
      sSql = sSql & "      SET @InclInAcct = ''" & vbCrLf
      sSql = sSql & "   Else" & vbCrLf
      sSql = sSql & "      SET @InclInAcct = '0'" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   DECLARE balAcctStruc CURSOR  FOR" & vbCrLf
      sSql = sSql & "      SELECT '1', COASSTACCT, COASSTDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      Union All" & vbCrLf
      sSql = sSql & "      SELECT '2', COLIABACCT, COLIABDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      Union All" & vbCrLf
      sSql = sSql & "      SELECT '3', COEQTYACCT, COEQTYDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   OPEN balAcctStruc" & vbCrLf
      sSql = sSql & "   FETCH NEXT FROM balAcctStruc INTO @level, @TopLevAcct, @TopLevelDesc" & vbCrLf
      sSql = sSql & "   WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "   BEGIN " & vbCrLf
      sSql = sSql & "      IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "      BEGIN " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "         With cte" & vbCrLf
      sSql = sSql & "         as" & vbCrLf
      sSql = sSql & "         (select GLACCTREF, GLDESCR, GLMASTER, GLFSLEVEL, 0 as level," & vbCrLf
      sSql = sSql & "            cast(cast(@level as varchar(4))+ char(36)+ GLACCTREF as varchar(max)) as SortKey" & vbCrLf
      sSql = sSql & "         From GlacTable" & vbCrLf
      sSql = sSql & "         where GLMASTER = cast(@TopLevAcct as varchar(20)) AND GLINACTIVE LIKE @InclInAcct" & vbCrLf
      sSql = sSql & "         Union All" & vbCrLf
      sSql = sSql & "         select a.GLACCTREF, a.GLDESCR, a.GLMASTER, a.GLFSLEVEL, level + 1," & vbCrLf
      sSql = sSql & "          cast(COALESCE(SortKey,'') + char(36) + COALESCE(a.GLACCTREF,'') as varchar(max))as SortKey" & vbCrLf
      sSql = sSql & "         From cte" & vbCrLf
      sSql = sSql & "            inner join GlacTable a" & vbCrLf
      sSql = sSql & "               on cte.GLACCTREF = a.GLMASTER" & vbCrLf
      sSql = sSql & "            WHERE GLINACTIVE LIKE @InclInAcct" & vbCrLf
      sSql = sSql & "         )" & vbCrLf
      sSql = sSql & "         INSERT INTO EsReportBalanceSheet (GLTOPMaster, GLTOPMASTERDESC, GLACCTREF, GLDESCR, GLMASTER, GLFSLEVEL,SORTKEYLEVEL,GLACCSORTKEY)" & vbCrLf
      sSql = sSql & "         select @level, @TopLevelDesc," & vbCrLf
      sSql = sSql & "         GLACCTREF , GLDESCR, GLMASTER, GLFSLEVEL, Level, SortKey" & vbCrLf
      sSql = sSql & "         from cte order by SortKey" & vbCrLf
      sSql = sSql & "         " & vbCrLf
      sSql = sSql & "      End" & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM balAcctStruc INTO @level, @TopLevAcct, @TopLevelDesc" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "   Close balAcctStruc" & vbCrLf
      sSql = sSql & "   DEALLOCATE balAcctStruc" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   UPDATE EsReportBalanceSheet SET CurrentBal = foo.Balance--, SUMCURBAL = foo.Balance" & vbCrLf
      sSql = sSql & "   From" & vbCrLf
      sSql = sSql & "       (SELECT SUM(GjitTable.JIDEB) - SUM(GjitTable.JICRD) as Balance, JIACCOUNT" & vbCrLf
      sSql = sSql & "         FROM GjhdTable INNER JOIN GjitTable ON GJNAME = JINAME" & vbCrLf
      sSql = sSql & "      WHERE GJPOST BETWEEN @StartDate AND @EndDate" & vbCrLf
      sSql = sSql & "         AND GjhdTable.GJPOSTED = 1" & vbCrLf
      sSql = sSql & "      GROUP BY JIACCOUNT) as foo" & vbCrLf
      sSql = sSql & "   Where foo.JIACCOUNT = GLACCTREF" & vbCrLf
      sSql = sSql & "  " & vbCrLf
      sSql = sSql & " UPDATE EsReportBalanceSheet SET PreviousBal = foo.Balance--, SUMPREVBAL = foo.Balance" & vbCrLf
      sSql = sSql & "   From" & vbCrLf
      sSql = sSql & "      (SELECT JIACCOUNT,SUM(GjitTable.JIDEB) - SUM(GjitTable.JICRD) AS Balance" & vbCrLf
      sSql = sSql & "         FROM GjhdTable INNER JOIN GjitTable ON GJNAME = JINAME" & vbCrLf
      sSql = sSql & "      WHERE (GJPOST  <  @StartDate)" & vbCrLf
      sSql = sSql & "         AND GjhdTable.GJPOSTED = 1" & vbCrLf
      sSql = sSql & "      GROUP BY JIACCOUNT) as foo" & vbCrLf
      sSql = sSql & "   Where foo.JIACCOUNT = GLACCTREF" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   set @level = 9" & vbCrLf
      sSql = sSql & "   WHILE (@level >= 1 )" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "      DECLARE curAcctStruc CURSOR  FOR" & vbCrLf
      sSql = sSql & "      SELECT GLMASTER, SUM(ISNULL(SUMCURBAL,0) + (ISNULL(CurrentBal,0))) ," & vbCrLf
      sSql = sSql & "         Sum (IsNull(SUMPREVBAL, 0) + (IsNull(PreviousBal, 0)))" & vbCrLf
      sSql = sSql & "      From" & vbCrLf
      sSql = sSql & "         (SELECT DISTINCT GLACCTREF, GLDESCR, GLMASTER," & vbCrLf
      sSql = sSql & "         CurrentBal , PreviousBal, SUMCURBAL, SUMPREVBAL" & vbCrLf
      sSql = sSql & "         FROM EsReportBalanceSheet WHERE GLFSLEVEL = @level) as foo" & vbCrLf
      sSql = sSql & "      group by GLMASTER" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "      OPEN curAcctStruc" & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM curAcctStruc INTO @glMsAcct, @SumCurBal, @SumPrevBal" & vbCrLf
      sSql = sSql & "      WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "      BEGIN" & vbCrLf
      sSql = sSql & "         IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "         BEGIN" & vbCrLf
      sSql = sSql & "            UPDATE EsReportBalanceSheet SET SUMCURBAL = @SumCurBal," & vbCrLf
      sSql = sSql & "               SUMPREVBAL = @SumPrevBal, GLDESCR = 'TOTAL '+ LTRIM(GLDESCR)," & vbCrLf
      sSql = sSql & "            HASCHILD = 1" & vbCrLf
      sSql = sSql & "            WHERE GLACCTREF = @glMsAcct" & vbCrLf
      sSql = sSql & "         End" & vbCrLf
      sSql = sSql & "         FETCH NEXT FROM curAcctStruc INTO @glMsAcct, @SumCurBal, @SumPrevBal" & vbCrLf
      sSql = sSql & "      End" & vbCrLf
      sSql = sSql & "            " & vbCrLf
      sSql = sSql & "      Close curAcctStruc" & vbCrLf
      sSql = sSql & "      DEALLOCATE curAcctStruc" & vbCrLf
      sSql = sSql & "      " & vbCrLf
      sSql = sSql & "      SET @level = @level - 1" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   UPDATE EsReportBalanceSheet SET SUMCURBAL = CurrentBal WHERE SUMCURBAL IS NULL" & vbCrLf
      sSql = sSql & "   UPDATE EsReportBalanceSheet SET SUMPREVBAL = PreviousBal WHERE SUMPREVBAL IS NULL" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   set @level = 0" & vbCrLf
      sSql = sSql & "   set @RowCount = 1" & vbCrLf
      sSql = sSql & "   SET @PrevMaster = ''" & vbCrLf
      sSql = sSql & "   DECLARE curAcctStruc CURSOR  FOR" & vbCrLf
      sSql = sSql & "      SELECT GLMASTER, GLACCSORTKEY" & vbCrLf
      sSql = sSql & "      From EsReportBalanceSheet" & vbCrLf
      sSql = sSql & "         WHERE HASCHILD IS NULL --GLFSLEVEL = 8 --AND GLMASTER ='AA10'--GLTOPMaster = 1 AND" & vbCrLf
      sSql = sSql & "      ORDER BY GLACCSORTKEY" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   OPEN curAcctStruc" & vbCrLf
      sSql = sSql & "   FETCH NEXT FROM curAcctStruc INTO @GlMasterAcc, @GLSortKey" & vbCrLf
      sSql = sSql & "   WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "    IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "    BEGIN" & vbCrLf
      sSql = sSql & "      if (@PrevMaster <> @GlMasterAcc)" & vbCrLf
      sSql = sSql & "      BEGIN" & vbCrLf
      sSql = sSql & "         UPDATE EsReportBalanceSheet SET" & vbCrLf
      sSql = sSql & "            SortKeyRev = RIGHT ('0000'+ Cast(@RowCount as varchar), 4) + char(36)+ @GlMasterAcc" & vbCrLf
      sSql = sSql & "         WHERE GLMASTER = @GlMasterAcc AND HASCHILD IS NULL --GLFSLEVEL = 8 --AND GLTOPMaster = 1" & vbCrLf
      sSql = sSql & "         SET @RowCount = @RowCount + 1" & vbCrLf
      sSql = sSql & "         SET @PrevMaster = @GlMasterAcc" & vbCrLf
      sSql = sSql & "      End" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "    End" & vbCrLf
      sSql = sSql & "    FETCH NEXT FROM curAcctStruc INTO @GlMasterAcc, @GLSortKey" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "       " & vbCrLf
      sSql = sSql & "   Close curAcctStruc" & vbCrLf
      sSql = sSql & "   DEALLOCATE curAcctStruc" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   set @level = 7" & vbCrLf
      sSql = sSql & "   WHILE (@level >= 1 )" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "      SET @PrevMaster = ''" & vbCrLf
      sSql = sSql & "        DECLARE curAcctStruc1 CURSOR  FOR" & vbCrLf
      sSql = sSql & "         SELECT DISTINCT GLACCTREF, GLMASTER, GLACCSORTKEY" & vbCrLf
      sSql = sSql & "         From EsReportBalanceSheet" & vbCrLf
      sSql = sSql & "            WHERE GLFSLEVEL = @level AND HASCHILD IS NOT NULL--GLTOPMaster = 1 AND" & vbCrLf
      sSql = sSql & "         order by GLACCSORTKEY" & vbCrLf
      sSql = sSql & "    " & vbCrLf
      sSql = sSql & "        OPEN curAcctStruc1" & vbCrLf
      sSql = sSql & "        FETCH NEXT FROM curAcctStruc1 INTO @GlChildAcct, @GlMasterAcc, @GLSortKey" & vbCrLf
      sSql = sSql & "        WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "        BEGIN" & vbCrLf
      sSql = sSql & "          IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "          BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "            if (@PrevMaster <> @GlChildAcct)" & vbCrLf
      sSql = sSql & "            BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   Print 'Record' + @GlChildAcct + ':' + @GlMasterAcc" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "               SELECT TOP 1 @ChildKey = SortKeyRev,@SortKey = GLACCSORTKEY" & vbCrLf
      sSql = sSql & "               From EsReportBalanceSheet" & vbCrLf
      sSql = sSql & "                  WHERE GLFSLEVEL > @level AND GLMASTER = @GlChildAcct --GLTOPMaster = 1 AND" & vbCrLf
      sSql = sSql & "               order by GLACCSORTKEY desc" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "               UPDATE EsReportBalanceSheet SET" & vbCrLf
      sSql = sSql & "                  SortKeyRev = Cast(@ChildKey as varchar(512)) + char(36)+ @GlMasterAcc" & vbCrLf
      sSql = sSql & "   --          select * from EsReportBalanceSheet" & vbCrLf
      sSql = sSql & "               WHERE GLACCTREF = @GlChildAcct AND GLMASTER = @GlMasterAcc" & vbCrLf
      sSql = sSql & "                  AND GLFSLEVEL = @level --GLTOPMaster = 1 AND" & vbCrLf
      sSql = sSql & "               SET @PrevMaster = @GlChildAcct" & vbCrLf
      sSql = sSql & "            End" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "          End" & vbCrLf
      sSql = sSql & "          FETCH NEXT FROM curAcctStruc1 INTO @GlChildAcct, @GlMasterAcc, @GLSortKey" & vbCrLf
      sSql = sSql & "        End" & vbCrLf
      sSql = sSql & "               " & vbCrLf
      sSql = sSql & "        Close curAcctStruc1" & vbCrLf
      sSql = sSql & "        DEALLOCATE curAcctStruc1" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "        SET @level = @level - 1" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   SELECT GLTOPMaster, GLTOPMASTERDESC, GLACCTREF, GLACCTNO, GLDESCR, GLMASTER, GLTYPE,GLINACTIVE, GLFSLEVEL," & vbCrLf
      sSql = sSql & "      SUMCURBAL , CurrentBal, SUMPREVBAL, PreviousBal, SORTKEYLEVEL, GLACCSORTKEY, SortKeyRev" & vbCrLf
      sSql = sSql & "   FROM EsReportBalanceSheet ORDER BY SortKeyRev --GLTOPMASTER, GLACCSORTKEY," & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "End"
      ' create the store procedure
      ExecuteScript False, sSql
      
      If StoreProcedureExists("RptIncomeStatement") Then
         sSql = "DROP PROCEDURE RptIncomeStatement"
         ExecuteScript False, sSql
      End If
      
      sSql = "CREATE PROCEDURE [dbo].[RptIncomeStatement]" & vbCrLf
      sSql = sSql & "   @StartDate as varchar(12),@EndDate as varchar(12)," & vbCrLf
      sSql = sSql & "   @YearBeginDate as varchar(12), @InclIncAcct as varchar(1)" & vbCrLf
      sSql = sSql & "AS " & vbCrLf
      sSql = sSql & "BEGIN" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   declare @glAcctRef as varchar(10)" & vbCrLf
      sSql = sSql & "   declare @glMsAcct as varchar(10)" & vbCrLf
      sSql = sSql & "   declare @SumCurBal decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @SumYTD decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @SumPrevBal as decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @level as integer" & vbCrLf
      sSql = sSql & "   declare @TopLevelDesc as varchar(30)" & vbCrLf
      sSql = sSql & "   declare @InclInAcct as Integer" & vbCrLf
      sSql = sSql & "   declare @TopLevAcct as varchar(20)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   declare @PrevMaster as varchar(10)" & vbCrLf
      sSql = sSql & "   declare @RowCount as integer" & vbCrLf
      sSql = sSql & "   declare @GlMasterAcc as varchar(10)" & vbCrLf
      sSql = sSql & "   declare @GlChildAcct as varchar(10)" & vbCrLf
      sSql = sSql & "   declare @ChildKey as varchar(1024)" & vbCrLf
      sSql = sSql & "   declare @GLSortKey as varchar(1024)" & vbCrLf
      sSql = sSql & "   declare @SortKey as varchar(1024)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   DELETE FROM EsReportIncStatement" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   if (@InclIncAcct = '1')" & vbCrLf
      sSql = sSql & "      SET @InclInAcct = ''" & vbCrLf
      sSql = sSql & "   Else" & vbCrLf
      sSql = sSql & "      SET @InclInAcct = '0'" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   DECLARE balAcctStruc CURSOR  FOR" & vbCrLf
      sSql = sSql & "      SELECT '4', COINCMACCT, COINCMDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      Union All" & vbCrLf
      sSql = sSql & "      SELECT '5', COCOGSACCT, COCOGSDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      Union All" & vbCrLf
      sSql = sSql & "      SELECT '6', COEXPNACCT, COEXPNDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      Union All" & vbCrLf
      sSql = sSql & "      SELECT '7', COOINCACCT, COOINCDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      Union All" & vbCrLf
      sSql = sSql & "      SELECT '9', COFDTXACCT, COFDTXDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   OPEN balAcctStruc" & vbCrLf
      sSql = sSql & "   FETCH NEXT FROM balAcctStruc INTO @level,@TopLevAcct, @TopLevelDesc" & vbCrLf
      sSql = sSql & "   WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "      IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "      BEGIN" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "        With cte" & vbCrLf
      sSql = sSql & "        as " & vbCrLf
      sSql = sSql & "        (select GLACCTREF, GLDESCR, GLMASTER, GLFSLEVEL, 0 as level," & vbCrLf
      sSql = sSql & "          cast(cast(@level as varchar(4))+ char(36)+ GLACCTREF as varchar(max)) as SortKey" & vbCrLf
      sSql = sSql & "        From GlacTable" & vbCrLf
      sSql = sSql & "        where GLMASTER = cast(@TopLevAcct as varchar(20)) AND GLINACTIVE LIKE @InclInAcct" & vbCrLf
      sSql = sSql & "        Union All" & vbCrLf
      sSql = sSql & "        select a.GLACCTREF, a.GLDESCR, a.GLMASTER, a.GLFSLEVEL, level + 1," & vbCrLf
      sSql = sSql & "         cast(COALESCE(SortKey,'') + char(36) + COALESCE(a.GLACCTREF,'') as varchar(max))as SortKey" & vbCrLf
      sSql = sSql & "        From cte" & vbCrLf
      sSql = sSql & "          inner join GlacTable a" & vbCrLf
      sSql = sSql & "            on cte.GLACCTREF = a.GLMASTER" & vbCrLf
      sSql = sSql & "          WHERE GLINACTIVE LIKE @InclInAcct" & vbCrLf
      sSql = sSql & "        )" & vbCrLf
      sSql = sSql & "        INSERT INTO EsReportIncStatement(GLTOPMaster, GLTOPMASTERDESC, GLACCTREF, GLDESCR, GLMASTER, GLFSLEVEL,SORTKEYLEVEL,GLACCSORTKEY)" & vbCrLf
      sSql = sSql & "        select @level, @TopLevelDesc, GLACCTREF, GLDESCR, GLMASTER, GLFSLEVEL, level, SortKey" & vbCrLf
      sSql = sSql & "        from cte order by SortKey" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "      End" & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM balAcctStruc INTO @level,@TopLevAcct, @TopLevelDesc" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "   Close balAcctStruc" & vbCrLf
      sSql = sSql & "   DEALLOCATE balAcctStruc" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   UPDATE EsReportIncStatement SET CurrentBal = foo.Balance--, SUMCURBAL = foo.Balance" & vbCrLf
      sSql = sSql & "   From" & vbCrLf
      sSql = sSql & "       (SELECT SUM(GjitTable.JICRD) - SUM(GjitTable.JIDEB) as Balance, JIACCOUNT" & vbCrLf
      sSql = sSql & "         FROM GjhdTable INNER JOIN GjitTable ON GJNAME = JINAME" & vbCrLf
      sSql = sSql & "      WHERE GJPOST BETWEEN @StartDate AND @EndDate" & vbCrLf
      sSql = sSql & "         AND GjhdTable.GJPOSTED = 1" & vbCrLf
      sSql = sSql & "      GROUP BY JIACCOUNT) as foo" & vbCrLf
      sSql = sSql & "   Where foo.JIACCOUNT = GLACCTREF" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   UPDATE EsReportIncStatement SET YTD = foo.Balance--, SUMYTD = foo.Balance" & vbCrLf
      sSql = sSql & "   From" & vbCrLf
      sSql = sSql & "      (SELECT JIACCOUNT,SUM(GjitTable.JICRD) - SUM(GjitTable.JIDEB) AS Balance" & vbCrLf
      sSql = sSql & "         FROM GjhdTable INNER JOIN GjitTable ON GJNAME = JINAME" & vbCrLf
      sSql = sSql & "      WHERE (GJPOST BETWEEN @YearBeginDate AND @EndDate)" & vbCrLf
      sSql = sSql & "         AND GjhdTable.GJPOSTED = 1" & vbCrLf
      sSql = sSql & "      GROUP BY JIACCOUNT) as foo" & vbCrLf
      sSql = sSql & "   Where foo.JIACCOUNT = GLACCTREF" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   UPDATE EsReportIncStatement SET PreviousBal = foo.Balance--, SUMPREVBAL = foo.Balance" & vbCrLf
      sSql = sSql & "   From" & vbCrLf
      sSql = sSql & "      (SELECT JIACCOUNT,SUM(GjitTable.JICRD) - SUM(GjitTable.JIDEB) AS Balance" & vbCrLf
      sSql = sSql & "         FROM GjhdTable INNER JOIN GjitTable ON GJNAME = JINAME" & vbCrLf
      sSql = sSql & "      WHERE (GJPOST BETWEEN DATEADD(year, -1, @YearBeginDate) AND DATEADD(year, -1, @EndDate))" & vbCrLf
      sSql = sSql & "         AND GjhdTable.GJPOSTED = 1" & vbCrLf
      sSql = sSql & "      GROUP BY JIACCOUNT) as foo" & vbCrLf
      sSql = sSql & "   Where foo.JIACCOUNT = GLACCTREF" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   set @level = 9" & vbCrLf
      sSql = sSql & "   WHILE (@level >= 0 )" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "      DECLARE curAcctStruc CURSOR  FOR" & vbCrLf
      sSql = sSql & "      SELECT GLMASTER, SUM(ISNULL(SUMCURBAL,0) + (ISNULL(CurrentBal,0))) ," & vbCrLf
      sSql = sSql & "         Sum (IsNull(SUMYTD, 0) + (IsNull(YTD, 0))), Sum(IsNull(SUMPREVBAL, 0) + (IsNull(PreviousBal, 0)))" & vbCrLf
      sSql = sSql & "      From" & vbCrLf
      sSql = sSql & "         (SELECT DISTINCT GLACCTREF, GLDESCR, GLMASTER," & vbCrLf
      sSql = sSql & "         CurrentBal , YTD, PreviousBal, SUMCURBAL, SUMYTD, SUMPREVBAL" & vbCrLf
      sSql = sSql & "         FROM EsReportIncStatement WHERE GLFSLEVEL = @level) as foo" & vbCrLf
      sSql = sSql & "      group by GLMASTER" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "      OPEN curAcctStruc" & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM curAcctStruc INTO @glMsAcct, @SumCurBal, @SumYTD, @SumPrevBal" & vbCrLf
      sSql = sSql & "      WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "      BEGIN" & vbCrLf
      sSql = sSql & "         IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "         BEGIN" & vbCrLf
      sSql = sSql & "            UPDATE EsReportIncStatement SET SUMCURBAL = @SumCurBal, SUMYTD = @SumYTD," & vbCrLf
      sSql = sSql & "               SUMPREVBAL = @SumPrevBal, GLDESCR = 'TOTAL ' + LTRIM(GLDESCR)," & vbCrLf
      sSql = sSql & "            HASCHILD = 1" & vbCrLf
      sSql = sSql & "            WHERE GLACCTREF = @glMsAcct" & vbCrLf
      sSql = sSql & "         End" & vbCrLf
      sSql = sSql & "         FETCH NEXT FROM curAcctStruc INTO @glMsAcct, @SumCurBal, @SumYTD, @SumPrevBal" & vbCrLf
      sSql = sSql & "      End" & vbCrLf
      sSql = sSql & "      Close curAcctStruc" & vbCrLf
      sSql = sSql & "      DEALLOCATE curAcctStruc" & vbCrLf
      sSql = sSql & "      SET @level = @level - 1" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   UPDATE EsReportIncStatement SET SUMCURBAL = CurrentBal WHERE SUMCURBAL IS NULL" & vbCrLf
      sSql = sSql & "   UPDATE EsReportIncStatement SET SUMPREVBAL = PreviousBal WHERE SUMPREVBAL IS NULL" & vbCrLf
      sSql = sSql & "   UPDATE EsReportIncStatement SET SUMYTD = YTD  WHERE SUMYTD IS NULL" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   set @level = 0 " & vbCrLf
      sSql = sSql & "   set @RowCount = 1" & vbCrLf
      sSql = sSql & "   SET @PrevMaster = ''" & vbCrLf
      sSql = sSql & "   DECLARE curAcctStruc CURSOR  FOR" & vbCrLf
      sSql = sSql & "      SELECT GLMASTER, GLACCSORTKEY" & vbCrLf
      sSql = sSql & "      FROM EsReportIncStatement " & vbCrLf
      sSql = sSql & "         WHERE HASCHILD IS NULL --GLFSLEVEL = 8 --AND GLMASTER ='AA10'--GLTOPMaster = 1 AND " & vbCrLf
      sSql = sSql & "      ORDER BY GLACCSORTKEY" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   OPEN curAcctStruc" & vbCrLf
      sSql = sSql & "   FETCH NEXT FROM curAcctStruc INTO @GlMasterAcc, @GLSortKey" & vbCrLf
      sSql = sSql & "   WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "    IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "    BEGIN" & vbCrLf
      sSql = sSql & "      if (@PrevMaster <> @GlMasterAcc)" & vbCrLf
      sSql = sSql & "      BEGIN" & vbCrLf
      sSql = sSql & "         UPDATE EsReportIncStatement SET " & vbCrLf
      sSql = sSql & "            SortKeyRev = RIGHT ('0000'+ Cast(@RowCount as varchar), 4) + char(36)+ @GlMasterAcc" & vbCrLf
      sSql = sSql & "         WHERE GLMASTER = @GlMasterAcc AND HASCHILD IS NULL --GLFSLEVEL = 8 --AND GLTOPMaster = 1 " & vbCrLf
      sSql = sSql & "         SET @RowCount = @RowCount + 1" & vbCrLf
      sSql = sSql & "         SET @PrevMaster = @GlMasterAcc" & vbCrLf
      sSql = sSql & "      END" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "    End" & vbCrLf
      sSql = sSql & "    FETCH NEXT FROM curAcctStruc INTO @GlMasterAcc, @GLSortKey" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "       " & vbCrLf
      sSql = sSql & "   Close curAcctStruc" & vbCrLf
      sSql = sSql & "   DEALLOCATE curAcctStruc" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   set @level = 7" & vbCrLf
      sSql = sSql & "   WHILE (@level >= 1 )" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "      SET @PrevMaster = ''" & vbCrLf
      sSql = sSql & "        DECLARE curAcctStruc1 CURSOR  FOR" & vbCrLf
      sSql = sSql & "         SELECT DISTINCT GLACCTREF, GLMASTER, GLACCSORTKEY" & vbCrLf
      sSql = sSql & "         FROM EsReportIncStatement " & vbCrLf
      sSql = sSql & "            WHERE GLFSLEVEL = @level AND HASCHILD IS NOT NULL--GLTOPMaster = 1 AND " & vbCrLf
      sSql = sSql & "         order by GLACCSORTKEY" & vbCrLf
      sSql = sSql & "    " & vbCrLf
      sSql = sSql & "        OPEN curAcctStruc1" & vbCrLf
      sSql = sSql & "        FETCH NEXT FROM curAcctStruc1 INTO @GlChildAcct, @GlMasterAcc, @GLSortKey" & vbCrLf
      sSql = sSql & "        WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "        BEGIN" & vbCrLf
      sSql = sSql & "          IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "          BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "            if (@PrevMaster <> @GlChildAcct)" & vbCrLf
      sSql = sSql & "            BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "               SELECT TOP 1 @ChildKey = SortKeyRev,@SortKey = GLACCSORTKEY" & vbCrLf
      sSql = sSql & "               FROM EsReportIncStatement " & vbCrLf
      sSql = sSql & "                  WHERE GLFSLEVEL > @level AND GLMASTER = @GlChildAcct --GLTOPMaster = 1 AND " & vbCrLf
      sSql = sSql & "               order by GLACCSORTKEY desc" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "               UPDATE EsReportIncStatement SET " & vbCrLf
      sSql = sSql & "                  SortKeyRev = Cast(@ChildKey as varchar(512)) + char(36)+ @GlMasterAcc" & vbCrLf
      sSql = sSql & "               WHERE GLACCTREF = @GlChildAcct AND GLMASTER = @GlMasterAcc " & vbCrLf
      sSql = sSql & "                  AND GLFSLEVEL = @level --GLTOPMaster = 1 AND " & vbCrLf
      sSql = sSql & "               SET @PrevMaster = @GlChildAcct" & vbCrLf
      sSql = sSql & "            END" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "          End" & vbCrLf
      sSql = sSql & "          FETCH NEXT FROM curAcctStruc1 INTO @GlChildAcct, @GlMasterAcc, @GLSortKey" & vbCrLf
      sSql = sSql & "        End" & vbCrLf
      sSql = sSql & "               " & vbCrLf
      sSql = sSql & "        Close curAcctStruc1" & vbCrLf
      sSql = sSql & "        DEALLOCATE curAcctStruc1" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "        SET @level = @level - 1" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "  SELECT GLTOPMaster, GLTOPMASTERDESC, GLACCTREF, GLACCTNO, GLDESCR, GLMASTER, GLTYPE,GLINACTIVE, GLFSLEVEL," & vbCrLf
      sSql = sSql & "      SUMCURBAL , CurrentBal, SUMYTD, YTD, SUMPREVBAL, PreviousBal, SORTKEYLEVEL, GLACCSORTKEY" & vbCrLf
      sSql = sSql & "   FROM EsReportIncStatement ORDER BY SortKeyRev --GLTOPMASTER, GLACCSORTKEY desc, SortKeyLevel" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "End"
      ' create the store procedure
      ExecuteScript False, sSql
      
      
      If StoreProcedureExists("RptProFormaIncStatement") Then
         sSql = "DROP PROCEDURE RptProFormaIncStatement"
         ExecuteScript False, sSql
      End If
      
      sSql = "CREATE PROCEDURE [dbo].[RptProFormaIncStatement]" & vbCrLf
      sSql = sSql & "   @StartDate as varchar(12),@EndDate as varchar(12)," & vbCrLf
      sSql = sSql & "   @Year as varchar(4), @Period1 as integer, @Period2 as integer," & vbCrLf
      sSql = sSql & "   @InclInAcct as varchar(1)" & vbCrLf
      sSql = sSql & "AS" & vbCrLf
      sSql = sSql & "BEGIN" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   declare @glAcctRef as varchar(10)" & vbCrLf
      sSql = sSql & "   declare @glMsAcct as varchar(10)" & vbCrLf
      sSql = sSql & "   declare @SumCurBal decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @SumBUDYTD decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @SumBUDCur as decimal(15,4)" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   declare @level as Integer" & vbCrLf
      sSql = sSql & "   declare @TopLevelDesc as varchar(30)" & vbCrLf
      sSql = sSql & "   declare @loop as integer" & vbCrLf
      sSql = sSql & "   declare @SQLBud as varchar(1024)" & vbCrLf
      sSql = sSql & "   declare @SQL as varchar(1024)" & vbCrLf
      sSql = sSql & "   declare @TopLevAcct as varchar(20)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   declare @PrevMaster as varchar(10)" & vbCrLf
      sSql = sSql & "   declare @RowCount as integer" & vbCrLf
      sSql = sSql & "   declare @GlMasterAcc as varchar(10)" & vbCrLf
      sSql = sSql & "   declare @GlChildAcct as varchar(10)" & vbCrLf
      sSql = sSql & "   declare @ChildKey as varchar(1024)" & vbCrLf
      sSql = sSql & "   declare @GLSortKey as varchar(1024)" & vbCrLf
      sSql = sSql & "   declare @SortKey as varchar(1024)" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   DELETE FROM EsReportProFormIncStat" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   if (@InclInAcct = '1')" & vbCrLf
      sSql = sSql & "      SET @InclInAcct = ''" & vbCrLf
      sSql = sSql & "   Else" & vbCrLf
      sSql = sSql & "      SET @InclInAcct = '0'" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   DECLARE balAcctStruc CURSOR  FOR" & vbCrLf
      sSql = sSql & "      SELECT '4', COINCMACCT, COINCMDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      Union All" & vbCrLf
      sSql = sSql & "      SELECT '5', COCOGSACCT, COCOGSDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      Union All" & vbCrLf
      sSql = sSql & "      SELECT '6', COEXPNACCT, COEXPNDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      Union All" & vbCrLf
      sSql = sSql & "      SELECT '7', COOINCACCT, COOINCDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      Union All" & vbCrLf
      sSql = sSql & "      SELECT '8', COOEXPACCT, COOEXPDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      Union All" & vbCrLf
      sSql = sSql & "      SELECT '9', COFDTXACCT, COFDTXDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   OPEN balAcctStruc" & vbCrLf
      sSql = sSql & "   FETCH NEXT FROM balAcctStruc INTO @level, @TopLevAcct, @TopLevelDesc" & vbCrLf
      sSql = sSql & "   WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "      IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "      BEGIN" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "         With cte" & vbCrLf
      sSql = sSql & "         as" & vbCrLf
      sSql = sSql & "         (select GLACCTREF, GLDESCR, GLMASTER, GLFSLEVEL, 0 as level," & vbCrLf
      sSql = sSql & "            cast(cast(@level as varchar(4))+ char(36)+ GLACCTREF as varchar(max)) as SortKey" & vbCrLf
      sSql = sSql & "         From GlacTable" & vbCrLf
      sSql = sSql & "         where GLMASTER = cast(@TopLevAcct as varchar(10)) AND GLINACTIVE LIKE @InclInAcct" & vbCrLf
      sSql = sSql & "         Union All" & vbCrLf
      sSql = sSql & "         select a.GLACCTREF, a.GLDESCR, a.GLMASTER, a.GLFSLEVEL, level + 1," & vbCrLf
      sSql = sSql & "          cast(COALESCE(SortKey,'') + char(36) + COALESCE(a.GLACCTREF,'') as varchar(max))as SortKey" & vbCrLf
      sSql = sSql & "         From cte" & vbCrLf
      sSql = sSql & "            inner join GlacTable a" & vbCrLf
      sSql = sSql & "               on cte.GLACCTREF = a.GLMASTER" & vbCrLf
      sSql = sSql & "            WHERE GLINACTIVE LIKE @InclInAcct" & vbCrLf
      sSql = sSql & "         )" & vbCrLf
      sSql = sSql & "         INSERT INTO EsReportProFormIncStat(GLTOPMaster, GLTOPMASTERDESC, GLACCTREF, GLDESCR, GLMASTER," & vbCrLf
      sSql = sSql & "               GLFSLEVEL,SORTKEYLEVEL,GLACCSORTKEY)" & vbCrLf
      sSql = sSql & "         select @level,  @TopLevelDesc, GLACCTREF, GLDESCR, GLMASTER, GLFSLEVEL, level, SortKey" & vbCrLf
      sSql = sSql & "         from cte order by SortKey" & vbCrLf
      sSql = sSql & "      " & vbCrLf
      sSql = sSql & "      End" & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM balAcctStruc INTO @level, @TopLevAcct, @TopLevelDesc" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "   Close balAcctStruc" & vbCrLf
      sSql = sSql & "   DEALLOCATE balAcctStruc" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   UPDATE EsReportProFormIncStat SET CURBAL = foo.Balance" & vbCrLf
      sSql = sSql & "   From" & vbCrLf
      sSql = sSql & "      (SELECT JIACCOUNT,SUM(GjitTable.JICRD) - SUM(GjitTable.JIDEB) AS Balance" & vbCrLf
      sSql = sSql & "         FROM GjhdTable INNER JOIN GjitTable ON GJNAME = JINAME" & vbCrLf
      sSql = sSql & "      WHERE (GJPOST BETWEEN @StartDate AND @EndDate)" & vbCrLf
      sSql = sSql & "         AND GjhdTable.GJPOSTED = 1" & vbCrLf
      sSql = sSql & "      GROUP BY JIACCOUNT) as foo" & vbCrLf
      sSql = sSql & "   Where foo.JIACCOUNT = GLACCTREF" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   set @loop = 1" & vbCrLf
      sSql = sSql & "   SET @SQLBud = '(SELECT GLACCTREF,'" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   WHILE (@loop <= @Period1 )" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "      IF @loop <> @Period1" & vbCrLf
      sSql = sSql & "         SET @SQLBud = @SQLBud +  'BUDPER' + Convert(varchar(2), @loop) + ' + '" & vbCrLf
      sSql = sSql & "      Else" & vbCrLf
      sSql = sSql & "         SET @SQLBud = @SQLBud +  'BUDPER' + Convert(varchar(2), @loop) + ' AS BUDGETYTD '" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "      SET @loop = @loop + 1" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   SET @SQLBud = @SQLBud +  'FROM BdgtTable RIGHT OUTER JOIN  GlacTable ON BdgtTable.BUDACCT = GlacTable.GLACCTREF ' +" & vbCrLf
      sSql = sSql & "               ' WHERE BUDFY = ''' +  @Year + ''') as foo '" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   SET @SQL = 'UPDATE EsReportProFormIncStat SET EsReportProFormIncStat.BUDYTD = foo.BUDGETYTD FROM '" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   SET @SQL = @SQL + @SQLBud" & vbCrLf
      sSql = sSql & "   SET @SQL = @SQL + 'WHERE foo.GLACCTREF = EsReportProFormIncStat.GLACCTREF '" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   EXEC(@SQL)" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   --// Current Budget calculation" & vbCrLf
      sSql = sSql & "   SET @SQL = ''" & vbCrLf
      sSql = sSql & "   SET @SQLBud = ''" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   set @loop = @Period1" & vbCrLf
      sSql = sSql & "   SET @SQLBud = '(SELECT GLACCTREF,'" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   WHILE (@loop <= @Period2 )" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "      IF @loop <> @Period2" & vbCrLf
      sSql = sSql & "         SET @SQLBud = @SQLBud +  'BUDPER' + Convert(varchar(2), @loop) + ' + '" & vbCrLf
      sSql = sSql & "      Else" & vbCrLf
      sSql = sSql & "         SET @SQLBud = @SQLBud +  'BUDPER' + Convert(varchar(2), @loop) + ' AS BUDGETCUR '" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "      SET @loop = @loop + 1" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   SET @SQLBud = @SQLBud +  'FROM BdgtTable RIGHT OUTER JOIN  GlacTable ON BdgtTable.BUDACCT = GlacTable.GLACCTREF ' +" & vbCrLf
      sSql = sSql & "               ' WHERE BUDFY = ''' +  @Year + ''') as foo '" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   SET @SQL = 'UPDATE EsReportProFormIncStat SET EsReportProFormIncStat.BUDCURBAL = foo.BUDGETCUR FROM '" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   SET @SQL = @SQL + @SQLBud" & vbCrLf
      sSql = sSql & "   SET @SQL = @SQL + 'WHERE foo.GLACCTREF = EsReportProFormIncStat.GLACCTREF '" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   EXEC(@SQL)" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   set @level = 9" & vbCrLf
      sSql = sSql & "   WHILE (@level >= 0 )" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "      DECLARE curAcctStruc CURSOR  FOR" & vbCrLf
      sSql = sSql & "      SELECT GLMASTER, SUM(ISNULL(SUMCURBAL,0) + (ISNULL(CURBAL,0))) ," & vbCrLf
      sSql = sSql & "         Sum (IsNull(SUMBUDYTD, 0) + (IsNull(BUDYTD, 0))), Sum(IsNull(SUMBUDCURBAL, 0) + (IsNull(BUDCURBAL, 0)))" & vbCrLf
      sSql = sSql & "      From" & vbCrLf
      sSql = sSql & "         (SELECT DISTINCT GLACCTREF, GLDESCR, GLMASTER," & vbCrLf
      sSql = sSql & "         CURBAL , BUDYTD, BUDCURBAL, SUMCURBAL, SUMBUDYTD, SUMBUDCURBAL" & vbCrLf
      sSql = sSql & "         FROM EsReportProFormIncStat WHERE GLFSLEVEL = @level) as foo" & vbCrLf
      sSql = sSql & "      group by GLMASTER" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "      OPEN curAcctStruc" & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM curAcctStruc INTO @glMsAcct, @SumCurBal, @SumBUDYTD, @SumBUDCur" & vbCrLf
      sSql = sSql & "      WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "      BEGIN" & vbCrLf
      sSql = sSql & "         IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "         BEGIN" & vbCrLf
      sSql = sSql & "            UPDATE EsReportProFormIncStat SET SUMCURBAL = @SumCurBal, SUMBUDYTD = @SumBUDYTD," & vbCrLf
      sSql = sSql & "               SUMBUDCURBAL = @SumBUDCur, GLDESCR = 'TOTAL ' + LTRIM(GLDESCR)" & vbCrLf
      sSql = sSql & "            WHERE GLACCTREF = @glMsAcct" & vbCrLf
      sSql = sSql & "         End" & vbCrLf
      sSql = sSql & "         FETCH NEXT FROM curAcctStruc INTO @glMsAcct, @SumCurBal, @SumBUDYTD, @SumBUDCur" & vbCrLf
      sSql = sSql & "      End" & vbCrLf
      sSql = sSql & "            " & vbCrLf
      sSql = sSql & "      Close curAcctStruc" & vbCrLf
      sSql = sSql & "      DEALLOCATE curAcctStruc" & vbCrLf
      sSql = sSql & "      " & vbCrLf
      sSql = sSql & "      SET @level = @level - 1" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   UPDATE EsReportProFormIncStat SET SUMCURBAL = CURBAL WHERE SUMCURBAL IS NULL" & vbCrLf
      sSql = sSql & "   UPDATE EsReportProFormIncStat SET SUMBUDYTD = BUDYTD WHERE SUMBUDYTD IS NULL" & vbCrLf
      sSql = sSql & "   UPDATE EsReportProFormIncStat SET SUMBUDCURBAL = BUDCURBAL  WHERE SUMBUDCURBAL IS NULL" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   set @level = 0 " & vbCrLf
      sSql = sSql & "   set @RowCount = 1" & vbCrLf
      sSql = sSql & "   SET @PrevMaster = ''" & vbCrLf
      sSql = sSql & "   DECLARE curAcctStruc CURSOR  FOR" & vbCrLf
      sSql = sSql & "      SELECT GLMASTER, GLACCSORTKEY" & vbCrLf
      sSql = sSql & "      FROM EsReportProFormIncStat " & vbCrLf
      sSql = sSql & "         WHERE HASCHILD IS NULL --GLFSLEVEL = 8 --AND GLMASTER ='AA10'--GLTOPMaster = 1 AND " & vbCrLf
      sSql = sSql & "      ORDER BY GLACCSORTKEY" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   OPEN curAcctStruc" & vbCrLf
      sSql = sSql & "   FETCH NEXT FROM curAcctStruc INTO @GlMasterAcc, @GLSortKey" & vbCrLf
      sSql = sSql & "   WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "    IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "    BEGIN" & vbCrLf
      sSql = sSql & "      if (@PrevMaster <> @GlMasterAcc)" & vbCrLf
      sSql = sSql & "      BEGIN" & vbCrLf
      sSql = sSql & "         UPDATE EsReportProFormIncStat SET " & vbCrLf
      sSql = sSql & "            SortKeyRev = RIGHT ('0000'+ Cast(@RowCount as varchar), 4) + char(36)+ @GlMasterAcc" & vbCrLf
      sSql = sSql & "         WHERE GLMASTER = @GlMasterAcc AND HASCHILD IS NULL  --AND GLFSLEVEL = 8 --AND GLTOPMaster = 1 " & vbCrLf
      sSql = sSql & "         SET @RowCount = @RowCount + 1" & vbCrLf
      sSql = sSql & "         SET @PrevMaster = @GlMasterAcc" & vbCrLf
      sSql = sSql & "      END" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "    End" & vbCrLf
      sSql = sSql & "    FETCH NEXT FROM curAcctStruc INTO @GlMasterAcc, @GLSortKey" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "       " & vbCrLf
      sSql = sSql & "   Close curAcctStruc" & vbCrLf
      sSql = sSql & "   DEALLOCATE curAcctStruc" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   set @level = 7" & vbCrLf
      sSql = sSql & "   WHILE (@level >= 1 )" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "      SET @PrevMaster = ''" & vbCrLf
      sSql = sSql & "        DECLARE curAcctStruc1 CURSOR  FOR" & vbCrLf
      sSql = sSql & "         SELECT DISTINCT GLACCTREF, GLMASTER, GLACCSORTKEY" & vbCrLf
      sSql = sSql & "         FROM EsReportProFormIncStat " & vbCrLf
      sSql = sSql & "            WHERE GLFSLEVEL = @level AND HASCHILD IS NOT NULL--GLTOPMaster = 1 AND " & vbCrLf
      sSql = sSql & "         order by GLACCSORTKEY" & vbCrLf
      sSql = sSql & "    " & vbCrLf
      sSql = sSql & "        OPEN curAcctStruc1" & vbCrLf
      sSql = sSql & "        FETCH NEXT FROM curAcctStruc1 INTO @GlChildAcct, @GlMasterAcc, @GLSortKey" & vbCrLf
      sSql = sSql & "        WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "        BEGIN" & vbCrLf
      sSql = sSql & "          IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "          BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "            if (@PrevMaster <> @GlChildAcct)" & vbCrLf
      sSql = sSql & "            BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "               SELECT TOP 1 @ChildKey = SortKeyRev,@SortKey = GLACCSORTKEY" & vbCrLf
      sSql = sSql & "               FROM EsReportProFormIncStat " & vbCrLf
      sSql = sSql & "                  WHERE GLFSLEVEL > @level AND GLMASTER = @GlChildAcct --GLTOPMaster = 1 AND " & vbCrLf
      sSql = sSql & "               order by GLACCSORTKEY desc" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "               UPDATE EsReportProFormIncStat SET " & vbCrLf
      sSql = sSql & "                  SortKeyRev = Cast(@ChildKey as varchar(512)) + char(36)+ @GlMasterAcc" & vbCrLf
      sSql = sSql & "               WHERE GLACCTREF = @GlChildAcct AND GLMASTER = @GlMasterAcc " & vbCrLf
      sSql = sSql & "                  AND GLFSLEVEL = @level --GLTOPMaster = 1 AND " & vbCrLf
      sSql = sSql & "               SET @PrevMaster = @GlChildAcct" & vbCrLf
      sSql = sSql & "            END" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "          End" & vbCrLf
      sSql = sSql & "          FETCH NEXT FROM curAcctStruc1 INTO @GlChildAcct, @GlMasterAcc, @GLSortKey" & vbCrLf
      sSql = sSql & "        End" & vbCrLf
      sSql = sSql & "               " & vbCrLf
      sSql = sSql & "        Close curAcctStruc1" & vbCrLf
      sSql = sSql & "        DEALLOCATE curAcctStruc1" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "        SET @level = @level - 1" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   SELECT GLTOPMaster, GLTOPMASTERDESC, GLACCTREF, GLACCTNO, GLDESCR, GLMASTER, GLTYPE,GLINACTIVE, GLFSLEVEL," & vbCrLf
      sSql = sSql & "      SUMCURBAL , CURBAL, SUMBUDYTD, BUDYTD, SUMBUDCURBAL, BUDCURBAL, SORTKEYLEVEL, GLACCSORTKEY" & vbCrLf
      sSql = sSql & "   FROM EsReportProFormIncStat ORDER BY SortKeyRev --GLTOPMASTER, GLACCSORTKEY desc, SortKeyLevel" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "End"
      ' create the store procedure
      ExecuteScript False, sSql
      
      
      ExecuteScript False, "Update Version Set Version = " & newver
   End If
    
End Function

Private Function UpdateDatabase30()
   newver = 104
   If ver < newver Then

      
      If Not TableExists("viewMopkPoitTableMO") Then
         
         sSql = "CREATE VIEW [dbo].[viewMopkPoitTableMO]" & vbCrLf
         sSql = sSql & "  AS" & vbCrLf
         sSql = sSql & "SELECT DISTINCT PKPARTREF AS PARTREF, PKMOPART AS MOPART, PKMORUN AS MORUN, PKMORUNOP AS MORUNOP, PKREV AS MOREV" & vbCrLf
         sSql = sSql & "From dbo.MopkTable" & vbCrLf
         sSql = sSql & "WHERE     (PKTYPE IN (10, 9))" & vbCrLf
         sSql = sSql & "         Union " & vbCrLf
         sSql = sSql & "SELECT DISTINCT PIPART AS PARTREF, PIRUNPART AS MOPART, PIRUNNO AS MORUN, PIRUNOPNO AS MORUNOP, PIREV AS MOREV" & vbCrLf
         sSql = sSql & "From dbo.PoitTable" & vbCrLf
         sSql = sSql & "Where (PIRUNPART Is Not Null) And (PIRUNNO Is Not Null)" & vbCrLf

          ExecuteScript False, sSql
      End If
      
      
      sSql = "DROP INDEX VendType ON vndrtable"
      ExecuteScript False, sSql

      sSql = "ALTER TABLE vndrtable ALTER COLUMN VETYPE char(4)"
      ExecuteScript False, sSql

      sSql = "CREATE NONCLUSTERED INDEX [VendType] ON [dbo].[VndrTable]" & vbCrLf
      sSql = sSql & "(" & vbCrLf
      sSql = sSql & "   [VETYPE] Asc" & vbCrLf
      sSql = sSql & ")WITH FILLFACTOR = 80 ON [PRIMARY]" & vbCrLf
      ExecuteScript False, sSql
      
      
      If StoreProcedureExists("RptIncomeStatement") Then
         sSql = "DROP PROCEDURE RptIncomeStatement"
                ExecuteScript False, sSql
      End If
      
      
      sSql = "ALTER PROCEDURE [dbo].[RptIncomeStatement]" & vbCrLf
      sSql = sSql & "   @StartDate as varchar(12),@EndDate as varchar(12)," & vbCrLf
      sSql = sSql & "   @YearBeginDate as varchar(12), @InclIncAcct as varchar(1)" & vbCrLf
      sSql = sSql & "AS " & vbCrLf
      sSql = sSql & "BEGIN" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   declare @glAcctRef as varchar(10)" & vbCrLf
      sSql = sSql & "   declare @glMsAcct as varchar(10)" & vbCrLf
      sSql = sSql & "   declare @SumCurBal decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @SumYTD decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @SumPrevBal as decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @level as integer" & vbCrLf
      sSql = sSql & "   declare @TopLevelDesc as varchar(30)" & vbCrLf
      sSql = sSql & "   declare @InclInAcct as Integer" & vbCrLf
      sSql = sSql & "   declare @TopLevAcct as varchar(20)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   declare @PrevMaster as varchar(10)" & vbCrLf
      sSql = sSql & "   declare @RowCount as integer" & vbCrLf
      sSql = sSql & "   declare @GlMasterAcc as varchar(10)" & vbCrLf
      sSql = sSql & "   declare @GlChildAcct as varchar(10)" & vbCrLf
      sSql = sSql & "   declare @ChildKey as varchar(1024)" & vbCrLf
      sSql = sSql & "   declare @GLSortKey as varchar(1024)" & vbCrLf
      sSql = sSql & "   declare @SortKey as varchar(1024)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   DELETE FROM EsReportIncStatement" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   if (@InclIncAcct = '1')" & vbCrLf
      sSql = sSql & "      SET @InclInAcct = ''" & vbCrLf
      sSql = sSql & "   Else" & vbCrLf
      sSql = sSql & "      SET @InclInAcct = '0'" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   DECLARE balAcctStruc CURSOR  FOR" & vbCrLf
      sSql = sSql & "      SELECT '4', COINCMACCT, COINCMDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      Union All" & vbCrLf
      sSql = sSql & "      SELECT '5', COCOGSACCT, COCOGSDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      Union All" & vbCrLf
      sSql = sSql & "      SELECT '6', COEXPNACCT, COEXPNDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      Union All" & vbCrLf
      sSql = sSql & "      SELECT '7', COOINCACCT, COOINCDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      Union All" & vbCrLf
      sSql = sSql & "      SELECT '8', COOEXPACCT, COOEXPDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      Union All" & vbCrLf
      sSql = sSql & "      SELECT '9', COFDTXACCT, COFDTXDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   OPEN balAcctStruc" & vbCrLf
      sSql = sSql & "   FETCH NEXT FROM balAcctStruc INTO @level,@TopLevAcct, @TopLevelDesc" & vbCrLf
      sSql = sSql & "   WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "      IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "      BEGIN" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "        With cte" & vbCrLf
      sSql = sSql & "        as " & vbCrLf
      sSql = sSql & "        (select GLACCTREF, GLDESCR, GLMASTER, GLFSLEVEL, 1 as level," & vbCrLf
      sSql = sSql & "          cast(cast(@level as varchar(4))+ char(36)+ GLACCTREF as varchar(max)) as SortKey" & vbCrLf
      sSql = sSql & "        From GlacTable" & vbCrLf
      sSql = sSql & "        where GLMASTER = cast(@TopLevAcct as varchar(20)) AND GLINACTIVE LIKE @InclInAcct" & vbCrLf
      sSql = sSql & "        Union All" & vbCrLf
      sSql = sSql & "        select a.GLACCTREF, a.GLDESCR, a.GLMASTER, a.GLFSLEVEL, level + 1," & vbCrLf
      sSql = sSql & "         cast(COALESCE(SortKey,'') + char(36) + COALESCE(a.GLACCTREF,'') as varchar(max))as SortKey" & vbCrLf
      sSql = sSql & "        From cte" & vbCrLf
      sSql = sSql & "          inner join GlacTable a" & vbCrLf
      sSql = sSql & "            on cte.GLACCTREF = a.GLMASTER" & vbCrLf
      sSql = sSql & "          WHERE GLINACTIVE LIKE @InclInAcct" & vbCrLf
      sSql = sSql & "        )" & vbCrLf
      sSql = sSql & "        INSERT INTO EsReportIncStatement(GLTOPMaster, GLTOPMASTERDESC, GLACCTREF, GLDESCR, GLMASTER, GLFSLEVEL,SORTKEYLEVEL,GLACCSORTKEY)" & vbCrLf
      sSql = sSql & "        select @level, @TopLevelDesc, GLACCTREF, GLDESCR, GLMASTER, GLFSLEVEL, level, SortKey" & vbCrLf
      sSql = sSql & "        from cte order by SortKey" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "      End" & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM balAcctStruc INTO @level,@TopLevAcct, @TopLevelDesc" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "   Close balAcctStruc" & vbCrLf
      sSql = sSql & "   DEALLOCATE balAcctStruc" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   UPDATE EsReportIncStatement SET CurrentBal = foo.Balance--, SUMCURBAL = foo.Balance" & vbCrLf
      sSql = sSql & "   From" & vbCrLf
      sSql = sSql & "       (SELECT SUM(GjitTable.JICRD) - SUM(GjitTable.JIDEB) as Balance, JIACCOUNT" & vbCrLf
      sSql = sSql & "         FROM GjhdTable INNER JOIN GjitTable ON GJNAME = JINAME" & vbCrLf
      sSql = sSql & "      WHERE GJPOST BETWEEN @StartDate AND @EndDate" & vbCrLf
      sSql = sSql & "         AND GjhdTable.GJPOSTED = 1" & vbCrLf
      sSql = sSql & "      GROUP BY JIACCOUNT) as foo" & vbCrLf
      sSql = sSql & "   Where foo.JIACCOUNT = GLACCTREF" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   UPDATE EsReportIncStatement SET YTD = foo.Balance--, SUMYTD = foo.Balance" & vbCrLf
      sSql = sSql & "   From" & vbCrLf
      sSql = sSql & "      (SELECT JIACCOUNT,SUM(GjitTable.JICRD) - SUM(GjitTable.JIDEB) AS Balance" & vbCrLf
      sSql = sSql & "         FROM GjhdTable INNER JOIN GjitTable ON GJNAME = JINAME" & vbCrLf
      sSql = sSql & "      WHERE (GJPOST BETWEEN @YearBeginDate AND @EndDate)" & vbCrLf
      sSql = sSql & "         AND GjhdTable.GJPOSTED = 1" & vbCrLf
      sSql = sSql & "      GROUP BY JIACCOUNT) as foo" & vbCrLf
      sSql = sSql & "   Where foo.JIACCOUNT = GLACCTREF" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   UPDATE EsReportIncStatement SET PreviousBal = foo.Balance--, SUMPREVBAL = foo.Balance" & vbCrLf
      sSql = sSql & "   From" & vbCrLf
      sSql = sSql & "      (SELECT JIACCOUNT,SUM(GjitTable.JICRD) - SUM(GjitTable.JIDEB) AS Balance" & vbCrLf
      sSql = sSql & "         FROM GjhdTable INNER JOIN GjitTable ON GJNAME = JINAME" & vbCrLf
      sSql = sSql & "      WHERE (GJPOST BETWEEN DATEADD(year, -1, @YearBeginDate) AND DATEADD(year, -1, @EndDate))" & vbCrLf
      sSql = sSql & "         AND GjhdTable.GJPOSTED = 1" & vbCrLf
      sSql = sSql & "      GROUP BY JIACCOUNT) as foo" & vbCrLf
      sSql = sSql & "   Where foo.JIACCOUNT = GLACCTREF" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   SELECT @level =  MAX(SORTKEYLEVEL) FROM EsReportIncStatement" & vbCrLf
      sSql = sSql & "   --set @level = 9" & vbCrLf
      sSql = sSql & "   WHILE (@level >= 1 )" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "      DECLARE curAcctStruc CURSOR  FOR" & vbCrLf
      sSql = sSql & "      SELECT GLMASTER, SUM(ISNULL(SUMCURBAL,0) + (ISNULL(CurrentBal,0))) ," & vbCrLf
      sSql = sSql & "         Sum (IsNull(SUMYTD, 0) + (IsNull(YTD, 0))), Sum(IsNull(SUMPREVBAL, 0) + (IsNull(PreviousBal, 0)))" & vbCrLf
      sSql = sSql & "      From" & vbCrLf
      sSql = sSql & "         (SELECT DISTINCT GLACCTREF, GLDESCR, GLMASTER," & vbCrLf
      sSql = sSql & "         CurrentBal , YTD, PreviousBal, SUMCURBAL, SUMYTD, SUMPREVBAL" & vbCrLf
      sSql = sSql & "         FROM EsReportIncStatement WHERE SORTKEYLEVEL = @level) as foo" & vbCrLf
      sSql = sSql & "      group by GLMASTER" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "      OPEN curAcctStruc" & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM curAcctStruc INTO @glMsAcct, @SumCurBal, @SumYTD, @SumPrevBal" & vbCrLf
      sSql = sSql & "      WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "      BEGIN" & vbCrLf
      sSql = sSql & "         IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "         BEGIN" & vbCrLf
      sSql = sSql & "            UPDATE EsReportIncStatement SET SUMCURBAL = @SumCurBal, SUMYTD = @SumYTD," & vbCrLf
      sSql = sSql & "               SUMPREVBAL = @SumPrevBal, GLDESCR = 'TOTAL ' + LTRIM(GLDESCR)," & vbCrLf
      sSql = sSql & "            HASCHILD = 1" & vbCrLf
      sSql = sSql & "            WHERE GLACCTREF = @glMsAcct" & vbCrLf
      sSql = sSql & "         End" & vbCrLf
      sSql = sSql & "         FETCH NEXT FROM curAcctStruc INTO @glMsAcct, @SumCurBal, @SumYTD, @SumPrevBal" & vbCrLf
      sSql = sSql & "      End" & vbCrLf
      sSql = sSql & "      Close curAcctStruc" & vbCrLf
      sSql = sSql & "      DEALLOCATE curAcctStruc" & vbCrLf
      sSql = sSql & "      SET @level = @level - 1" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   UPDATE EsReportIncStatement SET SUMCURBAL = CurrentBal WHERE SUMCURBAL IS NULL" & vbCrLf
      sSql = sSql & "   UPDATE EsReportIncStatement SET SUMPREVBAL = PreviousBal WHERE SUMPREVBAL IS NULL" & vbCrLf
      sSql = sSql & "   UPDATE EsReportIncStatement SET SUMYTD = YTD  WHERE SUMYTD IS NULL" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   set @level = 0 " & vbCrLf
      sSql = sSql & "   set @RowCount = 1" & vbCrLf
      sSql = sSql & "   SET @PrevMaster = ''" & vbCrLf
      sSql = sSql & "   DECLARE curAcctStruc CURSOR  FOR" & vbCrLf
      sSql = sSql & "      SELECT GLMASTER, GLACCSORTKEY" & vbCrLf
      sSql = sSql & "      FROM EsReportIncStatement " & vbCrLf
      sSql = sSql & "         WHERE HASCHILD IS NULL --GLFSLEVEL = 8 --AND GLMASTER ='AA10'--GLTOPMaster = 1 AND " & vbCrLf
      sSql = sSql & "      ORDER BY GLACCSORTKEY" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   OPEN curAcctStruc" & vbCrLf
      sSql = sSql & "   FETCH NEXT FROM curAcctStruc INTO @GlMasterAcc, @GLSortKey" & vbCrLf
      sSql = sSql & "   WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "    IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "    BEGIN" & vbCrLf
      sSql = sSql & "      if (@PrevMaster <> @GlMasterAcc)" & vbCrLf
      sSql = sSql & "      BEGIN" & vbCrLf
      sSql = sSql & "         UPDATE EsReportIncStatement SET " & vbCrLf
      sSql = sSql & "            SortKeyRev = RIGHT ('0000'+ Cast(@RowCount as varchar), 4) + char(36)+ @GlMasterAcc" & vbCrLf
      sSql = sSql & "         WHERE GLMASTER = @GlMasterAcc AND HASCHILD IS NULL --GLFSLEVEL = 8 --AND GLTOPMaster = 1 " & vbCrLf
      sSql = sSql & "         SET @RowCount = @RowCount + 1" & vbCrLf
      sSql = sSql & "         SET @PrevMaster = @GlMasterAcc" & vbCrLf
      sSql = sSql & "      END" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "    End" & vbCrLf
      sSql = sSql & "    FETCH NEXT FROM curAcctStruc INTO @GlMasterAcc, @GLSortKey" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "       " & vbCrLf
      sSql = sSql & "   Close curAcctStruc" & vbCrLf
      sSql = sSql & "   DEALLOCATE curAcctStruc" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "    SELECT @level = MAX(SORTKEYLEVEL) FROM EsReportIncStatement" & vbCrLf
      sSql = sSql & "   --set @level = 7" & vbCrLf
      sSql = sSql & "   WHILE (@level >= 1 )" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "      SET @PrevMaster = ''" & vbCrLf
      sSql = sSql & "        DECLARE curAcctStruc1 CURSOR  FOR" & vbCrLf
      sSql = sSql & "         SELECT DISTINCT GLACCTREF, GLMASTER, GLACCSORTKEY" & vbCrLf
      sSql = sSql & "         FROM EsReportIncStatement " & vbCrLf
      sSql = sSql & "            WHERE SORTKEYLEVEL = @level AND HASCHILD IS NOT NULL--GLTOPMaster = 1 AND " & vbCrLf
      sSql = sSql & "         order by GLACCSORTKEY" & vbCrLf
      sSql = sSql & "    " & vbCrLf
      sSql = sSql & "        OPEN curAcctStruc1" & vbCrLf
      sSql = sSql & "        FETCH NEXT FROM curAcctStruc1 INTO @GlChildAcct, @GlMasterAcc, @GLSortKey" & vbCrLf
      sSql = sSql & "        WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "        BEGIN" & vbCrLf
      sSql = sSql & "          IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "          BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "            if (@PrevMaster <> @GlChildAcct)" & vbCrLf
      sSql = sSql & "            BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   print 'Record' + @GlChildAcct + ':' + @GlMasterAcc" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "               SELECT TOP 1 @ChildKey = SortKeyRev,@SortKey = GLACCSORTKEY" & vbCrLf
      sSql = sSql & "               FROM EsReportIncStatement " & vbCrLf
      sSql = sSql & "                  WHERE SORTKEYLEVEL > @level AND GLMASTER = @GlChildAcct --GLTOPMaster = 1 AND " & vbCrLf
      sSql = sSql & "               order by GLACCSORTKEY desc" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "               UPDATE EsReportIncStatement SET " & vbCrLf
      sSql = sSql & "                  SortKeyRev = Cast(@ChildKey as varchar(512)) + char(36)+ @GlMasterAcc" & vbCrLf
      sSql = sSql & "               WHERE GLACCTREF = @GlChildAcct AND GLMASTER = @GlMasterAcc " & vbCrLf
      sSql = sSql & "                  AND SORTKEYLEVEL = @level --GLTOPMaster = 1 AND " & vbCrLf
      sSql = sSql & "               SET @PrevMaster = @GlChildAcct" & vbCrLf
      sSql = sSql & "            END" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "          End" & vbCrLf
      sSql = sSql & "          FETCH NEXT FROM curAcctStruc1 INTO @GlChildAcct, @GlMasterAcc, @GLSortKey" & vbCrLf
      sSql = sSql & "        End" & vbCrLf
      sSql = sSql & "               " & vbCrLf
      sSql = sSql & "        Close curAcctStruc1" & vbCrLf
      sSql = sSql & "        DEALLOCATE curAcctStruc1" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "        SET @level = @level - 1" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "  SELECT GLTOPMaster, GLTOPMASTERDESC, GLACCTREF, GLACCTNO, GLDESCR, GLMASTER, GLTYPE,GLINACTIVE, GLFSLEVEL," & vbCrLf
      sSql = sSql & "      SUMCURBAL , CurrentBal, SUMYTD, YTD, SUMPREVBAL, PreviousBal, SORTKEYLEVEL, GLACCSORTKEY" & vbCrLf
      sSql = sSql & "   FROM EsReportIncStatement ORDER BY SortKeyRev --GLTOPMASTER, GLACCSORTKEY desc, SortKeyLevel" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "End"
      
      ExecuteScript False, sSql
      
      
          ExecuteScript False, "Update Version Set Version = " & newver
   End If
    
End Function


Private Function UpdateDatabase31()
   newver = 105
   If ver < newver Then

      
      sSql = "update VihdTable set VICHKACCT = chkacct" & vbCrLf
      sSql = sSql & "      FROM ChksTable, VihdTable b WHERE b.VICHECKNO = chknumber"
      ExecuteScript False, sSql


      sSql = "update jritTable set DCCHKACCT = chkacct" & vbCrLf
      sSql = sSql & " FROM ChksTable, jritTable b WHERE b.DCCHECKNO = chknumber" & vbCrLf
      sSql = sSql & " AND DCDATE = CHKPOSTDATE"
      ExecuteScript False, sSql
      
      
      ExecuteScript False, "Update Version Set Version = " & newver
   End If
    
End Function


Private Function UpdateDatabase32()
   newver = 106
   If ver < newver Then

      
      If Not ColumnExists("ComnTable", "COALLOWDELOVERQTY") Then
         sSql = "ALTER TABLE ComnTable ADD COALLOWDELOVERQTY tinyint"
         ExecuteScript False, sSql
      End If

      If Not ColumnExists("cihdTable", "INVORGCANCDATE") Then
         sSql = "ALTER TABLE cihdTable ADD INVORGCANCDATE smalldatetime"
         ExecuteScript False, sSql
      End If

      If StoreProcedureExists("RptIncomeStatement") Then
         sSql = "DROP PROCEDURE RptIncomeStatement"
         ExecuteScript False, sSql
      End If
      
      
      sSql = "CREATE PROCEDURE [dbo].[RptIncomeStatement]" & vbCrLf
      sSql = sSql & "   @StartDate as varchar(12),@EndDate as varchar(12)," & vbCrLf
      sSql = sSql & "   @YearBeginDate as varchar(12), @InclIncAcct as varchar(1)" & vbCrLf
      sSql = sSql & "AS " & vbCrLf
      sSql = sSql & "BEGIN" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   declare @glAcctRef as varchar(10)" & vbCrLf
      sSql = sSql & "   declare @glMsAcct as varchar(10)" & vbCrLf
      sSql = sSql & "   declare @SumCurBal decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @SumYTD decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @SumPrevBal as decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @level as integer" & vbCrLf
      sSql = sSql & "   declare @TopLevelDesc as varchar(30)" & vbCrLf
      sSql = sSql & "   declare @InclInAcct as Integer" & vbCrLf
      sSql = sSql & "   declare @TopLevAcct as varchar(20)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   declare @PrevMaster as varchar(10)" & vbCrLf
      sSql = sSql & "   declare @RowCount as integer" & vbCrLf
      sSql = sSql & "   declare @GlMasterAcc as varchar(10)" & vbCrLf
      sSql = sSql & "   declare @GlChildAcct as varchar(10)" & vbCrLf
      sSql = sSql & "   declare @ChildKey as varchar(1024)" & vbCrLf
      sSql = sSql & "   declare @GLSortKey as varchar(1024)" & vbCrLf
      sSql = sSql & "   declare @SortKey as varchar(1024)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   DELETE FROM EsReportIncStatement" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   if (@InclIncAcct = '1')" & vbCrLf
      sSql = sSql & "      SET @InclInAcct = ''" & vbCrLf
      sSql = sSql & "   Else" & vbCrLf
      sSql = sSql & "      SET @InclInAcct = '0'" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   DECLARE balAcctStruc CURSOR  FOR" & vbCrLf
      sSql = sSql & "      SELECT '4', COINCMACCT, COINCMDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      Union All" & vbCrLf
      sSql = sSql & "      SELECT '5', COCOGSACCT, COCOGSDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      Union All" & vbCrLf
      sSql = sSql & "      SELECT '6', COEXPNACCT, COEXPNDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      Union All" & vbCrLf
      sSql = sSql & "      SELECT '7', COOINCACCT, COOINCDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      Union All" & vbCrLf
      sSql = sSql & "      SELECT '8', COOEXPACCT, COOEXPDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      Union All" & vbCrLf
      sSql = sSql & "      SELECT '9', COFDTXACCT, COFDTXDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   OPEN balAcctStruc" & vbCrLf
      sSql = sSql & "   FETCH NEXT FROM balAcctStruc INTO @level,@TopLevAcct, @TopLevelDesc" & vbCrLf
      sSql = sSql & "   WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "      IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "      BEGIN" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "        With cte" & vbCrLf
      sSql = sSql & "        as " & vbCrLf
      sSql = sSql & "        (select GLACCTREF, GLDESCR, GLMASTER, GLFSLEVEL, 1 as level," & vbCrLf
      sSql = sSql & "          cast(cast(@level as varchar(4))+ char(36)+ GLACCTREF as varchar(max)) as SortKey" & vbCrLf
      sSql = sSql & "        From GlacTable" & vbCrLf
      sSql = sSql & "        where GLMASTER = cast(@TopLevAcct as varchar(20)) AND GLINACTIVE LIKE @InclInAcct" & vbCrLf
      sSql = sSql & "        Union All" & vbCrLf
      sSql = sSql & "        select a.GLACCTREF, a.GLDESCR, a.GLMASTER, a.GLFSLEVEL, level + 1," & vbCrLf
      sSql = sSql & "         cast(COALESCE(SortKey,'') + char(36) + COALESCE(a.GLACCTREF,'') as varchar(max))as SortKey" & vbCrLf
      sSql = sSql & "        From cte" & vbCrLf
      sSql = sSql & "          inner join GlacTable a" & vbCrLf
      sSql = sSql & "            on cte.GLACCTREF = a.GLMASTER" & vbCrLf
      sSql = sSql & "          WHERE GLINACTIVE LIKE @InclInAcct" & vbCrLf
      sSql = sSql & "        )" & vbCrLf
      sSql = sSql & "        INSERT INTO EsReportIncStatement(GLTOPMaster, GLTOPMASTERDESC, GLACCTREF, GLDESCR, GLMASTER, GLFSLEVEL,SORTKEYLEVEL,GLACCSORTKEY)" & vbCrLf
      sSql = sSql & "        select @level, @TopLevelDesc, GLACCTREF, GLDESCR, GLMASTER, GLFSLEVEL, level, SortKey" & vbCrLf
      sSql = sSql & "        from cte order by SortKey" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "      End" & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM balAcctStruc INTO @level,@TopLevAcct, @TopLevelDesc" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "   Close balAcctStruc" & vbCrLf
      sSql = sSql & "   DEALLOCATE balAcctStruc" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   UPDATE EsReportIncStatement SET CurrentBal = foo.Balance--, SUMCURBAL = foo.Balance" & vbCrLf
      sSql = sSql & "   From" & vbCrLf
      sSql = sSql & "       (SELECT SUM(GjitTable.JICRD) - SUM(GjitTable.JIDEB) as Balance, JIACCOUNT" & vbCrLf
      sSql = sSql & "         FROM GjhdTable INNER JOIN GjitTable ON GJNAME = JINAME" & vbCrLf
      sSql = sSql & "      WHERE GJPOST BETWEEN @StartDate AND @EndDate" & vbCrLf
      sSql = sSql & "         AND GjhdTable.GJPOSTED = 1" & vbCrLf
      sSql = sSql & "      GROUP BY JIACCOUNT) as foo" & vbCrLf
      sSql = sSql & "   Where foo.JIACCOUNT = GLACCTREF" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   UPDATE EsReportIncStatement SET YTD = foo.Balance--, SUMYTD = foo.Balance" & vbCrLf
      sSql = sSql & "   From" & vbCrLf
      sSql = sSql & "      (SELECT JIACCOUNT,SUM(GjitTable.JICRD) - SUM(GjitTable.JIDEB) AS Balance" & vbCrLf
      sSql = sSql & "         FROM GjhdTable INNER JOIN GjitTable ON GJNAME = JINAME" & vbCrLf
      sSql = sSql & "      WHERE (GJPOST BETWEEN @YearBeginDate AND @EndDate)" & vbCrLf
      sSql = sSql & "         AND GjhdTable.GJPOSTED = 1" & vbCrLf
      sSql = sSql & "      GROUP BY JIACCOUNT) as foo" & vbCrLf
      sSql = sSql & "   Where foo.JIACCOUNT = GLACCTREF" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   UPDATE EsReportIncStatement SET PreviousBal = foo.Balance--, SUMPREVBAL = foo.Balance" & vbCrLf
      sSql = sSql & "   From" & vbCrLf
      sSql = sSql & "      (SELECT JIACCOUNT,SUM(GjitTable.JICRD) - SUM(GjitTable.JIDEB) AS Balance" & vbCrLf
      sSql = sSql & "         FROM GjhdTable INNER JOIN GjitTable ON GJNAME = JINAME" & vbCrLf
      sSql = sSql & "      WHERE (GJPOST BETWEEN DATEADD(year, -1, @YearBeginDate) AND DATEADD(year, -1, @EndDate))" & vbCrLf
      sSql = sSql & "         AND GjhdTable.GJPOSTED = 1" & vbCrLf
      sSql = sSql & "      GROUP BY JIACCOUNT) as foo" & vbCrLf
      sSql = sSql & "   Where foo.JIACCOUNT = GLACCTREF" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   SELECT @level =  MAX(SORTKEYLEVEL) FROM EsReportIncStatement" & vbCrLf
      sSql = sSql & "   --set @level = 9" & vbCrLf
      sSql = sSql & "   WHILE (@level >= 1 )" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "      DECLARE curAcctStruc CURSOR  FOR" & vbCrLf
      sSql = sSql & "      SELECT GLMASTER, SUM(ISNULL(SUMCURBAL,0) + (ISNULL(CurrentBal,0))) ," & vbCrLf
      sSql = sSql & "         Sum (IsNull(SUMYTD, 0) + (IsNull(YTD, 0))), Sum(IsNull(SUMPREVBAL, 0) + (IsNull(PreviousBal, 0)))" & vbCrLf
      sSql = sSql & "      From" & vbCrLf
      sSql = sSql & "         (SELECT DISTINCT GLACCTREF, GLDESCR, GLMASTER," & vbCrLf
      sSql = sSql & "         CurrentBal , YTD, PreviousBal, SUMCURBAL, SUMYTD, SUMPREVBAL" & vbCrLf
      sSql = sSql & "         FROM EsReportIncStatement WHERE SORTKEYLEVEL = @level) as foo" & vbCrLf
      sSql = sSql & "      group by GLMASTER" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "      OPEN curAcctStruc" & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM curAcctStruc INTO @glMsAcct, @SumCurBal, @SumYTD, @SumPrevBal" & vbCrLf
      sSql = sSql & "      WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "      BEGIN" & vbCrLf
      sSql = sSql & "         IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "         BEGIN" & vbCrLf
      sSql = sSql & "            UPDATE EsReportIncStatement SET SUMCURBAL = @SumCurBal, SUMYTD = @SumYTD," & vbCrLf
      sSql = sSql & "               SUMPREVBAL = @SumPrevBal, GLDESCR = 'TOTAL ' + LTRIM(GLDESCR)," & vbCrLf
      sSql = sSql & "            HASCHILD = 1" & vbCrLf
      sSql = sSql & "            WHERE GLACCTREF = @glMsAcct" & vbCrLf
      sSql = sSql & "         End" & vbCrLf
      sSql = sSql & "         FETCH NEXT FROM curAcctStruc INTO @glMsAcct, @SumCurBal, @SumYTD, @SumPrevBal" & vbCrLf
      sSql = sSql & "      End" & vbCrLf
      sSql = sSql & "      Close curAcctStruc" & vbCrLf
      sSql = sSql & "      DEALLOCATE curAcctStruc" & vbCrLf
      sSql = sSql & "      SET @level = @level - 1" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   UPDATE EsReportIncStatement SET SUMCURBAL = CurrentBal WHERE SUMCURBAL IS NULL" & vbCrLf
      sSql = sSql & "   UPDATE EsReportIncStatement SET SUMPREVBAL = PreviousBal WHERE SUMPREVBAL IS NULL" & vbCrLf
      sSql = sSql & "   UPDATE EsReportIncStatement SET SUMYTD = YTD  WHERE SUMYTD IS NULL" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   set @level = 0 " & vbCrLf
      sSql = sSql & "   set @RowCount = 1" & vbCrLf
      sSql = sSql & "   SET @PrevMaster = ''" & vbCrLf
      sSql = sSql & "   DECLARE curAcctStruc CURSOR  FOR" & vbCrLf
      sSql = sSql & "      SELECT GLMASTER, GLACCSORTKEY" & vbCrLf
      sSql = sSql & "      FROM EsReportIncStatement " & vbCrLf
      sSql = sSql & "         WHERE HASCHILD IS NULL --GLFSLEVEL = 8 --AND GLMASTER ='AA10'--GLTOPMaster = 1 AND " & vbCrLf
      sSql = sSql & "      ORDER BY GLACCSORTKEY" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   OPEN curAcctStruc" & vbCrLf
      sSql = sSql & "   FETCH NEXT FROM curAcctStruc INTO @GlMasterAcc, @GLSortKey" & vbCrLf
      sSql = sSql & "   WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "    IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "    BEGIN" & vbCrLf
      sSql = sSql & "      if (@PrevMaster <> @GlMasterAcc)" & vbCrLf
      sSql = sSql & "      BEGIN" & vbCrLf
      sSql = sSql & "         UPDATE EsReportIncStatement SET " & vbCrLf
      sSql = sSql & "            SortKeyRev = RIGHT ('0000'+ Cast(@RowCount as varchar), 4) + char(36)+ @GlMasterAcc" & vbCrLf
      sSql = sSql & "         WHERE GLMASTER = @GlMasterAcc AND HASCHILD IS NULL --GLFSLEVEL = 8 --AND GLTOPMaster = 1 " & vbCrLf
      sSql = sSql & "         SET @RowCount = @RowCount + 1" & vbCrLf
      sSql = sSql & "         SET @PrevMaster = @GlMasterAcc" & vbCrLf
      sSql = sSql & "      END" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "    End" & vbCrLf
      sSql = sSql & "    FETCH NEXT FROM curAcctStruc INTO @GlMasterAcc, @GLSortKey" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "       " & vbCrLf
      sSql = sSql & "   Close curAcctStruc" & vbCrLf
      sSql = sSql & "   DEALLOCATE curAcctStruc" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "    SELECT @level = MAX(SORTKEYLEVEL) FROM EsReportIncStatement" & vbCrLf
      sSql = sSql & "   --set @level = 7" & vbCrLf
      sSql = sSql & "   WHILE (@level >= 1 )" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "      SET @PrevMaster = ''" & vbCrLf
      sSql = sSql & "        DECLARE curAcctStruc1 CURSOR  FOR" & vbCrLf
      sSql = sSql & "         SELECT DISTINCT GLACCTREF, GLMASTER, GLACCSORTKEY" & vbCrLf
      sSql = sSql & "         FROM EsReportIncStatement " & vbCrLf
      sSql = sSql & "            WHERE SORTKEYLEVEL = @level AND HASCHILD IS NOT NULL--GLTOPMaster = 1 AND " & vbCrLf
      sSql = sSql & "         order by GLACCSORTKEY" & vbCrLf
      sSql = sSql & "    " & vbCrLf
      sSql = sSql & "        OPEN curAcctStruc1" & vbCrLf
      sSql = sSql & "        FETCH NEXT FROM curAcctStruc1 INTO @GlChildAcct, @GlMasterAcc, @GLSortKey" & vbCrLf
      sSql = sSql & "        WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "        BEGIN" & vbCrLf
      sSql = sSql & "          IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "          BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "            if (@PrevMaster <> @GlChildAcct)" & vbCrLf
      sSql = sSql & "            BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   print 'Record' + @GlChildAcct + ':' + @GlMasterAcc" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "               SELECT TOP 1 @ChildKey = SortKeyRev,@SortKey = GLACCSORTKEY" & vbCrLf
      sSql = sSql & "               FROM EsReportIncStatement " & vbCrLf
      sSql = sSql & "                  WHERE SORTKEYLEVEL > @level AND GLMASTER = @GlChildAcct --GLTOPMaster = 1 AND " & vbCrLf
      sSql = sSql & "               order by GLACCSORTKEY desc" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "               UPDATE EsReportIncStatement SET " & vbCrLf
      sSql = sSql & "                  SortKeyRev = Cast(@ChildKey as varchar(512)) + char(36)+ @GlMasterAcc" & vbCrLf
      sSql = sSql & "               WHERE GLACCTREF = @GlChildAcct AND GLMASTER = @GlMasterAcc " & vbCrLf
      sSql = sSql & "                  AND SORTKEYLEVEL = @level --GLTOPMaster = 1 AND " & vbCrLf
      sSql = sSql & "               SET @PrevMaster = @GlChildAcct" & vbCrLf
      sSql = sSql & "            END" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "          End" & vbCrLf
      sSql = sSql & "          FETCH NEXT FROM curAcctStruc1 INTO @GlChildAcct, @GlMasterAcc, @GLSortKey" & vbCrLf
      sSql = sSql & "        End" & vbCrLf
      sSql = sSql & "               " & vbCrLf
      sSql = sSql & "        Close curAcctStruc1" & vbCrLf
      sSql = sSql & "        DEALLOCATE curAcctStruc1" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "        SET @level = @level - 1" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "  SELECT GLTOPMaster, GLTOPMASTERDESC, GLACCTREF, GLACCTNO, GLDESCR, GLMASTER, GLTYPE,GLINACTIVE, GLFSLEVEL," & vbCrLf
      sSql = sSql & "      SUMCURBAL , CurrentBal, SUMYTD, YTD, SUMPREVBAL, PreviousBal, SORTKEYLEVEL, GLACCSORTKEY" & vbCrLf
      sSql = sSql & "   FROM EsReportIncStatement ORDER BY SortKeyRev --GLTOPMASTER, GLACCSORTKEY desc, SortKeyLevel" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "End"
      
      ExecuteScript False, sSql
      
      
      If StoreProcedureExists("RptAcctBalanceSheet") Then
         sSql = "DROP PROCEDURE RptAcctBalanceSheet"
         ExecuteScript False, sSql
      End If
      
      sSql = "CREATE PROCEDURE [dbo].[RptAcctBalanceSheet]" & vbCrLf
      sSql = sSql & "   @StartDate as varchar(12),@EndDate as varchar(12)," & vbCrLf
      sSql = sSql & "   @InclInAcct as varchar(1)AS" & vbCrLf
      sSql = sSql & "BEGIN " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   declare @glAcctRef as varchar(10)" & vbCrLf
      sSql = sSql & "   declare @glMsAcct as varchar(10)" & vbCrLf
      sSql = sSql & "   declare @SumCurBal decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @SumPrevBal as decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @level as integer" & vbCrLf
      sSql = sSql & "   declare @TopLevelDesc as varchar(30)" & vbCrLf
      sSql = sSql & "   declare @TopLevAcct as varchar(20)" & vbCrLf
      sSql = sSql & "   declare @PrevMaster as varchar(10)" & vbCrLf
      sSql = sSql & "   declare @RowCount as integer" & vbCrLf
      sSql = sSql & "   declare @GlMasterAcc as varchar(10)" & vbCrLf
      sSql = sSql & "   declare @GlChildAcct as varchar(10)" & vbCrLf
      sSql = sSql & "   declare @ChildKey as varchar(1024)" & vbCrLf
      sSql = sSql & "   declare @GLSortKey as varchar(1024)" & vbCrLf
      sSql = sSql & "   declare @SortKey as varchar(1024)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   DELETE FROM EsReportBalanceSheet" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   if (@InclInAcct = '1')" & vbCrLf
      sSql = sSql & "      SET @InclInAcct = ''" & vbCrLf
      sSql = sSql & "   Else" & vbCrLf
      sSql = sSql & "      SET @InclInAcct = '0'" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   DECLARE balAcctStruc CURSOR  FOR" & vbCrLf
      sSql = sSql & "      SELECT '1', COASSTACCT, COASSTDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      Union All" & vbCrLf
      sSql = sSql & "      SELECT '2', COLIABACCT, COLIABDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      Union All" & vbCrLf
      sSql = sSql & "      SELECT '3', COEQTYACCT, COEQTYDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   OPEN balAcctStruc" & vbCrLf
      sSql = sSql & "   FETCH NEXT FROM balAcctStruc INTO @level, @TopLevAcct, @TopLevelDesc" & vbCrLf
      sSql = sSql & "   WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "   BEGIN " & vbCrLf
      sSql = sSql & "      IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "      BEGIN " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "         With cte" & vbCrLf
      sSql = sSql & "         as" & vbCrLf
      sSql = sSql & "         (select GLACCTREF, GLDESCR, GLMASTER, GLFSLEVEL, 0 as level," & vbCrLf
      sSql = sSql & "            cast(cast(@level as varchar(4))+ char(36)+ GLACCTREF as varchar(max)) as SortKey" & vbCrLf
      sSql = sSql & "         From GlacTable" & vbCrLf
      sSql = sSql & "         where GLMASTER = cast(@TopLevAcct as varchar(20)) AND GLINACTIVE LIKE @InclInAcct" & vbCrLf
      sSql = sSql & "         Union All" & vbCrLf
      sSql = sSql & "         select a.GLACCTREF, a.GLDESCR, a.GLMASTER, a.GLFSLEVEL, level + 1," & vbCrLf
      sSql = sSql & "          cast(COALESCE(SortKey,'') + char(36) + COALESCE(a.GLACCTREF,'') as varchar(max))as SortKey" & vbCrLf
      sSql = sSql & "         From cte" & vbCrLf
      sSql = sSql & "            inner join GlacTable a" & vbCrLf
      sSql = sSql & "               on cte.GLACCTREF = a.GLMASTER" & vbCrLf
      sSql = sSql & "            WHERE GLINACTIVE LIKE @InclInAcct" & vbCrLf
      sSql = sSql & "         )" & vbCrLf
      sSql = sSql & "         INSERT INTO EsReportBalanceSheet (GLTOPMaster, GLTOPMASTERDESC, GLACCTREF, GLDESCR, GLMASTER, GLFSLEVEL,SORTKEYLEVEL,GLACCSORTKEY)" & vbCrLf
      sSql = sSql & "         select @level, @TopLevelDesc," & vbCrLf
      sSql = sSql & "         GLACCTREF , GLDESCR, GLMASTER, GLFSLEVEL, Level, SortKey" & vbCrLf
      sSql = sSql & "         from cte order by SortKey" & vbCrLf
      sSql = sSql & "         " & vbCrLf
      sSql = sSql & "      End" & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM balAcctStruc INTO @level, @TopLevAcct, @TopLevelDesc" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "   Close balAcctStruc" & vbCrLf
      sSql = sSql & "   DEALLOCATE balAcctStruc" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   UPDATE EsReportBalanceSheet SET CurrentBal = foo.Balance--, SUMCURBAL = foo.Balance" & vbCrLf
      sSql = sSql & "   From" & vbCrLf
      sSql = sSql & "       (SELECT SUM(GjitTable.JIDEB) - SUM(GjitTable.JICRD) as Balance, JIACCOUNT" & vbCrLf
      sSql = sSql & "         FROM GjhdTable INNER JOIN GjitTable ON GJNAME = JINAME" & vbCrLf
      sSql = sSql & "      WHERE GJPOST BETWEEN @StartDate AND @EndDate" & vbCrLf
      sSql = sSql & "         AND GjhdTable.GJPOSTED = 1" & vbCrLf
      sSql = sSql & "      GROUP BY JIACCOUNT) as foo" & vbCrLf
      sSql = sSql & "   Where foo.JIACCOUNT = GLACCTREF" & vbCrLf
      sSql = sSql & "  " & vbCrLf
      sSql = sSql & " UPDATE EsReportBalanceSheet SET PreviousBal = foo.Balance--, SUMPREVBAL = foo.Balance" & vbCrLf
      sSql = sSql & "   From" & vbCrLf
      sSql = sSql & "      (SELECT JIACCOUNT,SUM(GjitTable.JIDEB) - SUM(GjitTable.JICRD) AS Balance" & vbCrLf
      sSql = sSql & "         FROM GjhdTable INNER JOIN GjitTable ON GJNAME = JINAME" & vbCrLf
      sSql = sSql & "      WHERE (GJPOST  <  @StartDate)" & vbCrLf
      sSql = sSql & "         AND GjhdTable.GJPOSTED = 1" & vbCrLf
      sSql = sSql & "      GROUP BY JIACCOUNT) as foo" & vbCrLf
      sSql = sSql & "   Where foo.JIACCOUNT = GLACCTREF" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   set @level = 9" & vbCrLf
      sSql = sSql & "   WHILE (@level >= 1 )" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "      DECLARE curAcctStruc CURSOR  FOR" & vbCrLf
      sSql = sSql & "      SELECT GLMASTER, SUM(ISNULL(SUMCURBAL,0) + (ISNULL(CurrentBal,0))) ," & vbCrLf
      sSql = sSql & "         Sum (IsNull(SUMPREVBAL, 0) + (IsNull(PreviousBal, 0)))" & vbCrLf
      sSql = sSql & "      From" & vbCrLf
      sSql = sSql & "         (SELECT DISTINCT GLACCTREF, GLDESCR, GLMASTER," & vbCrLf
      sSql = sSql & "         CurrentBal , PreviousBal, SUMCURBAL, SUMPREVBAL" & vbCrLf
      sSql = sSql & "         FROM EsReportBalanceSheet WHERE GLFSLEVEL = @level) as foo" & vbCrLf
      sSql = sSql & "      group by GLMASTER" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "      OPEN curAcctStruc" & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM curAcctStruc INTO @glMsAcct, @SumCurBal, @SumPrevBal" & vbCrLf
      sSql = sSql & "      WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "      BEGIN" & vbCrLf
      sSql = sSql & "         IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "         BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "           UPDATE EsReportBalanceSheet SET SUMCURBAL = (ISNULL(SUMCURBAL, 0) + @SumCurBal)," & vbCrLf
      sSql = sSql & "               SUMPREVBAL = (ISNULL(SUMPREVBAL, 0) + @SumPrevBal), GLDESCR = 'TOTAL '+ LTRIM(GLDESCR)," & vbCrLf
      sSql = sSql & "            HASCHILD = 1" & vbCrLf
      sSql = sSql & "            WHERE GLACCTREF = @glMsAcct" & vbCrLf
      sSql = sSql & "         End" & vbCrLf
      sSql = sSql & "         FETCH NEXT FROM curAcctStruc INTO @glMsAcct, @SumCurBal, @SumPrevBal" & vbCrLf
      sSql = sSql & "      End" & vbCrLf
      sSql = sSql & "            " & vbCrLf
      sSql = sSql & "      Close curAcctStruc" & vbCrLf
      sSql = sSql & "      DEALLOCATE curAcctStruc" & vbCrLf
      sSql = sSql & "      " & vbCrLf
      sSql = sSql & "      SET @level = @level - 1" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   UPDATE EsReportBalanceSheet SET SUMCURBAL = CurrentBal WHERE SUMCURBAL IS NULL" & vbCrLf
      sSql = sSql & "   UPDATE EsReportBalanceSheet SET SUMPREVBAL = PreviousBal WHERE SUMPREVBAL IS NULL" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   set @level = 0" & vbCrLf
      sSql = sSql & "   set @RowCount = 1" & vbCrLf
      sSql = sSql & "   SET @PrevMaster = ''" & vbCrLf
      sSql = sSql & "   DECLARE curAcctStruc CURSOR  FOR" & vbCrLf
      sSql = sSql & "      SELECT GLMASTER, GLACCSORTKEY" & vbCrLf
      sSql = sSql & "      From EsReportBalanceSheet" & vbCrLf
      sSql = sSql & "         WHERE HASCHILD IS NULL --GLFSLEVEL = 8 --AND GLMASTER ='AA10'--GLTOPMaster = 1 AND" & vbCrLf
      sSql = sSql & "      ORDER BY GLACCSORTKEY" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   OPEN curAcctStruc" & vbCrLf
      sSql = sSql & "   FETCH NEXT FROM curAcctStruc INTO @GlMasterAcc, @GLSortKey" & vbCrLf
      sSql = sSql & "   WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "    IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "    BEGIN" & vbCrLf
      sSql = sSql & "      if (@PrevMaster <> @GlMasterAcc)" & vbCrLf
      sSql = sSql & "      BEGIN" & vbCrLf
      sSql = sSql & "         UPDATE EsReportBalanceSheet SET" & vbCrLf
      sSql = sSql & "            SortKeyRev = RIGHT ('0000'+ Cast(@RowCount as varchar), 4) + char(36)+ @GlMasterAcc" & vbCrLf
      sSql = sSql & "         WHERE GLMASTER = @GlMasterAcc AND HASCHILD IS NULL --GLFSLEVEL = 8 --AND GLTOPMaster = 1" & vbCrLf
      sSql = sSql & "         SET @RowCount = @RowCount + 1" & vbCrLf
      sSql = sSql & "         SET @PrevMaster = @GlMasterAcc" & vbCrLf
      sSql = sSql & "      End" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "    End" & vbCrLf
      sSql = sSql & "    FETCH NEXT FROM curAcctStruc INTO @GlMasterAcc, @GLSortKey" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "       " & vbCrLf
      sSql = sSql & "   Close curAcctStruc" & vbCrLf
      sSql = sSql & "   DEALLOCATE curAcctStruc" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   set @level = 7" & vbCrLf
      sSql = sSql & "   WHILE (@level >= 1 )" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "      SET @PrevMaster = ''" & vbCrLf
      sSql = sSql & "        DECLARE curAcctStruc1 CURSOR  FOR" & vbCrLf
      sSql = sSql & "         SELECT DISTINCT GLACCTREF, GLMASTER, GLACCSORTKEY" & vbCrLf
      sSql = sSql & "         From EsReportBalanceSheet" & vbCrLf
      sSql = sSql & "            WHERE GLFSLEVEL = @level AND HASCHILD IS NOT NULL--GLTOPMaster = 1 AND" & vbCrLf
      sSql = sSql & "         order by GLACCSORTKEY" & vbCrLf
      sSql = sSql & "    " & vbCrLf
      sSql = sSql & "        OPEN curAcctStruc1" & vbCrLf
      sSql = sSql & "        FETCH NEXT FROM curAcctStruc1 INTO @GlChildAcct, @GlMasterAcc, @GLSortKey" & vbCrLf
      sSql = sSql & "        WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "        BEGIN" & vbCrLf
      sSql = sSql & "          IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "          BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "            if (@PrevMaster <> @GlChildAcct)" & vbCrLf
      sSql = sSql & "            BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   --Print 'Record' + @GlChildAcct + ':' + @GlMasterAcc" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "               SELECT TOP 1 @ChildKey = SortKeyRev,@SortKey = GLACCSORTKEY" & vbCrLf
      sSql = sSql & "               From EsReportBalanceSheet" & vbCrLf
      sSql = sSql & "                  WHERE GLFSLEVEL > @level AND GLMASTER = @GlChildAcct --GLTOPMaster = 1 AND" & vbCrLf
      sSql = sSql & "               order by GLACCSORTKEY desc" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "               UPDATE EsReportBalanceSheet SET" & vbCrLf
      sSql = sSql & "                  SortKeyRev = Cast(@ChildKey as varchar(512)) + char(36)+ @GlMasterAcc" & vbCrLf
      sSql = sSql & "   --          select * from EsReportBalanceSheet" & vbCrLf
      sSql = sSql & "               WHERE GLACCTREF = @GlChildAcct AND GLMASTER = @GlMasterAcc" & vbCrLf
      sSql = sSql & "                  AND GLFSLEVEL = @level --GLTOPMaster = 1 AND" & vbCrLf
      sSql = sSql & "               SET @PrevMaster = @GlChildAcct" & vbCrLf
      sSql = sSql & "            End" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "          End" & vbCrLf
      sSql = sSql & "          FETCH NEXT FROM curAcctStruc1 INTO @GlChildAcct, @GlMasterAcc, @GLSortKey" & vbCrLf
      sSql = sSql & "        End" & vbCrLf
      sSql = sSql & "               " & vbCrLf
      sSql = sSql & "        Close curAcctStruc1" & vbCrLf
      sSql = sSql & "        DEALLOCATE curAcctStruc1" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "        SET @level = @level - 1" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   SELECT GLTOPMaster, GLTOPMASTERDESC, GLACCTREF, GLACCTNO, GLDESCR, GLMASTER, GLTYPE,GLINACTIVE, GLFSLEVEL," & vbCrLf
      sSql = sSql & "      SUMCURBAL , CurrentBal, SUMPREVBAL, PreviousBal, SORTKEYLEVEL, GLACCSORTKEY, SortKeyRev,HASCHILD" & vbCrLf
      sSql = sSql & "   FROM EsReportBalanceSheet ORDER BY SortKeyRev --GLTOPMASTER, GLACCSORTKEY," & vbCrLf
      sSql = sSql & "End"
      
      ExecuteScript False, sSql
      
      If TableExists("viewCGSReport") Then
         sSql = "DROP VIEW viewCGSReport"
         ExecuteScript False, sSql
      End If
      
      sSql = "CREATE VIEW [dbo].[viewCGSReport] " & vbCrLf
      sSql = sSql & "AS" & vbCrLf
      sSql = sSql & "SELECT     TOP (100) PERCENT CihdTable.INVNO, CihdTable.INVPRE, CihdTable.INVTYPE, CihdTable.INVTOTAL, CihdTable.INVDATE, CihdTable.INVCUST, " & vbCrLf
      sSql = sSql & "                      CihdTable.INVCANCELED, SoitTable.ITNUMBER, SoitTable.ITREV, SoitTable.ITQTY, SoitTable.ITACTUAL, SoitTable.ITPSNUMBER, SoitTable.ITPSITEM, " & vbCrLf
      sSql = sSql & "                      SoitTable.ITCANCELED, InvaTable.INTYPE, InvaTable.INADATE, InvaTable.INAQTY, InvaTable.INTOTMATL, InvaTable.INTOTLABOR, " & vbCrLf
      sSql = sSql & "                      InvaTable.INTOTEXP, InvaTable.INTOTOH, InvaTable.INPSNUMBER, InvaTable.INPSITEM, PartTable.PARTNUM, PartTable.PALEVEL, " & vbCrLf
      sSql = sSql & "                      PartTable.PAUNITS, PartTable.PALOTTRACK, PartTable.PAUSEACTUALCOST, SohdTable.SONUMBER, SohdTable.SOTYPE, PsitTable.PIQTY, " & vbCrLf
      sSql = sSql & "                      PshdTable.PSCANCELED, dbo.LoitTable.LOINUMBER, dbo.LoitTable.LOIRECORD, dbo.LoitTable.LOITYPE, dbo.LoitTable.LOIPARTREF, " & vbCrLf
      sSql = sSql & "                      dbo.LoitTable.LOIQUANTITY, dbo.LoitTable.LOIPSNUMBER, dbo.LoitTable.LOIPSITEM, dbo.LohdTable.LOTUSERLOTID, " & vbCrLf
      sSql = sSql & "                      dbo.LohdTable.LOTORIGINALQTY, dbo.LohdTable.LOTDATECOSTED, dbo.LohdTable.LOTPO, dbo.LohdTable.LOTMOPARTREF, " & vbCrLf
      sSql = sSql & "                      dbo.LohdTable.LOTMORUNNO, dbo.LohdTable.LOTTOTMATL, dbo.LohdTable.LOTTOTLABOR, dbo.LohdTable.LOTTOTEXP, dbo.LohdTable.LOTTOTOH, " & vbCrLf
      sSql = sSql & "                      dbo.PoitTable.PITYPE, dbo.RunsTable.RUNSTATUS, InvaTable.INCREDITACCT, InvaTable.INDEBITACCT, InvaTable.INDRLABACCT, " & vbCrLf
      sSql = sSql & "                      InvaTable.INDRMATACCT, InvaTable.INDREXPACCT, InvaTable.INDROHDACCT, InvaTable.INCRLABACCT, InvaTable.INCRMATACCT, " & vbCrLf
      sSql = sSql & "                      InvaTable.INCREXPACCT, InvaTable.INCROHDACCT, InvaTable.INAMT, dbo.LohdTable.LOTUNITCOST" & vbCrLf
      sSql = sSql & "FROM         dbo.CihdTable AS CihdTable INNER JOIN" & vbCrLf
      sSql = sSql & "                      dbo.SoitTable AS SoitTable ON CihdTable.INVNO = SoitTable.ITINVOICE INNER JOIN" & vbCrLf
      sSql = sSql & "                      dbo.PartTable AS PartTable ON SoitTable.ITPART = PartTable.PARTREF INNER JOIN" & vbCrLf
      sSql = sSql & "                      dbo.SohdTable AS SohdTable ON SoitTable.ITSO = SohdTable.SONUMBER INNER JOIN" & vbCrLf
      sSql = sSql & "                      dbo.InvaTable AS InvaTable ON SoitTable.ITSO = InvaTable.INSONUMBER AND SoitTable.ITNUMBER = InvaTable.INSOITEM AND " & vbCrLf
      sSql = sSql & "                      SoitTable.ITREV = InvaTable.INSOREV LEFT OUTER JOIN" & vbCrLf
      sSql = sSql & "                      dbo.PsitTable AS PsitTable ON InvaTable.INPSNUMBER = PsitTable.PIPACKSLIP AND InvaTable.INPSITEM = PsitTable.PIITNO AND " & vbCrLf
      sSql = sSql & "                      InvaTable.INPART = PsitTable.PIPART AND InvaTable.INSONUMBER = PsitTable.PISONUMBER AND InvaTable.INSOITEM = PsitTable.PISOITEM AND " & vbCrLf
      sSql = sSql & "                      InvaTable.INSOREV = PsitTable.PISOREV INNER JOIN" & vbCrLf
      sSql = sSql & "                      dbo.PshdTable AS PshdTable ON PsitTable.PIPACKSLIP = PshdTable.PSNUMBER INNER JOIN" & vbCrLf
      sSql = sSql & "                      dbo.LohdTable ON PartTable.PARTREF = dbo.LohdTable.LOTPARTREF LEFT OUTER JOIN" & vbCrLf
      sSql = sSql & "                      dbo.PoitTable ON dbo.LohdTable.LOTPOITEMREV = dbo.PoitTable.PIREV AND dbo.LohdTable.LOTPOITEM = dbo.PoitTable.PIITEM AND " & vbCrLf
      sSql = sSql & "                      dbo.LohdTable.LOTPO = dbo.PoitTable.PINUMBER LEFT OUTER JOIN" & vbCrLf
      sSql = sSql & "                      dbo.RunsTable ON dbo.LohdTable.LOTMOPARTREF = dbo.RunsTable.RUNREF AND " & vbCrLf
      sSql = sSql & "                      dbo.LohdTable.LOTMORUNNO = dbo.RunsTable.RUNNO LEFT OUTER JOIN" & vbCrLf
      sSql = sSql & "                      dbo.LoitTable ON dbo.LohdTable.LOTNUMBER = dbo.LoitTable.LOINUMBER AND PsitTable.PIITNO = dbo.LoitTable.LOIPSITEM AND " & vbCrLf
      sSql = sSql & "                      PsitTable.PIPACKSLIP = dbo.LoitTable.LOIPSNUMBER" & vbCrLf
      sSql = sSql & "WHERE     (InvaTable.INTYPE = 4 OR" & vbCrLf
      sSql = sSql & "                      InvaTable.INTYPE = 3 OR" & vbCrLf
      sSql = sSql & "                      InvaTable.INTYPE = 26 OR" & vbCrLf
      sSql = sSql & "                      InvaTable.INTYPE = 25 OR" & vbCrLf
      sSql = sSql & "                      InvaTable.INTYPE = 24) AND (PshdTable.PSCANCELED = 0) AND (CihdTable.INVCANCELED = 0) AND (SoitTable.ITCANCELED = 0) AND " & vbCrLf
      sSql = sSql & "                      (dbo.LoitTable.LOITYPE = 33 OR" & vbCrLf
      sSql = sSql & "                      dbo.LoitTable.LOITYPE = 25) AND (PshdTable.PSCANCELED <> 1)" & vbCrLf
      sSql = sSql & "ORDER BY CihdTable.INVNO"
      
      ExecuteScript False, sSql


      sSql = "ALTER VIEW [dbo].[Vw_Sales]" & vbCrLf
      sSql = sSql & "AS" & vbCrLf
      sSql = sSql & "SELECT DISTINCT" & vbCrLf
      sSql = sSql & "                      TOP (100) PERCENT dbo.CihdTable.INVCANCELED, dbo.CihdTable.INVTYPE, dbo.CihdTable.INVPRE, dbo.CihdTable.INVNO, " & vbCrLf
      sSql = sSql & "                      dbo.LoitTable.LOICUSTINVNO, dbo.CihdTable.INVCUST, dbo.CustTable.CUNUMBER, dbo.CustTable.CUNAME, dbo.CihdTable.INVDATE, " & vbCrLf
      sSql = sSql & "                      dbo.CihdTable.INVPIF, dbo.PshdTable.PSCANCELED, dbo.PshdTable.PSTYPE, dbo.PsitTable.PIPACKSLIP, dbo.PsitTable.PIITNO, " & vbCrLf
      sSql = sSql & "                      dbo.InvaTable.INPSNUMBER, dbo.InvaTable.INPSITEM, dbo.LoitTable.LOIPSNUMBER, dbo.LoitTable.LOIPSITEM, dbo.SoitTable.ITPSSHIPPED, " & vbCrLf
      sSql = sSql & "                      dbo.SohdTable.SOSALESMAN AS PSSoSalesman, SohdTable_1.SOSALESMAN AS SOSoSlsmn, dbo.SohdTable.SOPO AS PSSoPo, " & vbCrLf
      sSql = sSql & "                      SohdTable_1.SOPO AS SOSoPo, dbo.SohdTable.SODIVISION AS PSSoDiv, SohdTable_1.SODIVISION AS SOSoDiv, " & vbCrLf
      sSql = sSql & "                      dbo.SohdTable.SOREGION AS PSSoReg, SohdTable_1.SOREGION AS SOSoReg, dbo.SohdTable.SOBUSUNIT AS PSSoBu, " & vbCrLf
      sSql = sSql & "                      SohdTable_1.SOBUSUNIT AS SOSoBu, dbo.SprsTable.SPLAST AS PSSlsmnLast, SprsTable_1.SPLAST AS SOSlsmnLast, " & vbCrLf
      sSql = sSql & "                      dbo.SprsTable.SPFIRST AS PSSlsmnFirst, SprsTable_1.SPFIRST AS SOSlsmnFirst, dbo.SprsTable.SPMIDD AS PSSlsmnInit, " & vbCrLf
      sSql = sSql & "                      SprsTable_1.SPMIDD AS SOSlsmnInit, dbo.SohdTable.SOTYPE AS SOSoType, SohdTable_1.SOTYPE AS PSSoType, dbo.SoitTable.ITSO, " & vbCrLf
      sSql = sSql & "                      dbo.SoitTable.ITNUMBER, dbo.SoitTable.ITREV, dbo.SoitTable.ITPART, dbo.PartTable.PARTNUM, dbo.PartTable.PADESC, dbo.PartTable.PALEVEL, " & vbCrLf
      sSql = sSql & "                      dbo.PartTable.PALOTTRACK, dbo.PartTable.PAUSEACTUALCOST, dbo.PartTable.PAUNITS, dbo.PartTable.PAMAKEBUY, dbo.PartTable.PAFAMILY, " & vbCrLf
      sSql = sSql & "                      dbo.PartTable.PAPRODCODE, dbo.PcodTable.PCDESC, dbo.PartTable.PACLASS, dbo.PclsTable.CCDESC, dbo.SoitTable.ITQTY, " & vbCrLf
      sSql = sSql & "                      dbo.SoitTable.ITDOLLARS, dbo.SoitTable.ITADJUST, dbo.SoitTable.ITDISCAMOUNT, dbo.SoitTable.ITCOMMISSION, dbo.SoitTable.ITBOOKDATE, " & vbCrLf
      sSql = sSql & "                      dbo.SoitTable.ITSCHED, dbo.SoitTable.ITACTUAL, dbo.SoitTable.ITCANCELDATE, dbo.SoitTable.ITCANCELED, dbo.SoitTable.ITREVACCT, " & vbCrLf
      sSql = sSql & "                      dbo.GlacTable.GLACCTNO AS RevAcct, dbo.GlacTable.GLDESCR AS RevAcctDesc, dbo.SoitTable.ITCGSACCT, dbo.SoitTable.ITDISACCT, " & vbCrLf
      sSql = sSql & "                      dbo.SoitTable.ITSTATE, dbo.SoitTable.ITTAXCODE, dbo.InvaTable.INTYPE, dbo.InvaTable.INAQTY, dbo.InvaTable.INAMT, dbo.InvaTable.INTOTLABOR, " & vbCrLf
      sSql = sSql & "                      dbo.InvaTable.INTOTMATL, dbo.InvaTable.INTOTEXP, dbo.InvaTable.INTOTOH, dbo.PartTable.PASTDCOST, dbo.PartTable.PATOTCOST, " & vbCrLf
      sSql = sSql & "                      dbo.PartTable.PATOTLABOR, dbo.PartTable.PATOTMATL, dbo.PartTable.PATOTEXP, dbo.PartTable.PATOTOH, dbo.InvaTable.INDRLABACCT, " & vbCrLf
      sSql = sSql & "                      dbo.InvaTable.INDRMATACCT, dbo.InvaTable.INDREXPACCT, dbo.InvaTable.INDROHDACCT, dbo.InvaTable.INCRLABACCT, " & vbCrLf
      sSql = sSql & "                      dbo.InvaTable.INCRMATACCT, dbo.InvaTable.INCREXPACCT, dbo.InvaTable.INCROHDACCT, dbo.LoitTable.LOITYPE, dbo.LoitTable.LOINUMBER, " & vbCrLf
      sSql = sSql & "                      dbo.LoitTable.LOIRECORD, dbo.LoitTable.LOIQUANTITY, dbo.LoitTable.LOIADATE, dbo.LohdTable.LOTNUMBER, dbo.LohdTable.LOTUSERLOTID, " & vbCrLf
      sSql = sSql & "                      dbo.LohdTable.LOTPARTREF, dbo.LohdTable.LOTDATECOSTED, dbo.LohdTable.LOTTOTLABOR, dbo.LohdTable.LOTTOTMATL, " & vbCrLf
      sSql = sSql & "                      dbo.LohdTable.LOTTOTEXP, dbo.LohdTable.LOTTOTOH, dbo.LohdTable.LOTUNITCOST, dbo.LoitTable.LOIACTIVITY" & vbCrLf
      sSql = sSql & "FROM         dbo.GlacTable RIGHT OUTER JOIN" & vbCrLf
      sSql = sSql & "                      dbo.SprsTable RIGHT OUTER JOIN" & vbCrLf
      sSql = sSql & "                      dbo.SoitTable LEFT OUTER JOIN" & vbCrLf
      sSql = sSql & "                      dbo.SohdTable ON dbo.SoitTable.ITSO = dbo.SohdTable.SONUMBER ON " & vbCrLf
      sSql = sSql & "                      dbo.SprsTable.SPNUMBER = dbo.SohdTable.SOSALESMAN RIGHT OUTER JOIN" & vbCrLf
      sSql = sSql & "                      dbo.CustTable RIGHT OUTER JOIN" & vbCrLf
      sSql = sSql & "                      dbo.CihdTable ON dbo.CustTable.CUREF = dbo.CihdTable.INVCUST ON dbo.SoitTable.ITINVOICE = dbo.CihdTable.INVNO LEFT OUTER JOIN" & vbCrLf
      sSql = sSql & "                      dbo.SprsTable AS SprsTable_1 RIGHT OUTER JOIN" & vbCrLf
      sSql = sSql & "                      dbo.SohdTable AS SohdTable_1 ON SprsTable_1.SPNUMBER = SohdTable_1.SOSALESMAN ON " & vbCrLf
      sSql = sSql & "                      dbo.CihdTable.INVSO = SohdTable_1.SONUMBER LEFT OUTER JOIN" & vbCrLf
      sSql = sSql & "                      dbo.PcodTable RIGHT OUTER JOIN" & vbCrLf
      sSql = sSql & "                      dbo.PclsTable RIGHT OUTER JOIN" & vbCrLf
      sSql = sSql & "                      dbo.PartTable ON dbo.PclsTable.CCREF = dbo.PartTable.PACLASS ON dbo.PcodTable.PCREF = dbo.PartTable.PAPRODCODE ON " & vbCrLf
      sSql = sSql & "                      dbo.SoitTable.ITPART = dbo.PartTable.PARTREF ON dbo.GlacTable.GLACCTREF = dbo.SoitTable.ITREVACCT LEFT OUTER JOIN" & vbCrLf
      sSql = sSql & "                      dbo.PshdTable RIGHT OUTER JOIN" & vbCrLf
      sSql = sSql & "                      dbo.PsitTable ON dbo.PshdTable.PSNUMBER = dbo.PsitTable.PIPACKSLIP LEFT OUTER JOIN" & vbCrLf
      sSql = sSql & "                      dbo.InvaTable LEFT OUTER JOIN" & vbCrLf
      sSql = sSql & "                      dbo.LoitTable INNER JOIN" & vbCrLf
      sSql = sSql & "                      dbo.LohdTable ON dbo.LoitTable.LOINUMBER = dbo.LohdTable.LOTNUMBER ON dbo.InvaTable.INLOTNUMBER = dbo.LoitTable.LOINUMBER AND " & vbCrLf
      sSql = sSql & "                      dbo.InvaTable.INAQTY = dbo.LoitTable.LOIQUANTITY AND dbo.InvaTable.INPSNUMBER = dbo.LoitTable.LOIPSNUMBER AND " & vbCrLf
      sSql = sSql & "                      dbo.InvaTable.INPSITEM = dbo.LoitTable.LOIPSITEM ON dbo.PsitTable.PIPACKSLIP = dbo.InvaTable.INPSNUMBER AND " & vbCrLf
      sSql = sSql & "                      dbo.PsitTable.PIITNO = dbo.InvaTable.INPSITEM ON dbo.SoitTable.ITSO = dbo.PsitTable.PISONUMBER AND " & vbCrLf
      sSql = sSql & "                      dbo.SoitTable.ITNUMBER = dbo.PsitTable.PISOITEM AND dbo.SoitTable.ITREV = dbo.PsitTable.PISOREV" & vbCrLf
      sSql = sSql & "ORDER BY dbo.CihdTable.INVDATE, dbo.CihdTable.INVNO, dbo.InvaTable.INPSNUMBER, dbo.InvaTable.INPSITEM, dbo.SoitTable.ITSO, " & vbCrLf
      sSql = sSql & "                      dbo.SoitTable.ITNUMBER, dbo.SoitTable.ITREV"

      ExecuteScript False, sSql


      ExecuteScript False, "Update Version Set Version = " & newver
   End If
    
End Function

Private Function UpdateDatabase33()
   newver = 107
   If ver < newver Then
   
        sSql = sSql & "ALTER PROCEDURE [dbo].[RptVendorDelPerformance] " & vbCrLf
        sSql = sSql & " @sVendorRef as VARCHAR(10)," & vbCrLf
        sSql = sSql & "@sBeginDate as VARCHAR(10)," & vbCrLf
        sSql = sSql & "@sEndDate as VARCHAR(10)," & vbCrLf
        sSql = sSql & "@iAllowDaysEarly as INTEGER," & vbCrLf
        sSql = sSql & "@iAllowDaysLate as INTEGER," & vbCrLf
        sSql = sSql & "@iUseOriginalShipDate as INTEGER," & vbCrLf
        sSql = sSql & "@iCalcLateBy as INTEGER" & vbCrLf
        sSql = sSql & "AS" & vbCrLf
        sSql = sSql & "BEGIN" & vbCrLf
        sSql = sSql & "-- SET NOCOUNT ON added to prevent extra result sets from" & vbCrLf
        sSql = sSql & "-- interfering with SELECT statements." & vbCrLf
        sSql = sSql & "SET NOCOUNT ON;" & vbCrLf

        sSql = sSql & "IF (UPPER(@sVendorRef) = 'ALL') Or (UPPER(@sVendorRef) = '<ALL>')" & vbCrLf
        sSql = sSql & "  BEGIN" & vbCrLf
        sSql = sSql & "     SET @sVendorRef = ''" & vbCrLf
        sSql = sSql & "  END" & vbCrLf
        sSql = sSql & "  IF (@iAllowDaysEarly > 0)" & vbCrLf
        sSql = sSql & "  BEGIN" & vbCrLf
        sSql = sSql & "     SET @iAllowDaysEarly = @iAllowDaysEarly * -1" & vbCrLf
        sSql = sSql & "  End" & vbCrLf
        sSql = sSql & "  -- Insert statements for procedure here" & vbCrLf
        sSql = sSql & "  SELECT VEREF, VEBNAME, PINUMBER, PIRELEASE, PIITEM, PIREV, PIPART, PARTNUM, PIADATE, PIPDATE, PIPQTY, PIAQTY, PIONDOCKINSPDATE," & vbCrLf
        sSql = sSql & "         PIINSDATE, PIRECEIVED, PIONDOCKINSPECTED, PIODDELDATE, PIPORIGDATE, PIONDOCKQTYACC, PIONDOCKQTYREJ, PIODDELQTY, PIREJECTED, PIWASTE, PIONDOCKQTYWASTE," & vbCrLf
        sSql = sSql & "         PIESTUNIT, ISNULL(INPQTY,0.0000) AS INPQTY, ISNULL(INAQTY,0.0000) AS INAQTY, ISNULL(INAMT,0.0000) AS INAMT, ISNULL(INPOITEM,0) AS INPOITEM," & vbCrLf
        sSql = sSql & "         ISNULL(INPOREV,'') AS INPOREV, ISNULL(INPONUMBER,0) AS INPONUMBER, ISNULL(INPORELEASE,0) AS INPORELEASE, ISNULL(INTYPE,0) AS INTYPE," & vbCrLf
        sSql = sSql & "         CASE WHEN @iCalcLateBy = 0 THEN PIADATE" & vbCrLf
        sSql = sSql & "              WHEN @iCalcLateBy = 1 THEN PIONDOCKINSPDATE" & vbCrLf
        sSql = sSql & "              ELSE PIODDELDATE END AS 'DELIVERYDATE'," & vbCrLf
        sSql = sSql & "         CASE WHEN (ISNULL(PIRECEIVED,'')='') AND (ISNULL(PIINSDATE,'')='') AND (ISNULL(PIODDELDATE,'')='') THEN 'PO'" & vbCrLf
        sSql = sSql & "              WHEN (ISNULL(PIRECEIVED,'')='') AND (ISNULL(PIINSDATE,'')='') THEN 'DEL'" & vbCrLf
        sSql = sSql & "              WHEN (ISNULL(PIRECEIVED,'')='') THEN 'DOCK'" & vbCrLf
        sSql = sSql & "              WHEN PIRECEIVED > '01/01/1900' THEN 'REC' ELSE '' END AS 'STATUS'," & vbCrLf
        sSql = sSql & "         CASE WHEN (@iUseOriginalShipDate=0) AND (ISNULL(PIPORIGDATE,''))='' THEN PIPDATE" & vbCrLf
        sSql = sSql & "              WHEN (@iUseOriginalShipDate=0) THEN PIPORIGDATE" & vbCrLf
        sSql = sSql & "              ELSE PIPDATE END AS 'DUEDATE'" & vbCrLf
        sSql = sSql & "  FROM VndrTable" & vbCrLf
        sSql = sSql & "    INNER JOIN PoitTable ON VEREF=PIVENDOR" & vbCrLf
        sSql = sSql & "    LEFT OUTER JOIN InvaTable ON INPONUMBER=PINUMBER AND INPORELEASE=PIRELEASE AND INPOREV=PIREV AND INPOITEM=PIITEM" & vbCrLf
        sSql = sSql & "    LEFT OUTER JOIN PartTable ON PARTREF=PIPART" & vbCrLf
        sSql = sSql & "  WHERE" & vbCrLf
        sSql = sSql & "    VEREF LIKE @sVendorRef + '%'" & vbCrLf
        sSql = sSql & "    AND" & vbCrLf
        sSql = sSql & "    (CASE WHEN @iCalcLateBy=0 THEN PIADATE WHEN @iCalcLateBy=1 Then PIONDOCKINSPDATE ELSE PIODDELDATE END) BETWEEN DateAdd(day, @iAllowDaysEarly, Cast(@sBeginDate AS DateTime)) AND DateAdd(day, @iAllowDaysLate, Cast(@sEndDate AS DateTime))" & vbCrLf
        sSql = sSql & "  END" & vbCrLf
   
        ExecuteScript False, sSql
   
         ExecuteScript False, "Update Version Set Version = " & newver
   
   End If
End Function

Private Function UpdateDatabase34()
   newver = 108
   If ver < newver Then
   
      If StoreProcedureExists("RptAcctBalanceSheet") Then
         sSql = "DROP PROCEDURE RptAcctBalanceSheet"
         ExecuteScript False, sSql
      End If
      
      sSql = "CREATE PROCEDURE [dbo].[RptAcctBalanceSheet]" & vbCrLf
      sSql = sSql & "   @StartDate as varchar(12),@EndDate as varchar(12)," & vbCrLf
      sSql = sSql & "   @InclInAcct as varchar(1)AS" & vbCrLf
      sSql = sSql & "BEGIN " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   declare @glAcctRef as varchar(10)" & vbCrLf
      sSql = sSql & "   declare @glMsAcct as varchar(10)" & vbCrLf
      sSql = sSql & "   declare @SumCurBal decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @SumPrevBal as decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @level as integer" & vbCrLf
      sSql = sSql & "   declare @TopLevelDesc as varchar(30)" & vbCrLf
      sSql = sSql & "   declare @TopLevAcct as varchar(20)" & vbCrLf
      sSql = sSql & "   declare @PrevMaster as varchar(10)" & vbCrLf
      sSql = sSql & "   declare @RowCount as integer" & vbCrLf
      sSql = sSql & "   declare @GlMasterAcc as varchar(10)" & vbCrLf
      sSql = sSql & "   declare @GlChildAcct as varchar(10)" & vbCrLf
      sSql = sSql & "   declare @ChildKey as varchar(1024)" & vbCrLf
      sSql = sSql & "   declare @GLSortKey as varchar(1024)" & vbCrLf
      sSql = sSql & "   declare @SortKey as varchar(1024)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   DELETE FROM EsReportBalanceSheet" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   if (@InclInAcct = '1')" & vbCrLf
      sSql = sSql & "      SET @InclInAcct = '%'" & vbCrLf
      sSql = sSql & "   Else" & vbCrLf
      sSql = sSql & "      SET @InclInAcct = '0'" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   DECLARE balAcctStruc CURSOR  FOR" & vbCrLf
      sSql = sSql & "      SELECT '1', COASSTACCT, COASSTDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      Union All" & vbCrLf
      sSql = sSql & "      SELECT '2', COLIABACCT, COLIABDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      Union All" & vbCrLf
      sSql = sSql & "      SELECT '3', COEQTYACCT, COEQTYDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   OPEN balAcctStruc" & vbCrLf
      sSql = sSql & "   FETCH NEXT FROM balAcctStruc INTO @level, @TopLevAcct, @TopLevelDesc" & vbCrLf
      sSql = sSql & "   WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "   BEGIN " & vbCrLf
      sSql = sSql & "      IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "      BEGIN " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "         With cte" & vbCrLf
      sSql = sSql & "         as" & vbCrLf
      sSql = sSql & "         (select GLACCTREF, GLDESCR, GLMASTER, GLFSLEVEL, 0 as level," & vbCrLf
      sSql = sSql & "            cast(cast(@level as varchar(4))+ char(36)+ GLACCTREF as varchar(max)) as SortKey" & vbCrLf
      sSql = sSql & "         From GlacTable" & vbCrLf
      sSql = sSql & "         where GLMASTER = cast(@TopLevAcct as varchar(20)) AND GLINACTIVE LIKE @InclInAcct" & vbCrLf
      sSql = sSql & "         Union All" & vbCrLf
      sSql = sSql & "         select a.GLACCTREF, a.GLDESCR, a.GLMASTER, a.GLFSLEVEL, level + 1," & vbCrLf
      sSql = sSql & "          cast(COALESCE(SortKey,'') + char(36) + COALESCE(a.GLACCTREF,'') as varchar(max))as SortKey" & vbCrLf
      sSql = sSql & "         From cte" & vbCrLf
      sSql = sSql & "            inner join GlacTable a" & vbCrLf
      sSql = sSql & "               on cte.GLACCTREF = a.GLMASTER" & vbCrLf
      sSql = sSql & "            WHERE GLINACTIVE LIKE @InclInAcct" & vbCrLf
      sSql = sSql & "         )" & vbCrLf
      sSql = sSql & "         INSERT INTO EsReportBalanceSheet (GLTOPMaster, GLTOPMASTERDESC, GLACCTREF, GLDESCR, GLMASTER, GLFSLEVEL,SORTKEYLEVEL,GLACCSORTKEY)" & vbCrLf
      sSql = sSql & "         select @level, @TopLevelDesc," & vbCrLf
      sSql = sSql & "         GLACCTREF , GLDESCR, GLMASTER, GLFSLEVEL, Level, SortKey" & vbCrLf
      sSql = sSql & "         from cte order by SortKey" & vbCrLf
      sSql = sSql & "         " & vbCrLf
      sSql = sSql & "      End" & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM balAcctStruc INTO @level, @TopLevAcct, @TopLevelDesc" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "   Close balAcctStruc" & vbCrLf
      sSql = sSql & "   DEALLOCATE balAcctStruc" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   UPDATE EsReportBalanceSheet SET CurrentBal = foo.Balance--, SUMCURBAL = foo.Balance" & vbCrLf
      sSql = sSql & "   From" & vbCrLf
      sSql = sSql & "       (SELECT SUM(GjitTable.JIDEB) - SUM(GjitTable.JICRD) as Balance, JIACCOUNT" & vbCrLf
      sSql = sSql & "         FROM GjhdTable INNER JOIN GjitTable ON GJNAME = JINAME" & vbCrLf
      sSql = sSql & "      WHERE GJPOST BETWEEN @StartDate AND @EndDate" & vbCrLf
      sSql = sSql & "         AND GjhdTable.GJPOSTED = 1" & vbCrLf
      sSql = sSql & "      GROUP BY JIACCOUNT) as foo" & vbCrLf
      sSql = sSql & "   Where foo.JIACCOUNT = GLACCTREF" & vbCrLf
      sSql = sSql & "  " & vbCrLf
      sSql = sSql & " UPDATE EsReportBalanceSheet SET PreviousBal = foo.Balance--, SUMPREVBAL = foo.Balance" & vbCrLf
      sSql = sSql & "   From" & vbCrLf
      sSql = sSql & "      (SELECT JIACCOUNT,SUM(GjitTable.JIDEB) - SUM(GjitTable.JICRD) AS Balance" & vbCrLf
      sSql = sSql & "         FROM GjhdTable INNER JOIN GjitTable ON GJNAME = JINAME" & vbCrLf
      sSql = sSql & "      WHERE (GJPOST  <  @StartDate)" & vbCrLf
      sSql = sSql & "         AND GjhdTable.GJPOSTED = 1" & vbCrLf
      sSql = sSql & "      GROUP BY JIACCOUNT) as foo" & vbCrLf
      sSql = sSql & "   Where foo.JIACCOUNT = GLACCTREF" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   set @level = 9" & vbCrLf
      sSql = sSql & "   WHILE (@level >= 1 )" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "      DECLARE curAcctStruc CURSOR  FOR" & vbCrLf
      sSql = sSql & "      SELECT GLMASTER, SUM(ISNULL(SUMCURBAL,0) + (ISNULL(CurrentBal,0))) ," & vbCrLf
      sSql = sSql & "         Sum (IsNull(SUMPREVBAL, 0) + (IsNull(PreviousBal, 0)))" & vbCrLf
      sSql = sSql & "      From" & vbCrLf
      sSql = sSql & "         (SELECT DISTINCT GLACCTREF, GLDESCR, GLMASTER," & vbCrLf
      sSql = sSql & "         CurrentBal , PreviousBal, SUMCURBAL, SUMPREVBAL" & vbCrLf
      sSql = sSql & "         FROM EsReportBalanceSheet WHERE GLFSLEVEL = @level) as foo" & vbCrLf
      sSql = sSql & "      group by GLMASTER" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "      OPEN curAcctStruc" & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM curAcctStruc INTO @glMsAcct, @SumCurBal, @SumPrevBal" & vbCrLf
      sSql = sSql & "      WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "      BEGIN" & vbCrLf
      sSql = sSql & "         IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "         BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "           UPDATE EsReportBalanceSheet SET SUMCURBAL = (ISNULL(SUMCURBAL, 0) + @SumCurBal)," & vbCrLf
      sSql = sSql & "               SUMPREVBAL = (ISNULL(SUMPREVBAL, 0) + @SumPrevBal), GLDESCR = 'TOTAL '+ LTRIM(GLDESCR)," & vbCrLf
      sSql = sSql & "            HASCHILD = 1" & vbCrLf
      sSql = sSql & "            WHERE GLACCTREF = @glMsAcct" & vbCrLf
      sSql = sSql & "         End" & vbCrLf
      sSql = sSql & "         FETCH NEXT FROM curAcctStruc INTO @glMsAcct, @SumCurBal, @SumPrevBal" & vbCrLf
      sSql = sSql & "      End" & vbCrLf
      sSql = sSql & "            " & vbCrLf
      sSql = sSql & "      Close curAcctStruc" & vbCrLf
      sSql = sSql & "      DEALLOCATE curAcctStruc" & vbCrLf
      sSql = sSql & "      " & vbCrLf
      sSql = sSql & "      SET @level = @level - 1" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   UPDATE EsReportBalanceSheet SET SUMCURBAL = CurrentBal WHERE SUMCURBAL IS NULL" & vbCrLf
      sSql = sSql & "   UPDATE EsReportBalanceSheet SET SUMPREVBAL = PreviousBal WHERE SUMPREVBAL IS NULL" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   set @level = 0" & vbCrLf
      sSql = sSql & "   set @RowCount = 1" & vbCrLf
      sSql = sSql & "   SET @PrevMaster = ''" & vbCrLf
      sSql = sSql & "   DECLARE curAcctStruc CURSOR  FOR" & vbCrLf
      sSql = sSql & "      SELECT GLMASTER, GLACCSORTKEY" & vbCrLf
      sSql = sSql & "      From EsReportBalanceSheet" & vbCrLf
      sSql = sSql & "         WHERE HASCHILD IS NULL --GLFSLEVEL = 8 --AND GLMASTER ='AA10'--GLTOPMaster = 1 AND" & vbCrLf
      sSql = sSql & "      ORDER BY GLACCSORTKEY" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   OPEN curAcctStruc" & vbCrLf
      sSql = sSql & "   FETCH NEXT FROM curAcctStruc INTO @GlMasterAcc, @GLSortKey" & vbCrLf
      sSql = sSql & "   WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "    IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "    BEGIN" & vbCrLf
      sSql = sSql & "      if (@PrevMaster <> @GlMasterAcc)" & vbCrLf
      sSql = sSql & "      BEGIN" & vbCrLf
      sSql = sSql & "         UPDATE EsReportBalanceSheet SET" & vbCrLf
      sSql = sSql & "            SortKeyRev = RIGHT ('0000'+ Cast(@RowCount as varchar), 4) + char(36)+ @GlMasterAcc" & vbCrLf
      sSql = sSql & "         WHERE GLMASTER = @GlMasterAcc AND HASCHILD IS NULL --GLFSLEVEL = 8 --AND GLTOPMaster = 1" & vbCrLf
      sSql = sSql & "         SET @RowCount = @RowCount + 1" & vbCrLf
      sSql = sSql & "         SET @PrevMaster = @GlMasterAcc" & vbCrLf
      sSql = sSql & "      End" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "    End" & vbCrLf
      sSql = sSql & "    FETCH NEXT FROM curAcctStruc INTO @GlMasterAcc, @GLSortKey" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "       " & vbCrLf
      sSql = sSql & "   Close curAcctStruc" & vbCrLf
      sSql = sSql & "   DEALLOCATE curAcctStruc" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   set @level = 7" & vbCrLf
      sSql = sSql & "   WHILE (@level >= 1 )" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "      SET @PrevMaster = ''" & vbCrLf
      sSql = sSql & "        DECLARE curAcctStruc1 CURSOR  FOR" & vbCrLf
      sSql = sSql & "         SELECT DISTINCT GLACCTREF, GLMASTER, GLACCSORTKEY" & vbCrLf
      sSql = sSql & "         From EsReportBalanceSheet" & vbCrLf
      sSql = sSql & "            WHERE GLFSLEVEL = @level AND HASCHILD IS NOT NULL--GLTOPMaster = 1 AND" & vbCrLf
      sSql = sSql & "         order by GLACCSORTKEY" & vbCrLf
      sSql = sSql & "    " & vbCrLf
      sSql = sSql & "        OPEN curAcctStruc1" & vbCrLf
      sSql = sSql & "        FETCH NEXT FROM curAcctStruc1 INTO @GlChildAcct, @GlMasterAcc, @GLSortKey" & vbCrLf
      sSql = sSql & "        WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "        BEGIN" & vbCrLf
      sSql = sSql & "          IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "          BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "            if (@PrevMaster <> @GlChildAcct)" & vbCrLf
      sSql = sSql & "            BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   --Print 'Record' + @GlChildAcct + ':' + @GlMasterAcc" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "               SELECT TOP 1 @ChildKey = SortKeyRev,@SortKey = GLACCSORTKEY" & vbCrLf
      sSql = sSql & "               From EsReportBalanceSheet" & vbCrLf
      sSql = sSql & "                  WHERE GLFSLEVEL > @level AND GLMASTER = @GlChildAcct --GLTOPMaster = 1 AND" & vbCrLf
      sSql = sSql & "               order by GLACCSORTKEY desc" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "               UPDATE EsReportBalanceSheet SET" & vbCrLf
      sSql = sSql & "                  SortKeyRev = Cast(@ChildKey as varchar(512)) + char(36)+ @GlMasterAcc" & vbCrLf
      sSql = sSql & "   --          select * from EsReportBalanceSheet" & vbCrLf
      sSql = sSql & "               WHERE GLACCTREF = @GlChildAcct AND GLMASTER = @GlMasterAcc" & vbCrLf
      sSql = sSql & "                  AND GLFSLEVEL = @level --GLTOPMaster = 1 AND" & vbCrLf
      sSql = sSql & "               SET @PrevMaster = @GlChildAcct" & vbCrLf
      sSql = sSql & "            End" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "          End" & vbCrLf
      sSql = sSql & "          FETCH NEXT FROM curAcctStruc1 INTO @GlChildAcct, @GlMasterAcc, @GLSortKey" & vbCrLf
      sSql = sSql & "        End" & vbCrLf
      sSql = sSql & "               " & vbCrLf
      sSql = sSql & "        Close curAcctStruc1" & vbCrLf
      sSql = sSql & "        DEALLOCATE curAcctStruc1" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "        SET @level = @level - 1" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   SELECT GLTOPMaster, GLTOPMASTERDESC, GLACCTREF, GLACCTNO, GLDESCR, GLMASTER, GLTYPE,GLINACTIVE, GLFSLEVEL," & vbCrLf
      sSql = sSql & "      SUMCURBAL , CurrentBal, SUMPREVBAL, PreviousBal, SORTKEYLEVEL, GLACCSORTKEY, SortKeyRev,HASCHILD" & vbCrLf
      sSql = sSql & "   FROM EsReportBalanceSheet ORDER BY SortKeyRev --GLTOPMASTER, GLACCSORTKEY," & vbCrLf
      sSql = sSql & "End"
      
      ExecuteScript False, sSql
   
         ExecuteScript False, "Update Version Set Version = " & newver
   
   End If
End Function

   
Private Function UpdateDatabase35()
   newver = 109
   If ver < newver Then
   
      If ColumnExists("RunsTable", "RUNRTAPPDATE") Then
         
         Dim sConstraintName As String
         sConstraintName = GetConstrinNameforColumn("RunsTable", "RUNRTAPPDATE")
         If sConstraintName <> "" Then ExecuteScript False, "alter table RunsTable drop CONSTRAINT " & sConstraintName
      
         sSql = "alter table RunsTable alter column RUNRTAPPDATE varchar(10)"
         ExecuteScript False, sSql
         
         sSql = "ALTER TABLE RunsTable ADD CONSTRAINT DF_RunsTable_RUNRTAPPDATE DEFAULT ('') FOR RUNRTAPPDATE"
         ExecuteScript False, sSql
      End If
   
      If Not ColumnExists("ComnTable", "COHIDEINACTIVEPART") Then
         sSql = "ALTER TABLE dbo.ComnTable ADD COHIDEINACTIVEPART tinyint NULL, COHIDEOBSOLETEPART tinyint NULL"
         ExecuteScript False, sSql
      End If
   
   
      If ColumnExists("EsReportMrplog", "log_text") Then
         sSql = "ALTER TABLE EsReportMrplog alter column log_text varchar(120)"
         ExecuteScript False, sSql
      End If
      
      ' update the version
      ExecuteScript False, "Update Version Set Version = " & newver
   
   End If
End Function


Private Function UpdateDatabase36()
   newver = 110
   If ver < newver Then
   
      If Not ColumnExists("ComnTable", "COBIVSOFFSETACCT") Then
         sSql = "ALTER TABLE dbo.ComnTable ADD COBIVSOFFSETACCT char(12)"
         ExecuteScript False, sSql
      End If
      
      If Not ColumnExists("ComnTable", "COSETUPTCPOM") Then
         sSql = "ALTER TABLE dbo.ComnTable ADD COSETUPTCPOM int"
         ExecuteScript False, sSql
      End If
      
      
      If Not TableExists("EsRollingIncStat") Then
         sSql = "CREATE TABLE [dbo].[EsRollingIncStat](" & vbCrLf
         sSql = sSql & "   [GLACCTREF] [char](12) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL," & vbCrLf
         sSql = sSql & "   [GLACCTNO] [char](12) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
         sSql = sSql & "   [GLDESCR] [char](100) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
         sSql = sSql & "   [GLMASTER] [char](12) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
         sSql = sSql & "   [GLTYPE] [int] NULL," & vbCrLf
         sSql = sSql & "   [GLINACTIVE] [tinyint] NULL," & vbCrLf
         sSql = sSql & "   [GLFSLEVEL] [tinyint] NULL," & vbCrLf
         sSql = sSql & "   [SUMCURBAL] [decimal](13, 2) NULL," & vbCrLf
         sSql = sSql & "   [CurrentBal] [decimal](13, 2) NULL," & vbCrLf
         sSql = sSql & "   [SUMBAL1] [decimal](13, 2) NULL," & vbCrLf
         sSql = sSql & "   [CURBAL1] [decimal](13, 2) NULL," & vbCrLf
         sSql = sSql & "   [SUMBAL2] [decimal](13, 2) NULL," & vbCrLf
         sSql = sSql & "   [CURBAL2] [decimal](13, 2) NULL," & vbCrLf
         sSql = sSql & "   [SUMBAL3] [decimal](13, 2) NULL," & vbCrLf
         sSql = sSql & "   [CURBAL3] [decimal](13, 2) NULL," & vbCrLf
         sSql = sSql & "   [SUMBAL4] [decimal](13, 2) NULL," & vbCrLf
         sSql = sSql & "   [CURBAL4] [decimal](13, 2) NULL," & vbCrLf
         sSql = sSql & "   [SUMBAL5] [decimal](13, 2) NULL," & vbCrLf
         sSql = sSql & "   [CURBAL5] [decimal](13, 2) NULL," & vbCrLf
         sSql = sSql & "   [SUMBAL6] [decimal](13, 2) NULL," & vbCrLf
         sSql = sSql & "   [CURBAL6] [decimal](13, 2) NULL," & vbCrLf
         sSql = sSql & "   [SUMBAL7] [decimal](13, 2) NULL," & vbCrLf
         sSql = sSql & "   [CURBAL7] [decimal](13, 2) NULL," & vbCrLf
         sSql = sSql & "   [SUMBAL8] [decimal](13, 2) NULL," & vbCrLf
         sSql = sSql & "   [CURBAL8] [decimal](13, 2) NULL," & vbCrLf
         sSql = sSql & "   [SUMBAL9] [decimal](13, 2) NULL," & vbCrLf
         sSql = sSql & "   [CURBAL9] [decimal](13, 2) NULL," & vbCrLf
         sSql = sSql & "   [SUMBAL10] [decimal](13, 2) NULL," & vbCrLf
         sSql = sSql & "   [CURBAL10] [decimal](13, 2) NULL," & vbCrLf
         sSql = sSql & "   [SUMBAL11] [decimal](13, 2) NULL," & vbCrLf
         sSql = sSql & "   [CURBAL11] [decimal](13, 2) NULL," & vbCrLf
         sSql = sSql & "   [SUMYTD] [decimal](13, 2) NULL," & vbCrLf
         sSql = sSql & "   [YTD] [decimal](13, 2) NULL," & vbCrLf
         sSql = sSql & "   [SORTKEYLEVEL] [tinyint] NULL," & vbCrLf
         sSql = sSql & "   [GLACCSORTKEY] [varchar](512) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
         sSql = sSql & "   [GLTOPMaster] [int] NULL," & vbCrLf
         sSql = sSql & "   [GLTOPMASTERDESC] [varchar](30) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
         sSql = sSql & "   [SortKeyRev] [varchar](256) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
         sSql = sSql & "   [HASCHILD] [int] NULL" & vbCrLf
         sSql = sSql & ") ON [PRIMARY]"
         
         ExecuteScript False, sSql
      
      End If
      
      
      If StoreProcedureExists("RptRollingIncStat") Then
         sSql = "DROP PROCEDURE RptRollingIncStat"
         ExecuteScript False, sSql
      End If
         
      sSql = "CREATE PROCEDURE [dbo].[RptRollingIncStat]" & vbCrLf
      sSql = sSql & "   @InStartDate as varchar(12),@InEndDate as varchar(12)," & vbCrLf
      sSql = sSql & "   @CurBeginYearDate as varchar(12), @InclInAcct as varchar(1)" & vbCrLf
      sSql = sSql & "AS " & vbCrLf
      sSql = sSql & "BEGIN" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   declare @CurYear as integer" & vbCrLf
      sSql = sSql & "   declare @CurMonth as integer" & vbCrLf
      sSql = sSql & "   declare @CurRStartDt as datetime" & vbCrLf
      sSql = sSql & "   declare @PrevRStartDt as datetime" & vbCrLf
      sSql = sSql & "   declare @CurREndDt as datetime" & vbCrLf
      sSql = sSql & "   declare @strRStartDt as varchar(24)" & vbCrLf
      sSql = sSql & "   declare @strREndDt as varchar(24)" & vbCrLf
      sSql = sSql & "   declare @strBeginYearDate as varchar(24)" & vbCrLf
      sSql = sSql & "   declare @SQL as varchar(1024)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   declare @Rolling as integer" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   if (@InclInAcct = '1')" & vbCrLf
      sSql = sSql & "     SET @InclInAcct = ''" & vbCrLf
      sSql = sSql & "   Else" & vbCrLf
      sSql = sSql & "     SET @InclInAcct = '0'" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   DELETE from dbo.EsReportIncStatement" & vbCrLf
      sSql = sSql & "   DELETE from dbo.EsRollingIncStat" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   Exec RptIncomeStatement @InStartDate, @InEndDate, @CurBeginYearDate, @InclInAcct" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   INSERT INTO EsRollingIncStat (GLTOPMaster, GLTOPMASTERDESC, GLACCTREF, GLACCTNO, GLDESCR, " & vbCrLf
      sSql = sSql & "      GLMASTER, GLTYPE,GLINACTIVE, GLFSLEVEL," & vbCrLf
      sSql = sSql & "     SUMCURBAL , CurrentBal, SUMYTD, YTD, SORTKEYLEVEL, GLACCSORTKEY)" & vbCrLf
      sSql = sSql & "   SELECT GLTOPMaster, GLTOPMASTERDESC, GLACCTREF, GLACCTNO, GLDESCR, GLMASTER, GLTYPE,GLINACTIVE, GLFSLEVEL," & vbCrLf
      sSql = sSql & "     SUMCURBAL , CurrentBal, SUMYTD, YTD, SORTKEYLEVEL, GLACCSORTKEY" & vbCrLf
      sSql = sSql & "   FROM EsReportIncStatement ORDER BY SortKeyRev --GLTOPMASTER, GLACCSORTKEY desc, SortKeyLevel" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   DELETE from dbo.EsReportIncStatement" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   Set @CurYear = DATEPART(year, @InStartDate)" & vbCrLf
      sSql = sSql & "   SET @CurMonth = DATEPART(month, @InStartDate)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   set @CurRStartDt = DATEADD (month, -1, convert(datetime, convert(varchar(2), @CurMonth)  + '/'+ '1' + '/' + convert(varchar(4), @CurYear), 101))" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   set @Rolling = 1" & vbCrLf
      sSql = sSql & "   WHILE (@Rolling <= 11 )" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "      --// increase a month and then reduce a day to the last day of the cur month" & vbCrLf
      sSql = sSql & "      SET @PrevRStartDt = DATEADD (month, 1, @CurRStartDt)" & vbCrLf
      sSql = sSql & "      SET @CurREndDt = DATEADD (day, -1, @PrevRStartDt)" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "      --// set as the begining year to the current rolling month" & vbCrLf
      sSql = sSql & "      IF (DATEPART(year, @CurBeginYearDate) > DATEPART (year, @CurRStartDt))" & vbCrLf
      sSql = sSql & "         SET @CurBeginYearDate = DATEADD (year, -1, @CurBeginYearDate)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "--print 'YEAR_START' + Convert(varchar(24),@CurBeginYearDate, 101)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "      SET @strRStartDt = CONVERT(varchar(24), @CurRStartDt,101)" & vbCrLf
      sSql = sSql & "      SET @strREndDt = CONVERT(varchar(24), @CurREndDt,101)" & vbCrLf
      sSql = sSql & "      SET @strBeginYearDate = CONVERT(varchar(24), @CurBeginYearDate,101)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "      Exec RptIncomeStatement @strRStartDt, @strREndDt,@strBeginYearDate, @InclInAcct" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "      SET @SQL = 'UPDATE EsRollingIncStat SET SUMBAL' + convert(varchar(2),@Rolling) +" & vbCrLf
      sSql = sSql & "                  '= c.SUMCURBAL, CURBAL' + convert(varchar(2),@Rolling) + " & vbCrLf
      sSql = sSql & "                  ' = c.CurrentBal FROM EsRollingIncStat b, EsReportIncStatement c WHERE b.GLACCTREF = c.GLACCTREF'" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "      Exec(@SQL)" & vbCrLf
      sSql = sSql & "      " & vbCrLf
      sSql = sSql & "      DELETE from dbo.EsReportIncStatement" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "      --// move to the previous month" & vbCrLf
      sSql = sSql & "      SET @CurRStartDt = DATEADD(month, -1, @CurRStartDt)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "      SET @Rolling = @Rolling + 1" & vbCrLf
      sSql = sSql & "   END   " & vbCrLf
      sSql = sSql & "End"
      
      ExecuteScript False, sSql
      
      
      If StoreProcedureExists("BackLogByPartNumber") Then
         sSql = "DROP PROCEDURE BackLogByPartNumber"
         ExecuteScript False, sSql
      End If
         
      sSql = "CREATE PROCEDURE [dbo].[BackLogByPartNumber]" & vbCrLf
      sSql = sSql & " @BegDate as varchar(16), @EndDate as varchar(16), @PartNumber as Varchar(30)," & vbCrLf
      sSql = sSql & " @Customer as varchar(10),@PartClass as Varchar(16),@PartCode as varchar(8)" & vbCrLf
      sSql = sSql & " AS                                               " & vbCrLf
      sSql = sSql & " BEGIN                           " & vbCrLf
      sSql = sSql & " declare @SoType as varchar(1)   " & vbCrLf
      sSql = sSql & " declare @SoText as varchar(6)   " & vbCrLf
      sSql = sSql & " declare @ItSo as int            " & vbCrLf
      sSql = sSql & " declare @ItRev as char(2)       " & vbCrLf
      sSql = sSql & " declare @ItNum as int           " & vbCrLf
      sSql = sSql & " declare @ItQty as decimal(12,4) " & vbCrLf
      sSql = sSql & " declare @PaLotRemQty as decimal(12,4)   " & vbCrLf
      sSql = sSql & " declare @PartRem as decimal(12,4)       " & vbCrLf
      sSql = sSql & " declare @RunningTot as decimal(12,4)    " & vbCrLf
      sSql = sSql & " declare @ItDollars as decimal(12,4)     " & vbCrLf
      sSql = sSql & " declare @ItSched as smalldatetime       " & vbCrLf
      sSql = sSql & " declare @CusName as varchar(10)         " & vbCrLf
      sSql = sSql & " declare @PartNum as varchar(30)         " & vbCrLf
      sSql = sSql & " declare @CurPartNum as varchar(30)      " & vbCrLf
      sSql = sSql & " declare @PartDesc as varchar(30)        " & vbCrLf
      sSql = sSql & " declare @PartLoc as varchar(4)          " & vbCrLf
      sSql = sSql & " declare @PartExDesc as varchar(3072)    " & vbCrLf
      sSql = sSql & " declare @ItCanceled as tinyint          " & vbCrLf
      sSql = sSql & " declare @ItPSNum as varchar(8)          " & vbCrLf
      sSql = sSql & " declare @ItInvoice as int declare @ItPSShipped as tinyint   " & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & " IF (@Customer = 'ALL')                      " & vbCrLf
      sSql = sSql & "   SET @Customer = ''                      " & vbCrLf
      sSql = sSql & " IF (@PartClass = 'ALL')                     " & vbCrLf
      sSql = sSql & "     SET @PartClass = ''                     " & vbCrLf
      sSql = sSql & " IF (@PartCode = 'ALL')                      " & vbCrLf
      sSql = sSql & "    SET @PartCode = ''                      " & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & " --IF (@PartNumber = 'ALL')                      " & vbCrLf
      sSql = sSql & "   -- SET @PartNumber = ''                      " & vbCrLf
      sSql = sSql & "        " & vbCrLf
      sSql = sSql & "     CREATE TABLE #tempBackLogInfo               " & vbCrLf
      sSql = sSql & "                 (SOTYPE varchar(1) NULL,        " & vbCrLf
      sSql = sSql & "                 SOTEXT varchar(6) NULL,         " & vbCrLf
      sSql = sSql & "                 ITSO Int NULL,                  " & vbCrLf
      sSql = sSql & "                ITREV char(2) NULL,              " & vbCrLf
      sSql = sSql & "                 ITNUMBER int NULL,              " & vbCrLf
      sSql = sSql & "                 ITQTY decimal(12,4) NULL,       " & vbCrLf
      sSql = sSql & "                 PALOTQTYREMAINING decimal(12,4) NULL,   " & vbCrLf
      sSql = sSql & "                 RUNQTYTOT decimal(12,4) NULL,   " & vbCrLf
      sSql = sSql & "                 ITDOLLARS decimal(12,4) NULL,   " & vbCrLf
      sSql = sSql & "                 ITSCHED smalldatetime NULL,     " & vbCrLf
      sSql = sSql & "                 CUNICKNAME varchar(10) NULL,    " & vbCrLf
      sSql = sSql & "                 PARTNUM varchar(30) NULL,       " & vbCrLf
      sSql = sSql & "                PADESC varchar(30) NULL,     " & vbCrLf
      sSql = sSql & "                 PAEXTDESC varchar(3072) NULL,   " & vbCrLf
      sSql = sSql & "                 PALOCATION varchar(4) NULL,     " & vbCrLf
      sSql = sSql & "                 ITCANCELED tinyint NULL,        " & vbCrLf
      sSql = sSql & "                 ITPSNUMBER varchar(8) NULL, ITINVOICE int NULL, " & vbCrLf
      sSql = sSql & "                 ITPSSHIPPED tinyint NULL)       " & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   IF (@PartNumber = 'ALL')" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "      DECLARE curbackLog CURSOR   FOR                             " & vbCrLf
      sSql = sSql & "       SELECT SohdTable.SOTYPE, SohdTable.SOTEXT,                  " & vbCrLf
      sSql = sSql & "          SoitTable.ITSO, SoitTable.ITREV, SoitTable.ITNUMBER,    " & vbCrLf
      sSql = sSql & "          SoitTable.ITQTY, PartTable.PALOTQTYREMAINING,           " & vbCrLf
      sSql = sSql & "          SoitTable.ITDOLLARS,SoitTable.ITSCHED, CustTable.CUNICKNAME,    " & vbCrLf
      sSql = sSql & "          PartTable.PARTNUM, PartTable.PADESC, PartTable.PAEXTDESC,       " & vbCrLf
      sSql = sSql & "          PartTable.PALOCATION, SoitTable.ITCANCELED,                     " & vbCrLf
      sSql = sSql & "          SoitTable.ITPSNUMBER , SoitTable.ITINVOICE, SoitTable.ITPSSHIPPED   " & vbCrLf
      sSql = sSql & "       From SohdTable, SoitTable, CustTable, PartTable             " & vbCrLf
      sSql = sSql & "       WHERE SohdTable.SOCUST = CustTable.CUREF AND                " & vbCrLf
      sSql = sSql & "          SohdTable.SONUMBER =SoitTable.ITSO AND                  " & vbCrLf
      sSql = sSql & "          SoitTable.ITPART=PartTable.PARTREF AND                  " & vbCrLf
      sSql = sSql & "          SoitTable.ITCANCELED=0 AND SoitTable.ITPSNUMBER=''      " & vbCrLf
      sSql = sSql & "          AND SoitTable.ITINVOICE=0 AND SoitTable.ITPSSHIPPED=0" & vbCrLf
      sSql = sSql & "           AND CUREF LIKE '%' + @Customer + '%'                    " & vbCrLf
      sSql = sSql & "          AND SoitTable.ITSCHED BETWEEN @BegDate AND @EndDate     " & vbCrLf
      sSql = sSql & "          AND PartTable.PACLASS LIKE '%' + @PartClass + '%'       " & vbCrLf
      sSql = sSql & "          AND PartTable.PAPRODCODE LIKE '%' + @PartCode + '%'     " & vbCrLf
      sSql = sSql & "       ORDER BY partnum, ITSCHED                                   " & vbCrLf
      sSql = sSql & "   END" & vbCrLf
      sSql = sSql & "   ELSE" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "      DECLARE curbackLog CURSOR   FOR                             " & vbCrLf
      sSql = sSql & "       SELECT SohdTable.SOTYPE, SohdTable.SOTEXT,                  " & vbCrLf
      sSql = sSql & "          SoitTable.ITSO, SoitTable.ITREV, SoitTable.ITNUMBER,    " & vbCrLf
      sSql = sSql & "          SoitTable.ITQTY, PartTable.PALOTQTYREMAINING,           " & vbCrLf
      sSql = sSql & "          SoitTable.ITDOLLARS,SoitTable.ITSCHED, CustTable.CUNICKNAME,    " & vbCrLf
      sSql = sSql & "          PartTable.PARTNUM, PartTable.PADESC, PartTable.PAEXTDESC,       " & vbCrLf
      sSql = sSql & "          PartTable.PALOCATION, SoitTable.ITCANCELED,                     " & vbCrLf
      sSql = sSql & "          SoitTable.ITPSNUMBER , SoitTable.ITINVOICE, SoitTable.ITPSSHIPPED   " & vbCrLf
      sSql = sSql & "       From SohdTable, SoitTable, CustTable, PartTable             " & vbCrLf
      sSql = sSql & "       WHERE SohdTable.SOCUST = CustTable.CUREF AND                " & vbCrLf
      sSql = sSql & "          SohdTable.SONUMBER =SoitTable.ITSO AND                  " & vbCrLf
      sSql = sSql & "          SoitTable.ITPART=PartTable.PARTREF AND                  " & vbCrLf
      sSql = sSql & "          SoitTable.ITCANCELED=0 AND SoitTable.ITPSNUMBER=''      " & vbCrLf
      sSql = sSql & "          AND SoitTable.ITINVOICE=0 AND SoitTable.ITPSSHIPPED=0" & vbCrLf
      sSql = sSql & "          AND SoitTable.ITPART = @PartNumber" & vbCrLf
      sSql = sSql & "           AND CUREF LIKE '%' + @Customer + '%'                    " & vbCrLf
      sSql = sSql & "          AND SoitTable.ITSCHED BETWEEN @BegDate AND @EndDate     " & vbCrLf
      sSql = sSql & "          AND PartTable.PACLASS LIKE '%' + @PartClass + '%'       " & vbCrLf
      sSql = sSql & "          AND PartTable.PAPRODCODE LIKE '%' + @PartCode + '%'     " & vbCrLf
      sSql = sSql & "       ORDER BY partnum, ITSCHED                                   " & vbCrLf
      sSql = sSql & "   END" & vbCrLf
      sSql = sSql & "    " & vbCrLf
      sSql = sSql & "    OPEN curbackLog                                                " & vbCrLf
      sSql = sSql & "    FETCH NEXT FROM curbackLog INTO @SoType, @SoText, @ItSo,  @ItRev, @ItNum, @ItQty, @PaLotRemQty, " & vbCrLf
      sSql = sSql & "                     @ItDollars,@ItSched, @CusName, @PartNum,        " & vbCrLf
      sSql = sSql & "                     @PartDesc, @PartExDesc, @PartLoc, @ItCanceled,  " & vbCrLf
      sSql = sSql & "                     @ItPSNum, @ItInvoice, @ItPSShipped              " & vbCrLf
      sSql = sSql & "     SET @CurPartNum = @PartNum                                      " & vbCrLf
      sSql = sSql & "     SET @RunningTot = 0                                             " & vbCrLf
      sSql = sSql & "     WHILE (@@FETCH_STATUS <> -1)                                    " & vbCrLf
      sSql = sSql & "     BEGIN                                                           " & vbCrLf
      sSql = sSql & "         IF (@@FETCH_STATUS <> -2)                                   " & vbCrLf
      sSql = sSql & "         BEGIN                                                       " & vbCrLf
      sSql = sSql & "             IF  @CurPartNum <> @PartNum                             " & vbCrLf
      sSql = sSql & "            BEGIN                                                    " & vbCrLf
      sSql = sSql & "                 SET @RunningTot = @ItQty                            " & vbCrLf
      sSql = sSql & "                 set @CurPartNum = @PartNum                          " & vbCrLf
      sSql = sSql & "             End                                                     " & vbCrLf
      sSql = sSql & "             Else                                                    " & vbCrLf
      sSql = sSql & "             BEGIN                                                   " & vbCrLf
      sSql = sSql & "                 SET @RunningTot = @RunningTot + @ItQty              " & vbCrLf
      sSql = sSql & "             End                                                     " & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "             SET @PartRem = @PaLotRemQty - @RunningTot                       " & vbCrLf
      sSql = sSql & "             INSERT INTO #tempBackLogInfo (SOTYPE, SOTEXT, ITSO, ITREV,      " & vbCrLf
      sSql = sSql & "                 ITNUMBER,ITQTY, PALOTQTYREMAINING,RUNQTYTOT, ITDOLLARS,     " & vbCrLf
      sSql = sSql & "                 ITSCHED,CUNICKNAME, PARTNUM, PADESC,PAEXTDESC,PALOCATION,   " & vbCrLf
      sSql = sSql & "                      ITCANCELED, ITPSNUMBER, ITINVOICE, ITPSSHIPPED)             " & vbCrLf
      sSql = sSql & "             VALUES (@SoType, @SoText, @ItSo, @ItRev,@ItNum, @ItQty,@PaLotRemQty,@PartRem, @ItDollars,@ItSched,@CusName, " & vbCrLf
      sSql = sSql & "                 @PartNum,@PartDesc,@PartExDesc,@PartLoc, @ItCanceled,@ItPSNum,@ItInvoice,@ItPSShipped)  " & vbCrLf
      sSql = sSql & "         End                                                                 " & vbCrLf
      sSql = sSql & "         FETCH NEXT FROM curbackLog INTO @SoType, @SoText, @ItSo,            " & vbCrLf
      sSql = sSql & "             @ItRev, @ItNum, @ItQty, @PaLotRemQty,                           " & vbCrLf
      sSql = sSql & "             @ItDollars,@ItSched, @CusName, @PartNum,                        " & vbCrLf
      sSql = sSql & "             @PartDesc, @PartExDesc, @PartLoc, @ItCanceled,                  " & vbCrLf
      sSql = sSql & "             @ItPSNum, @ItInvoice, @ItPSShipped                              " & vbCrLf
      sSql = sSql & "     End                                                                     " & vbCrLf
      sSql = sSql & "     CLOSE curbackLog   --// close the cursor                                " & vbCrLf
      sSql = sSql & "     DEALLOCATE curbackLog                                                   " & vbCrLf
      sSql = sSql & "     -- select data for the report                                           " & vbCrLf
      sSql = sSql & "     SELECT SOTYPE, SOTEXT, ITSO, ITREV,                                     " & vbCrLf
      sSql = sSql & "         ITNUMBER,ITQTY, PALOTQTYREMAINING,RUNQTYTOT, ITDOLLARS,             " & vbCrLf
      sSql = sSql & "         ITSCHED,CUNICKNAME, PARTNUM, PADESC,PAEXTDESC, PALOCATION,          " & vbCrLf
      sSql = sSql & "         ITCANCELED , ITPSNUMBER, ITINVOICE, ITPSSHIPPED                     " & vbCrLf
      sSql = sSql & "     FROM #tempBackLogInfo                                                   " & vbCrLf
      sSql = sSql & "     ORDER BY ITSCHED                                                        " & vbCrLf
      sSql = sSql & "     -- drop the temp table                                                  " & vbCrLf
      sSql = sSql & "     DROP table #tempBackLogInfo                                             " & vbCrLf
      sSql = sSql & "     End "
   
      ExecuteScript False, sSql
      
      ' update the version
      ExecuteScript False, "Update Version Set Version = " & newver
   
   End If
End Function

Private Function UpdateDatabase37()
   newver = 111
   If ver < newver Then
   
      If Not ColumnExists("IstcTable", "ISSURUN") Then
         sSql = "alter table IstcTable Add ISSURUN char(1)"
         ExecuteScript False, sSql
      End If
      
      If Not ColumnExists("TempPickLots", "selIndex") Then
         sSql = "alter table TempPickLots add selIndex integer"
         ExecuteScript False, sSql
      End If
      
      ' update the version
      ExecuteScript False, "Update Version Set Version = " & newver
   
   End If
End Function


Private Function UpdateDatabase38()
   newver = 112
   If ver < newver Then
   
      If Not ColumnExists("ComnTable", "CONOTCSHAREOVH") Then
         sSql = "alter table ComnTable add CONOTCSHAREOVH tinyint"
         ExecuteScript False, sSql
      End If
      
      If ColumnExists("EsReportBomTable", "BomSortKey") Then
         sSql = "alter table EsReportBomTable alter column BomSortKey varchar(256)"
         ExecuteScript False, sSql
      End If

      
      sSql = "ALTER PROCEDURE [dbo].[RptVendorDelPerformance]" & vbCrLf
      sSql = sSql & "   @sVendorRef as VARCHAR(10)," & vbCrLf
      sSql = sSql & "   @sBeginDate as VARCHAR(10)," & vbCrLf
      sSql = sSql & "   @sEndDate as VARCHAR(10)," & vbCrLf
      sSql = sSql & "   @iAllowDaysEarly as INTEGER," & vbCrLf
      sSql = sSql & "   @iAllowDaysLate as INTEGER," & vbCrLf
      sSql = sSql & "   @iUseOriginalShipDate as INTEGER" & vbCrLf
      sSql = sSql & " AS " & vbCrLf
      sSql = sSql & " BEGIN " & vbCrLf
      sSql = sSql & "  -- SET NOCOUNT ON added to prevent extra result sets from" & vbCrLf
      sSql = sSql & "  -- interfering with SELECT statements." & vbCrLf
      sSql = sSql & "  SET NOCOUNT ON;" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "  IF (UPPER(@sVendorRef) = 'ALL') Or (UPPER(@sVendorRef) = '<ALL>')" & vbCrLf
      sSql = sSql & "     BEGIN " & vbCrLf
      sSql = sSql & "        SET @sVendorRef = ''" & vbCrLf
      sSql = sSql & "     End" & vbCrLf
      sSql = sSql & "     IF (@iAllowDaysEarly > 0)" & vbCrLf
      sSql = sSql & "     BEGIN " & vbCrLf
      sSql = sSql & "        SET @iAllowDaysEarly = @iAllowDaysEarly * -1" & vbCrLf
      sSql = sSql & "     End" & vbCrLf
      sSql = sSql & "     -- Insert statements for procedure here" & vbCrLf
      sSql = sSql & "  SELECT DISTINCT VEREF, VEBNAME, PINUMBER, PIRELEASE, PIITEM, PIREV, PIPART, PARTNUM, PIADATE, PIPDATE, PIPQTY, PIAQTY, PIONDOCKINSPDATE," & vbCrLf
      sSql = sSql & "            PIINSDATE , PIRECEIVED, PIONDOCKINSPECTED, PIODDELDATE, PIPORIGDATE, PIONDOCKQTYACC, PIONDOCKQTYREJ, PIODDELQTY, PIREJECTED, PIWASTE, PIONDOCKQTYWASTE, " & vbCrLf
      sSql = sSql & "            PIESTUNIT, ISNULL(INPQTY,0.0000) AS INPQTY, ISNULL(INAQTY,0.0000) AS INAQTY, ISNULL(INAMT,0.0000) AS INAMT, ISNULL(INPOITEM,0) AS INPOITEM," & vbCrLf
      sSql = sSql & "            ISNULL(INPOREV,'') AS INPOREV, ISNULL(INPONUMBER,0) AS INPONUMBER, ISNULL(INPORELEASE,0) AS INPORELEASE, ISNULL(INTYPE,0) AS INTYPE," & vbCrLf
      sSql = sSql & "         CASE WHEN ISNULL(PIODDELDATE, '')>'' THEN PIODDELDATE" & vbCrLf
      sSql = sSql & "         WHEN ISNULL(PIONDOCKINSPDATE,'')>'' THEN PIONDOCKINSPDATE" & vbCrLf
      sSql = sSql & "         ELSE PIADATE END AS 'DELIVERYDATE'," & vbCrLf
      sSql = sSql & "            CASE WHEN (ISNULL(PIRECEIVED,'')='') AND (ISNULL(PIINSDATE,'')='') AND (ISNULL(PIODDELDATE,'')='') THEN 'PO'" & vbCrLf
      sSql = sSql & "                 WHEN (ISNULL(PIRECEIVED,'')='') AND (ISNULL(PIINSDATE,'')='') THEN 'DEL'" & vbCrLf
      sSql = sSql & "                 WHEN (ISNULL(PIRECEIVED,'')='') THEN 'DOCK'" & vbCrLf
      sSql = sSql & "                 WHEN PIRECEIVED > '01/01/1900' THEN 'REC' ELSE '' END AS 'STATUS'," & vbCrLf
      sSql = sSql & "            CASE WHEN (@iUseOriginalShipDate=0) AND (ISNULL(PIPORIGDATE,''))='' THEN PIPDATE" & vbCrLf
      sSql = sSql & "                 WHEN (@iUseOriginalShipDate=0) THEN PIPORIGDATE" & vbCrLf
      sSql = sSql & "                 ELSE PIPDATE END AS 'DUEDATE'" & vbCrLf
      sSql = sSql & "     From VndrTable" & vbCrLf
      sSql = sSql & "     INNER JOIN PoitTable ON VEREF=PIVENDOR" & vbCrLf
      sSql = sSql & "     LEFT OUTER JOIN InvaTable ON INPONUMBER=PINUMBER AND INPORELEASE=PIRELEASE AND INPOREV=PIREV AND INPOITEM=PIITEM" & vbCrLf
      sSql = sSql & "     LEFT OUTER JOIN PartTable ON PARTREF=PIPART" & vbCrLf
      sSql = sSql & "  Where " & vbCrLf
      sSql = sSql & "     VEREF LIKE @sVendorRef + '%' AND INTYPE = 15" & vbCrLf
      sSql = sSql & "     AND" & vbCrLf
      sSql = sSql & "     ((PIADATE IS NOT NULL) OR (PIODDELDATE IS NOT NULL) OR (PIONDOCKINSPDATE IS NOT NULL))" & vbCrLf
      sSql = sSql & "  AND" & vbCrLf
      sSql = sSql & "  (" & vbCrLf
      sSql = sSql & "      (PIADATE IS NOT NULL AND PIADATE BETWEEN DateAdd(day, @iAllowDaysEarly, Cast(@sBeginDate AS DateTime)) AND DateAdd(day, @iAllowDaysLate, Cast(@sEndDate AS DateTime)))" & vbCrLf
      sSql = sSql & "  )" & vbCrLf
      sSql = sSql & " End"
      
      ExecuteScript False, sSql

      If Not TableExists("ImpPartCdCls") Then
         sSql = "CREATE TABLE [dbo].[ImpPartCdCls](" & vbCrLf
         sSql = sSql & "     [IMPARTNUM] [nvarchar](30) NULL," & vbCrLf
         sSql = sSql & "     [IMPARTTYPE] [int] NULL," & vbCrLf
         sSql = sSql & "     [IMPRODCODE] [varchar](4) NULL," & vbCrLf
         sSql = sSql & "     [IMPRODCLS] [varchar](4) NULL" & vbCrLf
         sSql = sSql & "    ) ON [PRIMARY]"
   
         ExecuteScript False, sSql
      End If
      
      
      sSql = "ALTER PROCEDURE [dbo].[RptChartOfAccount]  " & vbCrLf
      sSql = sSql & "    @InclIncAcct as varchar(1)" & vbCrLf
      sSql = sSql & "AS " & vbCrLf
      sSql = sSql & "BEGIN " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   declare @glAcctRef as varchar(10) " & vbCrLf
      sSql = sSql & "   declare @glMsAcct as varchar(10) " & vbCrLf
      sSql = sSql & "   declare @TopLevelDesc as varchar(30)" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   declare @level as varchar(10)" & vbCrLf
      sSql = sSql & "   declare @InclInAcct as Integer" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   if (@InclIncAcct = '1')" & vbCrLf
      sSql = sSql & "      SET @InclInAcct = ''" & vbCrLf
      sSql = sSql & "   else" & vbCrLf
      sSql = sSql & "      SET @InclInAcct = '0'" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   CREATE TABLE #tempChartOfAcct(   " & vbCrLf
      sSql = sSql & "   [TOPLEVEL] [varchar](10) NULL,  " & vbCrLf
      sSql = sSql & "   [TOPLEVELDESC] [varchar](30) NULL, " & vbCrLf
      sSql = sSql & "   [GLACCTREF] [varchar](112) NULL,         " & vbCrLf
      sSql = sSql & "   [GLDESCR] [varchar](120) NULL,  " & vbCrLf
      sSql = sSql & "   [GLMASTER] [varchar](12) NULL,   " & vbCrLf
      sSql = sSql & "   [GLFSLEVEL] [INT] NULL," & vbCrLf
      sSql = sSql & "   [GLINACTIVE] [int] NULL," & vbCrLf
      sSql = sSql & "   [SORTKEYLEVEL] [int] NULL,           " & vbCrLf
      sSql = sSql & "   [GLACCSORTKEY] [varchar](512) NULL           " & vbCrLf
      sSql = sSql & ")                             " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   DECLARE balAcctStruc CURSOR  FOR " & vbCrLf
      sSql = sSql & "      SELECT COASSTACCT, COASSTDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      UNION ALL" & vbCrLf
      sSql = sSql & "      SELECT COLIABACCT, COLIABDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      UNION ALL" & vbCrLf
      sSql = sSql & "      SELECT COINCMACCT, COINCMDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      UNION ALL " & vbCrLf
      sSql = sSql & "      SELECT COEQTYACCT, COEQTYDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      UNION ALL" & vbCrLf
      sSql = sSql & "      SELECT COCOGSACCT, COCOGSDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      UNION ALL" & vbCrLf
      sSql = sSql & "      SELECT COEXPNACCT, COEXPNDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      UNION ALL" & vbCrLf
      sSql = sSql & "      SELECT COOINCACCT, COOINCDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      UNION ALL" & vbCrLf
      sSql = sSql & "      SELECT COFDTXACCT, COFDTXDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      UNION ALL" & vbCrLf
      sSql = sSql & "     SELECT COOEXPACCT, COOEXPDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      UNION ALL" & vbCrLf
      sSql = sSql & "      SELECT COFDTXACCT, COFDTXDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   OPEN balAcctStruc" & vbCrLf
      sSql = sSql & "   FETCH NEXT FROM balAcctStruc INTO @level, @TopLevelDesc" & vbCrLf
      sSql = sSql & "   WHILE (@@FETCH_STATUS <> -1) " & vbCrLf
      sSql = sSql & "   BEGIN " & vbCrLf
      sSql = sSql & "      IF (@@FETCH_STATUS <> -2) " & vbCrLf
      sSql = sSql & "      BEGIN " & vbCrLf
      sSql = sSql & "         " & vbCrLf
      sSql = sSql & "         INSERT INTO #tempChartOfAcct(TOPLEVEL, TOPLEVELDESC, GLACCTREF, GLDESCR, GLMASTER, GLFSLEVEL,GLINACTIVE, SORTKEYLEVEL,GLACCSORTKEY)" & vbCrLf
      sSql = sSql & "         select @level as TopLevel, @TopLevelDesc as TopLevelDesc, @level as GLACCTREF, " & vbCrLf
      sSql = sSql & "            @TopLevelDesc as GLDESCR, '' as GLMASTER, 0 as GLFSLEVEL, 0,0 as level, @level as SortKey" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "         with cte" & vbCrLf
      sSql = sSql & "         as" & vbCrLf
      sSql = sSql & "         (select GLACCTREF, GLDESCR, GLMASTER, GLFSLEVEL, GLINACTIVE, 0 as level," & vbCrLf
      sSql = sSql & "            cast(cast(@level as varchar(4))+ char(36)+ GLACCTREF as varchar(max)) as SortKey" & vbCrLf
      sSql = sSql & "         from GlacTable" & vbCrLf
      sSql = sSql & "         where GLMASTER = cast(@level as varchar(4)) AND GLINACTIVE LIKE @InclInAcct" & vbCrLf
      sSql = sSql & "         union all" & vbCrLf
      sSql = sSql & "         select a.GLACCTREF, a.GLDESCR, a.GLMASTER, a.GLFSLEVEL, a.GLINACTIVE, level + 1," & vbCrLf
      sSql = sSql & "          cast(COALESCE(SortKey,'') + char(36) + COALESCE(a.GLACCTREF,'') as varchar(max))as SortKey" & vbCrLf
      sSql = sSql & "         from cte" & vbCrLf
      sSql = sSql & "            inner join GlacTable a" & vbCrLf
      sSql = sSql & "               on cte.GLACCTREF = a.GLMASTER" & vbCrLf
      sSql = sSql & "            WHERE a.GLINACTIVE LIKE @InclInAcct" & vbCrLf
      sSql = sSql & "         )" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "         INSERT INTO #tempChartOfAcct(TOPLEVEL, TOPLEVELDESC, GLACCTREF, GLDESCR, GLMASTER, GLFSLEVEL,GLINACTIVE, SORTKEYLEVEL,GLACCSORTKEY)" & vbCrLf
      sSql = sSql & "         select @level as TopLevel, @TopLevelDesc as TopLevelDesc, " & vbCrLf
      sSql = sSql & "               Replicate('  ', level) + GLACCTREF as GLACCTREF, " & vbCrLf
      sSql = sSql & "               Replicate('  ', level) + GLDESCR as GLDESCR, GLMASTER, " & vbCrLf
      sSql = sSql & "               GLFSLEVEL, GLINACTIVE,level, SortKey" & vbCrLf
      sSql = sSql & "         from cte order by SortKey" & vbCrLf
      sSql = sSql & "         " & vbCrLf
      sSql = sSql & "      END" & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM balAcctStruc INTO @level, @TopLevelDesc" & vbCrLf
      sSql = sSql & "   END         " & vbCrLf
      sSql = sSql & "   CLOSE balAcctStruc" & vbCrLf
      sSql = sSql & "   DEALLOCATE balAcctStruc" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   SELECT TOPLEVEL, TOPLEVELDESC, GLACCTREF, GLDESCR, GLMASTER, " & vbCrLf
      sSql = sSql & "      GLFSLEVEL,GLINACTIVE, SORTKEYLEVEL,GLACCSORTKEY " & vbCrLf
      sSql = sSql & "   FROM #tempChartOfAcct ORDER BY GLACCSORTKEY" & vbCrLf
      sSql = sSql & "                                           " & vbCrLf
      sSql = sSql & "   DROP table #tempChartOfAcct            " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "End"
      
      ExecuteScript False, sSql
      
      ' update the version
      ExecuteScript False, "Update Version Set Version = " & newver
   
   End If
End Function


Private Function UpdateDatabase39()
   newver = 113
   If ver < newver Then
   
      If Not ColumnExists("EstiTable", "BIDQUOTEDATE") Then
         sSql = "ALTER TABLE EstiTable ADD BIDQUOTEDATE DATETIME NULL,BIDLEADTIME varchar(128), BIDFOB varchar(128)"
         ExecuteScript False, sSql
      End If
      
      sSql = "ALTER PROCEDURE [dbo].[RptChartOfAccount]  " & vbCrLf
      sSql = sSql & "    @InclIncAcct as varchar(1)" & vbCrLf
      sSql = sSql & "AS " & vbCrLf
      sSql = sSql & "BEGIN " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   declare @glAcctRef as varchar(10) " & vbCrLf
      sSql = sSql & "   declare @glMsAcct as varchar(10) " & vbCrLf
      sSql = sSql & "   declare @TopLevelDesc as varchar(30)" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   declare @level as varchar(10)" & vbCrLf
      sSql = sSql & "   declare @InclInAcct as Integer" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   if (@InclIncAcct = '1')" & vbCrLf
      sSql = sSql & "      SET @InclInAcct = ''" & vbCrLf
      sSql = sSql & "   else" & vbCrLf
      sSql = sSql & "      SET @InclInAcct = '0'" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   CREATE TABLE #tempChartOfAcct(   " & vbCrLf
      sSql = sSql & "   [TOPLEVEL] [varchar](10) NULL,  " & vbCrLf
      sSql = sSql & "   [TOPLEVELDESC] [varchar](30) NULL, " & vbCrLf
      sSql = sSql & "   [GLACCTREF] [varchar](112) NULL,         " & vbCrLf
      sSql = sSql & "   [GLDESCR] [varchar](120) NULL,  " & vbCrLf
      sSql = sSql & "   [GLMASTER] [varchar](12) NULL,   " & vbCrLf
      sSql = sSql & "   [GLFSLEVEL] [INT] NULL," & vbCrLf
      sSql = sSql & "   [GLINACTIVE] [int] NULL," & vbCrLf
      sSql = sSql & "   [SORTKEYLEVEL] [int] NULL,           " & vbCrLf
      sSql = sSql & "   [GLACCSORTKEY] [varchar](512) NULL           " & vbCrLf
      sSql = sSql & ")                             " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   DECLARE balAcctStruc CURSOR  FOR " & vbCrLf
      sSql = sSql & "      SELECT COASSTACCT, COASSTDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      UNION ALL" & vbCrLf
      sSql = sSql & "      SELECT COLIABACCT, COLIABDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      UNION ALL" & vbCrLf
      sSql = sSql & "      SELECT COINCMACCT, COINCMDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      UNION ALL " & vbCrLf
      sSql = sSql & "      SELECT COEQTYACCT, COEQTYDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      UNION ALL" & vbCrLf
      sSql = sSql & "      SELECT COCOGSACCT, COCOGSDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      UNION ALL" & vbCrLf
      sSql = sSql & "      SELECT COEXPNACCT, COEXPNDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      UNION ALL" & vbCrLf
      sSql = sSql & "      SELECT COOINCACCT, COOINCDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      UNION ALL" & vbCrLf
      sSql = sSql & "      SELECT COFDTXACCT, COFDTXDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      UNION ALL" & vbCrLf
      sSql = sSql & "     SELECT COOEXPACCT, COOEXPDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      --UNION ALL" & vbCrLf
      sSql = sSql & "      --SELECT COFDTXACCT, COFDTXDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   OPEN balAcctStruc" & vbCrLf
      sSql = sSql & "   FETCH NEXT FROM balAcctStruc INTO @level, @TopLevelDesc" & vbCrLf
      sSql = sSql & "   WHILE (@@FETCH_STATUS <> -1) " & vbCrLf
      sSql = sSql & "   BEGIN " & vbCrLf
      sSql = sSql & "      IF (@@FETCH_STATUS <> -2) " & vbCrLf
      sSql = sSql & "      BEGIN " & vbCrLf
      sSql = sSql & "         " & vbCrLf
      sSql = sSql & "         INSERT INTO #tempChartOfAcct(TOPLEVEL, TOPLEVELDESC, GLACCTREF, GLDESCR, GLMASTER, GLFSLEVEL,GLINACTIVE, SORTKEYLEVEL,GLACCSORTKEY)" & vbCrLf
      sSql = sSql & "         select @level as TopLevel, @TopLevelDesc as TopLevelDesc, @level as GLACCTREF, " & vbCrLf
      sSql = sSql & "            @TopLevelDesc as GLDESCR, '' as GLMASTER, 0 as GLFSLEVEL, 0,0 as level, @level as SortKey" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "         with cte" & vbCrLf
      sSql = sSql & "         as" & vbCrLf
      sSql = sSql & "         (select GLACCTREF, GLDESCR, GLMASTER, GLFSLEVEL, GLINACTIVE, 0 as level," & vbCrLf
      sSql = sSql & "            cast(cast(@level as varchar(4))+ char(36)+ GLACCTREF as varchar(max)) as SortKey" & vbCrLf
      sSql = sSql & "         from GlacTable" & vbCrLf
      sSql = sSql & "         where GLMASTER = cast(@level as varchar(4)) AND GLINACTIVE LIKE @InclInAcct" & vbCrLf
      sSql = sSql & "         union all" & vbCrLf
      sSql = sSql & "         select a.GLACCTREF, a.GLDESCR, a.GLMASTER, a.GLFSLEVEL, a.GLINACTIVE, level + 1," & vbCrLf
      sSql = sSql & "          cast(COALESCE(SortKey,'') + char(36) + COALESCE(a.GLACCTREF,'') as varchar(max))as SortKey" & vbCrLf
      sSql = sSql & "         from cte" & vbCrLf
      sSql = sSql & "            inner join GlacTable a" & vbCrLf
      sSql = sSql & "               on cte.GLACCTREF = a.GLMASTER" & vbCrLf
      sSql = sSql & "            WHERE a.GLINACTIVE LIKE @InclInAcct" & vbCrLf
      sSql = sSql & "         )" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "         INSERT INTO #tempChartOfAcct(TOPLEVEL, TOPLEVELDESC, GLACCTREF, GLDESCR, GLMASTER, GLFSLEVEL,GLINACTIVE, SORTKEYLEVEL,GLACCSORTKEY)" & vbCrLf
      sSql = sSql & "         select @level as TopLevel, @TopLevelDesc as TopLevelDesc, " & vbCrLf
      sSql = sSql & "               Replicate('  ', level) + GLACCTREF as GLACCTREF, " & vbCrLf
      sSql = sSql & "               Replicate('  ', level) + GLDESCR as GLDESCR, GLMASTER, " & vbCrLf
      sSql = sSql & "               GLFSLEVEL, GLINACTIVE,level, SortKey" & vbCrLf
      sSql = sSql & "         from cte order by SortKey" & vbCrLf
      sSql = sSql & "         " & vbCrLf
      sSql = sSql & "      END" & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM balAcctStruc INTO @level, @TopLevelDesc" & vbCrLf
      sSql = sSql & "   END         " & vbCrLf
      sSql = sSql & "   CLOSE balAcctStruc" & vbCrLf
      sSql = sSql & "   DEALLOCATE balAcctStruc" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   SELECT TOPLEVEL, TOPLEVELDESC, GLACCTREF, GLDESCR, GLMASTER, " & vbCrLf
      sSql = sSql & "      GLFSLEVEL,GLINACTIVE, SORTKEYLEVEL,GLACCSORTKEY " & vbCrLf
      sSql = sSql & "   FROM #tempChartOfAcct ORDER BY GLACCSORTKEY" & vbCrLf
      sSql = sSql & "                                           " & vbCrLf
      sSql = sSql & "   DROP table #tempChartOfAcct            " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "End"
      
      ExecuteScript False, sSql
         
      ' update the version
      ExecuteScript False, "Update Version Set Version = " & newver
   
   End If
End Function


Private Function UpdateDatabase40()
   newver = 114
   If ver < newver Then
   
   
      If Not ColumnExists("ComnTable", "COORDBYRUN") Then
         sSql = "ALTER TABLE ComnTable ADD COORDBYRUN tinyint"
         ExecuteScript False, sSql
      End If
      
      
      If Not TableExists("CustomFields") Then
         sSql = "CREATE TABLE [dbo].[CustomFields](" & vbCrLf
         sSql = sSql & "   [REPORT_INDEX] [int] IDENTITY(1,1) NOT NULL," & vbCrLf
         sSql = sSql & "   [LABEL_ID] [char](50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
         sSql = sSql & "   [LABEL_NAME] [varchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
         sSql = sSql & "   [TBL_NAME] [nvarchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
         sSql = sSql & "   [TBL_COLNAME] [nvarchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL," & vbCrLf
         sSql = sSql & "   [COLREF_KEY] [char](30) COLLATE SQL_Latin1_General_CP1_CI_AS NULL" & vbCrLf
         sSql = sSql & ") ON [PRIMARY]"
      
         ExecuteScript False, sSql
      
         sSql = "INSERT INTO [dbo].[CustomFields]([LABEL_ID],[LABEL_NAME],[TBL_NAME]" & vbCrLf
         sSql = sSql & "           ,[TBL_COLNAME],[COLREF_KEY])" & vbCrLf
         sSql = sSql & "VALUES ('MaterialID','Material','PartTable','PAMATERIALTYPE','PARTREF')" & vbCrLf
         ExecuteScript False, sSql

         sSql = "INSERT INTO [dbo].[CustomFields]([LABEL_ID],[LABEL_NAME],[TBL_NAME]" & vbCrLf
         sSql = sSql & "           ,[TBL_COLNAME],[COLREF_KEY])" & vbCrLf
         sSql = sSql & "VALUES ('AlloyID','Alloy/Temper','PartTable','PAMATERIALALLOY','PARTREF')" & vbCrLf
         ExecuteScript False, sSql

         sSql = "INSERT INTO [dbo].[CustomFields]([LABEL_ID],[LABEL_NAME],[TBL_NAME]" & vbCrLf
         sSql = sSql & "           ,[TBL_COLNAME],[COLREF_KEY])" & vbCrLf
         sSql = sSql & "VALUES ('ColorID','Color','PartTable','PACOLOR','PARTREF')"
         ExecuteScript False, sSql
      
      End If
      

      ' update the version
      ExecuteScript False, "Update Version Set Version = " & newver
   
   End If
End Function

Private Function UpdateDatabase41()
   newver = 115
   If ver < newver Then
   
      If ColumnExists("ExoitImport", "TOT_QTY") Then
         sSql = "ALTER TABLE ExoitImport ALTER COLUMN TOT_QTY decimal (12,4)"
         ExecuteScript False, sSql
         
         sSql = "ALTER TABLE ExoitImport ALTER COLUMN UNIT_PRICE decimal (12,4)"
         ExecuteScript False, sSql
         
         sSql = "ALTER TABLE ExoitImport ALTER COLUMN SCHED_QTY_VALUE decimal (12,4)"
         ExecuteScript False, sSql
         
      End If

      ' update the version
      ExecuteScript False, "Update Version Set Version = " & newver
   
   End If
End Function


Private Function UpdateDatabase42()
   newver = 116
   If ver < newver Then
   
      If Not ColumnExists("CihdTable", "CIUSER") Then
         sSql = "ALTER TABLE dbo.CihdTable ADD CIUSER varchar(4)"
         ExecuteScript False, sSql
      End If

      If StoreProcedureExists("RptVendorProfile") Then
         sSql = "DROP PROCEDURE RptVendorProfile"
         ExecuteScript False, sSql
      End If
         
      sSql = "CREATE PROCEDURE [dbo].[RptVendorProfile]" & vbCrLf
      sSql = sSql & "   @StartDate as varchar(12),@EndDate as varchar(12) AS" & vbCrLf
      sSql = sSql & "BEGIN " & vbCrLf
      sSql = sSql & "   SELECT DISTINCT 'Minority-owned Business' as VndrBusType," & vbCrLf
      sSql = sSql & "      VndrTable.VENICKNAME , VndrTable.VEBNAME, VihdTable.VINO, " & vbCrLf
      sSql = sSql & "      VihdTable.VIDATE , VihdTable.VIDTRECD, VihdTable.VIPIF, VihdTable.VIDUE, " & vbCrLf
      sSql = sSql & "      VihdTable.VIDUEDATE , VihdTable.VICHECKNO, VihdTable.VITYPE" & vbCrLf
      sSql = sSql & "   From " & vbCrLf
      sSql = sSql & "      VndrTable VndrTable INNER JOIN VihdTable VihdTable ON" & vbCrLf
      sSql = sSql & "         VndrTable.VEREF = VihdTable.VIVENDOR" & vbCrLf
      sSql = sSql & "   WHERE VihdTable.VIDATE BETWEEN @StartDate and @EndDate AND VESMALLBUS = 1--, VEMINBUS , VESWMNBUS" & vbCrLf
      sSql = sSql & "   Union " & vbCrLf
      sSql = sSql & "   SELECT DISTINCT 'Small Business' as VndrBusType," & vbCrLf
      sSql = sSql & "      VndrTable.VENICKNAME , VndrTable.VEBNAME, VihdTable.VINO, " & vbCrLf
      sSql = sSql & "      VihdTable.VIDATE , VihdTable.VIDTRECD, VihdTable.VIPIF, VihdTable.VIDUE, " & vbCrLf
      sSql = sSql & "      VihdTable.VIDUEDATE , VihdTable.VICHECKNO, VihdTable.VITYPE" & vbCrLf
      sSql = sSql & "   From " & vbCrLf
      sSql = sSql & "      VndrTable VndrTable INNER JOIN VihdTable VihdTable ON" & vbCrLf
      sSql = sSql & "         VndrTable.VEREF = VihdTable.VIVENDOR" & vbCrLf
      sSql = sSql & "   WHERE VihdTable.VIDATE BETWEEN @StartDate and @EndDate AND VESMALLBUS = 1--, VEMINBUS , VESWMNBUS" & vbCrLf
      sSql = sSql & "   Union " & vbCrLf
      sSql = sSql & "   SELECT DISTINCT 'Woman-owned Business' as VndrBusType," & vbCrLf
      sSql = sSql & "      VndrTable.VENICKNAME , VndrTable.VEBNAME, VihdTable.VINO, " & vbCrLf
      sSql = sSql & "      VihdTable.VIDATE , VihdTable.VIDTRECD, VihdTable.VIPIF, VihdTable.VIDUE, " & vbCrLf
      sSql = sSql & "      VihdTable.VIDUEDATE , VihdTable.VICHECKNO, VihdTable.VITYPE" & vbCrLf
      sSql = sSql & "   From " & vbCrLf
      sSql = sSql & "      VndrTable VndrTable INNER JOIN VihdTable VihdTable ON" & vbCrLf
      sSql = sSql & "         VndrTable.VEREF = VihdTable.VIVENDOR" & vbCrLf
      sSql = sSql & "   WHERE VihdTable.VIDATE BETWEEN @StartDate and @EndDate AND VESMALLBUS = 1--, VEMINBUS , VESWMNBUS" & vbCrLf
      sSql = sSql & "   Order By" & vbCrLf
      sSql = sSql & "      VndrTable.VENICKNAME Asc" & vbCrLf
      sSql = sSql & "End"
      
      ExecuteScript False, sSql


      ' update the version
      ExecuteScript False, "Update Version Set Version = " & newver
   
   End If
End Function


Private Function UpdateDatabase43()
   newver = 117
   If ver < newver Then
   

      If StoreProcedureExists("rptAllMOLevels") Then
         sSql = "DROP PROCEDURE rptAllMOLevels"
         ExecuteScript False, sSql
      End If
         
      sSql = "CREATE PROCEDURE [dbo].[rptAllMOLevels]" & vbCrLf
      sSql = sSql & "   @MOPartRef as varchar(30), @MORun as int," & vbCrLf
      sSql = sSql & "   @Startdate as varchar(12)" & vbCrLf
      sSql = sSql & "AS" & vbCrLf
      sSql = sSql & "BEGIN " & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   CREATE TABLE #tempMOruns" & vbCrLf
      sSql = sSql & "   (" & vbCrLf
      sSql = sSql & "     tmpMOPartRef varchar(30) NULL ," & vbCrLf
      sSql = sSql & "     tmpMORun int NULL" & vbCrLf
      sSql = sSql & "   )" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   INSERT INTO #tempMOruns (tmpMOPartRef,tmpMORun)" & vbCrLf
      sSql = sSql & "   select DISTINCT LOTMOPARTREF, LOTMORUNNO --INLOTNUMBER," & vbCrLf
      sSql = sSql & "         From InvaTable, lohdTable" & vbCrLf
      sSql = sSql & "      where INMOPART = @MOPartRef --'169420001'" & vbCrLf
      sSql = sSql & "            AND INMORUN  = @MORun" & vbCrLf
      sSql = sSql & "            AND INLOTNUMBER = LOTnumber" & vbCrLf
      sSql = sSql & "            and lotpartref = INPART" & vbCrLf
      sSql = sSql & "            and lotmopartref <> ''" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   SELECT * FROM #tempMOruns" & vbCrLf
      sSql = sSql & "   Drop table #tempMOruns" & vbCrLf
      sSql = sSql & "End"
      
      ExecuteScript False, sSql


      ' update the version
      ExecuteScript False, "Update Version Set Version = " & newver
   
   End If
End Function


Private Function UpdateDatabase44()
   newver = 118
   If ver < newver Then
   

      If Not ColumnExists("VndrTable", "VESMALLBUS") Then
         sSql = "ALTER table dbo.VndrTable add VESMALLBUS tinyint, VEMINBUS tinyint, VESWMNBUS tinyint"
         ExecuteScript False, sSql
      End If

      ' update the version
      ExecuteScript False, "Update Version Set Version = " & newver
   
   End If
End Function


Private Function UpdateDatabase45()
   newver = 119
   If ver < newver Then
   

      If StoreProcedureExists("rptAllMOLevels") Then
         sSql = "DROP PROCEDURE rptAllMOLevels"
         ExecuteScript False, sSql
      End If
         
      sSql = "CREATE PROCEDURE [dbo].[rptAllMOLevels]" & vbCrLf
      sSql = sSql & "   @MOPartRef as varchar(30), @MORun as int," & vbCrLf
      sSql = sSql & "   @Startdate as varchar(12)" & vbCrLf
      sSql = sSql & "AS" & vbCrLf
      sSql = sSql & "BEGIN " & vbCrLf
      sSql = sSql & "   CREATE TABLE #tempMOruns" & vbCrLf
      sSql = sSql & "   (" & vbCrLf
      sSql = sSql & "     tmpMOPartRef varchar(30) NULL ," & vbCrLf
      sSql = sSql & "     tmpMORun int NULL," & vbCrLf
      sSql = sSql & "     Sort int" & vbCrLf
      sSql = sSql & "   )" & vbCrLf
      sSql = sSql & "   INSERT INTO #tempMOruns (Sort ,tmpMOPartRef,tmpMORun)" & vbCrLf
      sSql = sSql & "   select DISTINCT 1,LOTMOPARTREF, LOTMORUNNO --INLOTNUMBER," & vbCrLf
      sSql = sSql & "         From InvaTable, lohdTable" & vbCrLf
      sSql = sSql & "      where INMOPART = @MOPartRef --'169420001'" & vbCrLf
      sSql = sSql & "            AND INMORUN  = @MORun" & vbCrLf
      sSql = sSql & "            AND INLOTNUMBER = LOTnumber" & vbCrLf
      sSql = sSql & "            and lotpartref = INPART" & vbCrLf
      sSql = sSql & "            and lotmopartref <> ''" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   UPDATE #tempMOruns SET Sort = 0 WHERE tmpMOPartRef = @MOPartRef --'169420001'" & vbCrLf
      sSql = sSql & "            AND tmpMORun  = @MORun" & vbCrLf
      sSql = sSql & "   SELECT * FROM #tempMOruns ORDER BY SORT" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   Drop table #tempMOruns" & vbCrLf
      sSql = sSql & "End"
         
      ExecuteScript False, sSql
         
      sSql = "ALTER table dbo.EstiTable ALTER COLUMN BIDCOMMENT varchar(1034)"
      ExecuteScript False, sSql
         
      ' update the version
      ExecuteScript False, "Update Version Set Version = " & newver
   
   End If
End Function


Private Function UpdateDatabase46()
   newver = 120
   If ver < newver Then
   

      If StoreProcedureExists("RptInventoryAdjustments") Then
         sSql = "DROP PROCEDURE RptInventoryAdjustments"
         ExecuteScript False, sSql
      End If
         
      sSql = "CREATE PROCEDURE [dbo].[RptInventoryAdjustments] " & vbCrLf
      sSql = sSql & "@StartDate as varchar(16), @EndDate as Varchar(16), @PartClass as Varchar(16),@PartCode as varchar(8) " & vbCrLf
      sSql = sSql & "AS " & vbCrLf
      sSql = sSql & "BEGIN " & vbCrLf
      sSql = sSql & "   declare @partRef as varchar(30) " & vbCrLf
      sSql = sSql & "   declare @partNum as varchar(30) " & vbCrLf
      sSql = sSql & "   declare @partDesc as varchar(30) " & vbCrLf
      sSql = sSql & "   declare @partExDesc as varchar(3072) " & vbCrLf
      sSql = sSql & "   declare @lotNum as varchar(15) " & vbCrLf
      sSql = sSql & "   declare @lotUserID as varchar(40) " & vbCrLf
      sSql = sSql & "   declare @Inno as Int " & vbCrLf
      sSql = sSql & "   declare @actualDt as varchar(30) " & vbCrLf
      sSql = sSql & "   declare @qty as int " & vbCrLf
      sSql = sSql & "   declare @invAmt as decimal(12,4) " & vbCrLf
      sSql = sSql & "   declare @invTotMatl decimal(12,4) " & vbCrLf
      sSql = sSql & "   declare @invTotLabor decimal(12,4) " & vbCrLf
      sSql = sSql & "   declare @invTotExp decimal(12,4) " & vbCrLf
      sSql = sSql & "   declare @invTotOH decimal(12,4) " & vbCrLf
      sSql = sSql & "   declare @creditAcc int " & vbCrLf
      sSql = sSql & "   declare @debitAcc int " & vbCrLf
      sSql = sSql & "   declare @lotTotMatl decimal(12,4) " & vbCrLf
      sSql = sSql & "   declare @lotTotLabor decimal(12,4) " & vbCrLf
      sSql = sSql & "   declare @lotTotExp decimal(12,4) " & vbCrLf
      sSql = sSql & "   declare @lotTotOH decimal(12,4) " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   declare @totMatlCost decimal(12,4) " & vbCrLf
      sSql = sSql & "   declare @totLaborCost decimal(12,4) " & vbCrLf
      sSql = sSql & "   declare @totExpCost decimal(12,4) " & vbCrLf
      sSql = sSql & "   declare @totOHCost decimal(12,4) " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   declare @fInvMatl int " & vbCrLf
      sSql = sSql & "   declare @fInvLabor int " & vbCrLf
      sSql = sSql & "   declare @fInvExp int " & vbCrLf
      sSql = sSql & "   declare @fInvOH int " & vbCrLf
      sSql = sSql & "                   " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "    IF (@PartClass = 'ALL') " & vbCrLf
      sSql = sSql & "    BEGIN " & vbCrLf
      sSql = sSql & "      SET @PartClass = '' " & vbCrLf
      sSql = sSql & "    End " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "    IF (@PartCode = 'ALL') " & vbCrLf
      sSql = sSql & "    BEGIN " & vbCrLf
      sSql = sSql & "      SET @PartCode = '' " & vbCrLf
      sSql = sSql & "    End " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   CREATE TABLE #tempINVReport " & vbCrLf
      sSql = sSql & "   ( " & vbCrLf
      sSql = sSql & "      PARTNUM Varchar(30) NULL, " & vbCrLf
      sSql = sSql & "      PADESC varchar(30) NULL , " & vbCrLf
      sSql = sSql & "      PAEXTDESC varchar(3072) NULL , " & vbCrLf
      sSql = sSql & "     LOTNUMBER varchar(15) NULL, " & vbCrLf
      sSql = sSql & "     LOTUSERLOTID varchar(40) NULL, " & vbCrLf
      sSql = sSql & "     INNO int NULL, " & vbCrLf
      sSql = sSql & "      INADATE varchar(30) NULL, " & vbCrLf
      sSql = sSql & "      INAQTY decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      INAMT decimal (12,4) NULL, " & vbCrLf
      sSql = sSql & "       TOTMATL decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "       TOTLABOR decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "       TOTEXP decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "       TOTOH decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      CREDITACCT int NULL, " & vbCrLf
      sSql = sSql & "      DEBITACCT int NULL, " & vbCrLf
      sSql = sSql & "      flgMatl int NULL, " & vbCrLf
      sSql = sSql & "      flgLabor int NULL, " & vbCrLf
      sSql = sSql & "      flgExp int NULL, " & vbCrLf
      sSql = sSql & "      flgOH int NULL " & vbCrLf
      sSql = sSql & "   ) " & vbCrLf
      sSql = sSql & "    " & vbCrLf
      sSql = sSql & "   DECLARE curInvRpt CURSOR   FOR " & vbCrLf
      sSql = sSql & "      SELECT INPART, LOTNUMBER, LOTUSERLOTID, INNO, INADATE, " & vbCrLf
      sSql = sSql & "         INAQTY, INAMT, INTOTMATL, " & vbCrLf
      sSql = sSql & "         INTOTLABOR, INTOTEXP, INTOTOH, " & vbCrLf
      sSql = sSql & "         INCREDITACCT, INDEBITACCT, LOTTOTMATL, " & vbCrLf
      sSql = sSql & "         LOTTOTLABOR, LOTTOTEXP, LOTTOTOH, " & vbCrLf
      sSql = sSql & "         PartNum , PADESC, PAEXTDESC " & vbCrLf
      sSql = sSql & "      From viewRptInventoryAdjustments, PartTable " & vbCrLf
      sSql = sSql & "      Where viewRptInventoryAdjustments.INPART = PartTable.PartRef " & vbCrLf
      sSql = sSql & "         AND viewRptInventoryAdjustments.INADATE BETWEEN @StartDate AND @EndDate " & vbCrLf
      sSql = sSql & "         AND PartTable.PACLASS LIKE '%' + @PartClass + '%' " & vbCrLf
      sSql = sSql & "         AND PartTable.PAPRODCODE LIKE '%' + @PartCode + '%' " & vbCrLf
      sSql = sSql & "         --AND INPART = '9148177X48X96' " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   OPEN curInvRpt " & vbCrLf
      sSql = sSql & "   FETCH NEXT FROM curInvRpt INTO @partRef, @lotNum, @lotUserID, @Inno, @actualDt, @qty, " & vbCrLf
      sSql = sSql & "                  @invAmt, @invTotMatl, @invTotLabor, " & vbCrLf
      sSql = sSql & "                  @invTotExp,@invTotOH, @creditAcc, @debitAcc, " & vbCrLf
      sSql = sSql & "                  @lotTotMatl, @lotTotLabor, @lotTotExp, @lotTotOH, " & vbCrLf
      sSql = sSql & "                  @partNum, @partDesc, @partExDesc " & vbCrLf
      sSql = sSql & "   WHILE (@@FETCH_STATUS <> -1) " & vbCrLf
      sSql = sSql & "   BEGIN " & vbCrLf
      sSql = sSql & "      IF (@@FETCH_STATUS <> -2) " & vbCrLf
      sSql = sSql & "      BEGIN " & vbCrLf
      sSql = sSql & "          " & vbCrLf
      sSql = sSql & "         -- Get the costed values from Lothd table " & vbCrLf
      sSql = sSql & "         -- if the Inv table does not have the cost for " & vbCrLf
      sSql = sSql & "         -- material, expenses, OH and Labour. " & vbCrLf
      sSql = sSql & "         SET @totMatlCost = @invTotMatl " & vbCrLf
      sSql = sSql & "         SET @fInvMatl = 1 " & vbCrLf
      sSql = sSql & "         IF (@invTotMatl = 0.0000) " & vbCrLf
      sSql = sSql & "         BEGIN " & vbCrLf
      sSql = sSql & "            IF (@lotTotMatl IS NOT NULL) " & vbCrLf
      sSql = sSql & "            BEGIN " & vbCrLf
      sSql = sSql & "               SET @totMatlCost = @lotTotMatl " & vbCrLf
      sSql = sSql & "               SET @fInvMatl = 0 " & vbCrLf
      sSql = sSql & "            End " & vbCrLf
      sSql = sSql & "         End " & vbCrLf
      sSql = sSql & "         -- Labour " & vbCrLf
      sSql = sSql & "         SET @totLaborCost = @invTotLabor " & vbCrLf
      sSql = sSql & "         SET @fInvLabor = 1 " & vbCrLf
      sSql = sSql & "         IF (@invTotLabor = 0.0000) " & vbCrLf
      sSql = sSql & "         BEGIN " & vbCrLf
      sSql = sSql & "            IF (@lotTotLabor IS NOT NULL) " & vbCrLf
      sSql = sSql & "            BEGIN " & vbCrLf
      sSql = sSql & "               SET @totLaborCost = @lotTotLabor " & vbCrLf
      sSql = sSql & "               SET @fInvLabor = 0 " & vbCrLf
      sSql = sSql & "            End " & vbCrLf
      sSql = sSql & "         End " & vbCrLf
      sSql = sSql & "         -- Exp " & vbCrLf
      sSql = sSql & "         SET @totExpCost = @invTotExp " & vbCrLf
      sSql = sSql & "         SET @fInvExp = 1 " & vbCrLf
      sSql = sSql & "         IF (@invTotExp = 0.0000) " & vbCrLf
      sSql = sSql & "         BEGIN " & vbCrLf
      sSql = sSql & "            IF (@lotTotExp IS NOT NULL) " & vbCrLf
      sSql = sSql & "            BEGIN " & vbCrLf
      sSql = sSql & "               SET @totExpCost = @lotTotExp " & vbCrLf
      sSql = sSql & "               SET @fInvExp = 0 " & vbCrLf
      sSql = sSql & "            End " & vbCrLf
      sSql = sSql & "         End " & vbCrLf
      sSql = sSql & "         -- OH " & vbCrLf
      sSql = sSql & "         SET @totOHCost = @invTotOH " & vbCrLf
      sSql = sSql & "         SET @fInvOH = 1 " & vbCrLf
      sSql = sSql & "         IF (@invTotOH = 0.0000) " & vbCrLf
      sSql = sSql & "         BEGIN " & vbCrLf
      sSql = sSql & "            IF (@lotTotOH IS NOT NULL) " & vbCrLf
      sSql = sSql & "            BEGIN " & vbCrLf
      sSql = sSql & "               SET @totOHCost = @lotTotOH " & vbCrLf
      sSql = sSql & "               SET @fInvOH = 0 " & vbCrLf
      sSql = sSql & "            End " & vbCrLf
      sSql = sSql & "         End " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "         -- Insert to the temp table " & vbCrLf
      sSql = sSql & "         INSERT INTO #tempINVReport (PARTNUM, LOTNUMBER, LOTUSERLOTID, " & vbCrLf
      sSql = sSql & "            INNO, PADESC, PAEXTDESC, INADATE, " & vbCrLf
      sSql = sSql & "               INAQTY,INAMT, TOTMATL,TOTLABOR,TOTEXP,TOTOH, CREDITACCT, DEBITACCT, " & vbCrLf
      sSql = sSql & "               flgMatl, flgLabor, flgExp, flgOH) " & vbCrLf
      sSql = sSql & "         VALUES (@partNum, @lotNum, @lotUserID, @Inno, @partDesc, @partExDesc, @actualDt,@qty, " & vbCrLf
      sSql = sSql & "               @invAmt,@totMatlCost,@totLaborCost,@totExpCost,@totOHCost, " & vbCrLf
      sSql = sSql & "               @creditAcc,@debitAcc,@fInvMatl,@fInvLabor,@fInvExp,@fInvOH) " & vbCrLf
      sSql = sSql & "      End " & vbCrLf
      sSql = sSql & "       " & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM curInvRpt INTO @partRef, @lotNum, @lotUserID, @Inno, @actualDt, @qty, " & vbCrLf
      sSql = sSql & "               @invAmt, @invTotMatl, @invTotLabor, " & vbCrLf
      sSql = sSql & "               @invTotExp,@invTotOH, @creditAcc, @debitAcc, " & vbCrLf
      sSql = sSql & "               @lotTotMatl, @lotTotLabor, @lotTotExp, @lotTotOH, " & vbCrLf
      sSql = sSql & "               @partNum, @partDesc, @partExDesc " & vbCrLf
      sSql = sSql & "   End " & vbCrLf
      sSql = sSql & "          " & vbCrLf
      sSql = sSql & "   CLOSE curInvRpt   --// close the cursor " & vbCrLf
      sSql = sSql & "   DEALLOCATE curInvRpt " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   -- select data for the report " & vbCrLf
      sSql = sSql & "   SELECT a.PARTNUM as PARTNUM, LOTNUMBER, LOTUSERLOTID, INNO, " & vbCrLf
      sSql = sSql & "      a.PADESC as PADESC, a.PAEXTDESC as PAEXTDESC, PALEVEL, INADATE, " & vbCrLf
      sSql = sSql & "         INAQTY,INAMT, TOTMATL,TOTLABOR,TOTEXP,TOTOH, " & vbCrLf
      sSql = sSql & "         CREDITACCT, DEBITACCT,flgMatl, flgLabor, " & vbCrLf
      sSql = sSql & "         flgExp , flgOH " & vbCrLf
      sSql = sSql & "      FROM #tempINVReport a, PartTable " & vbCrLf
      sSql = sSql & "     WHERE PartTable.PartRef = a.PARTNUM" & vbCrLf
      sSql = sSql & "       " & vbCrLf
      sSql = sSql & "-- drop the temp table " & vbCrLf
      sSql = sSql & "DROP table #tempINVReport " & vbCrLf
      sSql = sSql & "End "
      
      ExecuteScript False, sSql
         
      
      If Not TableExists("SINCReportCat") Then
         sSql = "CREATE TABLE SINCReportCat" & vbCrLf
         sSql = sSql & "( " & vbCrLf
         sSql = sSql & "   SINRPTDATE datetime," & vbCrLf
         sSql = sSql & "   SINCPARTREF varchar(30) null, " & vbCrLf
         sSql = sSql & "   SINCMORELCAT1 decimal(12,4) null, " & vbCrLf
         sSql = sSql & "   SINCMORELCAT8 decimal(12,4) null," & vbCrLf
         sSql = sSql & "   SINCMORELCAT15 decimal(12,4) null," & vbCrLf
         sSql = sSql & "   SINCMORELCAT30 decimal(12,4) null," & vbCrLf
         sSql = sSql & "   SINCTOTMOREL decimal(12,4) null," & vbCrLf
         sSql = sSql & "   SINCCUST varchar(10)" & vbCrLf
         sSql = sSql & ")  ON [PRIMARY]"
      
         ExecuteScript False, sSql
         
         
         sSql = "CREATE TABLE [dbo].[SinchdTable](" & vbCrLf
         sSql = sSql & "   [SINCBU_ID] [int] IDENTITY(1,1) NOT NULL," & vbCrLf
         sSql = sSql & "   [SINC_BUCODE] [varchar](4) NOT NULL" & vbCrLf
         sSql = sSql & ") ON [PRIMARY]"
         
         ExecuteScript False, sSql

         sSql = "CREATE TABLE [dbo].[sincbuPCTable](" & vbCrLf
         sSql = sSql & "   [BUCODE] [varchar](5) NULL," & vbCrLf
         sSql = sSql & "   [BUPARTREFCODE] [varchar](30) NULL" & vbCrLf
         sSql = sSql & ") ON [PRIMARY]"
         
         ExecuteScript False, sSql
         
      End If
      
      If StoreProcedureExists("Sinc_ManufacturingReleases") Then
         sSql = "DROP PROCEDURE Sinc_ManufacturingReleases"
         ExecuteScript False, sSql
      End If
      
      sSql = "CREATE PROCEDURE [dbo].[Sinc_ManufacturingReleases] " & vbCrLf
      sSql = sSql & "@StartDate as varchar(16), @EndDate as Varchar(16)" & vbCrLf
      sSql = sSql & "AS " & vbCrLf
      sSql = sSql & "BEGIN " & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   declare @BUPartCode as varchar(30)" & vbCrLf
      sSql = sSql & "   declare @BUCUST as varchar(10)" & vbCrLf
      sSql = sSql & "   declare @BUPartRef as varchar(30)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   declare @OpPartRef as varchar(30) " & vbCrLf
      sSql = sSql & "   declare @OpRunNo as int" & vbCrLf
      sSql = sSql & "   declare @CompleteDays as int" & vbCrLf
      sSql = sSql & "   declare @RunQty as decimal(12,4)" & vbCrLf
      sSql = sSql & "   declare @CatSOCust as varchar(10)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   declare @MORel1 as int" & vbCrLf
      sSql = sSql & "   declare @MORel8 as int" & vbCrLf
      sSql = sSql & "   declare @MORel15 as int" & vbCrLf
      sSql = sSql & "   declare @MORel30 as int" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   declare @TotMOs as int" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   CREATE TABLE #tmpBUParts" & vbCrLf
      sSql = sSql & "   ( " & vbCrLf
      sSql = sSql & "      BUPartRef varchar(30) null," & vbCrLf
      sSql = sSql & "      BUCUST varchar(10) null " & vbCrLf
      sSql = sSql & "   ) " & vbCrLf
      sSql = sSql & "    " & vbCrLf
      sSql = sSql & "   DECLARE curPartCust CURSOR   FOR " & vbCrLf
      sSql = sSql & "      SELECT BUPARTREFCODE,BUCODE FROM sincbuPCTable" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   OPEN curPartCust" & vbCrLf
      sSql = sSql & "   FETCH NEXT FROM curPartCust INTO @BUPartCode, @BUCUST" & vbCrLf
      sSql = sSql & "   WHILE (@@FETCH_STATUS <> -1) " & vbCrLf
      sSql = sSql & "   BEGIN " & vbCrLf
      sSql = sSql & "      IF (@@FETCH_STATUS <> -2) " & vbCrLf
      sSql = sSql & "      BEGIN " & vbCrLf
      sSql = sSql & "         " & vbCrLf
      sSql = sSql & "         INSERT INTO #tmpBUParts (BUPartRef,BUCUST)" & vbCrLf
      sSql = sSql & "            SELECT PARTREF, @BUCUST FROM PARTTABLE WHERE PARTREF LIKE (@BUPartCode + '%')" & vbCrLf
      sSql = sSql & "      End --outer  cursor" & vbCrLf
      sSql = sSql & "       " & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM curPartCust INTO @BUPartCode, @BUCUST" & vbCrLf
      sSql = sSql & "   End " & vbCrLf
      sSql = sSql & "          " & vbCrLf
      sSql = sSql & "   CLOSE curPartCust --// close the cursor " & vbCrLf
      sSql = sSql & "   DEALLOCATE curPartCust" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   CREATE TABLE #tmpRUNParts" & vbCrLf
      sSql = sSql & "   ( " & vbCrLf
      sSql = sSql & "      tmpOPREF varchar(30) null, " & vbCrLf
      sSql = sSql & "      tmpOPRUN int," & vbCrLf
      sSql = sSql & "      tmpBUCUST varchar(10)" & vbCrLf
      sSql = sSql & "      " & vbCrLf
      sSql = sSql & "   ) " & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   INSERT INTO #tmpRUNParts (tmpOPREF, tmpOPRUN, tmpBUCUST)" & vbCrLf
      sSql = sSql & "   (SELECT DISTINCT OPREF, OPRUN, BUCUST FROM RnopTable,#tmpBUParts " & vbCrLf
      sSql = sSql & "    WHERE OPREF = BUPartRef AND " & vbCrLf
      sSql = sSql & "      (OPSCHEDDATE IS NOT NULL) AND (OPNO = 10) " & vbCrLf
      sSql = sSql & "         AND (OPSCHEDDATE BETWEEN @StartDate AND @EndDate)" & vbCrLf
      sSql = sSql & "   UNION" & vbCrLf
      sSql = sSql & "   SELECT DISTINCT OPREF, OPRUN, BUCUST  FROM RnopTable,#tmpBUParts" & vbCrLf
      sSql = sSql & "   WHERE OPREF = BUPartRef AND " & vbCrLf
      sSql = sSql & "      (OPSCHEDDATE IS NOT NULL) AND (OPNO = 10) " & vbCrLf
      sSql = sSql & "         AND (OPCOMPDATE BETWEEN @StartDate AND @EndDate)" & vbCrLf
      sSql = sSql & "   )" & vbCrLf
      sSql = sSql & "   --/ catagerize the parts." & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   DELETE FROM SINCReportCat" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   INSERT INTO SINCReportCat (SINRPTDATE, SINCPARTREF, SINCMORELCAT1,SINCMORELCAT8,SINCMORELCAT15," & vbCrLf
      sSql = sSql & "         SINCMORELCAT30,SINCTOTMOREL,SINCCUST) " & vbCrLf
      sSql = sSql & "      VALUES (@EndDate,'site', 0,0,0,0,0,'site')" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   DECLARE curPartsCat CURSOR   FOR " & vbCrLf
      sSql = sSql & "      SELECT OPREF, OPRUN,DATEDIFF(d, OPSCHEDDATE, " & vbCrLf
      sSql = sSql & "         CASE WHEN OPCOMPDATE IS NULL THEN @EndDate ELSE OPCOMPDATE END) AS completedays, " & vbCrLf
      sSql = sSql & "         RUNQTY, tmpBUCUST " & vbCrLf
      sSql = sSql & "      FROM RnopTable INNER JOIN" & vbCrLf
      sSql = sSql & "         RunsTable ON OPREF = RUNREF " & vbCrLf
      sSql = sSql & "            AND OPRUN = RUNNO INNER JOIN" & vbCrLf
      sSql = sSql & "         #tmpRUNParts ON OPREF = tmpOPREF" & vbCrLf
      sSql = sSql & "            AND OPRUN = tmpOPRUN" & vbCrLf
      sSql = sSql & "      WHERE (OPSCHEDDATE IS NOT NULL) AND (OPNO = 10) " & vbCrLf
      sSql = sSql & "            AND ((OPSCHEDDATE BETWEEN @StartDate AND @EndDate))" & vbCrLf
      sSql = sSql & "      UNION" & vbCrLf
      sSql = sSql & "      SELECT OPREF, OPRUN,DATEDIFF(d, OPSCHEDDATE, " & vbCrLf
      sSql = sSql & "         CASE WHEN OPCOMPDATE IS NULL THEN @EndDate ELSE OPCOMPDATE END) AS completedays, " & vbCrLf
      sSql = sSql & "         RUNQTY, tmpBUCUST" & vbCrLf
      sSql = sSql & "      FROM RnopTable INNER JOIN" & vbCrLf
      sSql = sSql & "         RunsTable ON OPREF = RUNREF " & vbCrLf
      sSql = sSql & "            AND OPRUN = RUNNO INNER JOIN" & vbCrLf
      sSql = sSql & "         #tmpRUNParts ON OPREF = tmpOPREF" & vbCrLf
      sSql = sSql & "            AND OPRUN = tmpOPRUN" & vbCrLf
      sSql = sSql & "      WHERE (OPSCHEDDATE IS NOT NULL) AND (OPNO = 10) " & vbCrLf
      sSql = sSql & "            AND ((OPCOMPDATE BETWEEN @StartDate AND @EndDate))" & vbCrLf
      sSql = sSql & "      ORDER BY OPREF, OPRUN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   OPEN curPartsCat" & vbCrLf
      sSql = sSql & "   FETCH NEXT FROM curPartsCat INTO @OpPartRef, @OpRunNo, @CompleteDays, @RunQty, @CatSOCust" & vbCrLf
      sSql = sSql & "   WHILE (@@FETCH_STATUS <> -1) " & vbCrLf
      sSql = sSql & "   BEGIN " & vbCrLf
      sSql = sSql & "      IF (@@FETCH_STATUS <> -2) " & vbCrLf
      sSql = sSql & "      BEGIN " & vbCrLf
      sSql = sSql & "         " & vbCrLf
      sSql = sSql & "         SET @MORel1 = 0" & vbCrLf
      sSql = sSql & "         SET @MORel8 = 0" & vbCrLf
      sSql = sSql & "         SET @MORel15 = 0" & vbCrLf
      sSql = sSql & "         SET @MORel30 = 0" & vbCrLf
      sSql = sSql & "         " & vbCrLf
      sSql = sSql & "         IF(@CompleteDays > 0)" & vbCrLf
      sSql = sSql & "         BEGIN" & vbCrLf
      sSql = sSql & "            IF  ((@CompleteDays > 0) AND (@CompleteDays < 8))" & vbCrLf
      sSql = sSql & "               SET @MORel1 = 1" & vbCrLf
      sSql = sSql & "            " & vbCrLf
      sSql = sSql & "            IF  ((@CompleteDays > 7) AND (@CompleteDays < 15))" & vbCrLf
      sSql = sSql & "               SET @MORel8 = 1" & vbCrLf
      sSql = sSql & "            " & vbCrLf
      sSql = sSql & "            IF  ((@CompleteDays > 14) AND (@CompleteDays < 31))" & vbCrLf
      sSql = sSql & "               SET @MORel15 = 1" & vbCrLf
      sSql = sSql & "            " & vbCrLf
      sSql = sSql & "            IF  (@CompleteDays > 30)" & vbCrLf
      sSql = sSql & "               SET @MORel30 = 1" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "            " & vbCrLf
      sSql = sSql & "            SELECT * FROM SINCReportCat WHERE SINCPARTREF = @OpPartRef" & vbCrLf
      sSql = sSql & "            IF (@@rowcount > 0)" & vbCrLf
      sSql = sSql & "               UPDATE   SINCReportCat SET SINCMORELCAT1 = SINCMORELCAT1 + @MORel1," & vbCrLf
      sSql = sSql & "                  SINCMORELCAT8 = SINCMORELCAT8 + @MORel8," & vbCrLf
      sSql = sSql & "                  SINCMORELCAT15 = SINCMORELCAT15 + @MORel15," & vbCrLf
      sSql = sSql & "                  SINCMORELCAT30 = SINCMORELCAT30 + @MORel30," & vbCrLf
      sSql = sSql & "                  SINCTOTMOREL = SINCTOTMOREL + 1 WHERE SINCPARTREF = @OpPartRef" & vbCrLf
      sSql = sSql & "            ELSE" & vbCrLf
      sSql = sSql & "               INSERT INTO SINCReportCat (SINRPTDATE, SINCPARTREF, SINCMORELCAT1,SINCMORELCAT8,SINCMORELCAT15," & vbCrLf
      sSql = sSql & "                     SINCMORELCAT30,SINCTOTMOREL,SINCCUST) " & vbCrLf
      sSql = sSql & "                  VALUES (@EndDate,@OpPartRef, @MORel1,@MORel8,@MORel15,@MORel30,1,@CatSOCust)" & vbCrLf
      sSql = sSql & "         END" & vbCrLf
      sSql = sSql & "         " & vbCrLf
      sSql = sSql & "         UPDATE   SINCReportCat SET SINCMORELCAT1 = SINCMORELCAT1 + @MORel1," & vbCrLf
      sSql = sSql & "            SINCMORELCAT8 = SINCMORELCAT8 + @MORel8," & vbCrLf
      sSql = sSql & "            SINCMORELCAT15 = SINCMORELCAT15 + @MORel15," & vbCrLf
      sSql = sSql & "            SINCMORELCAT30 = SINCMORELCAT30 + @MORel30" & vbCrLf
      sSql = sSql & "            WHERE SINCPARTREF = 'site'" & vbCrLf
      sSql = sSql & "         --SINCTOTMOREL = SINCTOTMOREL + 1 " & vbCrLf
      sSql = sSql & "         " & vbCrLf
      sSql = sSql & "      End --outer  cursor" & vbCrLf
      sSql = sSql & "       " & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM curPartsCat INTO @OpPartRef, @OpRunNo, @CompleteDays, @RunQty, @CatSOCust" & vbCrLf
      sSql = sSql & "   End " & vbCrLf
      sSql = sSql & "    " & vbCrLf
      sSql = sSql & "    -- Update the TOT MO's for the whole period" & vbCrLf
      sSql = sSql & "    " & vbCrLf
      sSql = sSql & "   CLOSE curPartsCat --// close the cursor " & vbCrLf
      sSql = sSql & "   DEALLOCATE curPartsCat " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   SELECT DISTINCT @TotMOs = COUNT(*)" & vbCrLf
      sSql = sSql & "   FROM RnopTable WHERE (OPSCHEDDATE IS NOT NULL) AND (OPNO = 10) " & vbCrLf
      sSql = sSql & "      AND ((OPSCHEDDATE BETWEEN @StartDate AND @EndDate)" & vbCrLf
      sSql = sSql & "         OR (OPCOMPDATE BETWEEN @StartDate AND @EndDate))" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   UPDATE   SINCReportCat SET SINCTOTMOREL = @TotMOs" & vbCrLf
      sSql = sSql & "      WHERE SINCPARTREF = 'site'" & vbCrLf
      sSql = sSql & "   --SINCTOTMOREL = SINCTOTMOREL + 1 " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   SELECT SINRPTDATE,SINCPARTREF,PARTNUM, SINCMORELCAT1,SINCMORELCAT8,SINCMORELCAT15," & vbCrLf
      sSql = sSql & "         SINCMORELCAT30,SINCTOTMOREL,SINCCUST FROM SINCReportCat,PartTable" & vbCrLf
      sSql = sSql & "      WHERE PARTREF = SINCPARTREF" & vbCrLf
      sSql = sSql & "   ORDER BY SINCPARTREF" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   -- drop the temp table " & vbCrLf
      sSql = sSql & "   DROP TABLE #tmpBUParts" & vbCrLf
      sSql = sSql & "   DROP TABLE #tmpRUNParts" & vbCrLf
      sSql = sSql & "End "
   
      ExecuteScript False, sSql
      
      ' update the version
      ExecuteScript False, "Update Version Set Version = " & newver
   
   End If
End Function

Private Function UpdateDatabase47()
   newver = 121
   If ver < newver Then
   
      If ColumnExists("ComnTable", "COLASTSALESORDER") Then
         sSql = "Alter Table ComnTable Alter Column COLASTSALESORDER char(7)"
         ExecuteScript False, sSql
      End If

      
      ' update the version
      ExecuteScript False, "Update Version Set Version = " & newver
   
   End If
End Function

Private Function UpdateDatabase48()
   newver = 122
   If ver < newver Then
   
      If ColumnExists("EsReportLots01h", "LotExpDate") Then
         sSql = "ALTER TABLE EsReportLots01h ADD LotExpDate datetime"
         ExecuteScript False, sSql
      End If

      sSql = "ALTER PROCEDURE [dbo].[RptInventoryAdjustments] " & vbCrLf
      sSql = sSql & "@StartDate as varchar(16), @EndDate as Varchar(16), @PartClass as Varchar(16),@PartCode as varchar(8) " & vbCrLf
      sSql = sSql & "AS " & vbCrLf
      sSql = sSql & "BEGIN " & vbCrLf
      sSql = sSql & "   declare @partRef as varchar(30) " & vbCrLf
      sSql = sSql & "   declare @partNum as varchar(30) " & vbCrLf
      sSql = sSql & "   declare @partDesc as varchar(30) " & vbCrLf
      sSql = sSql & "   declare @partExDesc as varchar(3072) " & vbCrLf
      sSql = sSql & "   declare @lotNum as varchar(15) " & vbCrLf
      sSql = sSql & "   declare @lotUserID as varchar(40) " & vbCrLf
      sSql = sSql & "   declare @Inno as Int " & vbCrLf
      sSql = sSql & "   declare @actualDt as varchar(30) " & vbCrLf
      sSql = sSql & "   declare @qty as int " & vbCrLf
      sSql = sSql & "   declare @invAmt as decimal(12,4) " & vbCrLf
      sSql = sSql & "   declare @invTotMatl decimal(12,4) " & vbCrLf
      sSql = sSql & "   declare @invTotLabor decimal(12,4) " & vbCrLf
      sSql = sSql & "   declare @invTotExp decimal(12,4) " & vbCrLf
      sSql = sSql & "   declare @invTotOH decimal(12,4) " & vbCrLf
      sSql = sSql & "   declare @creditAcc varchar(12)" & vbCrLf
      sSql = sSql & "   declare @debitAcc varchar(12)" & vbCrLf
      sSql = sSql & "   declare @lotTotMatl decimal(12,4) " & vbCrLf
      sSql = sSql & "   declare @lotTotLabor decimal(12,4) " & vbCrLf
      sSql = sSql & "   declare @lotTotExp decimal(12,4) " & vbCrLf
      sSql = sSql & "   declare @lotTotOH decimal(12,4) " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   declare @totMatlCost decimal(12,4) " & vbCrLf
      sSql = sSql & "   declare @totLaborCost decimal(12,4) " & vbCrLf
      sSql = sSql & "   declare @totExpCost decimal(12,4) " & vbCrLf
      sSql = sSql & "   declare @totOHCost decimal(12,4) " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   declare @fInvMatl int " & vbCrLf
      sSql = sSql & "   declare @fInvLabor int " & vbCrLf
      sSql = sSql & "   declare @fInvExp int " & vbCrLf
      sSql = sSql & "   declare @fInvOH int " & vbCrLf
      sSql = sSql & "                   " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "    IF (@PartClass = 'ALL') " & vbCrLf
      sSql = sSql & "    BEGIN " & vbCrLf
      sSql = sSql & "      SET @PartClass = '' " & vbCrLf
      sSql = sSql & "    End " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "    IF (@PartCode = 'ALL') " & vbCrLf
      sSql = sSql & "    BEGIN " & vbCrLf
      sSql = sSql & "      SET @PartCode = '' " & vbCrLf
      sSql = sSql & "    End " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   CREATE TABLE #tempINVReport " & vbCrLf
      sSql = sSql & "   ( " & vbCrLf
      sSql = sSql & "      PARTNUM Varchar(30) NULL, " & vbCrLf
      sSql = sSql & "      PADESC varchar(30) NULL , " & vbCrLf
      sSql = sSql & "      PAEXTDESC varchar(3072) NULL , " & vbCrLf
      sSql = sSql & "     LOTNUMBER varchar(15) NULL, " & vbCrLf
      sSql = sSql & "     LOTUSERLOTID varchar(40) NULL, " & vbCrLf
      sSql = sSql & "     INNO int NULL, " & vbCrLf
      sSql = sSql & "      INADATE varchar(30) NULL, " & vbCrLf
      sSql = sSql & "      INAQTY decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      INAMT decimal (12,4) NULL, " & vbCrLf
      sSql = sSql & "       TOTMATL decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "       TOTLABOR decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "       TOTEXP decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "       TOTOH decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      CREDITACCT varchar(12) NULL, " & vbCrLf
      sSql = sSql & "      DEBITACCT varchar(12) NULL, " & vbCrLf
      sSql = sSql & "      flgMatl int NULL, " & vbCrLf
      sSql = sSql & "      flgLabor int NULL, " & vbCrLf
      sSql = sSql & "      flgExp int NULL, " & vbCrLf
      sSql = sSql & "      flgOH int NULL " & vbCrLf
      sSql = sSql & "   ) " & vbCrLf
      sSql = sSql & "    " & vbCrLf
      sSql = sSql & "   DECLARE curInvRpt CURSOR   FOR " & vbCrLf
      sSql = sSql & "      SELECT INPART, LOTNUMBER, LOTUSERLOTID, INNO, INADATE, " & vbCrLf
      sSql = sSql & "         INAQTY, INAMT, INTOTMATL, " & vbCrLf
      sSql = sSql & "         INTOTLABOR, INTOTEXP, INTOTOH, " & vbCrLf
      sSql = sSql & "         INCREDITACCT, INDEBITACCT, LOTTOTMATL, " & vbCrLf
      sSql = sSql & "         LOTTOTLABOR, LOTTOTEXP, LOTTOTOH, " & vbCrLf
      sSql = sSql & "         PartNum , PADESC, PAEXTDESC " & vbCrLf
      sSql = sSql & "      From viewRptInventoryAdjustments, PartTable " & vbCrLf
      sSql = sSql & "      Where viewRptInventoryAdjustments.INPART = PartTable.PartRef " & vbCrLf
      sSql = sSql & "         AND viewRptInventoryAdjustments.INADATE BETWEEN @StartDate AND @EndDate" & vbCrLf
      sSql = sSql & "         AND PartTable.PACLASS LIKE '%' + @PartClass + '%' " & vbCrLf
      sSql = sSql & "         AND PartTable.PAPRODCODE LIKE '%' + @PartCode + '%' " & vbCrLf
      sSql = sSql & "--         AND INPART = '65B801038' " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   OPEN curInvRpt " & vbCrLf
      sSql = sSql & "   FETCH NEXT FROM curInvRpt INTO @partRef, @lotNum, @lotUserID, @Inno, @actualDt, @qty, " & vbCrLf
      sSql = sSql & "                  @invAmt, @invTotMatl, @invTotLabor, " & vbCrLf
      sSql = sSql & "                  @invTotExp,@invTotOH, @creditAcc, @debitAcc, " & vbCrLf
      sSql = sSql & "                  @lotTotMatl, @lotTotLabor, @lotTotExp, @lotTotOH, " & vbCrLf
      sSql = sSql & "                  @partNum, @partDesc, @partExDesc " & vbCrLf
      sSql = sSql & "   WHILE (@@FETCH_STATUS <> -1) " & vbCrLf
      sSql = sSql & "   BEGIN " & vbCrLf
      sSql = sSql & "      IF (@@FETCH_STATUS <> -2) " & vbCrLf
      sSql = sSql & "      BEGIN " & vbCrLf
      sSql = sSql & "          " & vbCrLf
      sSql = sSql & "         -- Get the costed values from Lothd table " & vbCrLf
      sSql = sSql & "         -- if the Inv table does not have the cost for " & vbCrLf
      sSql = sSql & "         -- material, expenses, OH and Labour. " & vbCrLf
      sSql = sSql & "         SET @totMatlCost = @invTotMatl " & vbCrLf
      sSql = sSql & "         SET @fInvMatl = 1 " & vbCrLf
      sSql = sSql & "         IF (@invTotMatl = 0.0000) " & vbCrLf
      sSql = sSql & "         BEGIN " & vbCrLf
      sSql = sSql & "            IF (@lotTotMatl IS NOT NULL) " & vbCrLf
      sSql = sSql & "            BEGIN " & vbCrLf
      sSql = sSql & "               SET @totMatlCost = @lotTotMatl " & vbCrLf
      sSql = sSql & "               SET @fInvMatl = 0 " & vbCrLf
      sSql = sSql & "            End " & vbCrLf
      sSql = sSql & "         End " & vbCrLf
      sSql = sSql & "         -- Labour " & vbCrLf
      sSql = sSql & "         SET @totLaborCost = @invTotLabor " & vbCrLf
      sSql = sSql & "         SET @fInvLabor = 1 " & vbCrLf
      sSql = sSql & "         IF (@invTotLabor = 0.0000) " & vbCrLf
      sSql = sSql & "         BEGIN " & vbCrLf
      sSql = sSql & "            IF (@lotTotLabor IS NOT NULL) " & vbCrLf
      sSql = sSql & "            BEGIN " & vbCrLf
      sSql = sSql & "               SET @totLaborCost = @lotTotLabor " & vbCrLf
      sSql = sSql & "               SET @fInvLabor = 0 " & vbCrLf
      sSql = sSql & "            End " & vbCrLf
      sSql = sSql & "         End " & vbCrLf
      sSql = sSql & "         -- Exp " & vbCrLf
      sSql = sSql & "         SET @totExpCost = @invTotExp " & vbCrLf
      sSql = sSql & "         SET @fInvExp = 1 " & vbCrLf
      sSql = sSql & "         IF (@invTotExp = 0.0000) " & vbCrLf
      sSql = sSql & "         BEGIN " & vbCrLf
      sSql = sSql & "            IF (@lotTotExp IS NOT NULL) " & vbCrLf
      sSql = sSql & "            BEGIN " & vbCrLf
      sSql = sSql & "               SET @totExpCost = @lotTotExp " & vbCrLf
      sSql = sSql & "               SET @fInvExp = 0 " & vbCrLf
      sSql = sSql & "            End " & vbCrLf
      sSql = sSql & "         End " & vbCrLf
      sSql = sSql & "         -- OH " & vbCrLf
      sSql = sSql & "         SET @totOHCost = @invTotOH " & vbCrLf
      sSql = sSql & "         SET @fInvOH = 1 " & vbCrLf
      sSql = sSql & "         IF (@invTotOH = 0.0000) " & vbCrLf
      sSql = sSql & "         BEGIN " & vbCrLf
      sSql = sSql & "            IF (@lotTotOH IS NOT NULL) " & vbCrLf
      sSql = sSql & "            BEGIN " & vbCrLf
      sSql = sSql & "               SET @totOHCost = @lotTotOH " & vbCrLf
      sSql = sSql & "               SET @fInvOH = 0 " & vbCrLf
      sSql = sSql & "            End " & vbCrLf
      sSql = sSql & "         End " & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "         -- Insert to the temp table " & vbCrLf
      sSql = sSql & "         INSERT INTO #tempINVReport (PARTNUM, LOTNUMBER, LOTUSERLOTID, " & vbCrLf
      sSql = sSql & "            INNO, PADESC, PAEXTDESC, INADATE, " & vbCrLf
      sSql = sSql & "               INAQTY,INAMT, TOTMATL,TOTLABOR,TOTEXP,TOTOH, CREDITACCT, DEBITACCT, " & vbCrLf
      sSql = sSql & "               flgMatl, flgLabor, flgExp, flgOH) " & vbCrLf
      sSql = sSql & "         VALUES (@partNum, @lotNum, @lotUserID, @Inno, @partDesc, @partExDesc, @actualDt,@qty, " & vbCrLf
      sSql = sSql & "               @invAmt,@totMatlCost,@totLaborCost,@totExpCost,@totOHCost, " & vbCrLf
      sSql = sSql & "               @creditAcc,@debitAcc,@fInvMatl,@fInvLabor,@fInvExp,@fInvOH) " & vbCrLf
      sSql = sSql & "     End " & vbCrLf
      sSql = sSql & "       " & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM curInvRpt INTO @partRef, @lotNum, @lotUserID, @Inno, @actualDt, @qty, " & vbCrLf
      sSql = sSql & "               @invAmt, @invTotMatl, @invTotLabor, " & vbCrLf
      sSql = sSql & "               @invTotExp,@invTotOH, @creditAcc, @debitAcc, " & vbCrLf
      sSql = sSql & "               @lotTotMatl, @lotTotLabor, @lotTotExp, @lotTotOH, " & vbCrLf
      sSql = sSql & "               @partNum, @partDesc, @partExDesc " & vbCrLf
      sSql = sSql & "   End " & vbCrLf
      sSql = sSql & "          " & vbCrLf
      sSql = sSql & "   CLOSE curInvRpt   --// close the cursor " & vbCrLf
      sSql = sSql & "   DEALLOCATE curInvRpt " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   -- select data for the report " & vbCrLf
      sSql = sSql & "   SELECT a.PARTNUM as PARTNUM, LOTNUMBER, LOTUSERLOTID, INNO, " & vbCrLf
      sSql = sSql & "      a.PADESC as PADESC, a.PAEXTDESC as PAEXTDESC, PALEVEL, INADATE, " & vbCrLf
      sSql = sSql & "         INAQTY,INAMT, TOTMATL,TOTLABOR,TOTEXP,TOTOH, " & vbCrLf
      sSql = sSql & "         CREDITACCT, DEBITACCT,flgMatl, flgLabor, " & vbCrLf
      sSql = sSql & "         flgExp , flgOH " & vbCrLf
      sSql = sSql & "      FROM #tempINVReport a, PartTable " & vbCrLf
      sSql = sSql & "     WHERE PartTable.PARTNUM = a.PARTNUM" & vbCrLf
      sSql = sSql & "       " & vbCrLf
      sSql = sSql & "-- drop the temp table " & vbCrLf
      sSql = sSql & "DROP table #tempINVReport " & vbCrLf
      sSql = sSql & "End "
      
      ExecuteScript False, sSql
      
      sSql = "ALTER VIEW [dbo].[viewRptInventoryAdjustments]" & vbCrLf
      sSql = sSql & "AS" & vbCrLf
      sSql = sSql & "SELECT     dbo.InvaTable.INTYPE, dbo.InvaTable.INPART, dbo.InvaTable.INADATE, dbo.InvaTable.INREF1, dbo.InvaTable.INAQTY, dbo.InvaTable.INAMT, " & vbCrLf
      sSql = sSql & "                      dbo.InvaTable.INTOTMATL, dbo.InvaTable.INTOTLABOR, dbo.InvaTable.INTOTEXP, dbo.InvaTable.INTOTOH, dbo.InvaTable.INCREDITACCT, " & vbCrLf
      sSql = sSql & "                      dbo.InvaTable.INDEBITACCT, dbo.LohdTable.LOTUNITCOST, dbo.LohdTable.LOTTOTMATL, dbo.LohdTable.LOTTOTLABOR, dbo.LohdTable.LOTTOTEXP, " & vbCrLf
      sSql = sSql & "                      dbo.LohdTable.LOTTOTOH, dbo.LohdTable.LOTNUMBER, dbo.LohdTable.LOTUSERLOTID, dbo.InvaTable.INNO" & vbCrLf
      sSql = sSql & "FROM         dbo.LoitTable INNER JOIN" & vbCrLf
      sSql = sSql & "                      dbo.LohdTable ON dbo.LoitTable.LOINUMBER = dbo.LohdTable.LOTNUMBER RIGHT OUTER JOIN" & vbCrLf
      sSql = sSql & "                      dbo.InvaTable ON dbo.LoitTable.LOIPARTREF = dbo.InvaTable.INPART AND dbo.LoitTable.LOIACTIVITY = dbo.InvaTable.INNUMBER" & vbCrLf
      sSql = sSql & "WHERE     (dbo.InvaTable.INTYPE = 19) OR" & vbCrLf
      sSql = sSql & "                      (dbo.InvaTable.INTYPE = 30)"
      
      ExecuteScript False, sSql
      
      ' update the version
      ExecuteScript False, "Update Version Set Version = " & newver
   
   End If
End Function


Private Function UpdateDatabase49()
   newver = 123
   If ver < newver Then
   
      If Not StoreProcedureExists("RptVendorProfile") Then
         
         sSql = "CREATE PROCEDURE [dbo].[RptVendorProfile]" & vbCrLf
         sSql = sSql & "@StartDate as varchar(12),@EndDate as varchar(12) AS" & vbCrLf
         sSql = sSql & "BEGIN " & vbCrLf
         sSql = sSql & "   SELECT DISTINCT 'Minority-owned Business' as VndrBusType, " & vbCrLf
         sSql = sSql & "      VndrTable.VENICKNAME, VndrTable.VEBNAME, VihdTable.VINO, " & vbCrLf
         sSql = sSql & "      VihdTable.VIDATE, VihdTable.VIDTRECD, VihdTable.VIPIF, VihdTable.VIDUE, " & vbCrLf
         sSql = sSql & "      VihdTable.VIDUEDATE, VihdTable.VICHECKNO, VihdTable.VITYPE" & vbCrLf
         sSql = sSql & "   FROM" & vbCrLf
         sSql = sSql & "      VndrTable VndrTable INNER JOIN VihdTable VihdTable ON" & vbCrLf
         sSql = sSql & "         VndrTable.VEREF = VihdTable.VIVENDOR" & vbCrLf
         sSql = sSql & "   WHERE VihdTable.VIDATE BETWEEN @StartDate and @EndDate AND VEMINBUS = 1--, VEMINBUS , VESWMNBUS" & vbCrLf
         sSql = sSql & "   UNION" & vbCrLf
         sSql = sSql & "   SELECT DISTINCT 'Small Business' as VndrBusType, " & vbCrLf
         sSql = sSql & "      VndrTable.VENICKNAME, VndrTable.VEBNAME, VihdTable.VINO, " & vbCrLf
         sSql = sSql & "      VihdTable.VIDATE, VihdTable.VIDTRECD, VihdTable.VIPIF, VihdTable.VIDUE, " & vbCrLf
         sSql = sSql & "      VihdTable.VIDUEDATE, VihdTable.VICHECKNO, VihdTable.VITYPE" & vbCrLf
         sSql = sSql & "   FROM" & vbCrLf
         sSql = sSql & "      VndrTable VndrTable INNER JOIN VihdTable VihdTable ON" & vbCrLf
         sSql = sSql & "         VndrTable.VEREF = VihdTable.VIVENDOR" & vbCrLf
         sSql = sSql & "   WHERE VihdTable.VIDATE BETWEEN @StartDate and @EndDate AND VESMALLBUS = 1--, VEMINBUS , VESWMNBUS" & vbCrLf
         sSql = sSql & "   UNION" & vbCrLf
         sSql = sSql & "   SELECT DISTINCT 'Woman-owned Business' as VndrBusType, " & vbCrLf
         sSql = sSql & "      VndrTable.VENICKNAME, VndrTable.VEBNAME, VihdTable.VINO, " & vbCrLf
         sSql = sSql & "      VihdTable.VIDATE, VihdTable.VIDTRECD, VihdTable.VIPIF, VihdTable.VIDUE, " & vbCrLf
         sSql = sSql & "      VihdTable.VIDUEDATE, VihdTable.VICHECKNO, VihdTable.VITYPE" & vbCrLf
         sSql = sSql & "   FROM" & vbCrLf
         sSql = sSql & "      VndrTable VndrTable INNER JOIN VihdTable VihdTable ON" & vbCrLf
         sSql = sSql & "         VndrTable.VEREF = VihdTable.VIVENDOR" & vbCrLf
         sSql = sSql & "   WHERE VihdTable.VIDATE BETWEEN @StartDate and @EndDate AND VESWMNBUS = 1--, VEMINBUS , VESWMNBUS" & vbCrLf
         sSql = sSql & "   ORDER BY" & vbCrLf
         sSql = sSql & "      VndrTable.VENICKNAME ASC" & vbCrLf
         sSql = sSql & "END"
         
         ExecuteScript False, sSql
      End If
            
      If Not StoreProcedureExists("Sinc_DeliverySupplyBase") Then
         
         sSql = "CREATE PROCEDURE [dbo].[Sinc_DeliverySupplyBase] " & vbCrLf
         sSql = sSql & "@StartDate as varchar(16), @EndDate as Varchar(16)" & vbCrLf
         sSql = sSql & "AS " & vbCrLf
         sSql = sSql & "BEGIN " & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "   declare @BUPartCode as varchar(30)" & vbCrLf
         sSql = sSql & "   declare @BUCUST as varchar(10)" & vbCrLf
         sSql = sSql & "   declare @BUPartRef as varchar(30)" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "   --//DELETE FROM tmpBUParts" & vbCrLf
         sSql = sSql & "   CREATE TABLE #tmpBUParts" & vbCrLf
         sSql = sSql & "   ( " & vbCrLf
         sSql = sSql & "      BUPartRef varchar(30) null," & vbCrLf
         sSql = sSql & "      BUCUST varchar(10) null " & vbCrLf
         sSql = sSql & "   ) " & vbCrLf
         sSql = sSql & "    " & vbCrLf
         sSql = sSql & "   DECLARE curPartCust CURSOR   FOR " & vbCrLf
         sSql = sSql & "      SELECT BUPARTREFCODE,BUCODE FROM sincbuPCTable" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "   OPEN curPartCust" & vbCrLf
         sSql = sSql & "   FETCH NEXT FROM curPartCust INTO @BUPartCode, @BUCUST" & vbCrLf
         sSql = sSql & "   WHILE (@@FETCH_STATUS <> -1) " & vbCrLf
         sSql = sSql & "   BEGIN " & vbCrLf
         sSql = sSql & "     IF (@@FETCH_STATUS <> -2) " & vbCrLf
         sSql = sSql & "     BEGIN " & vbCrLf
         sSql = sSql & "        " & vbCrLf
         sSql = sSql & "       INSERT INTO #tmpBUParts (BUPartRef,BUCUST)" & vbCrLf
         sSql = sSql & "         SELECT PARTREF, @BUCUST FROM PARTTABLE WHERE PARTREF LIKE (@BUPartCode + '%')" & vbCrLf
         sSql = sSql & "     End --outer  cursor" & vbCrLf
         sSql = sSql & "      " & vbCrLf
         sSql = sSql & "     FETCH NEXT FROM curPartCust INTO @BUPartCode, @BUCUST" & vbCrLf
         sSql = sSql & "   End " & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "   CLOSE curPartCust --// close the cursor " & vbCrLf
         sSql = sSql & "   DEALLOCATE curPartCust" & vbCrLf
         sSql = sSql & " " & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "   --DROP TABLE tmpPOPart" & vbCrLf
         sSql = sSql & "   CREATE TABLE #tmpPOPart" & vbCrLf
         sSql = sSql & "   ( " & vbCrLf
         sSql = sSql & "      tmpPartRef varchar(30)," & vbCrLf
         sSql = sSql & "      tmpBUCUST varchar(10)," & vbCrLf
         sSql = sSql & "      tmpOntimeQty decimal(18,2) null," & vbCrLf
         sSql = sSql & "      tmpLateQty decimal(18,2) null" & vbCrLf
         sSql = sSql & "   ) " & vbCrLf
         sSql = sSql & "--//  DELETE FROM tmpPOPart" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "   INSERT INTO #tmpPOPart(tmpPartRef, tmpBUCUST, tmpOntimeQty, tmpLateQty)" & vbCrLf
         sSql = sSql & "   SELECT PIRUNPART,BUCUST, SUM(PIPQTY) as OntimeQty, 0 as LateQty FROM PoitTable, #tmpBUParts" & vbCrLf
         sSql = sSql & "      WHERE PIRUNPART = BUPARTREF AND PIPDATE >= PIODDELDATE AND PIRUNPART <> '' " & vbCrLf
         sSql = sSql & "         AND PIPDATE BETWEEN @StartDate AND @EndDate" & vbCrLf
         sSql = sSql & "   GROUP BY PIRUNPART, BUCUST" & vbCrLf
         sSql = sSql & "   UNION" & vbCrLf
         sSql = sSql & "   SELECT PIRUNPART,BUCUST, 0 as OntimeQty,SUM(PIPQTY) as LateQty FROM PoitTable, #tmpBUParts" & vbCrLf
         sSql = sSql & "      WHERE PIRUNPART = BUPARTREF AND PIPDATE < PIODDELDATE AND PIRUNPART <> '' " & vbCrLf
         sSql = sSql & "      AND PIPDATE BETWEEN @StartDate AND @EndDate" & vbCrLf
         sSql = sSql & "   GROUP BY PIRUNPART,BUCUST" & vbCrLf
         sSql = sSql & "   ORDER BY PIRUNPART" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "   SELECT tmpPartRef, tmpBUCUST, SUM(tmpOntimeQty) OntimeQty, SUM(tmpLateQty) as LateQty," & vbCrLf
         sSql = sSql & "      (SUM(tmpOntimeQty) + SUM(tmpLateQty)) as TotQty" & vbCrLf
         sSql = sSql & "   FROM #tmpPOPart GROUP BY tmpPartRef, tmpBUCUST" & vbCrLf
         sSql = sSql & "   ORDER BY tmpPartRef" & vbCrLf
         sSql = sSql & "   " & vbCrLf
         sSql = sSql & "   DROP TABLE #tmpPOPart" & vbCrLf
         sSql = sSql & "   DROP TABLE #tmpBUParts" & vbCrLf
         sSql = sSql & "End "
         
         ExecuteScript False, sSql
      End If
      
      If Not StoreProcedureExists("Sinc_QualitySupplyBase") Then
      
         sSql = "CREATE PROCEDURE [dbo].[Sinc_QualitySupplyBase] " & vbCrLf
         sSql = sSql & "@StartDate as varchar(16), @EndDate as Varchar(16)" & vbCrLf
         sSql = sSql & "AS " & vbCrLf
         sSql = sSql & "BEGIN " & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "   declare @BUPartCode as varchar(30)" & vbCrLf
         sSql = sSql & "   declare @BUCUST as varchar(10)" & vbCrLf
         sSql = sSql & "   declare @BUPartRef as varchar(30)" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "   CREATE TABLE #tmpBUParts" & vbCrLf
         sSql = sSql & "   ( " & vbCrLf
         sSql = sSql & "      BUPartRef varchar(30) null," & vbCrLf
         sSql = sSql & "      BUCUST varchar(10) null " & vbCrLf
         sSql = sSql & "   ) " & vbCrLf
         sSql = sSql & "    " & vbCrLf
         sSql = sSql & "   DECLARE curPartCust CURSOR   FOR " & vbCrLf
         sSql = sSql & "      SELECT BUPARTREFCODE,BUCODE FROM sincbuPCTable" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "   OPEN curPartCust" & vbCrLf
         sSql = sSql & "   FETCH NEXT FROM curPartCust INTO @BUPartCode, @BUCUST" & vbCrLf
         sSql = sSql & "   WHILE (@@FETCH_STATUS <> -1) " & vbCrLf
         sSql = sSql & "   BEGIN " & vbCrLf
         sSql = sSql & "     IF (@@FETCH_STATUS <> -2) " & vbCrLf
         sSql = sSql & "     BEGIN " & vbCrLf
         sSql = sSql & "        " & vbCrLf
         sSql = sSql & "       INSERT INTO #tmpBUParts (BUPartRef,BUCUST)" & vbCrLf
         sSql = sSql & "         SELECT PARTREF, @BUCUST FROM PARTTABLE WHERE PARTREF LIKE (@BUPartCode + '%')" & vbCrLf
         sSql = sSql & "     End --outer  cursor" & vbCrLf
         sSql = sSql & "      " & vbCrLf
         sSql = sSql & "     FETCH NEXT FROM curPartCust INTO @BUPartCode, @BUCUST" & vbCrLf
         sSql = sSql & "   End " & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "   CLOSE curPartCust --// close the cursor " & vbCrLf
         sSql = sSql & "   DEALLOCATE curPartCust" & vbCrLf
         sSql = sSql & " " & vbCrLf
         sSql = sSql & "   SELECT PIRUNPART,BUCUST, SUM(PIONDOCKQTYREJ) as DOCKQTYREJ, " & vbCrLf
         sSql = sSql & "      SUM(PIONDOCKQTYACC) AS DOCKQTYACC FROM PoitTable, #tmpBUParts" & vbCrLf
         sSql = sSql & "      WHERE PIRUNPART = BUPARTREF AND PIONDOCKINSPDATE BETWEEN @StartDate AND @EndDate" & vbCrLf
         sSql = sSql & "   GROUP BY PIRUNPART, BUCUST" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "   DROP TABLE #tmpBUParts" & vbCrLf
         sSql = sSql & "End "
         
         ExecuteScript False, sSql
      End If
      
      ' update the version
      ExecuteScript False, "Update Version Set Version = " & newver
   
   End If
End Function


Private Function UpdateDatabase50()
   newver = 124
   If ver < newver Then
   
      If StoreProcedureExists("InventoryExcessReport") Then
         sSql = "DROP PROCEDURE InventoryExcessReport"
         ExecuteScript False, sSql
      End If
      
      sSql = "CREATE PROCEDURE [dbo].[InventoryExcessReport] " & vbCrLf
      sSql = sSql & "          @BeginDate as varchar(16), @EndDate as varchar(16), @PartClass as Varchar(16), " & vbCrLf
      sSql = sSql & "          @PartCode as varchar(8), @InclZQty as Integer, @PartType1 as Integer, " & vbCrLf
      sSql = sSql & "          @PartType2 as Integer, @PartType3 as Integer, @PartType4 as Integer" & vbCrLf
      sSql = sSql & "      AS                                    " & vbCrLf
      sSql = sSql & "      BEGIN                                 " & vbCrLf
      sSql = sSql & "                                            " & vbCrLf
      sSql = sSql & "          declare @sqlZQty as varchar(12)   " & vbCrLf
      sSql = sSql & "                                            " & vbCrLf
      sSql = sSql & "          IF (@PartClass = 'ALL')           " & vbCrLf
      sSql = sSql & "          BEGIN                             " & vbCrLf
      sSql = sSql & "              SET @PartClass = ''           " & vbCrLf
      sSql = sSql & "          End                               " & vbCrLf
      sSql = sSql & "          IF (@PartCode = 'ALL')            " & vbCrLf
      sSql = sSql & "          BEGIN                             " & vbCrLf
      sSql = sSql & "              SET @PartCode = ''            " & vbCrLf
      sSql = sSql & "          End                               " & vbCrLf
      sSql = sSql & "                                            " & vbCrLf
      sSql = sSql & "          IF (@PartType1 = 1)               " & vbCrLf
      sSql = sSql & "              SET @PartType1 = 1            " & vbCrLf
      sSql = sSql & "          Else                              " & vbCrLf
      sSql = sSql & "              SET @PartType1 = 0            " & vbCrLf
      sSql = sSql & "                                            " & vbCrLf
      sSql = sSql & "          IF (@PartType2 = 1)               " & vbCrLf
      sSql = sSql & "              SET @PartType2 = 2            " & vbCrLf
      sSql = sSql & "     Else                              " & vbCrLf
      sSql = sSql & "        SET @PartType2 = 0                " & vbCrLf
      sSql = sSql & "                                          " & vbCrLf
      sSql = sSql & "    IF (@PartType3 = 1)                   " & vbCrLf
      sSql = sSql & "        SET @PartType3 = 3                " & vbCrLf
      sSql = sSql & "    Else                                  " & vbCrLf
      sSql = sSql & "        SET @PartType3 = 0                " & vbCrLf
      sSql = sSql & "                                          " & vbCrLf
      sSql = sSql & "    IF (@PartType4 = 1)                   " & vbCrLf
      sSql = sSql & "        SET @PartType4 = 4                " & vbCrLf
      sSql = sSql & "    Else                                  " & vbCrLf
      sSql = sSql & "        SET @PartType4 = 0                " & vbCrLf
      sSql = sSql & "                                          " & vbCrLf
      sSql = sSql & "    CREATE TABLE #tempExRpt               " & vbCrLf
      sSql = sSql & "    (                                     " & vbCrLf
      sSql = sSql & "        PACLASS varchar(4) NULL ,         " & vbCrLf
      sSql = sSql & "        PAPRODCODE varchar(6) NULL ,      " & vbCrLf
      sSql = sSql & "        PALEVEL tinyint NULL ,            " & vbCrLf
      sSql = sSql & "        PADESC varchar(30) NULL ,         " & vbCrLf
      sSql = sSql & "        PAEXTDESC varchar(3072) NULL ,    " & vbCrLf
      sSql = sSql & "        INPART varchar(30) NULL ,         " & vbCrLf
      sSql = sSql & "        INNUMBER int NULL ,               " & vbCrLf
      sSql = sSql & "        INTYPE int NULL ,                 " & vbCrLf
      sSql = sSql & "        INAMT decimal(12,4) NULL ,        " & vbCrLf
      sSql = sSql & "        LOTUNITCOST decimal(12,4) NULL ,  " & vbCrLf
      sSql = sSql & "        LOTNUMBER varchar(15) NULL,       " & vbCrLf
      sSql = sSql & "        LOTUSERLOTID varchar(40) NULL,       " & vbCrLf
      sSql = sSql & "        LOIQUANTITY decimal(12,4) NULL ,      " & vbCrLf
      sSql = sSql & "        LOTREMAININGQTY decimal(12,4) NULL ,  " & vbCrLf
      sSql = sSql & "        INADATE smalldatetime NULL ,          " & vbCrLf
      sSql = sSql & "        LOTADATE smalldatetime NULL ,         " & vbCrLf
      sSql = sSql & "        LOIMOPARTREF varchar(30) NULL         " & vbCrLf
      sSql = sSql & "    )                                          " & vbCrLf
      sSql = sSql & "                                              " & vbCrLf
      sSql = sSql & "    IF (@InclZQty = 1)                        " & vbCrLf
      sSql = sSql & "                                              " & vbCrLf
      sSql = sSql & "        INSERT INTO #tempExRpt (PACLASS, PAPRODCODE, PALEVEL,                             " & vbCrLf
      sSql = sSql & "            PADESC, PAEXTDESC, INPART , INNUMBER, INTYPE, INAMT,                          " & vbCrLf
      sSql = sSql & "            LOTUNITCOST, LOTNUMBER, LOTUSERLOTID, LOIQUANTITY,                            " & vbCrLf
      sSql = sSql & "            LOTREMAININGQTY, INADATE, LOTADATE, LOIMOPARTREF)                             " & vbCrLf
      sSql = sSql & "        SELECT PACLASS, PAPRODCODE, PALEVEL, PADESC, PAEXTDESC, a.INPART , a.INNUMBER,    " & vbCrLf
      sSql = sSql & "            a.INTYPE, a.INAMT, LOTUNITCOST, LOTNUMBER, LOTUSERLOTID,                      " & vbCrLf
      sSql = sSql & "            LOIQUANTITY , LOTREMAININGQTY, a.INADATE, LOTADATE, LOIMOPARTREF              " & vbCrLf
      sSql = sSql & "        FROM invaTable a, LoitTable, ViewLohdPartTable                                    " & vbCrLf
      sSql = sSql & "        Where a.INPART = LoitTable.LOIPARTREF                                             " & vbCrLf
      sSql = sSql & "            AND ViewLohdPartTable.partref = a.INPART                                      " & vbCrLf
      sSql = sSql & "            AND LoitTable.LOIPARTREF = ViewLohdPartTable.partref                          " & vbCrLf
      sSql = sSql & "            AND ViewLohdPartTable.LOTNUMBER = LoitTable.LOINUMBER                         " & vbCrLf
      sSql = sSql & "            AND a.INNUMBER = LoitTable.LOIACTIVITY                                        " & vbCrLf
      sSql = sSql & "            AND ViewLohdPartTable.PACLASS LIKE '%' + @PartClass + '%'                     " & vbCrLf
      sSql = sSql & "            AND ViewLohdPartTable.PAPRODCODE LIKE '%' + @PartCode + '%'                       " & vbCrLf
      sSql = sSql & "            AND ViewLohdPartTable.PALEVEL IN (@PartType1, @PartType2, @PartType3, @PartType4)  " & vbCrLf
      sSql = sSql & "            AND a.INPART NOT IN                          " & vbCrLf
      sSql = sSql & "                (SELECT INPART FROM invaTable b          " & vbCrLf
      sSql = sSql & "                Where a.INPART = b.INPART                " & vbCrLf
      sSql = sSql & "                    AND INADATE BETWEEN @BeginDate and @EndDate  " & vbCrLf
      sSql = sSql & "                    AND INTYPE IN (1, 3, 4, 6, 7, 9, 10, 11,15,17,19,23,25,26,32))   " & vbCrLf
      sSql = sSql & "        AND a.INADATE <=                                  " & vbCrLf
      sSql = sSql & "                (SELECT MAX(INADATE) FROM invaTable c    " & vbCrLf
      sSql = sSql & "                Where C.INPART = a.INPART                " & vbCrLf
      sSql = sSql & "                    AND c.INADATE < DATEADD(dd, -1 , @BeginDate)     " & vbCrLf
      sSql = sSql & "                Group by c.INPART)                       " & vbCrLf
      sSql = sSql & "        order by a.INPART                                " & vbCrLf
      sSql = sSql & "    Else                                                 " & vbCrLf
      sSql = sSql & "        INSERT INTO #tempExRpt (PACLASS, PAPRODCODE, PALEVEL,PADESC, PAEXTDESC,  " & vbCrLf
      sSql = sSql & "            INPART, INNUMBER, INTYPE, INAMT, LOTUNITCOST, LOTNUMBER,             " & vbCrLf
      sSql = sSql & "            LOTUSERLOTID, LOIQUANTITY, LOTREMAININGQTY, INADATE,                 " & vbCrLf
      sSql = sSql & "            LOTADATE, LOIMOPARTREF)                                              " & vbCrLf
      sSql = sSql & "        SELECT PACLASS, PAPRODCODE, PALEVEL, PADESC, PAEXTDESC, a.INPART , a.INNUMBER,   " & vbCrLf
      sSql = sSql & "            a.INTYPE, a.INAMT, LOTUNITCOST, LOTNUMBER, LOTUSERLOTID,            " & vbCrLf
      sSql = sSql & "            LOIQUANTITY , LOTREMAININGQTY, a.INADATE, LOTADATE, LOIMOPARTREF     " & vbCrLf
      sSql = sSql & "        FROM invaTable a, LoitTable, ViewLohdPartTable                           " & vbCrLf
      sSql = sSql & "        Where a.INPART = LoitTable.LOIPARTREF                                    " & vbCrLf
      sSql = sSql & "            AND ViewLohdPartTable.partref = a.INPART                             " & vbCrLf
      sSql = sSql & "            AND LoitTable.LOIPARTREF = ViewLohdPartTable.partref                 " & vbCrLf
      sSql = sSql & "            AND ViewLohdPartTable.LOTNUMBER = LoitTable.LOINUMBER                " & vbCrLf
      sSql = sSql & "            AND a.INNUMBER = LoitTable.LOIACTIVITY                               " & vbCrLf
      sSql = sSql & "            AND ViewLohdPartTable.PACLASS LIKE '%' + @PartClass + '%'            " & vbCrLf
      sSql = sSql & "            AND ViewLohdPartTable.PAPRODCODE LIKE '%' + @PartCode + '%'          " & vbCrLf
      sSql = sSql & "            AND ViewLohdPartTable.PALEVEL IN (@PartType1, @PartType2, @PartType3, @PartType4)    " & vbCrLf
      sSql = sSql & "            AND a.INPART NOT IN                                      " & vbCrLf
      sSql = sSql & "                (SELECT INPART FROM invaTable b                      " & vbCrLf
      sSql = sSql & "                Where a.INPART = b.INPART                            " & vbCrLf
      sSql = sSql & "                    AND INADATE BETWEEN @BeginDate and @EndDate      " & vbCrLf
      sSql = sSql & "                    AND INTYPE IN (1, 3, 4, 6, 7, 9, 10, 11,15,17,19,23,25,26,32))   " & vbCrLf
      sSql = sSql & "        AND a.INADATE <=                                              " & vbCrLf
      sSql = sSql & "                (SELECT MAX(INADATE) FROM invaTable c                " & vbCrLf
      sSql = sSql & "                Where C.INPART = a.INPART                            " & vbCrLf
      sSql = sSql & "                    AND c.INADATE < DATEADD(dd, -1 , @BeginDate)     " & vbCrLf
      sSql = sSql & "                Group by c.INPART)                                   " & vbCrLf
      sSql = sSql & "        AND a.INAQTY > 0                                             " & vbCrLf
      sSql = sSql & "            order by a.INPART                                        " & vbCrLf
      sSql = sSql & "                                                                     " & vbCrLf
      sSql = sSql & "    SELECT PACLASS, PAPRODCODE, PALEVEL, PADESC, PAEXTDESC, INPART,  " & vbCrLf
      sSql = sSql & "        INPART, INNUMBER, INTYPE, INAMT, a.LOTUNITCOST,                " & vbCrLf
      sSql = sSql & "        a.LOTNUMBER, a.LOTUSERLOTID, a.LOIQUANTITY,                        " & vbCrLf
      sSql = sSql & "        a.LOTREMAININGQTY , INADATE, a.LOTADATE, a.LOIMOPARTREF, b.LOTLOCATION" & vbCrLf
      sSql = sSql & "    FROM #tempExRpt a, lohdTable b" & vbCrLf
      sSql = sSql & "        WHERE a.LOTNUMBER = b.LOTNUMBER AND a.INPART NOT IN                                          " & vbCrLf
      sSql = sSql & "                (SELECT DISTINCT mrp_Partref FROM dbo.MrplTable      " & vbCrLf
      sSql = sSql & "         WHERE mrp_type IN (2, 3, 4, 11, 12, 17)              " & vbCrLf
      sSql = sSql & "                        AND mrp_partDateRQD < DATEADD(dd, +1 , @EndDate))    " & vbCrLf
      sSql = sSql & "    DROP table #tempExRpt                                                    " & vbCrLf
      sSql = sSql & " End "
      
      ExecuteScript False, sSql
      
      ' update the version
      ExecuteScript False, "Update Version Set Version = " & newver
   
   End If
End Function


Private Function UpdateDatabase51()
   newver = 125
   If ver < newver Then
   
      If Not TableExists("EsReportWIPOH") Then
      
         sSql = "CREATE TABLE [dbo].[EsReportWIPOH](" & vbCrLf
         sSql = sSql & "   [WIPRUNREF] [char](30) NULL," & vbCrLf
         sSql = sSql & "   [WIPRUNNO] [int] NULL," & vbCrLf
         sSql = sSql & "   [WIPRUNSTATUS] [char](2) NULL," & vbCrLf
         sSql = sSql & "   [WIPCOSTTYPE] [char](3) NULL," & vbCrLf
         sSql = sSql & "   [WIPLABOR] [real] NULL," & vbCrLf
         sSql = sSql & "   [WIPMISSTIME] [tinyint] NULL," & vbCrLf
         sSql = sSql & "   [WIPMATL] [real] NULL," & vbCrLf
         sSql = sSql & "   [WIPMISSMATL] [tinyint] NULL," & vbCrLf
         sSql = sSql & "   [WIPOH] [real] NULL," & vbCrLf
         sSql = sSql & "   [WIPCALOH] [real] NULL," & vbCrLf
         sSql = sSql & "   [WIPEXP] [real] NULL," & vbCrLf
         sSql = sSql & "   [WIPMISSEXP] [tinyint] NULL," & vbCrLf
         sSql = sSql & "   [WIPFREIGHT] [real] NULL," & vbCrLf
         sSql = sSql & "   [WIPTAX] [real] NULL," & vbCrLf
         sSql = sSql & "   [WIPUNCOSTED] [tinyint] NULL," & vbCrLf
         sSql = sSql & "   [WIPRUNQTY] [real] NULL" & vbCrLf
         sSql = sSql & ") ON [PRIMARY]"
      
         ExecuteScript False, sSql
      End If
   
      If StoreProcedureExists("GetMOOverHead") Then
         sSql = "DROP PROCEDURE GetMOOverHead"
         ExecuteScript False, sSql
      End If
      
      sSql = "CREATE PROCEDURE [dbo].[GetMOOverHead]" & vbCrLf
      sSql = sSql & "      @InputLotNum as varchar(15),@MOPart as varchar(30),@MORun as int," & vbCrLf
      sSql = sSql & "      @MOQty as decimal(15,4), @CalTotOH decimal(15,4) OUTPUT" & vbCrLf
      sSql = sSql & "AS " & vbCrLf
      sSql = sSql & "BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   declare @SumTotMat decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @SumTotLabor decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @SumTotExp decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @SumTotOH decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @LotTotOH decimal (15,4)" & vbCrLf
      sSql = sSql & "   declare @level as integer" & vbCrLf
      sSql = sSql & "   declare @Part as varchar(30)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   declare @PrevParent  as varchar(30)" & vbCrLf
      sSql = sSql & "   declare @RowCount as integer" & vbCrLf
      sSql = sSql & "   declare @ChildPart as varchar(30)" & vbCrLf
      sSql = sSql & "   declare @ParentPart as varchar(30)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   declare @ChildKey as varchar(1024)" & vbCrLf
      sSql = sSql & "   declare @GLSortKey as varchar(1024)" & vbCrLf
      sSql = sSql & "   declare @SortKey as varchar(1024)" & vbCrLf
      sSql = sSql & "   declare @ParentLotNum as varchar(15)" & vbCrLf
      sSql = sSql & "   declare @Maxlevel as int" & vbCrLf
      sSql = sSql & "   declare @LotRunNo as int" & vbCrLf
      sSql = sSql & "   declare @LotOrgQty as decimal(15,4)" & vbCrLf
      sSql = sSql & "   --declare @MOPart as varchar(30)" & vbCrLf
      sSql = sSql & "   --declare @MORun as int" & vbCrLf
      sSql = sSql & "   --declare @MOQty as decimal(15,4)" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   CREATE TABLE #tempMOPartsDetail " & vbCrLf
      sSql = sSql & "   ( " & vbCrLf
      sSql = sSql & "      INMOPART Varchar(30) NULL, " & vbCrLf
      sSql = sSql & "      INMORUN int NULL , " & vbCrLf
      sSql = sSql & "      INPART varchar(30) NULL , " & vbCrLf
      sSql = sSql & "      LOTNUMBER varchar(15) NULL, " & vbCrLf
      sSql = sSql & "      INTOTMATL decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      INTOTLABOR decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      INTOTEXP decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      INTOTOH decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      LOTTOTMATL decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      LOTTOTLABOR decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      LOTTOTEXP decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      LOTTOTOH decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      SUMTOTMAL decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      SUMTOTLABOR decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      SUMTOTEXP decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      SUMTOTOH decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      LOTDATECOSTED smalldatetime NULL," & vbCrLf
      sSql = sSql & "      SortKey varchar(512) NULL," & vbCrLf
      sSql = sSql & "      HASCHILD int NULL," & vbCrLf
      sSql = sSql & "      SORTKEYLEVEL tinyint NULL," & vbCrLf
      sSql = sSql & "      SortKeyRev varchar(512)," & vbCrLf
      sSql = sSql & "      PARTSUM varchar(40)," & vbCrLf
      sSql = sSql & "      BMQTYREQD decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      LOTORGQTY decimal(12,4) NULL," & vbCrLf
      sSql = sSql & "      BMTOTOH decimal(12,4) NULL" & vbCrLf
      sSql = sSql & "   ) " & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "--ALTER TABLE tempMOPartsDetail ADD SortKeyRev varchar(512)" & vbCrLf
      sSql = sSql & "--ALTER TABLE tempMOPartsDetail ADD PARTSUM varchar(40)" & vbCrLf
      sSql = sSql & "--ALTER TABLE tempMOPartsDetail ADD BMQTYREQD decimal(12,4) NULL, LOTORGQTY decimal(12,4) NULL" & vbCrLf
      sSql = sSql & "--ALTER TABLE tempMOPartsDetail ADD BMTOTOH decimal(12,4) NULL" & vbCrLf
      sSql = sSql & "  " & vbCrLf
      sSql = sSql & "-- DELETE FROM tempMOPartsDetail" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   IF (@InputLotNum <> '')" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "      SELECT @MOPart = LOTMOPARTREF,@MORun =LOTMORUNNO, @MOQty = LOTORIGINALQTY" & vbCrLf
      sSql = sSql & "         FROM LohdTable WHERE LOTNUMBER = @InputLotNum" & vbCrLf
      sSql = sSql & "   END" & vbCrLf
      sSql = sSql & "      " & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "      with cte" & vbCrLf
      sSql = sSql & "      as" & vbCrLf
      sSql = sSql & "      (select BMASSYPART, BMPARTREF,  BMQTYREQD,0 as level, cast('1' + char(36)+ BMPARTREF as varchar(max)) as SortKey" & vbCrLf
      sSql = sSql & "      from BmplTable" & vbCrLf
      sSql = sSql & "      where BMASSYPART = @MOPart" & vbCrLf
      sSql = sSql & "      union all" & vbCrLf
      sSql = sSql & "      select a.BMASSYPART, a.BMPARTREF, a.BMQTYREQD, level + 1," & vbCrLf
      sSql = sSql & "         cast(COALESCE(SortKey,'') + char(36) + COALESCE(a.BMPARTREF,'') as varchar(max))as SortKey" & vbCrLf
      sSql = sSql & "      from cte" & vbCrLf
      sSql = sSql & "         inner join BmplTable a" & vbCrLf
      sSql = sSql & "            on cte.BMPARTREF = a.BMASSYPART " & vbCrLf
      sSql = sSql & "      )" & vbCrLf
      sSql = sSql & "      INSERT INTO #tempMOPartsDetail(INMOPART,INPART,BMQTYREQD,SORTKEYLEVEL,SortKey)" & vbCrLf
      sSql = sSql & "      select BMASSYPART, BMPARTREF,BMQTYREQD,level,SortKey " & vbCrLf
      sSql = sSql & "         from cte order by SortKey " & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   END" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "print 'TopLevel:' + @MOPart + ' RUN:' + convert(varchar(10), @MORun)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   --// update the top level" & vbCrLf
      sSql = sSql & "   UPDATE #tempMOPartsDetail SET INMORUN = @MORun, LOTNUMBER = b.INLOTNUMBER, " & vbCrLf
      sSql = sSql & "            INTOTMATL = b.INTOTMATL, INTOTLABOR = b.INTOTLABOR, " & vbCrLf
      sSql = sSql & "            INTOTEXP = b.INTOTEXP, INTOTOH = b.INTOTOH, " & vbCrLf
      sSql = sSql & "            LOTTOTMATL = c.LOTTOTMATL, LOTTOTLABOR = c.LOTTOTLABOR, " & vbCrLf
      sSql = sSql & "            LOTTOTEXP = c.LOTTOTEXP, LOTTOTOH = c.LOTTOTOH," & vbCrLf
      sSql = sSql & "            LOTDATECOSTED = c.LOTDATECOSTED, LOTORGQTY = c.LOTORIGINALQTY," & vbCrLf
      sSql = sSql & "            BMTOTOH = (c.LOTTOTOH * BMQTYREQD) / c.LOTORIGINALQTY" & vbCrLf
      sSql = sSql & "   FROM #tempMOPartsDetail d, InvaTable b, LohdTable c" & vbCrLf
      sSql = sSql & "   WHERE d.INMOPART = b.INMOPART AND d.INPART = b.INPART " & vbCrLf
      sSql = sSql & "      AND b.INLOTNUMBER = c.LOTnumber" & vbCrLf
      sSql = sSql & "      and c.lotpartref = b.INPART" & vbCrLf
      sSql = sSql & "      and b.INMOPART = @MOPart AND b.INMORUN  = @MORun" & vbCrLf
      sSql = sSql & "      AND b.INTYPE = 10 AND SORTKEYLEVEL = 0" & vbCrLf
      sSql = sSql & "      AND c.LOTORIGINALQTY <> 0  " & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   --// set the totals for " & vbCrLf
      sSql = sSql & "   SELECT @Maxlevel =  MAX(SORTKEYLEVEL) FROM #tempMOPartsDetail" & vbCrLf
      sSql = sSql & "   SET @level  = 1" & vbCrLf
      sSql = sSql & "   WHILE (@level <= @Maxlevel )" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "      DECLARE curMORun CURSOR  FOR" & vbCrLf
      sSql = sSql & "      SELECT DISTINCT INMOPART,INPART " & vbCrLf
      sSql = sSql & "         FROM #tempMOPartsDetail WHERE SORTKEYLEVEL = @level" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "      OPEN curMORun" & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM curMORun INTO @MOPart, @Part" & vbCrLf
      sSql = sSql & "      WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "      BEGIN" & vbCrLf
      sSql = sSql & "         IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "         BEGIN" & vbCrLf
      sSql = sSql & "         " & vbCrLf
      sSql = sSql & "         SELECT @ParentLotNum = LOTNUMBER FROM #tempMOPartsDetail  WHERE" & vbCrLf
      sSql = sSql & "               INPART = @MOPart AND SORTKEYLEVEL = @level - 1" & vbCrLf
      sSql = sSql & "         " & vbCrLf
      sSql = sSql & "         SELECT @LotRunNo = LOTMORUNNO, @LotOrgQty = LOTORIGINALQTY " & vbCrLf
      sSql = sSql & "                  FROM lohdTable where LOTNUMBER = @ParentLotNum" & vbCrLf
      sSql = sSql & "         " & vbCrLf
      sSql = sSql & "--print 'InLoopLevel:' + @MOPart + ' RUN:' + convert(varchar(10), @LotRunNo)" & vbCrLf
      sSql = sSql & "         --// update the top level" & vbCrLf
      sSql = sSql & "         UPDATE #tempMOPartsDetail SET INMORUN = @LotRunNo, LOTNUMBER = b.INLOTNUMBER, " & vbCrLf
      sSql = sSql & "                  INTOTMATL = b.INTOTMATL, INTOTLABOR = b.INTOTLABOR, " & vbCrLf
      sSql = sSql & "                  INTOTEXP = b.INTOTEXP, INTOTOH = b.INTOTOH, " & vbCrLf
      sSql = sSql & "                  LOTTOTMATL = c.LOTTOTMATL, LOTTOTLABOR = c.LOTTOTLABOR, " & vbCrLf
      sSql = sSql & "                  LOTTOTEXP = c.LOTTOTEXP, LOTTOTOH = c.LOTTOTOH," & vbCrLf
      sSql = sSql & "                  LOTDATECOSTED = c.LOTDATECOSTED, LOTORGQTY = @LotOrgQty," & vbCrLf
      sSql = sSql & "                  BMTOTOH = (c.LOTTOTOH * BMQTYREQD) / @LotOrgQty" & vbCrLf
      sSql = sSql & "         FROM #tempMOPartsDetail d, InvaTable b, LohdTable c" & vbCrLf
      sSql = sSql & "         WHERE d.INMOPART = b.INMOPART AND d.INPART = b.INPART " & vbCrLf
      sSql = sSql & "            AND b.INLOTNUMBER = c.LOTnumber" & vbCrLf
      sSql = sSql & "            and c.lotpartref = b.INPART" & vbCrLf
      sSql = sSql & "            and b.INMOPART = @MOPart AND b.INMORUN  = @LotRunNo" & vbCrLf
      sSql = sSql & "            AND b.INTYPE = 10 AND SORTKEYLEVEL = @level" & vbCrLf
      sSql = sSql & "            AND c.LOTORIGINALQTY <> 0" & vbCrLf
      sSql = sSql & "      End" & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM curMORun INTO @MOPart, @Part" & vbCrLf
      sSql = sSql & "      End" & vbCrLf
      sSql = sSql & "      Close curMORun" & vbCrLf
      sSql = sSql & "      DEALLOCATE curMORun" & vbCrLf
      sSql = sSql & "      SET @level = @level + 1" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   SELECT @level =  MAX(SORTKEYLEVEL) FROM #tempMOPartsDetail" & vbCrLf
      sSql = sSql & "   WHILE (@level >= 0 )" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "      DECLARE curMODet CURSOR  FOR" & vbCrLf
      sSql = sSql & "      --SELECT INPART, LOTTOTMATL, LOTTOTLABOR, LOTTOTEXP , LOTTOTOH FROM tempMOPartsDetail" & vbCrLf
      sSql = sSql & "      -- WHERE INPART = '775345149'" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "      SELECT INMOPART, " & vbCrLf
      sSql = sSql & "      SUM(IsNull(LOTTOTMATL, 0)), SUM(ISNULL(LOTTOTLABOR,0)) ," & vbCrLf
      sSql = sSql & "        Sum (IsNull(LOTTOTEXP, 0)) , SUM(IsNull(BMTOTOH, 0))" & vbCrLf
      sSql = sSql & "      From" & vbCrLf
      sSql = sSql & "         (SELECT DISTINCT INMOPART,INMORUN,INPART,LOTTOTMATL,LOTTOTLABOR," & vbCrLf
      sSql = sSql & "         LOTTOTEXP,LOTTOTOH,SUMTOTMAL,SUMTOTLABOR, SUMTOTEXP, SUMTOTOH,BMTOTOH" & vbCrLf
      sSql = sSql & "         FROM #tempMOPartsDetail WHERE SORTKEYLEVEL = @level) as foo" & vbCrLf
      sSql = sSql & "      group by INMOPART" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "      OPEN curMODet" & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM curMODet INTO @MOPart, @SumTotMat, @SumTotLabor,@SumTotExp,@SumTotOH" & vbCrLf
      sSql = sSql & "      WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "      BEGIN" & vbCrLf
      sSql = sSql & "         IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "         BEGIN" & vbCrLf
      sSql = sSql & "            " & vbCrLf
      sSql = sSql & "            print 'PartNum : ' + @MOPart" & vbCrLf
      sSql = sSql & "            print 'SumTotoh : ' + Convert(varchar(24), @SumTotOH)" & vbCrLf
      sSql = sSql & "            " & vbCrLf
      sSql = sSql & "            UPDATE #tempMOPartsDetail SET SUMTOTMAL = LOTTOTMATL + @SumTotMat, " & vbCrLf
      sSql = sSql & "            SUMTOTLABOR = LOTTOTLABOR + @SumTotLabor," & vbCrLf
      sSql = sSql & "               SUMTOTEXP = LOTTOTEXP + @SumTotExp, SUMTOTOH = (BMTOTOH + @SumTotOH) * @MOQty , " & vbCrLf
      sSql = sSql & "               HASCHILD = 1,PARTSUM = 'TOTAL ' + LTRIM(INPART)" & vbCrLf
      sSql = sSql & "            " & vbCrLf
      sSql = sSql & "            WHERE INPART = @MOPart AND SORTKEYLEVEL = @level - 1" & vbCrLf
      sSql = sSql & "            " & vbCrLf
      sSql = sSql & "      End" & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM curMODet INTO @MOPart, @SumTotMat, @SumTotLabor,@SumTotExp,@SumTotOH" & vbCrLf
      sSql = sSql & "      End" & vbCrLf
      sSql = sSql & "      Close curMODet" & vbCrLf
      sSql = sSql & "      DEALLOCATE curMODet" & vbCrLf
      sSql = sSql & "      SET @level = @level - 1" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   --// update the Lower level cost detail" & vbCrLf
      sSql = sSql & "    UPDATE #tempMOPartsDetail SET SUMTOTMAL = LOTTOTMATL, SUMTOTLABOR = LOTTOTLABOR," & vbCrLf
      sSql = sSql & "       SUMTOTEXP = LOTTOTEXP, SUMTOTOH = BMTOTOH WHERE HASCHILD IS NULL" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   SET @SumTotMat  = 0" & vbCrLf
      sSql = sSql & "   SET @SumTotLabor  = 0" & vbCrLf
      sSql = sSql & "   SET @SumTotExp  = 0" & vbCrLf
      sSql = sSql & "   SET @SumTotOH  = 0" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   --// Udpate the Root total" & vbCrLf
      sSql = sSql & "    SELECT @SumTotMat = SUM(SUMTOTMAL), @SumTotLabor = SUM(SUMTOTLABOR)," & vbCrLf
      sSql = sSql & "         @SumTotExp = SUM(SUMTOTEXP) ,@SumTotOH = SUM(SUMTOTOH)" & vbCrLf
      sSql = sSql & "     FROM #tempMOPartsDetail WHERE SORTKEYLEVEL = 0 " & vbCrLf
      sSql = sSql & "      AND  RTRIM(INMOPART) <> RTRIM(INPART)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "    UPDATE #tempMOPartsDetail SET PARTSUM = INPART" & vbCrLf
      sSql = sSql & "      WHERE PARTSUM IS NULL" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "  ----  SELECT * FROM tempMOPartsDetail WHERE SORTKEYLEVEL = 0 " & vbCrLf
      sSql = sSql & "      ----AND  RTRIM(INMOPART) = RTRIM(INPART)" & vbCrLf
      sSql = sSql & "   --// Reverse the partnumbers." & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   set @level = 0 " & vbCrLf
      sSql = sSql & "   set @RowCount = 1" & vbCrLf
      sSql = sSql & "   SET @PrevParent = ''" & vbCrLf
      sSql = sSql & "   DECLARE curAcctStruc CURSOR  FOR" & vbCrLf
      sSql = sSql & "      SELECT INMOPART, SortKey" & vbCrLf
      sSql = sSql & "      FROM #tempMOPartsDetail " & vbCrLf
      sSql = sSql & "         WHERE HASCHILD IS NULL --GLFSLEVEL = 8 --AND GLMASTER ='AA10'--GLTOPMaster = 1 AND " & vbCrLf
      sSql = sSql & "      ORDER BY SortKey" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   OPEN curAcctStruc" & vbCrLf
      sSql = sSql & "   FETCH NEXT FROM curAcctStruc INTO @ParentPart, @SortKey" & vbCrLf
      sSql = sSql & "   WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "    IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "    BEGIN" & vbCrLf
      sSql = sSql & "      if (@PrevParent <> @ParentPart)" & vbCrLf
      sSql = sSql & "      BEGIN" & vbCrLf
      sSql = sSql & "         UPDATE #tempMOPartsDetail SET " & vbCrLf
      sSql = sSql & "            SortKeyRev = RIGHT ('0000'+ Cast(@RowCount as varchar), 4) + char(36)+ @ParentPart" & vbCrLf
      sSql = sSql & "         WHERE INMOPART = @ParentPart AND HASCHILD IS NULL --GLFSLEVEL = 8 --AND GLTOPMaster = 1 " & vbCrLf
      sSql = sSql & "         SET @RowCount = @RowCount + 1" & vbCrLf
      sSql = sSql & "         SET @PrevParent = @ParentPart" & vbCrLf
      sSql = sSql & "      END" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "    End" & vbCrLf
      sSql = sSql & "    FETCH NEXT FROM curAcctStruc INTO @ParentPart, @SortKey" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "       " & vbCrLf
      sSql = sSql & "   Close curAcctStruc" & vbCrLf
      sSql = sSql & "   DEALLOCATE curAcctStruc" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   SELECT @level =  MAX(SORTKEYLEVEL) FROM #tempMOPartsDetail" & vbCrLf
      sSql = sSql & "   --set @level = 7" & vbCrLf
      sSql = sSql & "   WHILE (@level >= 0 )" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "      SET @PrevParent = ''" & vbCrLf
      sSql = sSql & "        DECLARE curAcctStruc1 CURSOR  FOR" & vbCrLf
      sSql = sSql & "         SELECT DISTINCT INPART, INMOPART, SortKey" & vbCrLf
      sSql = sSql & "         FROM #tempMOPartsDetail " & vbCrLf
      sSql = sSql & "            WHERE SORTKEYLEVEL = @level AND HASCHILD IS NOT NULL--GLTOPMaster = 1 AND " & vbCrLf
      sSql = sSql & "         order by SortKey" & vbCrLf
      sSql = sSql & "    " & vbCrLf
      sSql = sSql & "        OPEN curAcctStruc1" & vbCrLf
      sSql = sSql & "        FETCH NEXT FROM curAcctStruc1 INTO @ChildPart, @ParentPart, @SortKey" & vbCrLf
      sSql = sSql & "        WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "        BEGIN" & vbCrLf
      sSql = sSql & "          IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "          BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "            if (@PrevParent <> @ChildPart)" & vbCrLf
      sSql = sSql & "            BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   --print 'Record' + @ChildPart + ':' + @ParentPart" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "               SELECT TOP 1 @ChildKey = SortKeyRev,@SortKey = SortKey" & vbCrLf
      sSql = sSql & "               FROM #tempMOPartsDetail " & vbCrLf
      sSql = sSql & "                  WHERE SORTKEYLEVEL > @level AND INMOPART = @ChildPart --GLTOPMaster = 1 AND " & vbCrLf
      sSql = sSql & "               order by SortKey desc" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "               UPDATE #tempMOPartsDetail SET " & vbCrLf
      sSql = sSql & "                  SortKeyRev = Cast(@ChildKey as varchar(256)) + char(36)+ @ParentPart" & vbCrLf
      sSql = sSql & "               WHERE INPART = @ChildPart AND INMOPART = @ParentPart " & vbCrLf
      sSql = sSql & "                  AND SORTKEYLEVEL = @level --GLTOPMaster = 1 AND " & vbCrLf
      sSql = sSql & "               " & vbCrLf
      sSql = sSql & "               SET @PrevParent = @ChildPart" & vbCrLf
      sSql = sSql & "            END" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "          End" & vbCrLf
      sSql = sSql & "         FETCH NEXT FROM curAcctStruc1 INTO @ChildPart, @ParentPart, @SortKey" & vbCrLf
      sSql = sSql & "        End" & vbCrLf
      sSql = sSql & "               " & vbCrLf
      sSql = sSql & "        Close curAcctStruc1" & vbCrLf
      sSql = sSql & "        DEALLOCATE curAcctStruc1" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "        SET @level = @level - 1" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   SELECT @LotTotOH = ISNULL(LOTTOTOH, 0) from lohdTable where lotpartref = @MOPart  AND LOTMORUNNO = @MORun " & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "--print 'LOT OH:' + Convert(varchar(10), @LotTotOH)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   SELECT @CalTotOH = SUM(ISNULL(BMTOTOH, 0)) + ISNULL(@LotTotOH, 0) FROM #tempMOPartsDetail" & vbCrLf
      sSql = sSql & "         WHERE SORTKEYLEVEL = 0" & vbCrLf
      sSql = sSql & "   print 'GetMOOverHead: CalOH:' + convert(varchar(10), @CalTotOH)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   DROP table #tempMOPartsDetail " & vbCrLf
      sSql = sSql & "END"
         
      ExecuteScript False, sSql
         
      
      If StoreProcedureExists("WIPCalculatedOH") Then
         sSql = "DROP PROCEDURE WIPCalculatedOH"
         ExecuteScript False, sSql
      End If
      
      sSql = "CREATE PROCEDURE [dbo].[WIPCalculatedOH]" & vbCrLf
      sSql = sSql & "AS " & vbCrLf
      sSql = sSql & "BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   --ALTER table dbo.EsReportWIPOH ADD WIPRUNQTY real" & vbCrLf
      sSql = sSql & "   -- select * from EsReportWIPOH" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   declare @MOPart as varchar(30)" & vbCrLf
      sSql = sSql & "   declare @MORun as int" & vbCrLf
      sSql = sSql & "   declare @MOQty as decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @CalTotOH as decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @TotMOOH as decimal (15,4)" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   DECLARE curWIP CURSOR  FOR" & vbCrLf
      sSql = sSql & "     SELECT DISTINCT WIPRUNREF,WIPRUNNO, WIPRUNQTY " & vbCrLf
      sSql = sSql & "     FROM EsReportWIPOH" & vbCrLf
      sSql = sSql & "   OPEN curWIP" & vbCrLf
      sSql = sSql & "   FETCH NEXT FROM curWIP INTO @MOPart, @MORun, @MOQty" & vbCrLf
      sSql = sSql & "   WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "      IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "      BEGIN" & vbCrLf
      sSql = sSql & "      " & vbCrLf
      sSql = sSql & "         --Print 'PartNum:' + @MOPart + ' Run:' + Convert(varchar(10), @MORun)" & vbCrLf
      sSql = sSql & "         " & vbCrLf
      sSql = sSql & "         EXECUTE GetMOOverHead '', @MOPart, @MORun, @MOQty, @CalTotOH = @TotMOOH OUTPUT;" & vbCrLf
      sSql = sSql & "         " & vbCrLf
      sSql = sSql & "         --print 'TotOH:' + Convert(varchar(10), @TotMOOH)" & vbCrLf
      sSql = sSql & "         " & vbCrLf
      sSql = sSql & "         UPDATE EsReportWIPOH SET WIPCALOH = @TotMOOH" & vbCrLf
      sSql = sSql & "            WHERE WIPRUNREF = @MOPart AND WIPRUNNO = @MORun" & vbCrLf
      sSql = sSql & "      End" & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM curWIP INTO @MOPart, @MORun, @MOQty" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "      " & vbCrLf
      sSql = sSql & "   Close curWIP" & vbCrLf
      sSql = sSql & "   DEALLOCATE curWIP" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   UPDATE EsReportWIPOH  SET WIPCALOH = WIPOH WHERE WIPOH <> WIPCALOH " & vbCrLf
      sSql = sSql & "   AND WIPCALOH = 0 AND WIPOH <> 0" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "END"
      
      ExecuteScript False, sSql
      
      
      If StoreProcedureExists("RptRMFGoodsWithCost") Then
         sSql = "DROP PROCEDURE RptRMFGoodsWithCost"
         ExecuteScript False, sSql
      End If
      
      sSql = "CREATE PROCEDURE [dbo].[RptRMFGoodsWithCost] " & vbCrLf
      sSql = sSql & " @ReportDate as varchar(16), @PartClass as Varchar(16), " & vbCrLf
      sSql = sSql & " @PartCode as varchar(8), @lotHDOnly as int, @PartType1 as Integer, " & vbCrLf
      sSql = sSql & " @PartType2 as Integer, @PartType3 as Integer, @PartType4 as Integer " & vbCrLf
      sSql = sSql & " AS        " & vbCrLf
      sSql = sSql & " BEGIN      " & vbCrLf
      sSql = sSql & "   declare @partRef as varchar(30)   " & vbCrLf
      sSql = sSql & "   declare @partType as int           " & vbCrLf
      sSql = sSql & "   declare @partDesc as varchar(30)     " & vbCrLf
      sSql = sSql & "   declare @partExDesc as varchar(3072)    " & vbCrLf
      sSql = sSql & "   declare @rptRemQty as decimal(12,4)  " & vbCrLf
      sSql = sSql & "   declare @deltaQty as decimal(12,4)   " & vbCrLf
      sSql = sSql & "   declare @lotRemQty as decimal(12,4)  " & vbCrLf
      sSql = sSql & "   declare @lotOrgQty as decimal(12,4)  " & vbCrLf
      sSql = sSql & "   declare @tmpInvQty as decimal(12,4)  " & vbCrLf
      sSql = sSql & "   declare @tmpLastInvQty as decimal(12,4)    " & vbCrLf
      sSql = sSql & "   declare @rptInvcost decimal(12,4)    " & vbCrLf
      sSql = sSql & "   declare @lastInvcost decimal(12,4)   " & vbCrLf
      sSql = sSql & "   declare @orgInvcost decimal(12,4)    " & vbCrLf
      sSql = sSql & "   declare @tmpInvCost decimal(12,4)    " & vbCrLf
      sSql = sSql & "   declare @tmpLastInvCost decimal(12,4)   " & vbCrLf
      sSql = sSql & "   declare @lastQty as decimal(12,4)    " & vbCrLf
      sSql = sSql & "   declare @orgQty as decimal(12,4)  " & vbCrLf
      sSql = sSql & "   declare @rptQty as decimal(12,4)  " & vbCrLf
      sSql = sSql & "   declare @rptCreditACC varchar(12)    " & vbCrLf
      sSql = sSql & " declare @rptDebitACC varchar(12)" & vbCrLf
      sSql = sSql & " declare @rptACC varchar(12)   " & vbCrLf
      sSql = sSql & " declare @CurACC varchar(12)   " & vbCrLf
      sSql = sSql & " declare @tmpCreditAcc varchar(12)   " & vbCrLf
      sSql = sSql & " declare @tmpDebitAcc varchar(12) " & vbCrLf
      sSql = sSql & " declare @tmplastCreditAcc varchar(12)  " & vbCrLf
      sSql = sSql & " declare @tmpLastDebitAcc varchar(12)   " & vbCrLf
      sSql = sSql & " declare @lastCreditACC varchar(12)  " & vbCrLf
      sSql = sSql & " declare @lastDebitACC varchar(12)   " & vbCrLf
      sSql = sSql & " declare @lastACC varchar(12)  " & vbCrLf
      sSql = sSql & " declare @orgCreditACC varchar(12)" & vbCrLf
      sSql = sSql & " declare @orgDebitACC varchar(12) " & vbCrLf
      sSql = sSql & " declare @orgACC varchar(12)   " & vbCrLf
      sSql = sSql & " declare @OrgInvNum as int  " & vbCrLf
      sSql = sSql & " declare @rptInvNum as int  " & vbCrLf
      sSql = sSql & " declare @LastInvNum as int " & vbCrLf
      sSql = sSql & " declare @tmpInvNum as int  " & vbCrLf
      sSql = sSql & " declare @tmpLastInvNum as int " & vbCrLf
      sSql = sSql & " declare @LotNumber varchar(51)   " & vbCrLf
      sSql = sSql & " declare @LotUserID varchar(51)   " & vbCrLf
      sSql = sSql & " declare @lotAcualDate as smalldatetime " & vbCrLf
      sSql = sSql & " declare @lotCostedDate as smalldatetime   " & vbCrLf
      sSql = sSql & " declare @curDate as smalldatetime   " & vbCrLf
      sSql = sSql & " declare @AcualDate as smalldatetime " & vbCrLf
      sSql = sSql & " declare @CostedDate as smalldatetime   " & vbCrLf
      sSql = sSql & " declare @tmpINVAdate  as smalldatetime   " & vbCrLf
      sSql = sSql & " declare @tmpLastINVAdate  as smalldatetime   " & vbCrLf
      sSql = sSql & " declare @unitcost as decimal(12,4)  " & vbCrLf
      sSql = sSql & " declare @partStdCost as decimal(12,4)  " & vbCrLf
      sSql = sSql & " declare @LotUnitCost as decimal(12,4)  " & vbCrLf
      sSql = sSql & " declare @partActCost as int   " & vbCrLf
      sSql = sSql & " declare @partLotTrack as int  " & vbCrLf
      sSql = sSql & " declare @flgStdCost as int " & vbCrLf
      sSql = sSql & " declare @flgLdCost as int  " & vbCrLf
      sSql = sSql & " declare @flgInvCost as int " & vbCrLf
      sSql = sSql & " declare @flgLdRQErr as int " & vbCrLf
      sSql = sSql & " declare @flgOrgAcc as int  " & vbCrLf
      sSql = sSql & " declare @flgRptAcc as int  " & vbCrLf
      sSql = sSql & " declare @flgLastAcc as int " & vbCrLf
      sSql = sSql & "declare @lotTotMat as decimal(12,4)" & vbCrLf
      sSql = sSql & "declare @lotTotLabor as decimal(12,4)" & vbCrLf
      sSql = sSql & "declare @lotTotExp as decimal(12,4)" & vbCrLf
      sSql = sSql & "declare @lotTotOH as decimal(12,4)" & vbCrLf
      sSql = sSql & "declare @InputLotNum as varchar(15)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "declare @CalTotOH as decimal(12,4)" & vbCrLf
      sSql = sSql & "declare @TotMOOH as decimal(12,4)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   IF (@PartClass = 'ALL')" & vbCrLf
      sSql = sSql & "   BEGIN " & vbCrLf
      sSql = sSql & "      SET @PartClass = ''  " & vbCrLf
      sSql = sSql & "   End            " & vbCrLf
      sSql = sSql & "   IF (@PartCode = 'ALL')  " & vbCrLf
      sSql = sSql & "   BEGIN " & vbCrLf
      sSql = sSql & "      SET @PartCode = ''      " & vbCrLf
      sSql = sSql & " End                     " & vbCrLf
      sSql = sSql & "    IF (@PartType1 = 1)     " & vbCrLf
      sSql = sSql & "      SET @PartType1 = 1    " & vbCrLf
      sSql = sSql & "   Else                    " & vbCrLf
      sSql = sSql & "     SET @PartType1 = 0    " & vbCrLf
      sSql = sSql & "   IF (@PartType2 = 1)     " & vbCrLf
      sSql = sSql & "     SET @PartType2 = 2    " & vbCrLf
      sSql = sSql & "   Else                    " & vbCrLf
      sSql = sSql & "     SET @PartType2 = 0    " & vbCrLf
      sSql = sSql & "    IF (@PartType3 = 1)    " & vbCrLf
      sSql = sSql & "        SET @PartType3 = 3 " & vbCrLf
      sSql = sSql & "    Else                   " & vbCrLf
      sSql = sSql & "        SET @PartType3 = 0 " & vbCrLf
      sSql = sSql & "                           " & vbCrLf
      sSql = sSql & "    IF (@PartType4 = 1)    " & vbCrLf
      sSql = sSql & "        SET @PartType4 = 4 " & vbCrLf
      sSql = sSql & "    Else                   " & vbCrLf
      sSql = sSql & "        SET @PartType4 = 0 " & vbCrLf
      sSql = sSql & "      " & vbCrLf
      sSql = sSql & "   CREATE TABLE #tempRMFGoods(   " & vbCrLf
      sSql = sSql & "   [LOTNUMBER] [varchar](15) NULL,  " & vbCrLf
      sSql = sSql & "   [PARTNUM] [varchar](30) NULL, " & vbCrLf
      sSql = sSql & "   [PALEVEL] [int] NULL,         " & vbCrLf
      sSql = sSql & "   [PADESC] [varchar](30) NULL,  " & vbCrLf
      sSql = sSql & "   [PAEXTDESC] [varchar](3072) NULL,   " & vbCrLf
      sSql = sSql & "   [LOTUSERLOTID] [char](40) NULL,     " & vbCrLf
      sSql = sSql & "   [ORGINNUMBER] [int] NULL,           " & vbCrLf
      sSql = sSql & "   [RPTINNUMBER] [int] NULL,           " & vbCrLf
      sSql = sSql & "   [CURINNUMBER] [int] NULL,           " & vbCrLf
      sSql = sSql & "   [ACTUALDATE] [smalldatetime] NULL,  " & vbCrLf
      sSql = sSql & "   [RPTDATEQTY] [decimal](12, 4) NULL, " & vbCrLf
      sSql = sSql & "   [ORGQTY] [decimal](12, 4) NULL, " & vbCrLf
      sSql = sSql & "   [UNITCOST] [decimal](12, 4) NULL,   " & vbCrLf
      sSql = sSql & "   [PASTDCOST] [decimal](12, 4) NULL,  " & vbCrLf
      sSql = sSql & "   [LOTUNITCOST] [decimal](12, 4) NULL,   " & vbCrLf
      sSql = sSql & "   [INAMT] [decimal](12, 4) NULL,      " & vbCrLf
      sSql = sSql & "   [LOTTOTMATL] [decimal](12, 4) NULL,      " & vbCrLf
      sSql = sSql & "    [LOTTOTLABOR] [decimal](12, 4) NULL,      " & vbCrLf
      sSql = sSql & "   [LOTTOTEXP] [decimal](12, 4) NULL," & vbCrLf
      sSql = sSql & "   [LOTTOTOH] [decimal](12, 4) NULL,      " & vbCrLf
      sSql = sSql & "   [CALLOTTOTOH] [decimal](12, 4) NULL,      " & vbCrLf
      sSql = sSql & "   [ORGCOST] [decimal](12, 4) NULL,       " & vbCrLf
      sSql = sSql & "   [STDCOST] [decimal](12, 4) NULL,       " & vbCrLf
      sSql = sSql & "   [LSTACOST] [decimal](12, 4) NULL,      " & vbCrLf
      sSql = sSql & "   [RPTCOST] [decimal](12, 4) NULL,       " & vbCrLf
      sSql = sSql & "   [CURCOST] [decimal](12, 4) NULL,       " & vbCrLf
      sSql = sSql & "   [COSTEDDATE] [smalldatetime] NULL,     " & vbCrLf
      sSql = sSql & "   [RPTACCOUNT] [char](12) NULL,          " & vbCrLf
      sSql = sSql & "   [ORIGINALACC] [char](12) NULL,         " & vbCrLf
      sSql = sSql & "   [LASTACTVITYACC] [char](12) NULL,      " & vbCrLf
      sSql = sSql & "   [CURRENTACC] [char](12) NULL, " & vbCrLf
      sSql = sSql & "   [PACLASS] [char](4) NULL,  " & vbCrLf
      sSql = sSql & "   [PAPRODCODE] [char](6) NULL,  " & vbCrLf
      sSql = sSql & "   [flgStdCost] [int] NULL,   " & vbCrLf
      sSql = sSql & "   [flgLdCost] [int] NULL,    " & vbCrLf
      sSql = sSql & "   [flgInvCost] [int] NULL,   " & vbCrLf
      sSql = sSql & "   [flgLdRQErr] [int] NULL,   " & vbCrLf
      sSql = sSql & "   [flgRptAcc] [int] NULL,    " & vbCrLf
      sSql = sSql & "   [flgOrgAcc] [int] NULL,    " & vbCrLf
      sSql = sSql & "   [flgLastAcc] [int] NULL    " & vbCrLf
      sSql = sSql & ")                             " & vbCrLf
      sSql = sSql & "                              " & vbCrLf
      sSql = sSql & " DECLARE curLotHd CURSOR LOCAL " & vbCrLf
      sSql = sSql & " FOR                           " & vbCrLf
      sSql = sSql & " SELECT LOTNUMBER, LOTUSERLOTID, PARTREF, PADESC, PAEXTDESC, " & vbCrLf
      sSql = sSql & "    LOTADATE,LOTORIGINALQTY, LOTREMAININGQTY, LOTUNITCOST, LOTTOTMATL, " & vbCrLf
      sSql = sSql & "   LOTTOTLABOR, LOTTOTEXP, LOTTOTOH, LOTDATECOSTED,   " & vbCrLf
      sSql = sSql & "    PACLASS , PAPRODCODE, PASTDCOST, PAUSEACTUALCOST, PALOTTRACK, PALEVEL   " & vbCrLf
      sSql = sSql & " From ViewLohdPartTable  " & vbCrLf
      sSql = sSql & " WHERE ViewLohdPartTable.LOTADATE  < DATEADD(dd, 1 , @ReportDate)  " & vbCrLf
      sSql = sSql & "    AND ViewLohdPartTable.PACLASS LIKE '%' + @PartClass + '%'      " & vbCrLf
      sSql = sSql & "    AND ViewLohdPartTable.PAPRODCODE LIKE '%' + @PartCode + '%'    " & vbCrLf
      sSql = sSql & "    AND ViewLohdPartTable.PALEVEL IN (@PartType1, @PartType2, @PartType3, @PartType4)   " & vbCrLf
      sSql = sSql & " OPEN curLotHd                                                     " & vbCrLf
      sSql = sSql & " FETCH NEXT FROM curLotHd INTO @LotNumber, @LotUserID, @partRef,   " & vbCrLf
      sSql = sSql & "    @partDesc, @partExDesc, @lotAcualDate, @lotOrgQty,             " & vbCrLf
      sSql = sSql & "    @lotRemQty,@LotUnitCost,@lotTotMat, @lotTotLabor, " & vbCrLf
      sSql = sSql & "   @lotTotExp, @lotTotOH, @lotCostedDate,                       " & vbCrLf
      sSql = sSql & "    @PartClass, @PartCode, @partStdCost, @partActCost, @partLotTrack, @partType   " & vbCrLf
      sSql = sSql & "                                                                " & vbCrLf
      sSql = sSql & " WHILE (@@FETCH_STATUS <> -1)                                   " & vbCrLf
      sSql = sSql & " BEGIN                                                          " & vbCrLf
      sSql = sSql & " IF (@@FETCH_STATUS <> -2)     " & vbCrLf
      sSql = sSql & " BEGIN                         " & vbCrLf
      sSql = sSql & "    SET @flgLdRQErr = 0        " & vbCrLf
      sSql = sSql & " IF (@lotRemQty < 0.0000)      " & vbCrLf
      sSql = sSql & " BEGIN                         " & vbCrLf
      sSql = sSql & "    SET @lotRemQty = 0.0000    " & vbCrLf
      sSql = sSql & "    SET @flgLdRQErr  = 1       " & vbCrLf
      sSql = sSql & " End                           " & vbCrLf
      sSql = sSql & " SET @curDate = GETDATE()      " & vbCrLf
      sSql = sSql & "                               " & vbCrLf
      sSql = sSql & " SELECT @deltaQty = ISNULL(SUM(LOIQUANTITY), 0.0000)   " & vbCrLf
      sSql = sSql & " From LoitTable                                        " & vbCrLf
      sSql = sSql & " WHERE LOIADATE BETWEEN DATEADD(dd, 1 ,@ReportDate) AND DATEADD(dd, 1 ,@curDate)  " & vbCrLf
      sSql = sSql & "    AND LOIPARTREF = @partRef                    " & vbCrLf
      sSql = sSql & "    AND LOINUMBER = @LotNumber                   " & vbCrLf
      sSql = sSql & " SET @rptRemQty = @lotRemQty + (@deltaQty * -1)  " & vbCrLf
      sSql = sSql & " IF @rptRemQty < 0.0000           " & vbCrLf
      sSql = sSql & " SET @rptRemQty = @rptRemQty * -1 " & vbCrLf
      sSql = sSql & " SET @flgStdCost = 0     " & vbCrLf
      sSql = sSql & " SET @flgLdCost = 0      " & vbCrLf
      sSql = sSql & " SET @flgInvCost = 0     " & vbCrLf
      sSql = sSql & " SET @flgOrgAcc = 0      " & vbCrLf
      sSql = sSql & " SET @flgRptAcc = 0      " & vbCrLf
      sSql = sSql & " SET @flgLastAcc = 0     " & vbCrLf
      sSql = sSql & "                         " & vbCrLf
      sSql = sSql & " DECLARE curInv CURSOR   " & vbCrLf
      sSql = sSql & " LOCAL                   " & vbCrLf
      sSql = sSql & " Scroll                  " & vbCrLf
      sSql = sSql & " FOR                     " & vbCrLf
      sSql = sSql & " SELECT INNUMBER, INAMT, INAQTY, ISNULL(INCREDITACCT,0), ISNULL(INDEBITACCT, 0), INADATE   " & vbCrLf
      sSql = sSql & "     From InvaTable, LoitTable                          " & vbCrLf
      sSql = sSql & " WHERE InvaTable.INPART = @partRef                  " & vbCrLf
      sSql = sSql & "    AND LoitTable.LOINUMBER = @LotNumber            " & vbCrLf
      sSql = sSql & "    AND InvaTable.INPART = LoitTable.LOIPARTREF     " & vbCrLf
      sSql = sSql & "    AND InvaTable.INNUMBER = LoitTable.LOIACTIVITY  " & vbCrLf
      sSql = sSql & " ORDER BY INADATE ASC          " & vbCrLf
      sSql = sSql & "                               " & vbCrLf
      sSql = sSql & " OPEN curInv                   " & vbCrLf
      sSql = sSql & " FETCH FIRST FROM curInv INTO @tmpInvNum, @tmpInvCost, @tmpInvQty, " & vbCrLf
      sSql = sSql & " @tmpCreditAcc, @tmpDebitAcc, @tmpINVAdate " & vbCrLf
      sSql = sSql & " IF (@@FETCH_STATUS <> -1)  " & vbCrLf
      sSql = sSql & " BEGIN                      " & vbCrLf
      sSql = sSql & " IF (@@FETCH_STATUS <> -2)  " & vbCrLf
      sSql = sSql & " BEGIN                      " & vbCrLf
      sSql = sSql & "    SET @orgInvcost = @tmpInvCost " & vbCrLf
      sSql = sSql & "    SET @orgQty = @tmpInvQty      " & vbCrLf
      sSql = sSql & "    SET @orgCreditACC = @tmpCreditAcc   " & vbCrLf
      sSql = sSql & "    SET @orgDebitACC = @tmpDebitAcc  " & vbCrLf
      sSql = sSql & "    SET @OrgInvNum = @tmpInvNum      " & vbCrLf
      sSql = sSql & " End                                 " & vbCrLf
      sSql = sSql & " FETCH LAST FROM curInv INTO @tmpLastInvNum, @tmpLastInvCost, @tmpLastInvQty,  " & vbCrLf
      sSql = sSql & " @tmplastCreditAcc, @tmpLastDebitAcc, @tmpLastINVAdate " & vbCrLf
      sSql = sSql & " IF (@@FETCH_STATUS <> -2)  " & vbCrLf
      sSql = sSql & " BEGIN                      " & vbCrLf
      sSql = sSql & " SET @lastInvcost = @tmpLastInvCost  " & vbCrLf
      sSql = sSql & " SET @lastQty = @tmpLastInvQty    " & vbCrLf
      sSql = sSql & " SET @lastCreditACC = @tmplastCreditAcc " & vbCrLf
      sSql = sSql & " SET @lastDebitACC = @tmpLastDebitAcc   " & vbCrLf
      sSql = sSql & " SET @LastInvNum = @tmpLastInvNum       " & vbCrLf
      sSql = sSql & " IF @tmpLastINVAdate > DATEADD(dd, 1, @ReportDate)  " & vbCrLf
      sSql = sSql & " BEGIN                                              " & vbCrLf
      sSql = sSql & "   SELECT TOP 1 @rptInvNum = INNUMBER, @rptInvcost = INAMT, " & vbCrLf
      sSql = sSql & "      @rptQty = INAQTY, @rptCreditACC = ISNULL(INCREDITACCT, 0),  " & vbCrLf
      sSql = sSql & "      @rptDebitACC = ISNULL(INDEBITACCT, 0)     " & vbCrLf
      sSql = sSql & "   From InvaTable, LoitTable                 " & vbCrLf
      sSql = sSql & "      WHERE INADATE < DATEADD(dd, 1, @ReportDate)  " & vbCrLf
      sSql = sSql & "         AND InvaTable.INPART = @partRef              " & vbCrLf
      sSql = sSql & "         AND LoitTable.LOINUMBER = @LotNumber         " & vbCrLf
      sSql = sSql & "         AND InvaTable.INPART = LoitTable.LOIPARTREF  " & vbCrLf
      sSql = sSql & "         AND InvaTable.INNUMBER = LoitTable.LOIACTIVITY  " & vbCrLf
      sSql = sSql & "         ORDER BY INADATE DESC                           " & vbCrLf
      sSql = sSql & "  End                                          " & vbCrLf
      sSql = sSql & "  Else                                         " & vbCrLf
      sSql = sSql & "  BEGIN                                        " & vbCrLf
      sSql = sSql & "  SET @rptInvNum = @tmpLastInvNum              " & vbCrLf
      sSql = sSql & "                                  " & vbCrLf
      sSql = sSql & "                                     " & vbCrLf
      sSql = sSql & " SET @rptInvcost = @tmpLastInvCost   " & vbCrLf
      sSql = sSql & " SET @rptQty = @tmpLastInvQty        " & vbCrLf
      sSql = sSql & " SET @rptCreditACC = @tmplastCreditAcc  " & vbCrLf
      sSql = sSql & " SET @rptDebitACC = @tmpLastDebitAcc    " & vbCrLf
      sSql = sSql & " End                                 " & vbCrLf
      sSql = sSql & " End                                 " & vbCrLf
      sSql = sSql & " End                                 " & vbCrLf
      sSql = sSql & " CLOSE curInv   --// close the cursor   " & vbCrLf
      sSql = sSql & " DEALLOCATE curInv          " & vbCrLf
      sSql = sSql & " IF (@partActCost = 0)      " & vbCrLf
      sSql = sSql & " BEGIN                      " & vbCrLf
      sSql = sSql & " SET @unitcost = @partStdCost  " & vbCrLf
      sSql = sSql & " SET @flgStdCost = 1        " & vbCrLf
      sSql = sSql & " End                        " & vbCrLf
      sSql = sSql & " Else                       " & vbCrLf
      sSql = sSql & " BEGIN                      " & vbCrLf
      sSql = sSql & " IF @lotHDOnly = 1          " & vbCrLf
      sSql = sSql & " BEGIN                      " & vbCrLf
      sSql = sSql & " SET @unitcost = @LotUnitCost  " & vbCrLf
      sSql = sSql & " SET @flgLdCost = 1            " & vbCrLf
      sSql = sSql & " End                           " & vbCrLf
      sSql = sSql & " Else                          " & vbCrLf
      sSql = sSql & " BEGIN                         " & vbCrLf
      sSql = sSql & " IF @lotCostedDate < DATEADD(dd, 1, @ReportDate) " & vbCrLf
      sSql = sSql & "    BEGIN                            " & vbCrLf
      sSql = sSql & "    SET @unitcost = @LotUnitCost     " & vbCrLf
      sSql = sSql & "    SET @flgLdCost = 1   " & vbCrLf
      sSql = sSql & "    End                  " & vbCrLf
      sSql = sSql & "    Else                 " & vbCrLf
      sSql = sSql & "    BEGIN                " & vbCrLf
      sSql = sSql & "    SET @unitcost = @rptInvcost   " & vbCrLf
      sSql = sSql & "    SET @flgInvCost = 1           " & vbCrLf
      sSql = sSql & "    End                        " & vbCrLf
      sSql = sSql & "    END --LotHD only           " & vbCrLf
      sSql = sSql & "    END --Part Cost            " & vbCrLf
      sSql = sSql & "    SELECT @CurACC = dbo.fnGetPartInvAccount(@partRef) " & vbCrLf
      sSql = sSql & "    -- Lastest < report account#        " & vbCrLf
      sSql = sSql & "    IF @rptQty >= 0.0000                " & vbCrLf
      sSql = sSql & "    SET @rptACC = @rptDebitACC          " & vbCrLf
      sSql = sSql & "    Else                                " & vbCrLf
      sSql = sSql & "    SET @rptACC = @rptCreditACC         " & vbCrLf
      sSql = sSql & "    IF ((@rptACC = '') OR (@rptACC = NULL))      " & vbCrLf
      sSql = sSql & "    BEGIN                   " & vbCrLf
      sSql = sSql & "    SET @rptACC = @CurACC   " & vbCrLf
      sSql = sSql & "    SET @flgRptAcc = 1      " & vbCrLf
      sSql = sSql & "    End                     " & vbCrLf
      sSql = sSql & "    -- last record          " & vbCrLf
      sSql = sSql & "    IF @lastQty >= 0.0000      " & vbCrLf
      sSql = sSql & "    SET @lastACC = @lastDebitACC  " & vbCrLf
      sSql = sSql & "    Else                          " & vbCrLf
      sSql = sSql & "    SET @lastACC = @lastCreditACC " & vbCrLf
      sSql = sSql & "    IF ((@lastACC = '') OR (@lastACC = NULL)) " & vbCrLf
      sSql = sSql & "    BEGIN                   " & vbCrLf
      sSql = sSql & "    SET @lastACC = @CurACC  " & vbCrLf
      sSql = sSql & "    SET @flgLastAcc = 1     " & vbCrLf
      sSql = sSql & "    End                     " & vbCrLf
      sSql = sSql & "    -- Lastest < report account#  " & vbCrLf
      sSql = sSql & "    IF @orgQty >= 0.0000          " & vbCrLf
      sSql = sSql & "    SET @orgACC = @orgDebitACC    " & vbCrLf
      sSql = sSql & "    Else                          " & vbCrLf
      sSql = sSql & "    SET @orgACC = @orgCreditACC      " & vbCrLf
      sSql = sSql & "    IF ((@orgACC = '') OR (@orgACC = NULL))   " & vbCrLf
      sSql = sSql & "    BEGIN                    " & vbCrLf
      sSql = sSql & "    SET @orgACC = @CurACC      " & vbCrLf
      sSql = sSql & "    SET @flgOrgAcc = 1      " & vbCrLf
      sSql = sSql & "    End                     " & vbCrLf
      sSql = sSql & "    -- Insert to the temp table   " & vbCrLf
      sSql = sSql & "    INSERT INTO #tempRMFGoods     " & vbCrLf
      sSql = sSql & "    (PARTNUM, PALEVEL, PADESC, PAEXTDESC, LOTNUMBER, LOTUSERLOTID, " & vbCrLf
      sSql = sSql & "    ORGINNUMBER, RPTINNUMBER, CURINNUMBER, ACTUALDATE,RPTDATEQTY, ORGQTY, COSTEDDATE,  " & vbCrLf
      sSql = sSql & "    UNITCOST,PASTDCOST, LOTUNITCOST, LOTTOTMATL,LOTTOTLABOR, LOTTOTEXP,LOTTOTOH," & vbCrLf
      sSql = sSql & "   ORGCOST, STDCOST, LSTACOST, RPTCOST, CURCOST, RPTACCOUNT,ORIGINALACC,   " & vbCrLf
      sSql = sSql & "    LASTACTVITYACC, CURRENTACC, PACLASS,PAPRODCODE,    " & vbCrLf
      sSql = sSql & "    flgStdCost, flgLdCost, flgInvCost, flgLdRQErr,  " & vbCrLf
      sSql = sSql & "    flgRptAcc, flgOrgAcc, flgLastAcc)      " & vbCrLf
      sSql = sSql & "    VALUES (@partRef, @partType, @partDesc, @partExDesc, @LotNumber,@LotUserID, @OrgInvNum,   " & vbCrLf
      sSql = sSql & "    @rptInvNum, @LastInvNum, @lotAcualDate,@rptRemQty,@lotOrgQty, @lotCostedDate, " & vbCrLf
      sSql = sSql & "    @unitcost,@partStdCost, @LotUnitCost,@lotTotMat, @lotTotLabor, " & vbCrLf
      sSql = sSql & "   @lotTotExp, @lotTotOH, @orgInvcost, @partStdCost,  " & vbCrLf
      sSql = sSql & "    @lastInvcost,@rptInvcost, @LotUnitCost, @rptACC, @orgACC, @lastACC,  " & vbCrLf
      sSql = sSql & "    @CurACC, @PartClass,@PartCode,@flgStdCost, @flgLdCost, @flgInvCost,  " & vbCrLf
      sSql = sSql & "    @flgLdRQErr, @flgRptAcc, @flgOrgAcc, @flgLastAcc)                    " & vbCrLf
      sSql = sSql & "    SET @rptRemQty = NULL   " & vbCrLf
      sSql = sSql & "    SET @deltaQty = NULL    " & vbCrLf
      sSql = sSql & "    SET @lotRemQty = NULL   " & vbCrLf
      sSql = sSql & "    SET @lotOrgQty = NULL   " & vbCrLf
      sSql = sSql & "    SET @tmpInvQty = NULL   " & vbCrLf
      sSql = sSql & "    SET @tmpLastInvQty  = NULL " & vbCrLf
      sSql = sSql & "    SET @rptInvcost = NULL  " & vbCrLf
      sSql = sSql & "    SET @lastInvcost = NULL " & vbCrLf
      sSql = sSql & "    SET @orgInvcost = NULL  " & vbCrLf
      sSql = sSql & "    SET @tmpInvCost = NULL  " & vbCrLf
      sSql = sSql & "    SET @unitcost = NULL    " & vbCrLf
      sSql = sSql & "    SET @tmpLastInvCost = NULL " & vbCrLf
      sSql = sSql & "    SET @lastQty = NULL  " & vbCrLf
      sSql = sSql & "    SET @orgQty = NULL   " & vbCrLf
      sSql = sSql & "    SET @rptQty  = NULL  " & vbCrLf
      sSql = sSql & "    SET @rptCreditACC = NULL   " & vbCrLf
      sSql = sSql & "    SET @rptDebitACC  = NULL   " & vbCrLf
      sSql = sSql & "   SET @rptACC  = NULL     " & vbCrLf
      sSql = sSql & "   SET @tmpCreditAcc  = NULL  " & vbCrLf
      sSql = sSql & "   SET @tmpDebitAcc = NULL    " & vbCrLf
      sSql = sSql & "   SET @tmplastCreditAcc = NULL  " & vbCrLf
      sSql = sSql & "   SET @tmpLastDebitAcc = NULL   " & vbCrLf
      sSql = sSql & "   SET @lastCreditACC = NULL     " & vbCrLf
      sSql = sSql & "   SET @lastDebitACC = NULL      " & vbCrLf
      sSql = sSql & "   SET @lastACC  = NULL          " & vbCrLf
      sSql = sSql & "   SET @orgCreditACC  = NULL     " & vbCrLf
      sSql = sSql & "   SET @orgDebitACC  = NULL      " & vbCrLf
      sSql = sSql & "   SET @orgACC  = NULL           " & vbCrLf
      sSql = sSql & "   SET @OrgInvNum = NULL         " & vbCrLf
      sSql = sSql & "   SET @rptInvNum = NULL         " & vbCrLf
      sSql = sSql & "   SET @LastInvNum = NULL        " & vbCrLf
      sSql = sSql & "   End                     " & vbCrLf
      sSql = sSql & "   FETCH NEXT FROM curLotHd INTO @LotNumber, @LotUserID, @partRef,   " & vbCrLf
      sSql = sSql & "   @partDesc, @partExDesc, @lotAcualDate, @lotOrgQty,                " & vbCrLf
      sSql = sSql & "   @lotRemQty,@LotUnitCost, @lotTotMat, @lotTotLabor, " & vbCrLf
      sSql = sSql & "   @lotTotExp, @lotTotOH, @lotCostedDate,                          " & vbCrLf
      sSql = sSql & "   @PartClass, @PartCode, @partStdCost, @partActCost, @partLotTrack, @partType   " & vbCrLf
      sSql = sSql & "   End                                    " & vbCrLf
      sSql = sSql & "   CLOSE curLotHd   --// close the cursor " & vbCrLf
      sSql = sSql & "   DEALLOCATE curLotHd                    " & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   DECLARE curLot CURSOR  FOR" & vbCrLf
      sSql = sSql & "     SELECT DISTINCT LOTNUMBER" & vbCrLf
      sSql = sSql & "     FROM #tempRMFGoods" & vbCrLf
      sSql = sSql & "   OPEN curLot" & vbCrLf
      sSql = sSql & "   FETCH NEXT FROM curLot INTO @InputLotNum" & vbCrLf
      sSql = sSql & "   WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "   IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "      Print 'LotNumber:' + @InputLotNum" & vbCrLf
      sSql = sSql & "      " & vbCrLf
      sSql = sSql & "      EXECUTE GetMOOverHead @InputLotNum, '',0,0.0,@CalTotOH = @TotMOOH OUTPUT;" & vbCrLf
      sSql = sSql & "      " & vbCrLf
      sSql = sSql & "      UPDATE #tempRMFGoods SET CALLOTTOTOH = @TotMOOH" & vbCrLf
      sSql = sSql & "         WHERE LOTNUMBER = @InputLotNum" & vbCrLf
      sSql = sSql & "      " & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "   FETCH NEXT FROM curLot INTO @InputLotNum" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "      " & vbCrLf
      sSql = sSql & "   Close curLot" & vbCrLf
      sSql = sSql & "   DEALLOCATE curLot" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   --// update all the Null value." & vbCrLf
      sSql = sSql & "   UPDATE #tempRMFGoods SET CALLOTTOTOH = LOTTOTOH WHERE CALLOTTOTOH IS NULL" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   SELECT LOTNUMBER, PARTNUM,PADESC,ACTUALDATE,ORGQTY,RPTDATEQTY,Unitcost,LotUnitcost," & vbCrLf
      sSql = sSql & "      LOTTOTMATL, LOTTOTLABOR, LOTTOTEXP, LOTTOTOH,CALLOTTOTOH,PALEVEL" & vbCrLf
      sSql = sSql & "   FROM #tempRMFGoods WHERE RPTDATEQTY > 0 order by PALEVEL, partNum" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "      " & vbCrLf
      sSql = sSql & "                                           " & vbCrLf
      sSql = sSql & "   DROP table #tempRMFGoods            " & vbCrLf
      sSql = sSql & "   End "
     
     ExecuteScript False, sSql
      
      
      If StoreProcedureExists("RptMOCostDetail") Then
         sSql = "DROP PROCEDURE RptMOCostDetail"
         ExecuteScript False, sSql
      End If
      
      sSql = "CREATE PROCEDURE [dbo].[RptMOCostDetail]" & vbCrLf
      sSql = sSql & "      @MOPart as varchar(30),@MORun as int, @MOQty as decimal(15,4)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "AS " & vbCrLf
      sSql = sSql & "BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   declare @SumTotMat decimal(15,4)a" & vbCrLf
      sSql = sSql & "   declare @SumTotLabor decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @SumTotExp decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @SumTotOH decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @level as integer" & vbCrLf
      sSql = sSql & "   declare @Part as varchar(30)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   declare @PrevParent  as varchar(30)" & vbCrLf
      sSql = sSql & "   declare @RowCount as integer" & vbCrLf
      sSql = sSql & "   declare @ChildPart as varchar(30)" & vbCrLf
      sSql = sSql & "   declare @ParentPart as varchar(30)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   declare @ChildKey as varchar(1024)" & vbCrLf
      sSql = sSql & "   declare @GLSortKey as varchar(1024)" & vbCrLf
      sSql = sSql & "   declare @SortKey as varchar(1024)" & vbCrLf
      sSql = sSql & "   declare @ParentLotNum as varchar(15)" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   declare @Maxlevel as int" & vbCrLf
      sSql = sSql & "   declare @LotRunNo as int" & vbCrLf
      sSql = sSql & "   declare @LotOrgQty as decimal(15,4)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   CREATE TABLE #tempMOPartsDetail " & vbCrLf
      sSql = sSql & "   ( " & vbCrLf
      sSql = sSql & "      INMOPART Varchar(30) NULL, " & vbCrLf
      sSql = sSql & "      INMORUN int NULL , " & vbCrLf
      sSql = sSql & "      INPART varchar(30) NULL , " & vbCrLf
      sSql = sSql & "      LOTNUMBER varchar(15) NULL, " & vbCrLf
      sSql = sSql & "      INTOTMATL decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      INTOTLABOR decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      INTOTEXP decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      INTOTOH decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      LOTTOTMATL decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      LOTTOTLABOR decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      LOTTOTEXP decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      LOTTOTOH decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      SUMTOTMAL decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      SUMTOTLABOR decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      SUMTOTEXP decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      SUMTOTOH decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      LOTDATECOSTED smalldatetime NULL," & vbCrLf
      sSql = sSql & "      SortKey varchar(512) NULL," & vbCrLf
      sSql = sSql & "      HASCHILD int NULL," & vbCrLf
      sSql = sSql & "      SORTKEYLEVEL tinyint NULL," & vbCrLf
      sSql = sSql & "      SortKeyRev varchar(512)," & vbCrLf
      sSql = sSql & "      PARTSUM varchar(40)," & vbCrLf
      sSql = sSql & "      BMQTYREQD decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      LOTORGQTY decimal(12,4) NULL," & vbCrLf
      sSql = sSql & "      BMTOTOH decimal(12,4) NULL" & vbCrLf
      sSql = sSql & "   ) " & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "--ALTER TABLE tempMOPartsDetail ADD SortKeyRev varchar(512)" & vbCrLf
      sSql = sSql & "--ALTER TABLE tempMOPartsDetail ADD PARTSUM varchar(40)" & vbCrLf
      sSql = sSql & "--ALTER TABLE tempMOPartsDetail ADD BMQTYREQD decimal(12,4) NULL, LOTORGQTY decimal(12,4) NULL" & vbCrLf
      sSql = sSql & "--ALTER TABLE tempMOPartsDetail ADD BMTOTOH decimal(12,4) NULL" & vbCrLf
      sSql = sSql & "  " & vbCrLf
      sSql = sSql & "--   DELETE FROM tempMOPartsDetail" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "      with cte" & vbCrLf
      sSql = sSql & "      as" & vbCrLf
      sSql = sSql & "      (select BMASSYPART, BMPARTREF,  BMQTYREQD,0 as level, cast('1' + char(36)+ BMPARTREF as varchar(max)) as SortKey" & vbCrLf
      sSql = sSql & "      from BmplTable" & vbCrLf
      sSql = sSql & "      where BMASSYPART = @MOPart" & vbCrLf
      sSql = sSql & "      union all" & vbCrLf
      sSql = sSql & "      select a.BMASSYPART, a.BMPARTREF, a.BMQTYREQD, level + 1," & vbCrLf
      sSql = sSql & "         cast(COALESCE(SortKey,'') + char(36) + COALESCE(a.BMPARTREF,'') as varchar(max))as SortKey" & vbCrLf
      sSql = sSql & "      from cte" & vbCrLf
      sSql = sSql & "         inner join BmplTable a" & vbCrLf
      sSql = sSql & "            on cte.BMPARTREF = a.BMASSYPART " & vbCrLf
      sSql = sSql & "      )" & vbCrLf
      sSql = sSql & "      INSERT INTO #tempMOPartsDetail(INMOPART,INPART,BMQTYREQD,SORTKEYLEVEL,SortKey)" & vbCrLf
      sSql = sSql & "      select BMASSYPART, BMPARTREF,BMQTYREQD,level,SortKey " & vbCrLf
      sSql = sSql & "         from cte order by SortKey " & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   END" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   --// update the top level" & vbCrLf
      sSql = sSql & "   UPDATE #tempMOPartsDetail SET INMORUN = @MORun, LOTNUMBER = b.INLOTNUMBER, " & vbCrLf
      sSql = sSql & "            INTOTMATL = b.INTOTMATL, INTOTLABOR = b.INTOTLABOR, " & vbCrLf
      sSql = sSql & "            INTOTEXP = b.INTOTEXP, INTOTOH = b.INTOTOH, " & vbCrLf
      sSql = sSql & "            LOTTOTMATL = c.LOTTOTMATL, LOTTOTLABOR = c.LOTTOTLABOR, " & vbCrLf
      sSql = sSql & "            LOTTOTEXP = c.LOTTOTEXP, LOTTOTOH = c.LOTTOTOH," & vbCrLf
      sSql = sSql & "            LOTDATECOSTED = c.LOTDATECOSTED, LOTORGQTY = c.LOTORIGINALQTY," & vbCrLf
      sSql = sSql & "            BMTOTOH = (c.LOTTOTOH * BMQTYREQD) / c.LOTORIGINALQTY" & vbCrLf
      sSql = sSql & "   FROM #tempMOPartsDetail d, InvaTable b, LohdTable c" & vbCrLf
      sSql = sSql & "   WHERE d.INMOPART = b.INMOPART AND d.INPART = b.INPART " & vbCrLf
      sSql = sSql & "      AND b.INLOTNUMBER = c.LOTnumber" & vbCrLf
      sSql = sSql & "      and c.lotpartref = b.INPART" & vbCrLf
      sSql = sSql & "      and b.INMOPART = @MOPart AND b.INMORUN  = @MORun" & vbCrLf
      sSql = sSql & "      AND b.INTYPE = 10 AND SORTKEYLEVEL = 0" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   --// set the totals for " & vbCrLf
      sSql = sSql & "   SELECT @Maxlevel =  MAX(SORTKEYLEVEL) FROM #tempMOPartsDetail" & vbCrLf
      sSql = sSql & "   SET @level  = 1" & vbCrLf
      sSql = sSql & "   WHILE (@level <= @Maxlevel )" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "      DECLARE curMORun CURSOR  FOR" & vbCrLf
      sSql = sSql & "      SELECT DISTINCT INMOPART,INPART " & vbCrLf
      sSql = sSql & "         FROM #tempMOPartsDetail WHERE SORTKEYLEVEL = @level" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "      OPEN curMORun" & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM curMORun INTO @MOPart, @Part" & vbCrLf
      sSql = sSql & "      WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "      BEGIN" & vbCrLf
      sSql = sSql & "         IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "         BEGIN" & vbCrLf
      sSql = sSql & "         " & vbCrLf
      sSql = sSql & "         SELECT @ParentLotNum = LOTNUMBER FROM #tempMOPartsDetail  WHERE" & vbCrLf
      sSql = sSql & "               INPART = @MOPart AND SORTKEYLEVEL = @level - 1" & vbCrLf
      sSql = sSql & "         " & vbCrLf
      sSql = sSql & "         SELECT @LotRunNo = LOTMORUNNO, @LotOrgQty = LOTORIGINALQTY " & vbCrLf
      sSql = sSql & "                  FROM lohdTable where LOTNUMBER = @ParentLotNum" & vbCrLf
      sSql = sSql & "         " & vbCrLf
      sSql = sSql & "         --// update the top level" & vbCrLf
      sSql = sSql & "         UPDATE #tempMOPartsDetail SET INMORUN = @LotRunNo, LOTNUMBER = b.INLOTNUMBER, " & vbCrLf
      sSql = sSql & "                  INTOTMATL = b.INTOTMATL, INTOTLABOR = b.INTOTLABOR, " & vbCrLf
      sSql = sSql & "                  INTOTEXP = b.INTOTEXP, INTOTOH = b.INTOTOH, " & vbCrLf
      sSql = sSql & "                  LOTTOTMATL = c.LOTTOTMATL, LOTTOTLABOR = c.LOTTOTLABOR, " & vbCrLf
      sSql = sSql & "                  LOTTOTEXP = c.LOTTOTEXP, LOTTOTOH = c.LOTTOTOH," & vbCrLf
      sSql = sSql & "                  LOTDATECOSTED = c.LOTDATECOSTED, LOTORGQTY = @LotOrgQty," & vbCrLf
      sSql = sSql & "                  BMTOTOH = (c.LOTTOTOH * BMQTYREQD) / @LotOrgQty" & vbCrLf
      sSql = sSql & "         FROM #tempMOPartsDetail d, InvaTable b, LohdTable c" & vbCrLf
      sSql = sSql & "         WHERE d.INMOPART = b.INMOPART AND d.INPART = b.INPART " & vbCrLf
      sSql = sSql & "            AND b.INLOTNUMBER = c.LOTnumber" & vbCrLf
      sSql = sSql & "            and c.lotpartref = b.INPART" & vbCrLf
      sSql = sSql & "            and b.INMOPART = @MOPart AND b.INMORUN  = @LotRunNo" & vbCrLf
      sSql = sSql & "            AND b.INTYPE = 10 AND SORTKEYLEVEL = @level" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "      End" & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM curMORun INTO @MOPart, @Part" & vbCrLf
      sSql = sSql & "      End" & vbCrLf
      sSql = sSql & "      Close curMORun" & vbCrLf
      sSql = sSql & "      DEALLOCATE curMORun" & vbCrLf
      sSql = sSql & "      SET @level = @level + 1" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   SELECT @level =  MAX(SORTKEYLEVEL) FROM #tempMOPartsDetail" & vbCrLf
      sSql = sSql & "   WHILE (@level >= 0 )" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "      DECLARE curMODet CURSOR  FOR" & vbCrLf
      sSql = sSql & "      --SELECT INPART, LOTTOTMATL, LOTTOTLABOR, LOTTOTEXP , LOTTOTOH FROM tempMOPartsDetail" & vbCrLf
      sSql = sSql & "      -- WHERE INPART = '775345149'" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "      SELECT INMOPART, " & vbCrLf
      sSql = sSql & "      SUM(IsNull(LOTTOTMATL, 0)), SUM(ISNULL(LOTTOTLABOR,0)) ," & vbCrLf
      sSql = sSql & "        Sum (IsNull(LOTTOTEXP, 0)) , SUM(IsNull(BMTOTOH, 0))" & vbCrLf
      sSql = sSql & "      From" & vbCrLf
      sSql = sSql & "         (SELECT DISTINCT INMOPART,INMORUN,INPART,LOTTOTMATL,LOTTOTLABOR," & vbCrLf
      sSql = sSql & "         LOTTOTEXP,LOTTOTOH,SUMTOTMAL,SUMTOTLABOR, SUMTOTEXP, SUMTOTOH,BMTOTOH" & vbCrLf
      sSql = sSql & "         FROM #tempMOPartsDetail WHERE SORTKEYLEVEL = @level) as foo" & vbCrLf
      sSql = sSql & "      group by INMOPART" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "      OPEN curMODet" & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM curMODet INTO @MOPart, @SumTotMat, @SumTotLabor,@SumTotExp,@SumTotOH" & vbCrLf
      sSql = sSql & "      WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "      BEGIN" & vbCrLf
      sSql = sSql & "         IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "         BEGIN" & vbCrLf
      sSql = sSql & "            " & vbCrLf
      sSql = sSql & "            print 'PartNum : ' + @MOPart" & vbCrLf
      sSql = sSql & "            print 'SumTotoh : ' + Convert(varchar(24), @SumTotOH)" & vbCrLf
      sSql = sSql & "            " & vbCrLf
      sSql = sSql & "            UPDATE #tempMOPartsDetail SET SUMTOTMAL = LOTTOTMATL + @SumTotMat, " & vbCrLf
      sSql = sSql & "            SUMTOTLABOR = LOTTOTLABOR + @SumTotLabor," & vbCrLf
      sSql = sSql & "               SUMTOTEXP = LOTTOTEXP + @SumTotExp, SUMTOTOH = (BMTOTOH + @SumTotOH) * @MOQty , " & vbCrLf
      sSql = sSql & "               HASCHILD = 1,PARTSUM = 'TOTAL ' + LTRIM(INPART)" & vbCrLf
      sSql = sSql & "            " & vbCrLf
      sSql = sSql & "            WHERE INPART = @MOPart AND SORTKEYLEVEL = @level - 1" & vbCrLf
      sSql = sSql & "            " & vbCrLf
      sSql = sSql & "      End" & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM curMODet INTO @MOPart, @SumTotMat, @SumTotLabor,@SumTotExp,@SumTotOH" & vbCrLf
      sSql = sSql & "      End" & vbCrLf
      sSql = sSql & "      Close curMODet" & vbCrLf
      sSql = sSql & "      DEALLOCATE curMODet" & vbCrLf
      sSql = sSql & "      SET @level = @level - 1" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   --// update the Lower level cost detail" & vbCrLf
      sSql = sSql & "    UPDATE #tempMOPartsDetail SET SUMTOTMAL = LOTTOTMATL, SUMTOTLABOR = LOTTOTLABOR," & vbCrLf
      sSql = sSql & "       SUMTOTEXP = LOTTOTEXP, SUMTOTOH = BMTOTOH WHERE HASCHILD IS NULL" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   SET @SumTotMat  = 0" & vbCrLf
      sSql = sSql & "   SET @SumTotLabor  = 0" & vbCrLf
      sSql = sSql & "   SET @SumTotExp  = 0" & vbCrLf
      sSql = sSql & "   SET @SumTotOH  = 0" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   --// Udpate the Root total" & vbCrLf
      sSql = sSql & "    SELECT @SumTotMat = SUM(SUMTOTMAL), @SumTotLabor = SUM(SUMTOTLABOR)," & vbCrLf
      sSql = sSql & "         @SumTotExp = SUM(SUMTOTEXP) ,@SumTotOH = SUM(SUMTOTOH)" & vbCrLf
      sSql = sSql & "     FROM #tempMOPartsDetail WHERE SORTKEYLEVEL = 0 " & vbCrLf
      sSql = sSql & "      AND  RTRIM(INMOPART) <> RTRIM(INPART)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "    UPDATE #tempMOPartsDetail SET PARTSUM = INPART" & vbCrLf
      sSql = sSql & "      WHERE PARTSUM IS NULL" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "  ----  SELECT * FROM tempMOPartsDetail WHERE SORTKEYLEVEL = 0 " & vbCrLf
      sSql = sSql & "      ----AND  RTRIM(INMOPART) = RTRIM(INPART)" & vbCrLf
      sSql = sSql & "   --// Reverse the partnumbers." & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   set @level = 0 " & vbCrLf
      sSql = sSql & "   set @RowCount = 1" & vbCrLf
      sSql = sSql & "   SET @PrevParent = ''" & vbCrLf
      sSql = sSql & "   DECLARE curAcctStruc CURSOR  FOR" & vbCrLf
      sSql = sSql & "      SELECT INMOPART, SortKey" & vbCrLf
      sSql = sSql & "      FROM #tempMOPartsDetail " & vbCrLf
      sSql = sSql & "         WHERE HASCHILD IS NULL --GLFSLEVEL = 8 --AND GLMASTER ='AA10'--GLTOPMaster = 1 AND " & vbCrLf
      sSql = sSql & "      ORDER BY SortKey" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   OPEN curAcctStruc" & vbCrLf
      sSql = sSql & "   FETCH NEXT FROM curAcctStruc INTO @ParentPart, @SortKey" & vbCrLf
      sSql = sSql & "   WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "    IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "    BEGIN" & vbCrLf
      sSql = sSql & "      if (@PrevParent <> @ParentPart)" & vbCrLf
      sSql = sSql & "      BEGIN" & vbCrLf
      sSql = sSql & "         UPDATE #tempMOPartsDetail SET " & vbCrLf
      sSql = sSql & "            SortKeyRev = RIGHT ('0000'+ Cast(@RowCount as varchar), 4) + char(36)+ @ParentPart" & vbCrLf
      sSql = sSql & "         WHERE INMOPART = @ParentPart AND HASCHILD IS NULL --GLFSLEVEL = 8 --AND GLTOPMaster = 1 " & vbCrLf
      sSql = sSql & "         SET @RowCount = @RowCount + 1" & vbCrLf
      sSql = sSql & "         SET @PrevParent = @ParentPart" & vbCrLf
      sSql = sSql & "      END" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "    End" & vbCrLf
      sSql = sSql & "    FETCH NEXT FROM curAcctStruc INTO @ParentPart, @SortKey" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "       " & vbCrLf
      sSql = sSql & "   Close curAcctStruc" & vbCrLf
      sSql = sSql & "   DEALLOCATE curAcctStruc" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   SELECT @level =  MAX(SORTKEYLEVEL) FROM #tempMOPartsDetail" & vbCrLf
      sSql = sSql & "   --set @level = 7" & vbCrLf
      sSql = sSql & "   WHILE (@level >= 0 )" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "      SET @PrevParent = ''" & vbCrLf
      sSql = sSql & "        DECLARE curAcctStruc1 CURSOR  FOR" & vbCrLf
      sSql = sSql & "         SELECT DISTINCT INPART, INMOPART, SortKey" & vbCrLf
      sSql = sSql & "         FROM #tempMOPartsDetail " & vbCrLf
      sSql = sSql & "            WHERE SORTKEYLEVEL = @level AND HASCHILD IS NOT NULL--GLTOPMaster = 1 AND " & vbCrLf
      sSql = sSql & "         order by SortKey" & vbCrLf
      sSql = sSql & "    " & vbCrLf
      sSql = sSql & "        OPEN curAcctStruc1" & vbCrLf
      sSql = sSql & "        FETCH NEXT FROM curAcctStruc1 INTO @ChildPart, @ParentPart, @SortKey" & vbCrLf
      sSql = sSql & "        WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "        BEGIN" & vbCrLf
      sSql = sSql & "          IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "          BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "            if (@PrevParent <> @ChildPart)" & vbCrLf
      sSql = sSql & "            BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   print 'Record' + @ChildPart + ':' + @ParentPart" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "               SELECT TOP 1 @ChildKey = SortKeyRev,@SortKey = SortKey" & vbCrLf
      sSql = sSql & "               FROM #tempMOPartsDetail " & vbCrLf
      sSql = sSql & "                  WHERE SORTKEYLEVEL > @level AND INMOPART = @ChildPart --GLTOPMaster = 1 AND " & vbCrLf
      sSql = sSql & "               order by SortKey desc" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "               UPDATE #tempMOPartsDetail SET " & vbCrLf
      sSql = sSql & "                  SortKeyRev = Cast(@ChildKey as varchar(256)) + char(36)+ @ParentPart" & vbCrLf
      sSql = sSql & "               WHERE INPART = @ChildPart AND INMOPART = @ParentPart " & vbCrLf
      sSql = sSql & "                  AND SORTKEYLEVEL = @level --GLTOPMaster = 1 AND " & vbCrLf
      sSql = sSql & "               " & vbCrLf
      sSql = sSql & "               SET @PrevParent = @ChildPart" & vbCrLf
      sSql = sSql & "            END" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "          End" & vbCrLf
      sSql = sSql & "         FETCH NEXT FROM curAcctStruc1 INTO @ChildPart, @ParentPart, @SortKey" & vbCrLf
      sSql = sSql & "        End" & vbCrLf
      sSql = sSql & "               " & vbCrLf
      sSql = sSql & "        Close curAcctStruc1" & vbCrLf
      sSql = sSql & "        DEALLOCATE curAcctStruc1" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "        SET @level = @level - 1" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   SELECT SortKeyRev,HASCHILD,INMOPART,INMORUN,INPART,PARTSUM,SORTKEYLEVEL,LOTNUMBER," & vbCrLf
      sSql = sSql & "      LOTTOTMATL,SUMTOTMAL, LOTTOTLABOR,SUMTOTLABOR, LOTTOTEXP, SUMTOTEXP, LOTTOTOH,SUMTOTOH,BMTOTOH," & vbCrLf
      sSql = sSql & "        LOTDATECOSTED, BMQTYREQD, LOTORGQTY, SORTKEYLEVEL,SortKey      " & vbCrLf
      sSql = sSql & "   FROM #tempMOPartsDetail --WHERE SORTKEYLEVEL = 1" & vbCrLf
      sSql = sSql & "   order by SortKeyRev      " & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   DROP table #tempMOPartsDetail " & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "END"
      
      ExecuteScript False, sSql
      
      ' update the version
      ExecuteScript False, "Update Version Set Version = " & newver
   
   End If
End Function

Private Function UpdateDatabase52()
   newver = 126
   If ver < newver Then
   
      If Not ColumnExists("ComnTable", "CODATACOLMOD") Then
         sSql = "ALTER TABLE ComnTable ADD CODATACOLMOD smallint"
         ExecuteScript False, sSql
      End If

      
      If Not TableExists("featAccs") Then
      
         sSql = "CREATE TABLE [dbo].[featAccs](" & vbCrLf
         sSql = sSql & "   [FEATUREID] [varchar](24) NULL," & vbCrLf
         sSql = sSql & "   [FEATURENAME] [varchar](24) NULL," & vbCrLf
         sSql = sSql & "   [FEATUREGRP] [smallint] NULL," & vbCrLf
         sSql = sSql & "   [FEATUREEDT] [smallint] NULL," & vbCrLf
         sSql = sSql & "   [FEATUREVW] [smallint] NULL," & vbCrLf
         sSql = sSql & "   [FEATUREFN] [smallint] NULL," & vbCrLf
         sSql = sSql & "   [USRNAME] [varchar](24) NULL" & vbCrLf
         sSql = sSql & ") ON [PRIMARY]"
      
         ExecuteScript False, sSql
      End If


      If Not TableExists("ChmImpTable") Then
         sSql = "CREATE TABLE [dbo].[ChmImpTable](" & vbCrLf
         sSql = sSql & "   [CHEMDATAID] [int] NOT NULL IDENTITY(1, 1)," & vbCrLf
         sSql = sSql & "   [IMPORTFILEID] [int] NOT NULL," & vbCrLf
         sSql = sSql & "   [HEATNUM] [varchar](24) NOT NULL," & vbCrLf
         sSql = sSql & "   [DATE] [datetime] NULL," & vbCrLf
         sSql = sSql & "   [TIME] [varchar](12) NULL," & vbCrLf
         sSql = sSql & "   [DATEFORMAT] [datetime] NULL," & vbCrLf
         sSql = sSql & "   [Al] [decimal](18, 4) NULL," & vbCrLf
         sSql = sSql & "   [Be] [decimal](18, 4) NULL," & vbCrLf
         sSql = sSql & "   [Ca] [decimal](18, 4) NULL," & vbCrLf
         sSql = sSql & "   [Cr] [decimal](18, 4) NULL," & vbCrLf
         sSql = sSql & "   [Cu] [decimal](18, 4) NULL," & vbCrLf
         sSql = sSql & "   [Fe] [decimal](18, 4) NULL," & vbCrLf
         sSql = sSql & "   [Mg] [decimal](18, 4) NULL," & vbCrLf
         sSql = sSql & "   [Mn] [decimal](18, 4) NULL," & vbCrLf
         sSql = sSql & "   [Na] [decimal](18, 4) NULL," & vbCrLf
         sSql = sSql & "   [Ni] [decimal](18, 4) NULL," & vbCrLf
         sSql = sSql & "   [Si] [decimal](18, 4) NULL," & vbCrLf
         sSql = sSql & "   [Sn] [decimal](18, 4) NULL," & vbCrLf
         sSql = sSql & "   [Sr] [decimal](18, 4) NULL," & vbCrLf
         sSql = sSql & "   [V] [decimal](18, 4) NULL," & vbCrLf
         sSql = sSql & "   [Ti] [decimal](18, 4) NULL," & vbCrLf
         sSql = sSql & "   [Zi] [decimal](18, 4) NULL" & vbCrLf
         sSql = sSql & ") ON [PRIMARY]"
         
         ExecuteScript False, sSql
      End If


      If Not TableExists("ChmFlTable") Then
         sSql = "CREATE TABLE [dbo].[ChmFlTable](" & vbCrLf
         sSql = sSql & "   [IMPORTFILEID] [int] NOT NULL IDENTITY(1, 1)," & vbCrLf
         sSql = sSql & "   [IMPORTFILENAME] [varchar](50) NOT NULL" & vbCrLf
         sSql = sSql & ") ON [PRIMARY]"
         
         ExecuteScript False, sSql
      End If

      If Not TableExists("TnbarTable") Then
         sSql = "CREATE TABLE [dbo].[TnbarTable](" & vbCrLf
         sSql = sSql & "   [TNSNFORMID] [int] NOT NULL," & vbCrLf
         sSql = sSql & "   [TNSERIALNUM] [int] NOT NULL," & vbCrLf
         sSql = sSql & "   [YIELDSTR] [decimal](18, 2) NULL," & vbCrLf
         sSql = sSql & "   [TENSILESTR] [decimal](18, 2) NULL," & vbCrLf
         sSql = sSql & "   [ELONGATION] [decimal](18, 2) NULL," & vbCrLf
         sSql = sSql & "   [MIN] [varchar](24) NULL," & vbCrLf
         sSql = sSql & "   [PASSFAIL] [smallint] NULL," & vbCrLf
         sSql = sSql & "   [LABTESTED] [smallint] NULL," & vbCrLf
         sSql = sSql & "   [FRACTUREMIDGL] [varchar](24) NULL," & vbCrLf
         sSql = sSql & "   [BARINSP] [smallint] NULL," & vbCrLf
         sSql = sSql & "   [MACHINED] [smallint] NULL," & vbCrLf
         sSql = sSql & "   [BARNUM] [int] NULL" & vbCrLf
         sSql = sSql & ") ON [PRIMARY]"
         
         ExecuteScript False, sSql
      End If

      If Not TableExists("TntshdTable") Then
         sSql = "CREATE TABLE [dbo].[TntshdTable](" & vbCrLf
         sSql = sSql & "   [TENSILEFORMID] [int] NOT NULL," & vbCrLf
         sSql = sSql & "   [CUSTOMER] [varchar](24) NOT NULL," & vbCrLf
         sSql = sSql & "   [MOPARTNUM] [varchar](30) NOT NULL," & vbCrLf
         sSql = sSql & "   [MORUN] [int] NOT NULL," & vbCrLf
         sSql = sSql & "   [ALLOYTEMP] [varchar](24) NULL," & vbCrLf
         sSql = sSql & "   [ALLOYSPEC] [varchar](24) NULL," & vbCrLf
         sSql = sSql & "   [FURNACE] [varchar](26) NULL," & vbCrLf
         sSql = sSql & "   [CASTDATE] [datetime] NULL," & vbCrLf
         sSql = sSql & "   [TEMPERATURE] [decimal](18, 2) NULL," & vbCrLf
         sSql = sSql & "   [HEATNUM] [varchar](24) NULL," & vbCrLf
         sSql = sSql & "   [NUMOFBARSPULLED] [int] NULL," & vbCrLf
         sSql = sSql & "   [REPORTNUM] [int] NULL," & vbCrLf
         sSql = sSql & "   [OPERATOR] [varchar](24) NULL," & vbCrLf
         sSql = sSql & "   [TESTDATE] [datetime] NULL," & vbCrLf
         sSql = sSql & "   [INSPECTOR] [varchar](24) NULL," & vbCrLf
         sSql = sSql & "   [HUMIDITY]  [decimal](18, 2) NULL" & vbCrLf
         sSql = sSql & ") ON [PRIMARY]"
         
         ExecuteScript False, sSql
      End If

      If Not TableExists("TnTsLkupTable") Then
         sSql = "CREATE TABLE [dbo].[TnTsLkupTable](" & vbCrLf
         sSql = sSql & "   [TENSILEPARTNUM] [varchar](30) NOT NULL," & vbCrLf
         sSql = sSql & "   [CUSTOMER] [varchar](50) NOT NULL," & vbCrLf
         sSql = sSql & "   [ALLOY] [varchar](24) NOT NULL," & vbCrLf
         sSql = sSql & "   [SPECS] [varchar](24) NOT NULL," & vbCrLf
         sSql = sSql & "   [YIELD] [int] NULL," & vbCrLf
         sSql = sSql & "   [TENSION] [int] NULL," & vbCrLf
         sSql = sSql & "   [ELONGATION] [decimal](18, 2) NULL," & vbCrLf
         sSql = sSql & "   [YLD_TEN_ELNG] [varchar](24) NULL" & vbCrLf
         sSql = sSql & ") ON [PRIMARY]"
         
         ExecuteScript False, sSql
      End If

      ' update the version
      ExecuteScript False, "Update Version Set Version = " & newver
   
   End If
End Function


Private Function UpdateDatabase53()
   newver = 127
   If ver < newver Then
   
      sSql = "ALTER PROCEDURE [dbo].[RptRMFGoodsWithCost] " & vbCrLf
      sSql = sSql & " @ReportDate as varchar(16), @PartClass as Varchar(16), " & vbCrLf
      sSql = sSql & " @PartCode as varchar(8), @lotHDOnly as int, @PartType1 as Integer, " & vbCrLf
      sSql = sSql & " @PartType2 as Integer, @PartType3 as Integer, @PartType4 as Integer " & vbCrLf
      sSql = sSql & " AS        " & vbCrLf
      sSql = sSql & " BEGIN      " & vbCrLf
      sSql = sSql & "   declare @partRef as varchar(30)   " & vbCrLf
      sSql = sSql & "   declare @partType as int           " & vbCrLf
      sSql = sSql & "   declare @partDesc as varchar(30)     " & vbCrLf
      sSql = sSql & "   declare @partExDesc as varchar(3072)    " & vbCrLf
      sSql = sSql & "   declare @rptRemQty as decimal(12,4)  " & vbCrLf
      sSql = sSql & "   declare @deltaQty as decimal(12,4)   " & vbCrLf
      sSql = sSql & "   declare @lotRemQty as decimal(12,4)  " & vbCrLf
      sSql = sSql & "   declare @lotOrgQty as decimal(12,4)  " & vbCrLf
      sSql = sSql & "   declare @tmpInvQty as decimal(12,4)  " & vbCrLf
      sSql = sSql & "   declare @tmpLastInvQty as decimal(12,4)    " & vbCrLf
      sSql = sSql & "   declare @rptInvcost decimal(12,4)    " & vbCrLf
      sSql = sSql & "   declare @lastInvcost decimal(12,4)   " & vbCrLf
      sSql = sSql & "   declare @orgInvcost decimal(12,4)    " & vbCrLf
      sSql = sSql & "   declare @tmpInvCost decimal(12,4)    " & vbCrLf
      sSql = sSql & "   declare @tmpLastInvCost decimal(12,4)   " & vbCrLf
      sSql = sSql & "   declare @lastQty as decimal(12,4)    " & vbCrLf
      sSql = sSql & "   declare @orgQty as decimal(12,4)  " & vbCrLf
      sSql = sSql & "   declare @rptQty as decimal(12,4)  " & vbCrLf
      sSql = sSql & "   declare @rptCreditACC varchar(12)    " & vbCrLf
      sSql = sSql & " declare @rptDebitACC varchar(12)" & vbCrLf
      sSql = sSql & " declare @rptACC varchar(12)   " & vbCrLf
      sSql = sSql & " declare @CurACC varchar(12)   " & vbCrLf
      sSql = sSql & " declare @tmpCreditAcc varchar(12)   " & vbCrLf
      sSql = sSql & " declare @tmpDebitAcc varchar(12) " & vbCrLf
      sSql = sSql & " declare @tmplastCreditAcc varchar(12)  " & vbCrLf
      sSql = sSql & " declare @tmpLastDebitAcc varchar(12)   " & vbCrLf
      sSql = sSql & " declare @lastCreditACC varchar(12)  " & vbCrLf
      sSql = sSql & " declare @lastDebitACC varchar(12)   " & vbCrLf
      sSql = sSql & " declare @lastACC varchar(12)  " & vbCrLf
      sSql = sSql & " declare @orgCreditACC varchar(12)" & vbCrLf
      sSql = sSql & " declare @orgDebitACC varchar(12) " & vbCrLf
      sSql = sSql & " declare @orgACC varchar(12)   " & vbCrLf
      sSql = sSql & " declare @OrgInvNum as int  " & vbCrLf
      sSql = sSql & " declare @rptInvNum as int  " & vbCrLf
      sSql = sSql & " declare @LastInvNum as int " & vbCrLf
      sSql = sSql & " declare @tmpInvNum as int  " & vbCrLf
      sSql = sSql & " declare @tmpLastInvNum as int " & vbCrLf
      sSql = sSql & " declare @LotNumber varchar(51)   " & vbCrLf
      sSql = sSql & " declare @LotUserID varchar(51)   " & vbCrLf
      sSql = sSql & " declare @lotAcualDate as smalldatetime " & vbCrLf
      sSql = sSql & " declare @lotCostedDate as smalldatetime   " & vbCrLf
      sSql = sSql & " declare @curDate as smalldatetime   " & vbCrLf
      sSql = sSql & " declare @AcualDate as smalldatetime " & vbCrLf
      sSql = sSql & " declare @CostedDate as smalldatetime   " & vbCrLf
      sSql = sSql & " declare @tmpINVAdate  as smalldatetime   " & vbCrLf
      sSql = sSql & " declare @tmpLastINVAdate  as smalldatetime   " & vbCrLf
      sSql = sSql & " declare @unitcost as decimal(12,4)  " & vbCrLf
      sSql = sSql & " declare @partStdCost as decimal(12,4)  " & vbCrLf
      sSql = sSql & " declare @LotUnitCost as decimal(12,4)  " & vbCrLf
      sSql = sSql & " declare @partActCost as int   " & vbCrLf
      sSql = sSql & " declare @partLotTrack as int  " & vbCrLf
      sSql = sSql & " declare @flgStdCost as int " & vbCrLf
      sSql = sSql & " declare @flgLdCost as int  " & vbCrLf
      sSql = sSql & " declare @flgInvCost as int " & vbCrLf
      sSql = sSql & " declare @flgLdRQErr as int " & vbCrLf
      sSql = sSql & " declare @flgOrgAcc as int  " & vbCrLf
      sSql = sSql & " declare @flgRptAcc as int  " & vbCrLf
      sSql = sSql & " declare @flgLastAcc as int " & vbCrLf
      sSql = sSql & "declare @lotTotMat as decimal(12,4)" & vbCrLf
      sSql = sSql & "declare @lotTotLabor as decimal(12,4)" & vbCrLf
      sSql = sSql & "declare @lotTotExp as decimal(12,4)" & vbCrLf
      sSql = sSql & "declare @lotTotOH as decimal(12,4)" & vbCrLf
      sSql = sSql & "declare @InputLotNum as varchar(15)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "declare @CalTotOH as decimal(12,4)" & vbCrLf
      sSql = sSql & "declare @TotMOOH as decimal(12,4)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   IF (@PartClass = 'ALL')" & vbCrLf
      sSql = sSql & "   BEGIN " & vbCrLf
      sSql = sSql & "      SET @PartClass = ''  " & vbCrLf
      sSql = sSql & "   End            " & vbCrLf
      sSql = sSql & "   IF (@PartCode = 'ALL')  " & vbCrLf
      sSql = sSql & "   BEGIN " & vbCrLf
      sSql = sSql & "      SET @PartCode = ''      " & vbCrLf
      sSql = sSql & " End                     " & vbCrLf
      sSql = sSql & "    IF (@PartType1 = 1)     " & vbCrLf
      sSql = sSql & "      SET @PartType1 = 1    " & vbCrLf
      sSql = sSql & "   Else                    " & vbCrLf
      sSql = sSql & "     SET @PartType1 = 0    " & vbCrLf
      sSql = sSql & "   IF (@PartType2 = 1)     " & vbCrLf
      sSql = sSql & "     SET @PartType2 = 2    " & vbCrLf
      sSql = sSql & "   Else                    " & vbCrLf
      sSql = sSql & "     SET @PartType2 = 0    " & vbCrLf
      sSql = sSql & "    IF (@PartType3 = 1)    " & vbCrLf
      sSql = sSql & "        SET @PartType3 = 3 " & vbCrLf
      sSql = sSql & "    Else                   " & vbCrLf
      sSql = sSql & "        SET @PartType3 = 0 " & vbCrLf
      sSql = sSql & "                           " & vbCrLf
      sSql = sSql & "    IF (@PartType4 = 1)    " & vbCrLf
      sSql = sSql & "        SET @PartType4 = 4 " & vbCrLf
      sSql = sSql & "    Else                   " & vbCrLf
      sSql = sSql & "        SET @PartType4 = 0 " & vbCrLf
      sSql = sSql & "      " & vbCrLf
      sSql = sSql & "   CREATE TABLE #tempRMFGoods(   " & vbCrLf
      sSql = sSql & "   [LOTNUMBER] [varchar](15) NULL,  " & vbCrLf
      sSql = sSql & "   [PARTNUM] [varchar](30) NULL, " & vbCrLf
      sSql = sSql & "   [PALEVEL] [int] NULL,         " & vbCrLf
      sSql = sSql & "   [PADESC] [varchar](30) NULL,  " & vbCrLf
      sSql = sSql & "   [PAEXTDESC] [varchar](3072) NULL,   " & vbCrLf
      sSql = sSql & "   [LOTUSERLOTID] [char](40) NULL,     " & vbCrLf
      sSql = sSql & "   [ORGINNUMBER] [int] NULL,           " & vbCrLf
      sSql = sSql & "   [RPTINNUMBER] [int] NULL,           " & vbCrLf
      sSql = sSql & "   [CURINNUMBER] [int] NULL,           " & vbCrLf
      sSql = sSql & "   [ACTUALDATE] [smalldatetime] NULL,  " & vbCrLf
      sSql = sSql & "   [RPTDATEQTY] [decimal](12, 4) NULL, " & vbCrLf
      sSql = sSql & "   [ORGQTY] [decimal](12, 4) NULL, " & vbCrLf
      sSql = sSql & "   [UNITCOST] [decimal](12, 4) NULL,   " & vbCrLf
      sSql = sSql & "   [PASTDCOST] [decimal](12, 4) NULL,  " & vbCrLf
      sSql = sSql & "   [LOTUNITCOST] [decimal](12, 4) NULL,   " & vbCrLf
      sSql = sSql & "   [INAMT] [decimal](12, 4) NULL,      " & vbCrLf
      sSql = sSql & "   [LOTTOTMATL] [decimal](12, 4) NULL,      " & vbCrLf
      sSql = sSql & "    [LOTTOTLABOR] [decimal](12, 4) NULL,      " & vbCrLf
      sSql = sSql & "   [LOTTOTEXP] [decimal](12, 4) NULL," & vbCrLf
      sSql = sSql & "   [LOTTOTOH] [decimal](12, 4) NULL,      " & vbCrLf
      sSql = sSql & "   [CALLOTTOTOH] [decimal](12, 4) NULL,      " & vbCrLf
      sSql = sSql & "   [ORGCOST] [decimal](12, 4) NULL,       " & vbCrLf
      sSql = sSql & "   [STDCOST] [decimal](12, 4) NULL,       " & vbCrLf
      sSql = sSql & "   [LSTACOST] [decimal](12, 4) NULL,      " & vbCrLf
      sSql = sSql & "   [RPTCOST] [decimal](12, 4) NULL,       " & vbCrLf
      sSql = sSql & "   [CURCOST] [decimal](12, 4) NULL,       " & vbCrLf
      sSql = sSql & "   [COSTEDDATE] [smalldatetime] NULL,     " & vbCrLf
      sSql = sSql & "   [RPTACCOUNT] [char](12) NULL,          " & vbCrLf
      sSql = sSql & "   [ORIGINALACC] [char](12) NULL,         " & vbCrLf
      sSql = sSql & "   [LASTACTVITYACC] [char](12) NULL,      " & vbCrLf
      sSql = sSql & "   [CURRENTACC] [char](12) NULL, " & vbCrLf
      sSql = sSql & "   [PACLASS] [char](4) NULL,  " & vbCrLf
      sSql = sSql & "   [PAPRODCODE] [char](6) NULL,  " & vbCrLf
      sSql = sSql & "   [flgStdCost] [int] NULL,   " & vbCrLf
      sSql = sSql & "   [flgLdCost] [int] NULL,    " & vbCrLf
      sSql = sSql & "   [flgInvCost] [int] NULL,   " & vbCrLf
      sSql = sSql & "   [flgLdRQErr] [int] NULL,   " & vbCrLf
      sSql = sSql & "   [flgRptAcc] [int] NULL,    " & vbCrLf
      sSql = sSql & "   [flgOrgAcc] [int] NULL,    " & vbCrLf
      sSql = sSql & "   [flgLastAcc] [int] NULL    " & vbCrLf
      sSql = sSql & ")                             " & vbCrLf
      sSql = sSql & "                              " & vbCrLf
      sSql = sSql & " DECLARE curLotHd CURSOR LOCAL " & vbCrLf
      sSql = sSql & " FOR                           " & vbCrLf
      sSql = sSql & " SELECT LOTNUMBER, LOTUSERLOTID, PARTREF, PADESC, PAEXTDESC, " & vbCrLf
      sSql = sSql & "    LOTADATE,LOTORIGINALQTY, LOTREMAININGQTY, LOTUNITCOST, LOTTOTMATL, " & vbCrLf
      sSql = sSql & "   LOTTOTLABOR, LOTTOTEXP, LOTTOTOH, LOTDATECOSTED,   " & vbCrLf
      sSql = sSql & "    PACLASS , PAPRODCODE, PASTDCOST, PAUSEACTUALCOST, PALOTTRACK, PALEVEL   " & vbCrLf
      sSql = sSql & " From ViewLohdPartTable  " & vbCrLf
      sSql = sSql & " WHERE ViewLohdPartTable.LOTADATE  < DATEADD(dd, 1 , @ReportDate)  " & vbCrLf
      sSql = sSql & "    AND ViewLohdPartTable.PACLASS LIKE '%' + @PartClass + '%'      " & vbCrLf
      sSql = sSql & "    AND ViewLohdPartTable.PAPRODCODE LIKE '%' + @PartCode + '%'    " & vbCrLf
      sSql = sSql & "    AND ViewLohdPartTable.PALEVEL IN (@PartType1, @PartType2, @PartType3, @PartType4)   " & vbCrLf
      sSql = sSql & " OPEN curLotHd                                                     " & vbCrLf
      sSql = sSql & " FETCH NEXT FROM curLotHd INTO @LotNumber, @LotUserID, @partRef,   " & vbCrLf
      sSql = sSql & "    @partDesc, @partExDesc, @lotAcualDate, @lotOrgQty,             " & vbCrLf
      sSql = sSql & "    @lotRemQty,@LotUnitCost,@lotTotMat, @lotTotLabor, " & vbCrLf
      sSql = sSql & "   @lotTotExp, @lotTotOH, @lotCostedDate,                       " & vbCrLf
      sSql = sSql & "    @PartClass, @PartCode, @partStdCost, @partActCost, @partLotTrack, @partType   " & vbCrLf
      sSql = sSql & "                                                                " & vbCrLf
      sSql = sSql & " WHILE (@@FETCH_STATUS <> -1)                                   " & vbCrLf
      sSql = sSql & " BEGIN                                                          " & vbCrLf
      sSql = sSql & " IF (@@FETCH_STATUS <> -2)     " & vbCrLf
      sSql = sSql & " BEGIN                         " & vbCrLf
      sSql = sSql & "    SET @flgLdRQErr = 0        " & vbCrLf
      sSql = sSql & " IF (@lotRemQty < 0.0000)      " & vbCrLf
      sSql = sSql & " BEGIN                         " & vbCrLf
      sSql = sSql & "    SET @lotRemQty = 0.0000    " & vbCrLf
      sSql = sSql & "    SET @flgLdRQErr  = 1       " & vbCrLf
      sSql = sSql & " End                           " & vbCrLf
      sSql = sSql & " SET @curDate = GETDATE()      " & vbCrLf
      sSql = sSql & "                               " & vbCrLf
      sSql = sSql & " SELECT @deltaQty = ISNULL(SUM(LOIQUANTITY), 0.0000)   " & vbCrLf
      sSql = sSql & " From LoitTable                                        " & vbCrLf
      sSql = sSql & " WHERE LOIADATE BETWEEN DATEADD(dd, 1 ,@ReportDate) AND DATEADD(dd, 1 ,@curDate)  " & vbCrLf
      sSql = sSql & "    AND LOIPARTREF = @partRef                    " & vbCrLf
      sSql = sSql & "    AND LOINUMBER = @LotNumber                   " & vbCrLf
      sSql = sSql & " SET @rptRemQty = @lotRemQty + (@deltaQty * -1)  " & vbCrLf
      sSql = sSql & " IF @rptRemQty < 0.0000           " & vbCrLf
      sSql = sSql & " SET @rptRemQty = @rptRemQty * -1 " & vbCrLf
      sSql = sSql & " SET @flgStdCost = 0     " & vbCrLf
      sSql = sSql & " SET @flgLdCost = 0      " & vbCrLf
      sSql = sSql & " SET @flgInvCost = 0     " & vbCrLf
      sSql = sSql & " SET @flgOrgAcc = 0      " & vbCrLf
      sSql = sSql & " SET @flgRptAcc = 0      " & vbCrLf
      sSql = sSql & " SET @flgLastAcc = 0     " & vbCrLf
      sSql = sSql & "                         " & vbCrLf
      sSql = sSql & " DECLARE curInv CURSOR   " & vbCrLf
      sSql = sSql & " LOCAL                   " & vbCrLf
      sSql = sSql & " Scroll                  " & vbCrLf
      sSql = sSql & " FOR                     " & vbCrLf
      sSql = sSql & " SELECT INNUMBER, INAMT, INAQTY, ISNULL(INCREDITACCT,0), ISNULL(INDEBITACCT, 0), INADATE   " & vbCrLf
      sSql = sSql & "     From InvaTable, LoitTable                          " & vbCrLf
      sSql = sSql & " WHERE InvaTable.INPART = @partRef                  " & vbCrLf
      sSql = sSql & "    AND LoitTable.LOINUMBER = @LotNumber            " & vbCrLf
      sSql = sSql & "    AND InvaTable.INPART = LoitTable.LOIPARTREF     " & vbCrLf
      sSql = sSql & "    AND InvaTable.INNUMBER = LoitTable.LOIACTIVITY  " & vbCrLf
      sSql = sSql & " ORDER BY INADATE ASC          " & vbCrLf
      sSql = sSql & "                               " & vbCrLf
      sSql = sSql & " OPEN curInv                   " & vbCrLf
      sSql = sSql & " FETCH FIRST FROM curInv INTO @tmpInvNum, @tmpInvCost, @tmpInvQty, " & vbCrLf
      sSql = sSql & " @tmpCreditAcc, @tmpDebitAcc, @tmpINVAdate " & vbCrLf
      sSql = sSql & " IF (@@FETCH_STATUS <> -1)  " & vbCrLf
      sSql = sSql & " BEGIN                      " & vbCrLf
      sSql = sSql & " IF (@@FETCH_STATUS <> -2)  " & vbCrLf
      sSql = sSql & " BEGIN                      " & vbCrLf
      sSql = sSql & "    SET @orgInvcost = @tmpInvCost " & vbCrLf
      sSql = sSql & "    SET @orgQty = @tmpInvQty      " & vbCrLf
      sSql = sSql & "    SET @orgCreditACC = @tmpCreditAcc   " & vbCrLf
      sSql = sSql & "    SET @orgDebitACC = @tmpDebitAcc  " & vbCrLf
      sSql = sSql & "    SET @OrgInvNum = @tmpInvNum      " & vbCrLf
      sSql = sSql & " End                                 " & vbCrLf
      sSql = sSql & " FETCH LAST FROM curInv INTO @tmpLastInvNum, @tmpLastInvCost, @tmpLastInvQty,  " & vbCrLf
      sSql = sSql & " @tmplastCreditAcc, @tmpLastDebitAcc, @tmpLastINVAdate " & vbCrLf
      sSql = sSql & " IF (@@FETCH_STATUS <> -2)  " & vbCrLf
      sSql = sSql & " BEGIN                      " & vbCrLf
      sSql = sSql & " SET @lastInvcost = @tmpLastInvCost  " & vbCrLf
      sSql = sSql & " SET @lastQty = @tmpLastInvQty    " & vbCrLf
      sSql = sSql & " SET @lastCreditACC = @tmplastCreditAcc " & vbCrLf
      sSql = sSql & " SET @lastDebitACC = @tmpLastDebitAcc   " & vbCrLf
      sSql = sSql & " SET @LastInvNum = @tmpLastInvNum       " & vbCrLf
      sSql = sSql & " IF @tmpLastINVAdate > DATEADD(dd, 1, @ReportDate)  " & vbCrLf
      sSql = sSql & " BEGIN                                              " & vbCrLf
      sSql = sSql & "   SELECT TOP 1 @rptInvNum = INNUMBER, @rptInvcost = INAMT, " & vbCrLf
      sSql = sSql & "      @rptQty = INAQTY, @rptCreditACC = ISNULL(INCREDITACCT, 0),  " & vbCrLf
      sSql = sSql & "      @rptDebitACC = ISNULL(INDEBITACCT, 0)     " & vbCrLf
      sSql = sSql & "   From InvaTable, LoitTable                 " & vbCrLf
      sSql = sSql & "      WHERE INADATE < DATEADD(dd, 1, @ReportDate)  " & vbCrLf
      sSql = sSql & "         AND InvaTable.INPART = @partRef              " & vbCrLf
      sSql = sSql & "         AND LoitTable.LOINUMBER = @LotNumber         " & vbCrLf
      sSql = sSql & "         AND InvaTable.INPART = LoitTable.LOIPARTREF  " & vbCrLf
      sSql = sSql & "         AND InvaTable.INNUMBER = LoitTable.LOIACTIVITY  " & vbCrLf
      sSql = sSql & "         ORDER BY INADATE DESC                           " & vbCrLf
      sSql = sSql & "  End                                          " & vbCrLf
      sSql = sSql & "  Else                                         " & vbCrLf
      sSql = sSql & "  BEGIN                                        " & vbCrLf
      sSql = sSql & "  SET @rptInvNum = @tmpLastInvNum              " & vbCrLf
      sSql = sSql & "                                  " & vbCrLf
      sSql = sSql & "                                     " & vbCrLf
      sSql = sSql & " SET @rptInvcost = @tmpLastInvCost   " & vbCrLf
      sSql = sSql & " SET @rptQty = @tmpLastInvQty        " & vbCrLf
      sSql = sSql & " SET @rptCreditACC = @tmplastCreditAcc  " & vbCrLf
      sSql = sSql & " SET @rptDebitACC = @tmpLastDebitAcc    " & vbCrLf
      sSql = sSql & " End                                 " & vbCrLf
      sSql = sSql & " End                                 " & vbCrLf
      sSql = sSql & " End                                 " & vbCrLf
      sSql = sSql & " CLOSE curInv   --// close the cursor   " & vbCrLf
      sSql = sSql & " DEALLOCATE curInv          " & vbCrLf
      sSql = sSql & " IF (@partActCost = 0)      " & vbCrLf
      sSql = sSql & " BEGIN                      " & vbCrLf
      sSql = sSql & " SET @unitcost = @partStdCost  " & vbCrLf
      sSql = sSql & " SET @flgStdCost = 1        " & vbCrLf
      sSql = sSql & " End                        " & vbCrLf
      sSql = sSql & " Else                       " & vbCrLf
      sSql = sSql & " BEGIN                      " & vbCrLf
      sSql = sSql & " IF @lotHDOnly = 1          " & vbCrLf
      sSql = sSql & " BEGIN                      " & vbCrLf
      sSql = sSql & " SET @unitcost = @LotUnitCost  " & vbCrLf
      sSql = sSql & " SET @flgLdCost = 1            " & vbCrLf
      sSql = sSql & " End                           " & vbCrLf
      sSql = sSql & " Else                          " & vbCrLf
      sSql = sSql & " BEGIN                         " & vbCrLf
      sSql = sSql & " IF @lotCostedDate < DATEADD(dd, 1, @ReportDate) " & vbCrLf
      sSql = sSql & "    BEGIN                            " & vbCrLf
      sSql = sSql & "    SET @unitcost = @LotUnitCost     " & vbCrLf
      sSql = sSql & "    SET @flgLdCost = 1   " & vbCrLf
      sSql = sSql & "    End                  " & vbCrLf
      sSql = sSql & "    Else                 " & vbCrLf
      sSql = sSql & "    BEGIN                " & vbCrLf
      sSql = sSql & "    SET @unitcost = @rptInvcost   " & vbCrLf
      sSql = sSql & "    SET @flgInvCost = 1           " & vbCrLf
      sSql = sSql & "    End                        " & vbCrLf
      sSql = sSql & "    END --LotHD only           " & vbCrLf
      sSql = sSql & "    END --Part Cost            " & vbCrLf
      sSql = sSql & "    SELECT @CurACC = dbo.fnGetPartInvAccount(@partRef) " & vbCrLf
      sSql = sSql & "    -- Lastest < report account#        " & vbCrLf
      sSql = sSql & "    IF @rptQty >= 0.0000                " & vbCrLf
      sSql = sSql & "    SET @rptACC = @rptDebitACC          " & vbCrLf
      sSql = sSql & "    Else                                " & vbCrLf
      sSql = sSql & "    SET @rptACC = @rptCreditACC         " & vbCrLf
      sSql = sSql & "    IF ((@rptACC = '') OR (@rptACC = NULL))      " & vbCrLf
      sSql = sSql & "    BEGIN                   " & vbCrLf
      sSql = sSql & "    SET @rptACC = @CurACC   " & vbCrLf
      sSql = sSql & "    SET @flgRptAcc = 1      " & vbCrLf
      sSql = sSql & "    End                     " & vbCrLf
      sSql = sSql & "    -- last record          " & vbCrLf
      sSql = sSql & "    IF @lastQty >= 0.0000      " & vbCrLf
      sSql = sSql & "    SET @lastACC = @lastDebitACC  " & vbCrLf
      sSql = sSql & "    Else                          " & vbCrLf
      sSql = sSql & "    SET @lastACC = @lastCreditACC " & vbCrLf
      sSql = sSql & "    IF ((@lastACC = '') OR (@lastACC = NULL)) " & vbCrLf
      sSql = sSql & "    BEGIN                   " & vbCrLf
      sSql = sSql & "    SET @lastACC = @CurACC  " & vbCrLf
      sSql = sSql & "    SET @flgLastAcc = 1     " & vbCrLf
      sSql = sSql & "    End                     " & vbCrLf
      sSql = sSql & "    -- Lastest < report account#  " & vbCrLf
      sSql = sSql & "    IF @orgQty >= 0.0000          " & vbCrLf
      sSql = sSql & "    SET @orgACC = @orgDebitACC    " & vbCrLf
      sSql = sSql & "    Else                          " & vbCrLf
      sSql = sSql & "    SET @orgACC = @orgCreditACC      " & vbCrLf
      sSql = sSql & "    IF ((@orgACC = '') OR (@orgACC = NULL))   " & vbCrLf
      sSql = sSql & "    BEGIN                    " & vbCrLf
      sSql = sSql & "    SET @orgACC = @CurACC      " & vbCrLf
      sSql = sSql & "    SET @flgOrgAcc = 1      " & vbCrLf
      sSql = sSql & "    End                     " & vbCrLf
      sSql = sSql & "    -- Insert to the temp table   " & vbCrLf
      sSql = sSql & "    INSERT INTO #tempRMFGoods     " & vbCrLf
      sSql = sSql & "    (PARTNUM, PALEVEL, PADESC, PAEXTDESC, LOTNUMBER, LOTUSERLOTID, " & vbCrLf
      sSql = sSql & "    ORGINNUMBER, RPTINNUMBER, CURINNUMBER, ACTUALDATE,RPTDATEQTY, ORGQTY, COSTEDDATE,  " & vbCrLf
      sSql = sSql & "    UNITCOST,PASTDCOST, LOTUNITCOST, LOTTOTMATL,LOTTOTLABOR, LOTTOTEXP,LOTTOTOH," & vbCrLf
      sSql = sSql & "   ORGCOST, STDCOST, LSTACOST, RPTCOST, CURCOST, RPTACCOUNT,ORIGINALACC,   " & vbCrLf
      sSql = sSql & "    LASTACTVITYACC, CURRENTACC, PACLASS,PAPRODCODE,    " & vbCrLf
      sSql = sSql & "    flgStdCost, flgLdCost, flgInvCost, flgLdRQErr,  " & vbCrLf
      sSql = sSql & "    flgRptAcc, flgOrgAcc, flgLastAcc)      " & vbCrLf
      sSql = sSql & "    VALUES (@partRef, @partType, @partDesc, @partExDesc, @LotNumber,@LotUserID, @OrgInvNum,   " & vbCrLf
      sSql = sSql & "    @rptInvNum, @LastInvNum, @lotAcualDate,@rptRemQty,@lotOrgQty, @lotCostedDate, " & vbCrLf
      sSql = sSql & "    @unitcost,@partStdCost, @LotUnitCost,@lotTotMat, @lotTotLabor, " & vbCrLf
      sSql = sSql & "   @lotTotExp, @lotTotOH, @orgInvcost, @partStdCost,  " & vbCrLf
      sSql = sSql & "    @lastInvcost,@rptInvcost, @LotUnitCost, @rptACC, @orgACC, @lastACC,  " & vbCrLf
      sSql = sSql & "    @CurACC, @PartClass,@PartCode,@flgStdCost, @flgLdCost, @flgInvCost,  " & vbCrLf
      sSql = sSql & "    @flgLdRQErr, @flgRptAcc, @flgOrgAcc, @flgLastAcc)                    " & vbCrLf
      sSql = sSql & "    SET @rptRemQty = NULL   " & vbCrLf
      sSql = sSql & "    SET @deltaQty = NULL    " & vbCrLf
      sSql = sSql & "    SET @lotRemQty = NULL   " & vbCrLf
      sSql = sSql & "    SET @lotOrgQty = NULL   " & vbCrLf
      sSql = sSql & "    SET @tmpInvQty = NULL   " & vbCrLf
      sSql = sSql & "    SET @tmpLastInvQty  = NULL " & vbCrLf
      sSql = sSql & "    SET @rptInvcost = NULL  " & vbCrLf
      sSql = sSql & "    SET @lastInvcost = NULL " & vbCrLf
      sSql = sSql & "    SET @orgInvcost = NULL  " & vbCrLf
      sSql = sSql & "    SET @tmpInvCost = NULL  " & vbCrLf
      sSql = sSql & "    SET @unitcost = NULL    " & vbCrLf
      sSql = sSql & "    SET @tmpLastInvCost = NULL " & vbCrLf
      sSql = sSql & "    SET @lastQty = NULL  " & vbCrLf
      sSql = sSql & "    SET @orgQty = NULL   " & vbCrLf
      sSql = sSql & "    SET @rptQty  = NULL  " & vbCrLf
      sSql = sSql & "    SET @rptCreditACC = NULL   " & vbCrLf
      sSql = sSql & "    SET @rptDebitACC  = NULL   " & vbCrLf
      sSql = sSql & "   SET @rptACC  = NULL     " & vbCrLf
      sSql = sSql & "   SET @tmpCreditAcc  = NULL  " & vbCrLf
      sSql = sSql & "   SET @tmpDebitAcc = NULL    " & vbCrLf
      sSql = sSql & "   SET @tmplastCreditAcc = NULL  " & vbCrLf
      sSql = sSql & "   SET @tmpLastDebitAcc = NULL   " & vbCrLf
      sSql = sSql & "   SET @lastCreditACC = NULL     " & vbCrLf
      sSql = sSql & "   SET @lastDebitACC = NULL      " & vbCrLf
      sSql = sSql & "   SET @lastACC  = NULL          " & vbCrLf
      sSql = sSql & "   SET @orgCreditACC  = NULL     " & vbCrLf
      sSql = sSql & "   SET @orgDebitACC  = NULL      " & vbCrLf
      sSql = sSql & "   SET @orgACC  = NULL           " & vbCrLf
      sSql = sSql & "   SET @OrgInvNum = NULL         " & vbCrLf
      sSql = sSql & "   SET @rptInvNum = NULL         " & vbCrLf
      sSql = sSql & "   SET @LastInvNum = NULL        " & vbCrLf
      sSql = sSql & "   End                     " & vbCrLf
      sSql = sSql & "   FETCH NEXT FROM curLotHd INTO @LotNumber, @LotUserID, @partRef,   " & vbCrLf
      sSql = sSql & "   @partDesc, @partExDesc, @lotAcualDate, @lotOrgQty,                " & vbCrLf
      sSql = sSql & "   @lotRemQty,@LotUnitCost, @lotTotMat, @lotTotLabor, " & vbCrLf
      sSql = sSql & "   @lotTotExp, @lotTotOH, @lotCostedDate,                          " & vbCrLf
      sSql = sSql & "   @PartClass, @PartCode, @partStdCost, @partActCost, @partLotTrack, @partType   " & vbCrLf
      sSql = sSql & "   End                                    " & vbCrLf
      sSql = sSql & "   CLOSE curLotHd   --// close the cursor " & vbCrLf
      sSql = sSql & "   DEALLOCATE curLotHd                    " & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   declare @tmpRptQty as decimal(12,4)" & vbCrLf
      sSql = sSql & "   declare @tmpOrgQty as decimal(12,4)" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   DECLARE curLot CURSOR  FOR" & vbCrLf
      sSql = sSql & "     SELECT DISTINCT LOTNUMBER,RPTDATEQTY, ORGQTY" & vbCrLf
      sSql = sSql & "     FROM #tempRMFGoods" & vbCrLf
      sSql = sSql & "   OPEN curLot" & vbCrLf
      sSql = sSql & "   FETCH NEXT FROM curLot INTO @InputLotNum, @tmpRptQty, @tmpOrgQty" & vbCrLf
      sSql = sSql & "   WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "   IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "      Print 'LotNumber:' + @InputLotNum" & vbCrLf
      sSql = sSql & "      " & vbCrLf
      sSql = sSql & "      EXECUTE GetMOOverHead @InputLotNum, '',0,0.0,@CalTotOH = @TotMOOH OUTPUT;" & vbCrLf
      sSql = sSql & "      " & vbCrLf
      sSql = sSql & "      IF @tmpOrgQty <> 0.0" & vbCrLf
      sSql = sSql & "      BEGIN" & vbCrLf
      sSql = sSql & "      SET @TotMOOH = (@TotMOOH  * @tmpRptQty) / @tmpOrgQty" & vbCrLf
      sSql = sSql & "      END " & vbCrLf
      sSql = sSql & "      ELSE" & vbCrLf
      sSql = sSql & "      SET @TotMOOH = @TotMOOH " & vbCrLf
      sSql = sSql & "      " & vbCrLf
      sSql = sSql & "      UPDATE #tempRMFGoods SET CALLOTTOTOH = @TotMOOH" & vbCrLf
      sSql = sSql & "         WHERE LOTNUMBER = @InputLotNum" & vbCrLf
      sSql = sSql & "      " & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "   FETCH NEXT FROM curLot INTO @InputLotNum, @tmpRptQty, @tmpOrgQty" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "      " & vbCrLf
      sSql = sSql & "   Close curLot" & vbCrLf
      sSql = sSql & "   DEALLOCATE curLot" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   --// update all the Null value." & vbCrLf
      sSql = sSql & "   UPDATE #tempRMFGoods SET CALLOTTOTOH = LOTTOTOH WHERE CALLOTTOTOH IS NULL" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   SELECT LOTNUMBER, PARTNUM,PADESC,ACTUALDATE,ORGQTY,RPTDATEQTY,Unitcost,LotUnitcost," & vbCrLf
      sSql = sSql & "      LOTTOTMATL, LOTTOTLABOR, LOTTOTEXP, LOTTOTOH,CALLOTTOTOH,PALEVEL" & vbCrLf
      sSql = sSql & "   FROM #tempRMFGoods WHERE RPTDATEQTY > 0 order by PALEVEL, partNum" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "      " & vbCrLf
      sSql = sSql & "                                           " & vbCrLf
      sSql = sSql & "   DROP table #tempRMFGoods            " & vbCrLf
      sSql = sSql & "   End "

      ExecuteScript False, sSql

      If StoreProcedureExists("GetMOOverHead_WIP") Then
         sSql = "DROP PROCEDURE GetMOOverHead_WIP"
         ExecuteScript False, sSql
      End If

      sSql = "CREATE PROCEDURE [dbo].[GetMOOverHead_WIP]" & vbCrLf
      sSql = sSql & "      @MOPart as varchar(30),@MORun as int," & vbCrLf
      sSql = sSql & "      @MOQty as decimal(15,4), @CutoffDate as Datetime,@CalTotOH decimal(15,4) OUTPUT" & vbCrLf
      sSql = sSql & "AS " & vbCrLf
      sSql = sSql & "BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   declare @SumTotMat decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @SumTotLabor decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @SumTotExp decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @SumTotOH decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @LotTotOH decimal (15,4)" & vbCrLf
      sSql = sSql & "   declare @level as integer" & vbCrLf
      sSql = sSql & "   declare @Part as varchar(30)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   declare @PrevParent  as varchar(30)" & vbCrLf
      sSql = sSql & "   declare @RowCount as integer" & vbCrLf
      sSql = sSql & "   declare @ChildPart as varchar(30)" & vbCrLf
      sSql = sSql & "   declare @ParentPart as varchar(30)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   declare @ChildKey as varchar(1024)" & vbCrLf
      sSql = sSql & "   declare @GLSortKey as varchar(1024)" & vbCrLf
      sSql = sSql & "   declare @SortKey as varchar(1024)" & vbCrLf
      sSql = sSql & "   declare @ParentLotNum as varchar(15)" & vbCrLf
      sSql = sSql & "   declare @Maxlevel as int" & vbCrLf
      sSql = sSql & "   declare @LotRunNo as int" & vbCrLf
      sSql = sSql & "   declare @LotOrgQty as decimal(15,4)" & vbCrLf
      sSql = sSql & "   --declare @MOPart as varchar(30)" & vbCrLf
      sSql = sSql & "   --declare @MORun as int" & vbCrLf
      sSql = sSql & "   --declare @MOQty as decimal(15,4)" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   CREATE TABLE #tempMOPartsDetail " & vbCrLf
      sSql = sSql & "   ( " & vbCrLf
      sSql = sSql & "      INMOPART Varchar(30) NULL, " & vbCrLf
      sSql = sSql & "      INMORUN int NULL , " & vbCrLf
      sSql = sSql & "      INPART varchar(30) NULL , " & vbCrLf
      sSql = sSql & "      LOTNUMBER varchar(15) NULL, " & vbCrLf
      sSql = sSql & "      INTOTMATL decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      INTOTLABOR decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      INTOTEXP decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      INTOTOH decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      LOTTOTMATL decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      LOTTOTLABOR decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      LOTTOTEXP decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      LOTTOTOH decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      SUMTOTMAL decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      SUMTOTLABOR decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      SUMTOTEXP decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      SUMTOTOH decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      LOTDATECOSTED smalldatetime NULL," & vbCrLf
      sSql = sSql & "      SortKey varchar(512) NULL," & vbCrLf
      sSql = sSql & "      HASCHILD int NULL," & vbCrLf
      sSql = sSql & "      SORTKEYLEVEL tinyint NULL," & vbCrLf
      sSql = sSql & "      SortKeyRev varchar(512)," & vbCrLf
      sSql = sSql & "      PARTSUM varchar(40)," & vbCrLf
      sSql = sSql & "      BMQTYREQD decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      LOTORGQTY decimal(12,4) NULL," & vbCrLf
      sSql = sSql & "      BMTOTOH decimal(12,4) NULL," & vbCrLf
      sSql = sSql & "      PICKEDDATE datetime" & vbCrLf
      sSql = sSql & "   ) " & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "--ALTER TABLE #tempMOPartsDetail ADD SortKeyRev varchar(512)" & vbCrLf
      sSql = sSql & "--ALTER TABLE #tempMOPartsDetail ADD PARTSUM varchar(40)" & vbCrLf
      sSql = sSql & "--ALTER TABLE #tempMOPartsDetail ADD BMQTYREQD decimal(12,4) NULL, LOTORGQTY decimal(12,4) NULL" & vbCrLf
      sSql = sSql & "--ALTER TABLE #tempMOPartsDetail ADD BMTOTOH decimal(12,4) NULL" & vbCrLf
      sSql = sSql & "--ALTER TABLE #tempMOPartsDetail ADD PICKEDDATE datetime" & vbCrLf
      sSql = sSql & "  " & vbCrLf
      sSql = sSql & "--DELETE FROM #tempMOPartsDetail" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "      with cte" & vbCrLf
      sSql = sSql & "      as" & vbCrLf
      sSql = sSql & "      (select BMASSYPART, BMPARTREF,  BMQTYREQD,0 as level, cast('1' + char(36)+ BMPARTREF as varchar(max)) as SortKey" & vbCrLf
      sSql = sSql & "      from BmplTable" & vbCrLf
      sSql = sSql & "      where BMASSYPART = @MOPart" & vbCrLf
      sSql = sSql & "      union all" & vbCrLf
      sSql = sSql & "      select a.BMASSYPART, a.BMPARTREF, a.BMQTYREQD, level + 1," & vbCrLf
      sSql = sSql & "         cast(COALESCE(SortKey,'') + char(36) + COALESCE(a.BMPARTREF,'') as varchar(max))as SortKey" & vbCrLf
      sSql = sSql & "      from cte" & vbCrLf
      sSql = sSql & "         inner join BmplTable a" & vbCrLf
      sSql = sSql & "            on cte.BMPARTREF = a.BMASSYPART " & vbCrLf
      sSql = sSql & "      )" & vbCrLf
      sSql = sSql & "      INSERT INTO #tempMOPartsDetail(INMOPART,INPART,BMQTYREQD,SORTKEYLEVEL,SortKey)" & vbCrLf
      sSql = sSql & "      select BMASSYPART, BMPARTREF,BMQTYREQD,level,SortKey " & vbCrLf
      sSql = sSql & "         from cte order by SortKey " & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   END" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "print 'TopLevel:' + @MOPart + ' RUN:' + convert(varchar(10), @MORun)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   --// update the top level" & vbCrLf
      sSql = sSql & "   UPDATE #tempMOPartsDetail SET INMORUN = @MORun, LOTNUMBER = b.INLOTNUMBER, " & vbCrLf
      sSql = sSql & "            INTOTMATL = b.INTOTMATL, INTOTLABOR = b.INTOTLABOR, " & vbCrLf
      sSql = sSql & "            INTOTEXP = b.INTOTEXP, INTOTOH = b.INTOTOH, " & vbCrLf
      sSql = sSql & "            LOTTOTMATL = c.LOTTOTMATL, LOTTOTLABOR = c.LOTTOTLABOR, " & vbCrLf
      sSql = sSql & "            LOTTOTEXP = c.LOTTOTEXP, LOTTOTOH = c.LOTTOTOH," & vbCrLf
      sSql = sSql & "            LOTDATECOSTED = c.LOTDATECOSTED, LOTORGQTY = c.LOTORIGINALQTY," & vbCrLf
      sSql = sSql & "            BMTOTOH = (c.LOTTOTOH * BMQTYREQD) / c.LOTORIGINALQTY," & vbCrLf
      sSql = sSql & "            PICKEDDATE = INADATE" & vbCrLf
      sSql = sSql & "   FROM #tempMOPartsDetail d, InvaTable b, LohdTable c" & vbCrLf
      sSql = sSql & "   WHERE d.INMOPART = b.INMOPART AND d.INPART = b.INPART " & vbCrLf
      sSql = sSql & "      AND b.INLOTNUMBER = c.LOTnumber" & vbCrLf
      sSql = sSql & "      and c.lotpartref = b.INPART" & vbCrLf
      sSql = sSql & "      and b.INMOPART = @MOPart AND b.INMORUN  = @MORun" & vbCrLf
      sSql = sSql & "      AND b.INTYPE = 10 AND SORTKEYLEVEL = 0" & vbCrLf
      sSql = sSql & "      AND c.LOTORIGINALQTY <> 0  AND INADATE <= @CutoffDate" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   --// set the totals for " & vbCrLf
      sSql = sSql & "   SELECT @Maxlevel =  MAX(SORTKEYLEVEL) FROM #tempMOPartsDetail" & vbCrLf
      sSql = sSql & "   SET @level  = 1" & vbCrLf
      sSql = sSql & "   WHILE (@level <= @Maxlevel )" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "      DECLARE curMORun CURSOR  FOR" & vbCrLf
      sSql = sSql & "      SELECT DISTINCT INMOPART,INPART " & vbCrLf
      sSql = sSql & "         FROM #tempMOPartsDetail WHERE SORTKEYLEVEL = @level" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "      OPEN curMORun" & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM curMORun INTO @MOPart, @Part" & vbCrLf
      sSql = sSql & "      WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "      BEGIN" & vbCrLf
      sSql = sSql & "         IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "         BEGIN" & vbCrLf
      sSql = sSql & "         " & vbCrLf
      sSql = sSql & "         SELECT @ParentLotNum = LOTNUMBER FROM #tempMOPartsDetail  WHERE" & vbCrLf
      sSql = sSql & "               INPART = @MOPart AND SORTKEYLEVEL = @level - 1" & vbCrLf
      sSql = sSql & "         " & vbCrLf
      sSql = sSql & "         SELECT @LotRunNo = LOTMORUNNO, @LotOrgQty = LOTORIGINALQTY " & vbCrLf
      sSql = sSql & "                  FROM lohdTable where LOTNUMBER = @ParentLotNum" & vbCrLf
      sSql = sSql & "         " & vbCrLf
      sSql = sSql & "--print 'InLoopLevel:' + @MOPart + ' RUN:' + convert(varchar(10), @LotRunNo)" & vbCrLf
      sSql = sSql & "         --// update the top level" & vbCrLf
      sSql = sSql & "         UPDATE #tempMOPartsDetail SET INMORUN = @LotRunNo, LOTNUMBER = b.INLOTNUMBER, " & vbCrLf
      sSql = sSql & "                  INTOTMATL = b.INTOTMATL, INTOTLABOR = b.INTOTLABOR, " & vbCrLf
      sSql = sSql & "                  INTOTEXP = b.INTOTEXP, INTOTOH = b.INTOTOH, " & vbCrLf
      sSql = sSql & "                  LOTTOTMATL = c.LOTTOTMATL, LOTTOTLABOR = c.LOTTOTLABOR, " & vbCrLf
      sSql = sSql & "                  LOTTOTEXP = c.LOTTOTEXP, LOTTOTOH = c.LOTTOTOH," & vbCrLf
      sSql = sSql & "                  LOTDATECOSTED = c.LOTDATECOSTED, LOTORGQTY = @LotOrgQty," & vbCrLf
      sSql = sSql & "                  BMTOTOH = (c.LOTTOTOH * BMQTYREQD) / @LotOrgQty," & vbCrLf
      sSql = sSql & "              PICKEDDATE = INADATE" & vbCrLf
      sSql = sSql & "         FROM #tempMOPartsDetail d, InvaTable b, LohdTable c" & vbCrLf
      sSql = sSql & "         WHERE d.INMOPART = b.INMOPART AND d.INPART = b.INPART " & vbCrLf
      sSql = sSql & "            AND b.INLOTNUMBER = c.LOTnumber" & vbCrLf
      sSql = sSql & "            and c.lotpartref = b.INPART" & vbCrLf
      sSql = sSql & "            and b.INMOPART = @MOPart AND b.INMORUN  = @LotRunNo" & vbCrLf
      sSql = sSql & "            AND b.INTYPE = 10 AND SORTKEYLEVEL = @level" & vbCrLf
      sSql = sSql & "            AND c.LOTORIGINALQTY <> 0 AND INADATE <= @CutoffDate" & vbCrLf
      sSql = sSql & "      End" & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM curMORun INTO @MOPart, @Part" & vbCrLf
      sSql = sSql & "      End" & vbCrLf
      sSql = sSql & "      Close curMORun" & vbCrLf
      sSql = sSql & "      DEALLOCATE curMORun" & vbCrLf
      sSql = sSql & "      SET @level = @level + 1" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   SELECT @level =  MAX(SORTKEYLEVEL) FROM #tempMOPartsDetail" & vbCrLf
      sSql = sSql & "   WHILE (@level >= 0 )" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "      DECLARE curMODet CURSOR  FOR" & vbCrLf
      sSql = sSql & "      --SELECT INPART, LOTTOTMATL, LOTTOTLABOR, LOTTOTEXP , LOTTOTOH FROM #tempMOPartsDetail" & vbCrLf
      sSql = sSql & "      -- WHERE INPART = '775345149'" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "      SELECT INMOPART, " & vbCrLf
      sSql = sSql & "      SUM(IsNull(LOTTOTMATL, 0)), SUM(ISNULL(LOTTOTLABOR,0)) ," & vbCrLf
      sSql = sSql & "        Sum (IsNull(LOTTOTEXP, 0)) , SUM(IsNull(BMTOTOH, 0))" & vbCrLf
      sSql = sSql & "      From" & vbCrLf
      sSql = sSql & "         (SELECT DISTINCT INMOPART,INMORUN,INPART,LOTTOTMATL,LOTTOTLABOR," & vbCrLf
      sSql = sSql & "         LOTTOTEXP,LOTTOTOH,SUMTOTMAL,SUMTOTLABOR, SUMTOTEXP, SUMTOTOH,BMTOTOH" & vbCrLf
      sSql = sSql & "         FROM #tempMOPartsDetail WHERE SORTKEYLEVEL = @level) as foo" & vbCrLf
      sSql = sSql & "      group by INMOPART" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "      OPEN curMODet" & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM curMODet INTO @MOPart, @SumTotMat, @SumTotLabor,@SumTotExp,@SumTotOH" & vbCrLf
      sSql = sSql & "      WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "      BEGIN" & vbCrLf
      sSql = sSql & "         IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "         BEGIN" & vbCrLf
      sSql = sSql & "            " & vbCrLf
      sSql = sSql & "            print 'PartNum : ' + @MOPart" & vbCrLf
      sSql = sSql & "            print 'SumTotoh : ' + Convert(varchar(24), @SumTotOH)" & vbCrLf
      sSql = sSql & "            Print 'MO Qty :' + Convert(varchar(24), @MOQty)" & vbCrLf
      sSql = sSql & "            " & vbCrLf
      sSql = sSql & "            UPDATE #tempMOPartsDetail SET SUMTOTMAL = LOTTOTMATL + @SumTotMat, " & vbCrLf
      sSql = sSql & "            SUMTOTLABOR = LOTTOTLABOR + @SumTotLabor," & vbCrLf
      sSql = sSql & "               SUMTOTEXP = LOTTOTEXP + @SumTotExp, SUMTOTOH = (BMTOTOH + @SumTotOH) * @MOQty , " & vbCrLf
      sSql = sSql & "               HASCHILD = 1,PARTSUM = 'TOTAL ' + LTRIM(INPART)" & vbCrLf
      sSql = sSql & "            " & vbCrLf
      sSql = sSql & "            WHERE INPART = @MOPart AND SORTKEYLEVEL = @level - 1" & vbCrLf
      sSql = sSql & "            " & vbCrLf
      sSql = sSql & "      End" & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM curMODet INTO @MOPart, @SumTotMat, @SumTotLabor,@SumTotExp,@SumTotOH" & vbCrLf
      sSql = sSql & "      End" & vbCrLf
      sSql = sSql & "      Close curMODet" & vbCrLf
      sSql = sSql & "      DEALLOCATE curMODet" & vbCrLf
      sSql = sSql & "      SET @level = @level - 1" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   --// update the Lower level cost detail" & vbCrLf
      sSql = sSql & "    UPDATE #tempMOPartsDetail SET SUMTOTMAL = LOTTOTMATL, SUMTOTLABOR = LOTTOTLABOR," & vbCrLf
      sSql = sSql & "       SUMTOTEXP = LOTTOTEXP, SUMTOTOH = BMTOTOH WHERE HASCHILD IS NULL" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   SET @SumTotMat  = 0" & vbCrLf
      sSql = sSql & "   SET @SumTotLabor  = 0" & vbCrLf
      sSql = sSql & "   SET @SumTotExp  = 0" & vbCrLf
      sSql = sSql & "   SET @SumTotOH  = 0" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   --// Udpate the Root total" & vbCrLf
      sSql = sSql & "    SELECT @SumTotMat = SUM(SUMTOTMAL), @SumTotLabor = SUM(SUMTOTLABOR)," & vbCrLf
      sSql = sSql & "         @SumTotExp = SUM(SUMTOTEXP) ,@SumTotOH = SUM(SUMTOTOH)" & vbCrLf
      sSql = sSql & "     FROM #tempMOPartsDetail WHERE SORTKEYLEVEL = 0 " & vbCrLf
      sSql = sSql & "      AND  RTRIM(INMOPART) <> RTRIM(INPART)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "    UPDATE #tempMOPartsDetail SET PARTSUM = INPART" & vbCrLf
      sSql = sSql & "      WHERE PARTSUM IS NULL" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "  ----  SELECT * FROM #tempMOPartsDetail WHERE SORTKEYLEVEL = 0 " & vbCrLf
      sSql = sSql & "      ----AND  RTRIM(INMOPART) = RTRIM(INPART)" & vbCrLf
      sSql = sSql & "   --// Reverse the partnumbers." & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   set @level = 0 " & vbCrLf
      sSql = sSql & "   set @RowCount = 1" & vbCrLf
      sSql = sSql & "   SET @PrevParent = ''" & vbCrLf
      sSql = sSql & "   DECLARE curAcctStruc CURSOR  FOR" & vbCrLf
      sSql = sSql & "      SELECT INMOPART, SortKey" & vbCrLf
      sSql = sSql & "      FROM #tempMOPartsDetail " & vbCrLf
      sSql = sSql & "         WHERE HASCHILD IS NULL --GLFSLEVEL = 8 --AND GLMASTER ='AA10'--GLTOPMaster = 1 AND " & vbCrLf
      sSql = sSql & "      ORDER BY SortKey" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   OPEN curAcctStruc" & vbCrLf
      sSql = sSql & "   FETCH NEXT FROM curAcctStruc INTO @ParentPart, @SortKey" & vbCrLf
      sSql = sSql & "   WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "    IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "    BEGIN" & vbCrLf
      sSql = sSql & "      if (@PrevParent <> @ParentPart)" & vbCrLf
      sSql = sSql & "      BEGIN" & vbCrLf
      sSql = sSql & "         UPDATE #tempMOPartsDetail SET " & vbCrLf
      sSql = sSql & "            SortKeyRev = RIGHT ('0000'+ Cast(@RowCount as varchar), 4) + char(36)+ @ParentPart" & vbCrLf
      sSql = sSql & "         WHERE INMOPART = @ParentPart AND HASCHILD IS NULL --GLFSLEVEL = 8 --AND GLTOPMaster = 1 " & vbCrLf
      sSql = sSql & "         SET @RowCount = @RowCount + 1" & vbCrLf
      sSql = sSql & "         SET @PrevParent = @ParentPart" & vbCrLf
      sSql = sSql & "      END" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "    End" & vbCrLf
      sSql = sSql & "    FETCH NEXT FROM curAcctStruc INTO @ParentPart, @SortKey" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "       " & vbCrLf
      sSql = sSql & "   Close curAcctStruc" & vbCrLf
      sSql = sSql & "   DEALLOCATE curAcctStruc" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   SELECT @level =  MAX(SORTKEYLEVEL) FROM #tempMOPartsDetail" & vbCrLf
      sSql = sSql & "   --set @level = 7" & vbCrLf
      sSql = sSql & "   WHILE (@level >= 0 )" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "      SET @PrevParent = ''" & vbCrLf
      sSql = sSql & "        DECLARE curAcctStruc1 CURSOR  FOR" & vbCrLf
      sSql = sSql & "         SELECT DISTINCT INPART, INMOPART, SortKey" & vbCrLf
      sSql = sSql & "         FROM #tempMOPartsDetail " & vbCrLf
      sSql = sSql & "            WHERE SORTKEYLEVEL = @level AND HASCHILD IS NOT NULL--GLTOPMaster = 1 AND " & vbCrLf
      sSql = sSql & "         order by SortKey" & vbCrLf
      sSql = sSql & "    " & vbCrLf
      sSql = sSql & "        OPEN curAcctStruc1" & vbCrLf
      sSql = sSql & "        FETCH NEXT FROM curAcctStruc1 INTO @ChildPart, @ParentPart, @SortKey" & vbCrLf
      sSql = sSql & "        WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "        BEGIN" & vbCrLf
      sSql = sSql & "          IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "          BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "            if (@PrevParent <> @ChildPart)" & vbCrLf
      sSql = sSql & "            BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   --print 'Record' + @ChildPart + ':' + @ParentPart" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "               SELECT TOP 1 @ChildKey = SortKeyRev,@SortKey = SortKey" & vbCrLf
      sSql = sSql & "               FROM #tempMOPartsDetail " & vbCrLf
      sSql = sSql & "                  WHERE SORTKEYLEVEL > @level AND INMOPART = @ChildPart --GLTOPMaster = 1 AND " & vbCrLf
      sSql = sSql & "               order by SortKey desc" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "               UPDATE #tempMOPartsDetail SET " & vbCrLf
      sSql = sSql & "                  SortKeyRev = Cast(@ChildKey as varchar(256)) + char(36)+ @ParentPart" & vbCrLf
      sSql = sSql & "               WHERE INPART = @ChildPart AND INMOPART = @ParentPart " & vbCrLf
      sSql = sSql & "                  AND SORTKEYLEVEL = @level --GLTOPMaster = 1 AND " & vbCrLf
      sSql = sSql & "               " & vbCrLf
      sSql = sSql & "               SET @PrevParent = @ChildPart" & vbCrLf
      sSql = sSql & "            END" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "          End" & vbCrLf
      sSql = sSql & "         FETCH NEXT FROM curAcctStruc1 INTO @ChildPart, @ParentPart, @SortKey" & vbCrLf
      sSql = sSql & "        End" & vbCrLf
      sSql = sSql & "               " & vbCrLf
      sSql = sSql & "        Close curAcctStruc1" & vbCrLf
      sSql = sSql & "        DEALLOCATE curAcctStruc1" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "        SET @level = @level - 1" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   SELECT @LotTotOH = ISNULL(LOTTOTOH, 0) from lohdTable " & vbCrLf
      sSql = sSql & "   where lotpartref = @MOPart  AND LOTMORUNNO = @MORun " & vbCrLf
      sSql = sSql & "         AND LOTADATE <= @CutoffDate" & vbCrLf
      sSql = sSql & "   print 'LOT OH:' + Convert(varchar(10), @LotTotOH)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   SELECT @CalTotOH = SUM(ISNULL(BMTOTOH, 0)) + ISNULL(@LotTotOH, 0) FROM #tempMOPartsDetail" & vbCrLf
      sSql = sSql & "         WHERE SORTKEYLEVEL = 0" & vbCrLf
      sSql = sSql & "   print 'GetMOOverHead: CalOH:' + convert(varchar(10), @CalTotOH)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   --select * from #tempMOPartsDetail " & vbCrLf
      sSql = sSql & "   DROP table #tempMOPartsDetail " & vbCrLf
      sSql = sSql & "END"
      
      ExecuteScript False, sSql
      
      sSql = "ALTER PROCEDURE [dbo].[WIPCalculatedOH]" & vbCrLf
      sSql = sSql & "   @CutOffDate as datetime" & vbCrLf
      sSql = sSql & "AS " & vbCrLf
      sSql = sSql & "BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   --ALTER table dbo.EsReportWIPOH ADD WIPRUNQTY real" & vbCrLf
      sSql = sSql & "   -- select * from EsReportWIPOH" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   declare @MOPart as varchar(30)" & vbCrLf
      sSql = sSql & "   declare @MORun as int" & vbCrLf
      sSql = sSql & "   declare @MOQty as decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @CalTotOH as decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @TotMOOH as decimal (15,4)" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   DECLARE curWIP CURSOR  FOR" & vbCrLf
      sSql = sSql & "     SELECT DISTINCT WIPRUNREF,WIPRUNNO, WIPRUNQTY " & vbCrLf
      sSql = sSql & "     FROM EsReportWIPOH" & vbCrLf
      sSql = sSql & "   OPEN curWIP" & vbCrLf
      sSql = sSql & "   FETCH NEXT FROM curWIP INTO @MOPart, @MORun, @MOQty" & vbCrLf
      sSql = sSql & "   WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "      IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "      BEGIN" & vbCrLf
      sSql = sSql & "      " & vbCrLf
      sSql = sSql & "         --Print 'PartNum:' + @MOPart + ' Run:' + Convert(varchar(10), @MORun)" & vbCrLf
      sSql = sSql & "         " & vbCrLf
      sSql = sSql & "         EXECUTE GetMOOverHead_WIP @MOPart, @MORun, @MOQty, @CutOffDate, @CalTotOH = @TotMOOH OUTPUT;" & vbCrLf
      sSql = sSql & "         " & vbCrLf
      sSql = sSql & "         --print 'TotOH:' + Convert(varchar(10), @TotMOOH)" & vbCrLf
      sSql = sSql & "         " & vbCrLf
      sSql = sSql & "         UPDATE EsReportWIPOH SET WIPCALOH = @TotMOOH" & vbCrLf
      sSql = sSql & "            WHERE WIPRUNREF = @MOPart AND WIPRUNNO = @MORun" & vbCrLf
      sSql = sSql & "      End" & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM curWIP INTO @MOPart, @MORun, @MOQty" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "      " & vbCrLf
      sSql = sSql & "   Close curWIP" & vbCrLf
      sSql = sSql & "   DEALLOCATE curWIP" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   UPDATE EsReportWIPOH  SET WIPCALOH = WIPOH WHERE WIPOH <> WIPCALOH " & vbCrLf
      sSql = sSql & "   AND WIPCALOH = 0 AND WIPOH <> 0" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "END"
      
      ExecuteScript False, sSql
      
      ' update the version
      ExecuteScript False, "Update Version Set Version = " & newver
   
   End If
End Function


Private Function UpdateDatabase54()
   newver = 128
   If ver < newver Then
   
      If Not TableExists("EsMOPartsCostDetail") Then
         sSql = "CREATE TABLE [dbo].[EsMOPartsCostDetail](" & vbCrLf
         sSql = sSql & "   [LOTMOPARTRUNKEY] [varchar](40) NULL," & vbCrLf
         sSql = sSql & "   [INMOPART] [varchar](30) NULL," & vbCrLf
         sSql = sSql & "   [INMORUN] [int] NULL," & vbCrLf
         sSql = sSql & "   [INPART] [varchar](30) NULL," & vbCrLf
         sSql = sSql & "   [LOTNUMBER] [varchar](15) NULL," & vbCrLf
         sSql = sSql & "   [LOTUSERLOTID] [varchar](40) NULL," & vbCrLf
         sSql = sSql & "   [INTOTMATL] [decimal](12, 4) NULL," & vbCrLf
         sSql = sSql & "   [INTOTLABOR] [decimal](12, 4) NULL," & vbCrLf
         sSql = sSql & "   [INTOTEXP] [decimal](12, 4) NULL," & vbCrLf
         sSql = sSql & "   [INTOTOH] [decimal](12, 4) NULL," & vbCrLf
         sSql = sSql & "   [LOTTOTMATL] [decimal](12, 4) NULL," & vbCrLf
         sSql = sSql & "   [LOTTOTLABOR] [decimal](12, 4) NULL," & vbCrLf
         sSql = sSql & "   [LOTTOTEXP] [decimal](12, 4) NULL," & vbCrLf
         sSql = sSql & "   [LOTTOTOH] [decimal](12, 4) NULL," & vbCrLf
         sSql = sSql & "   [SUMTOTMAL] [decimal](12, 4) NULL," & vbCrLf
         sSql = sSql & "   [SUMTOTLABOR] [decimal](12, 4) NULL," & vbCrLf
         sSql = sSql & "   [SUMTOTEXP] [decimal](12, 4) NULL," & vbCrLf
         sSql = sSql & "   [SUMTOTOH] [decimal](12, 4) NULL," & vbCrLf
         sSql = sSql & "   [LOTDATECOSTED] [smalldatetime] NULL," & vbCrLf
         sSql = sSql & "   [SortKey] [varchar](512) NULL," & vbCrLf
         sSql = sSql & "   [HASCHILD] [int] NULL," & vbCrLf
         sSql = sSql & "   [SORTKEYLEVEL] [tinyint] NULL," & vbCrLf
         sSql = sSql & "   [SortKeyRev] [varchar](512) NULL," & vbCrLf
         sSql = sSql & "   [PARTSUM] [varchar](40) NULL," & vbCrLf
         sSql = sSql & "   [BMQTYREQD] [decimal](12, 4) NULL," & vbCrLf
         sSql = sSql & "   [LOTORGQTY] [decimal](12, 4) NULL," & vbCrLf
         sSql = sSql & "   [BMTOTOH] [decimal](12, 4) NULL," & vbCrLf
         sSql = sSql & "   [LOTSPLITFROMSYS] [varchar](15) NULL," & vbCrLf
         sSql = sSql & "   [INVNO] [int] NULL," & vbCrLf
         sSql = sSql & "   [ITPSNUMBER] [varchar](8) NULL," & vbCrLf
         sSql = sSql & "   [ITPSITEM] [smallint] NULL," & vbCrLf
         sSql = sSql & "   [PICKQTY] [decimal](12, 4) NULL" & vbCrLf
         sSql = sSql & ") ON [PRIMARY]"
         
         ExecuteScript False, sSql
      End If

      If StoreProcedureExists("RptPSMOs") Then
         sSql = "DROP PROCEDURE RptPSMOs"
         ExecuteScript False, sSql
      End If

      sSql = "CREATE PROCEDURE [dbo].[RptPSMOs]" & vbCrLf
      sSql = sSql & "   @StartDate as varchar(12), @EndDate as varchar(12)" & vbCrLf
      sSql = sSql & "AS " & vbCrLf
      sSql = sSql & "BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   declare @SumTotMat decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @SumTotLabor decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @SumTotExp decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @SumTotOH decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @level as integer" & vbCrLf
      sSql = sSql & "   declare @Part as varchar(30)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   declare @LotNum as varchar(15)" & vbCrLf
      sSql = sSql & "   declare @MOPart as varchar(30)" & vbCrLf
      sSql = sSql & "   declare @MORun as int" & vbCrLf
      sSql = sSql & "   declare @LotOrgQty as decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @InvNo as Integer" & vbCrLf
      sSql = sSql & "   declare @PSNum as varchar(30)" & vbCrLf
      sSql = sSql & "   declare @PSItem as integer" & vbCrLf
      sSql = sSql & "   declare @MOPartRunKey as Varchar(30)" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   delete FROM EsMOPartsCostDetail " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "      DECLARE curPackSlip CURSOR  FOR" & vbCrLf
      sSql = sSql & "       SELECT DISTINCT INVNO, SoitTable.ITPSNUMBER, SoitTable.ITPSITEM" & vbCrLf
      sSql = sSql & "      FROM" & vbCrLf
      sSql = sSql & "         (((((CihdTable CihdTable INNER JOIN SoitTable SoitTable ON" & vbCrLf
      sSql = sSql & "            CihdTable.INVNO = SoitTable.ITINVOICE)" & vbCrLf
      sSql = sSql & "          INNER JOIN PartTable PartTable ON" & vbCrLf
      sSql = sSql & "            SoitTable.ITPART = PartTable.PARTREF)" & vbCrLf
      sSql = sSql & "          INNER JOIN SohdTable SohdTable ON" & vbCrLf
      sSql = sSql & "            SoitTable.ITSO = SohdTable.SONUMBER)" & vbCrLf
      sSql = sSql & "          INNER JOIN InvaTable InvaTable ON" & vbCrLf
      sSql = sSql & "            SoitTable.ITSO = InvaTable.INSONUMBER AND" & vbCrLf
      sSql = sSql & "         SoitTable.ITNUMBER = InvaTable.INSOITEM AND" & vbCrLf
      sSql = sSql & "         SoitTable.ITREV = InvaTable.INSOREV)" & vbCrLf
      sSql = sSql & "          LEFT OUTER JOIN PsitTable PsitTable ON" & vbCrLf
      sSql = sSql & "            InvaTable.INPSNUMBER = PsitTable.PIPACKSLIP AND" & vbCrLf
      sSql = sSql & "         InvaTable.INPSITEM = PsitTable.PIITNO AND" & vbCrLf
      sSql = sSql & "         InvaTable.INPART = PsitTable.PIPART AND" & vbCrLf
      sSql = sSql & "         InvaTable.INSONUMBER = PsitTable.PISONUMBER AND" & vbCrLf
      sSql = sSql & "         InvaTable.INSOITEM = PsitTable.PISOITEM AND" & vbCrLf
      sSql = sSql & "         InvaTable.INSOREV = PsitTable.PISOREV)" & vbCrLf
      sSql = sSql & "          INNER JOIN PshdTable PshdTable ON" & vbCrLf
      sSql = sSql & "            PsitTable.PIPACKSLIP = PshdTable.PSNUMBER" & vbCrLf
      sSql = sSql & "      WHERE" & vbCrLf
      sSql = sSql & "         CihdTable.INVDATE BETWEEN @StartDate and @EndDate AND " & vbCrLf
      sSql = sSql & "--       INPSNUMBER = 'PS020139' AND " & vbCrLf
      sSql = sSql & "         (InvaTable.INTYPE = 4 OR" & vbCrLf
      sSql = sSql & "         InvaTable.INTYPE = 3 OR" & vbCrLf
      sSql = sSql & "         InvaTable.INTYPE = 26 OR" & vbCrLf
      sSql = sSql & "         InvaTable.INTYPE = 25 OR" & vbCrLf
      sSql = sSql & "         InvaTable.INTYPE = 24) AND" & vbCrLf
      sSql = sSql & "         PshdTable.PSCANCELED = 0 AND" & vbCrLf
      sSql = sSql & "         CihdTable.INVCANCELED = 0 AND" & vbCrLf
      sSql = sSql & "         SoitTable.ITCANCELED = 0" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "      OPEN curPackSlip" & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM curPackSlip INTO @InvNo, @PSNum, @PSItem" & vbCrLf
      sSql = sSql & "      WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "      BEGIN" & vbCrLf
      sSql = sSql & "         IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "         BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "           DECLARE curAllMOsRun CURSOR  FOR" & vbCrLf
      sSql = sSql & "            SELECT distinct LOINUMBER, LOTMOPARTREF, LOTMORUNNO,LOTORIGINALQTY  FROM " & vbCrLf
      sSql = sSql & "               LohdTable, LoitTable, PshdTable" & vbCrLf
      sSql = sSql & "            WHERE LohdTable.LOTNUMBER = LoitTable.LOINUMBER AND" & vbCrLf
      sSql = sSql & "               LoitTable.LOIPSNUMBER = @PSNum AND" & vbCrLf
      sSql = sSql & "               LoitTable.LOIPSITEM = @PSItem AND" & vbCrLf
      sSql = sSql & "               (LoitTable.LOITYPE = 33 OR" & vbCrLf
      sSql = sSql & "               LoitTable.LOITYPE = 25) AND" & vbCrLf
      sSql = sSql & "               PshdTable.PSCANCELED <> 1" & vbCrLf
      sSql = sSql & "       " & vbCrLf
      sSql = sSql & "           OPEN curAllMOsRun" & vbCrLf
      sSql = sSql & "           FETCH NEXT FROM curAllMOsRun INTO @LotNum, @MOPart, @MORun,@LotOrgQty" & vbCrLf
      sSql = sSql & "           WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "           BEGIN" & vbCrLf
      sSql = sSql & "             IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "             BEGIN" & vbCrLf
      sSql = sSql & "               Exec RptMOCostDetail @MOPart, @MORun, @LotOrgQty" & vbCrLf
      sSql = sSql & "               SET @MOPartRunKey = RTRIM(@MOPart) + '_' + Convert(varchar(10), @MORun)" & vbCrLf
      sSql = sSql & "                              " & vbCrLf
      sSql = sSql & "               UPDATE EsMOPartsCostDetail SET INVNO = @InvNo, ITPSNUMBER = @PSNum, ITPSITEM = @PSItem" & vbCrLf
      sSql = sSql & "                  WHERE LOTMOPARTRUNKEY = @MOPartRunKey" & vbCrLf
      sSql = sSql & "               " & vbCrLf
      sSql = sSql & "            End" & vbCrLf
      sSql = sSql & "            FETCH NEXT FROM curAllMOsRun INTO @LotNum, @MOPart, @MORun,@LotOrgQty" & vbCrLf
      sSql = sSql & "           End" & vbCrLf
      sSql = sSql & "           Close curAllMOsRun" & vbCrLf
      sSql = sSql & "           DEALLOCATE curAllMOsRun" & vbCrLf
      sSql = sSql & "      " & vbCrLf
      sSql = sSql & "      End" & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM curPackSlip INTO @InvNo, @PSNum, @PSItem" & vbCrLf
      sSql = sSql & "      End" & vbCrLf
      sSql = sSql & "      Close curPackSlip" & vbCrLf
      sSql = sSql & "      DEALLOCATE curPackSlip" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   SELECT LOTMOPARTRUNKEY, INVNO, ITPSNUMBER, ITPSITEM, INMOPART,INMORUN,INPART,PARTSUM,SORTKEYLEVEL,LOTNUMBER,LOTUSERLOTID," & vbCrLf
      sSql = sSql & "      LOTTOTMATL,SUMTOTMAL, LOTTOTLABOR,SUMTOTLABOR, LOTTOTEXP, SUMTOTEXP, LOTTOTOH,SUMTOTOH,BMTOTOH," & vbCrLf
      sSql = sSql & "        LOTDATECOSTED, BMQTYREQD, LOTORGQTY, SORTKEYLEVEL,SortKey,SortKeyRev,HASCHILD      " & vbCrLf
      sSql = sSql & "   FROM EsMOPartsCostDetail --WHERE LOTMOPARTRUNKEY IS NOT NULL --SORTKEYLEVEL = 1" & vbCrLf
      sSql = sSql & "   order by LOTMOPARTRUNKEY,SortKey--SortKeyRev      " & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   --DROP table tempMOPartsDetail   " & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "END"
      
      ExecuteScript False, sSql

      If StoreProcedureExists("RptMOCostDetail") Then
         sSql = "DROP PROCEDURE RptMOCostDetail"
         ExecuteScript False, sSql
      End If

      sSql = "CREATE PROCEDURE [dbo].[RptMOCostDetail]" & vbCrLf
      sSql = sSql & "      @MOPart as varchar(30),@MORun as int, @MOQty as decimal(15,4)" & vbCrLf
      sSql = sSql & "AS " & vbCrLf
      sSql = sSql & "BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   declare @SumTotMat decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @SumTotLabor decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @SumTotExp decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @SumTotOH decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @level as integer" & vbCrLf
      sSql = sSql & "   declare @Part as varchar(30)" & vbCrLf
      sSql = sSql & "   declare @PrevParent  as varchar(30)" & vbCrLf
      sSql = sSql & "   declare @RowCount as integer" & vbCrLf
      sSql = sSql & "   declare @ChildPart as varchar(30)" & vbCrLf
      sSql = sSql & "   declare @ParentPart as varchar(30)" & vbCrLf
      sSql = sSql & "   declare @MOPart1 as varchar(30)" & vbCrLf
      sSql = sSql & "   declare @MoRun1 as varchar(20)" & vbCrLf
      sSql = sSql & "   declare @Part1 as varchar(30)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   declare @ChildKey as varchar(1024)" & vbCrLf
      sSql = sSql & "   declare @GLSortKey as varchar(1024)" & vbCrLf
      sSql = sSql & "   declare @SortKey as varchar(1024)" & vbCrLf
      sSql = sSql & "   declare @ParentLotNum as varchar(15)" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   declare @Maxlevel as int" & vbCrLf
      sSql = sSql & "   declare @LotRunNo as int" & vbCrLf
      sSql = sSql & "   declare @LotOrgQty as decimal(15,4)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   declare @LotUSpMat decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @LotUSpLabor decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @LotUSpExp decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @LotUSpOH decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @LotMatl decimal(15,4)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   declare @MOLotNum as varchar(15)" & vbCrLf
      sSql = sSql & "   declare @SplitLot as varchar(15)" & vbCrLf
      sSql = sSql & "   declare @cnt  as int" & vbCrLf
      sSql = sSql & "   declare @sumQty decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @MOPartRunKey as Varchar(30)" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   --DROP TABLE #tempMOPartsDetail " & vbCrLf
      sSql = sSql & "-- DELETE FROM #tempMOPartsDetail " & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   SET @MOPartRunKey = RTRIM(@MOPart) + '_' + Convert(varchar(10), @MORun)" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   CREATE TABLE #tempMOPartsDetail " & vbCrLf
      sSql = sSql & "   ( " & vbCrLf
      sSql = sSql & "      LOTMOPARTRUNKEY varchar(50) NULL," & vbCrLf
      sSql = sSql & "      INMOPART Varchar(30) NULL, " & vbCrLf
      sSql = sSql & "      INMORUN int NULL , " & vbCrLf
      sSql = sSql & "      INPART varchar(30) NULL , " & vbCrLf
      sSql = sSql & "      LOTNUMBER varchar(15) NULL, " & vbCrLf
      sSql = sSql & "      LOTUSERLOTID varchar(40) NULL," & vbCrLf
      sSql = sSql & "      INTOTMATL decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      INTOTLABOR decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      INTOTEXP decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      INTOTOH decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      LOTTOTMATL decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      LOTTOTLABOR decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      LOTTOTEXP decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      LOTTOTOH decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      SUMTOTMAL decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      SUMTOTLABOR decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      SUMTOTEXP decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      SUMTOTOH decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      LOTDATECOSTED smalldatetime NULL," & vbCrLf
      sSql = sSql & "      SortKey varchar(512) NULL," & vbCrLf
      sSql = sSql & "      HASCHILD int NULL," & vbCrLf
      sSql = sSql & "      SORTKEYLEVEL tinyint NULL," & vbCrLf
      sSql = sSql & "      SortKeyRev varchar(512)," & vbCrLf
      sSql = sSql & "      PARTSUM varchar(40)," & vbCrLf
      sSql = sSql & "      BMQTYREQD decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      LOTORGQTY decimal(12,4) NULL," & vbCrLf
      sSql = sSql & "      BMTOTOH decimal(12,4) NULL," & vbCrLf
      sSql = sSql & "      LOTSPLITFROMSYS varchar(15)," & vbCrLf
      sSql = sSql & "      INVNO int NULL," & vbCrLf
      sSql = sSql & "      ITPSNUMBER varchar(8) NULL," & vbCrLf
      sSql = sSql & "      ITPSITEM smallint NULL," & vbCrLf
      sSql = sSql & "      PICKQTY decimal(12,4) NULL" & vbCrLf
      sSql = sSql & "   ) " & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "      with cte" & vbCrLf
      sSql = sSql & "      as" & vbCrLf
      sSql = sSql & "      (select BMASSYPART, BMPARTREF,  BMQTYREQD,0 as level, cast('1' + char(36)+ BMPARTREF as varchar(max)) as SortKey" & vbCrLf
      sSql = sSql & "      from BmplTable" & vbCrLf
      sSql = sSql & "      where BMASSYPART = @MOPart" & vbCrLf
      sSql = sSql & "      union all" & vbCrLf
      sSql = sSql & "      select a.BMASSYPART, a.BMPARTREF, a.BMQTYREQD, level + 1," & vbCrLf
      sSql = sSql & "         cast(COALESCE(SortKey,'') + char(36) + COALESCE(a.BMPARTREF,'') as varchar(max))as SortKey" & vbCrLf
      sSql = sSql & "      from cte" & vbCrLf
      sSql = sSql & "         inner join BmplTable a" & vbCrLf
      sSql = sSql & "            on cte.BMPARTREF = a.BMASSYPART " & vbCrLf
      sSql = sSql & "      )" & vbCrLf
      sSql = sSql & "      INSERT INTO #tempMOPartsDetail(INMOPART,INPART,BMQTYREQD,SORTKEYLEVEL,SortKey)" & vbCrLf
      sSql = sSql & "      select BMASSYPART, BMPARTREF,BMQTYREQD,level,SortKey " & vbCrLf
      sSql = sSql & "         from cte order by SortKey " & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   END" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   SET @cnt = 0" & vbCrLf
      sSql = sSql & "print 'Update Start:' + cast(getdate() as char(25))" & vbCrLf
      sSql = sSql & "print 'Count :' + Convert(varchar(10), @cnt)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   UPDATE #tempMOPartsDetail SET INMORUN = @MORun, LOTNUMBER = b.INLOTNUMBER, " & vbCrLf
      sSql = sSql & "            LOTSPLITFROMSYS = c.LOTSPLITFROMSYS" & vbCrLf
      sSql = sSql & "      FROM dbo.LohdTable AS c INNER JOIN" & vbCrLf
      sSql = sSql & "              dbo.InvaTable AS b ON c.LOTNUMBER = b.INLOTNUMBER AND c.LOTPARTREF = b.INPART LEFT OUTER JOIN" & vbCrLf
      sSql = sSql & "              dbo.#tempMOPartsDetail AS d ON b.INMOPART = d.INMOPART AND b.INPART = d.INPART" & vbCrLf
      sSql = sSql & "      WHERE     (b.INMOPART = @MOPart) AND (b.INMORUN = @MORun) AND (b.INTYPE = 10) AND (d.SORTKEYLEVEL = 0)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   UPDATE #tempMOPartsDetail SET PICKQTY = sumqty * -1" & vbCrLf
      sSql = sSql & "      FROM #tempMOPartsDetail," & vbCrLf
      sSql = sSql & "   (SELECT SUM(b.INAQTY) sumqty, d.INMOPART mopart, d.INMORUN morun, d.LOTNUMBER lotnum, d.INPART subpart" & vbCrLf
      sSql = sSql & "   FROM dbo.LohdTable AS c INNER JOIN" & vbCrLf
      sSql = sSql & "           dbo.InvaTable AS b ON c.LOTNUMBER = b.INLOTNUMBER AND c.LOTPARTREF = b.INPART LEFT OUTER JOIN" & vbCrLf
      sSql = sSql & "           dbo.#tempMOPartsDetail AS d ON b.INMOPART = d.INMOPART AND b.INPART = d.INPART" & vbCrLf
      sSql = sSql & "   WHERE     b.INMOPART = @MOPart AND b.INMORUN  = @MORun AND (b.INTYPE = 10) AND (d.SORTKEYLEVEL = 0)" & vbCrLf
      sSql = sSql & "   GROUP BY d.INMOPART, d.INMORUN, d.LOTNUMBER, d.INPART" & vbCrLf
      sSql = sSql & "   ) as f" & vbCrLf
      sSql = sSql & "   WHERE INMOPART = f.mopart AND INMORUN = f.morun " & vbCrLf
      sSql = sSql & "    AND LOTNUMBER = lotnum AND INPART = subpart" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   --// Update the " & vbCrLf
      sSql = sSql & "   --// update the top level" & vbCrLf
      sSql = sSql & "   UPDATE #tempMOPartsDetail SET INMORUN = @MORun, LOTNUMBER = b.INLOTNUMBER, " & vbCrLf
      sSql = sSql & "            LOTUSERLOTID = c.LOTUSERLOTID," & vbCrLf
      sSql = sSql & "            INTOTMATL = b.INTOTMATL, INTOTLABOR = b.INTOTLABOR, " & vbCrLf
      sSql = sSql & "            INTOTEXP = b.INTOTEXP, INTOTOH = b.INTOTOH, " & vbCrLf
      sSql = sSql & "            LOTTOTMATL = (c.LOTTOTMATL * PICKQTY) / c.LOTORIGINALQTY, " & vbCrLf
      sSql = sSql & "            LOTTOTLABOR = (c.LOTTOTLABOR * PICKQTY) / c.LOTORIGINALQTY, " & vbCrLf
      sSql = sSql & "            LOTTOTEXP = (c.LOTTOTEXP * PICKQTY) / c.LOTORIGINALQTY, " & vbCrLf
      sSql = sSql & "            LOTTOTOH = (c.LOTTOTOH * PICKQTY) / c.LOTORIGINALQTY," & vbCrLf
      sSql = sSql & "            LOTDATECOSTED = c.LOTDATECOSTED, LOTORGQTY = c.LOTORIGINALQTY," & vbCrLf
      sSql = sSql & "            BMTOTOH = (c.LOTTOTOH * PICKQTY) / c.LOTORIGINALQTY," & vbCrLf
      sSql = sSql & "            LOTSPLITFROMSYS = c.LOTSPLITFROMSYS" & vbCrLf
      sSql = sSql & "      FROM dbo.LohdTable AS c INNER JOIN" & vbCrLf
      sSql = sSql & "              dbo.InvaTable AS b ON c.LOTNUMBER = b.INLOTNUMBER AND c.LOTPARTREF = b.INPART LEFT OUTER JOIN" & vbCrLf
      sSql = sSql & "              dbo.#tempMOPartsDetail AS d ON b.INMOPART = d.INMOPART AND b.INPART = d.INPART" & vbCrLf
      sSql = sSql & "      WHERE     (b.INMOPART = @MOPart) AND (b.INMORUN = @MORun) AND (b.INTYPE = 10) AND (d.SORTKEYLEVEL = 0)" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "print 'Update 2:' + cast(getdate() as char(25))" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   --FROM #tempMOPartsDetail d, InvaTable b, LohdTable c" & vbCrLf
      sSql = sSql & "   --WHERE d.INMOPART = b.INMOPART AND d.INPART = b.INPART " & vbCrLf
      sSql = sSql & "   -- AND b.INLOTNUMBER = c.LOTnumber" & vbCrLf
      sSql = sSql & "   -- and c.lotpartref = b.INPART" & vbCrLf
      sSql = sSql & "   -- and b.INMOPART = @MOPart AND b.INMORUN  = @MORun" & vbCrLf
      sSql = sSql & "   -- AND b.INTYPE = 10 AND SORTKEYLEVEL = 0" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   --// set the totals for " & vbCrLf
      sSql = sSql & "   SELECT @Maxlevel =  MAX(SORTKEYLEVEL) FROM #tempMOPartsDetail" & vbCrLf
      sSql = sSql & "   SET @level  = 1" & vbCrLf
      sSql = sSql & "   WHILE (@level <= @Maxlevel )" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "      DECLARE curMORun CURSOR  FOR" & vbCrLf
      sSql = sSql & "      SELECT DISTINCT INMOPART,INPART " & vbCrLf
      sSql = sSql & "         FROM #tempMOPartsDetail WHERE SORTKEYLEVEL = @level" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "      OPEN curMORun" & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM curMORun INTO @MOPart, @Part" & vbCrLf
      sSql = sSql & "      WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "      BEGIN" & vbCrLf
      sSql = sSql & "         IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "         BEGIN" & vbCrLf
      sSql = sSql & "         " & vbCrLf
      sSql = sSql & "         SELECT @ParentLotNum = LOTNUMBER FROM #tempMOPartsDetail WHERE" & vbCrLf
      sSql = sSql & "               INPART = @MOPart AND SORTKEYLEVEL = @level - 1" & vbCrLf
      sSql = sSql & "         " & vbCrLf
      sSql = sSql & "         SELECT @LotRunNo = LOTMORUNNO, @LotOrgQty = LOTORIGINALQTY " & vbCrLf
      sSql = sSql & "                  FROM lohdTable where LOTNUMBER = @ParentLotNum" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "         UPDATE #tempMOPartsDetail SET INMORUN = @LotRunNo, LOTNUMBER = b.INLOTNUMBER, " & vbCrLf
      sSql = sSql & "                  LOTSPLITFROMSYS = c.LOTSPLITFROMSYS" & vbCrLf
      sSql = sSql & "         FROM #tempMOPartsDetail d, InvaTable b, LohdTable c" & vbCrLf
      sSql = sSql & "         WHERE d.INMOPART = b.INMOPART AND d.INPART = b.INPART " & vbCrLf
      sSql = sSql & "            AND b.INLOTNUMBER = c.LOTnumber" & vbCrLf
      sSql = sSql & "            and c.lotpartref = b.INPART" & vbCrLf
      sSql = sSql & "            and b.INMOPART = @MOPart AND b.INMORUN  = @LotRunNo" & vbCrLf
      sSql = sSql & "            AND b.INTYPE = 10 AND SORTKEYLEVEL = @level" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "         UPDATE #tempMOPartsDetail SET PICKQTY = sumqty * -1" & vbCrLf
      sSql = sSql & "            FROM " & vbCrLf
      sSql = sSql & "         (SELECT SUM(b.INAQTY) sumqty, d.INMOPART mopart, d.INMORUN morun, d.LOTNUMBER lotnum, d.INPART subpart" & vbCrLf
      sSql = sSql & "         FROM dbo.LohdTable AS c INNER JOIN" & vbCrLf
      sSql = sSql & "                 dbo.InvaTable AS b ON c.LOTNUMBER = b.INLOTNUMBER AND c.LOTPARTREF = b.INPART LEFT OUTER JOIN" & vbCrLf
      sSql = sSql & "                 dbo.#tempMOPartsDetail AS d ON b.INMOPART = d.INMOPART AND b.INPART = d.INPART" & vbCrLf
      sSql = sSql & "         WHERE     b.INMOPART = @MOPart AND b.INMORUN  = @LotRunNo AND (b.INTYPE = 10) AND (d.SORTKEYLEVEL = @level)" & vbCrLf
      sSql = sSql & "         GROUP BY d.INMOPART, d.INMORUN, d.LOTNUMBER, d.INPART" & vbCrLf
      sSql = sSql & "         ) as f" & vbCrLf
      sSql = sSql & "         WHERE INMOPART = mopart AND INMORUN = morun " & vbCrLf
      sSql = sSql & "          AND LOTNUMBER = lotnum AND INPART = subpart" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "         --// update the top level" & vbCrLf
      sSql = sSql & "         UPDATE #tempMOPartsDetail SET INMORUN = @LotRunNo, LOTNUMBER = b.INLOTNUMBER, " & vbCrLf
      sSql = sSql & "                  LOTUSERLOTID = c.LOTUSERLOTID," & vbCrLf
      sSql = sSql & "                  INTOTMATL = b.INTOTMATL, INTOTLABOR = b.INTOTLABOR, " & vbCrLf
      sSql = sSql & "                  INTOTEXP = b.INTOTEXP, INTOTOH = b.INTOTOH, " & vbCrLf
      sSql = sSql & "                  LOTTOTMATL = (c.LOTTOTMATL * PICKQTY) / c.LOTORIGINALQTY, " & vbCrLf
      sSql = sSql & "                  LOTTOTLABOR = (c.LOTTOTLABOR * PICKQTY) / c.LOTORIGINALQTY, " & vbCrLf
      sSql = sSql & "                  LOTTOTEXP = (c.LOTTOTEXP * PICKQTY) / c.LOTORIGINALQTY, " & vbCrLf
      sSql = sSql & "                  LOTTOTOH = (c.LOTTOTOH * PICKQTY) / c.LOTORIGINALQTY," & vbCrLf
      sSql = sSql & "                  LOTDATECOSTED = c.LOTDATECOSTED, LOTORGQTY = @LotOrgQty," & vbCrLf
      sSql = sSql & "                  BMTOTOH = (c.LOTTOTOH * PICKQTY) / @LotOrgQty," & vbCrLf
      sSql = sSql & "                  LOTSPLITFROMSYS = c.LOTSPLITFROMSYS" & vbCrLf
      sSql = sSql & "         FROM #tempMOPartsDetail d, InvaTable b, LohdTable c" & vbCrLf
      sSql = sSql & "         WHERE d.INMOPART = b.INMOPART AND d.INPART = b.INPART " & vbCrLf
      sSql = sSql & "            AND b.INLOTNUMBER = c.LOTnumber" & vbCrLf
      sSql = sSql & "            and c.lotpartref = b.INPART" & vbCrLf
      sSql = sSql & "            and b.INMOPART = @MOPart AND b.INMORUN  = @LotRunNo" & vbCrLf
      sSql = sSql & "            AND b.INTYPE = 10 AND SORTKEYLEVEL = @level" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "      End" & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM curMORun INTO @MOPart, @Part" & vbCrLf
      sSql = sSql & "      End" & vbCrLf
      sSql = sSql & "      Close curMORun" & vbCrLf
      sSql = sSql & "      DEALLOCATE curMORun" & vbCrLf
      sSql = sSql & "      SET @level = @level + 1" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "print 'Update 2:'+ cast(getdate() as char(25))" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "  DECLARE curMOSplit CURSOR  FOR" & vbCrLf
      sSql = sSql & "   SELECT DISTINCT LOTNUMBER, LOTSPLITFROMSYS, LOTTOTMATL--, LOTTOTLABOR, LOTTOTEXP, LOTTOTOH" & vbCrLf
      sSql = sSql & "     FROM #tempMOPartsDetail WHERE LOTSPLITFROMSYS <> ''" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "  OPEN curMOSplit" & vbCrLf
      sSql = sSql & "  FETCH NEXT FROM curMOSplit INTO @MOLotNum, @SplitLot, @LotMatl" & vbCrLf
      sSql = sSql & "  WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "  BEGIN" & vbCrLf
      sSql = sSql & "     IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "     BEGIN" & vbCrLf
      sSql = sSql & "      " & vbCrLf
      sSql = sSql & "      print 'LotSplit LotNum:' + @SplitLot" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "      IF @LotMatl = 0" & vbCrLf
      sSql = sSql & "      BEGIN" & vbCrLf
      sSql = sSql & "         SELECT @LotUSpMat = (LOTTOTMATL / LOTORIGINALQTY), " & vbCrLf
      sSql = sSql & "               @LotUSpLabor = (LOTTOTLABOR / LOTORIGINALQTY)," & vbCrLf
      sSql = sSql & "               @LotUSpExp = (LOTTOTEXP / LOTORIGINALQTY), " & vbCrLf
      sSql = sSql & "               @LotUSpOH = (LOTTOTOH / LOTORIGINALQTY)" & vbCrLf
      sSql = sSql & "         FROM Lohdtable WHERE LOTNUMBER = @SplitLot" & vbCrLf
      sSql = sSql & "         " & vbCrLf
      sSql = sSql & "         UPDATE #tempMOPartsDetail SET LOTTOTMATL = (@LotUSpMat * PICKQTY), " & vbCrLf
      sSql = sSql & "                  LOTTOTLABOR = (@LotUSpLabor * PICKQTY), " & vbCrLf
      sSql = sSql & "                  LOTTOTEXP = (@LotUSpExp * PICKQTY), " & vbCrLf
      sSql = sSql & "                  LOTTOTOH = (@LotUSpOH * PICKQTY)" & vbCrLf
      sSql = sSql & "         WHERE LOTNUMBER = @MOLotNum AND LOTSPLITFROMSYS = @SplitLot" & vbCrLf
      sSql = sSql & "               " & vbCrLf
      sSql = sSql & "      END" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "   FETCH NEXT FROM curMOSplit INTO @MOLotNum, @SplitLot, @LotMatl" & vbCrLf
      sSql = sSql & "  End" & vbCrLf
      sSql = sSql & "  Close curMOSplit" & vbCrLf
      sSql = sSql & "  DEALLOCATE curMOSplit" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   SELECT @level =  MAX(SORTKEYLEVEL) FROM #tempMOPartsDetail" & vbCrLf
      sSql = sSql & "   WHILE (@level >= 0 )" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "      DECLARE curMODet CURSOR  FOR" & vbCrLf
      sSql = sSql & "      --SELECT INPART, LOTTOTMATL, LOTTOTLABOR, LOTTOTEXP , LOTTOTOH FROM #tempMOPartsDetail" & vbCrLf
      sSql = sSql & "      -- WHERE INPART = '775345149'" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "      SELECT INMOPART, " & vbCrLf
      sSql = sSql & "      SUM(IsNull(LOTTOTMATL, 0)), SUM(ISNULL(LOTTOTLABOR,0)) ," & vbCrLf
      sSql = sSql & "        Sum (IsNull(LOTTOTEXP, 0)) , SUM(IsNull(BMTOTOH, 0))" & vbCrLf
      sSql = sSql & "      From" & vbCrLf
      sSql = sSql & "         (SELECT DISTINCT INMOPART,INMORUN,INPART,LOTTOTMATL,LOTTOTLABOR," & vbCrLf
      sSql = sSql & "         LOTTOTEXP,LOTTOTOH,SUMTOTMAL,SUMTOTLABOR, SUMTOTEXP, SUMTOTOH,BMTOTOH" & vbCrLf
      sSql = sSql & "         FROM #tempMOPartsDetail WHERE SORTKEYLEVEL = @level) as foo" & vbCrLf
      sSql = sSql & "      group by INMOPART" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "      OPEN curMODet" & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM curMODet INTO @MOPart, @SumTotMat, @SumTotLabor,@SumTotExp,@SumTotOH" & vbCrLf
      sSql = sSql & "      WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "      BEGIN" & vbCrLf
      sSql = sSql & "         IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "         BEGIN" & vbCrLf
      sSql = sSql & "            " & vbCrLf
      sSql = sSql & "            print 'PartNum : ' + @MOPart" & vbCrLf
      sSql = sSql & "            print 'SumTotoh : ' + Convert(varchar(24), @SumTotOH)" & vbCrLf
      sSql = sSql & "            " & vbCrLf
      sSql = sSql & "            UPDATE #tempMOPartsDetail SET SUMTOTMAL = LOTTOTMATL + @SumTotMat, " & vbCrLf
      sSql = sSql & "            SUMTOTLABOR = LOTTOTLABOR + @SumTotLabor," & vbCrLf
      sSql = sSql & "               SUMTOTEXP = LOTTOTEXP + @SumTotExp, SUMTOTOH = (BMTOTOH + @SumTotOH) * @MOQty , " & vbCrLf
      sSql = sSql & "               HASCHILD = 1,PARTSUM = 'TOTAL ' + LTRIM(INPART)" & vbCrLf
      sSql = sSql & "            " & vbCrLf
      sSql = sSql & "            WHERE INPART = @MOPart AND SORTKEYLEVEL = @level - 1" & vbCrLf
      sSql = sSql & "            " & vbCrLf
      sSql = sSql & "      End" & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM curMODet INTO @MOPart, @SumTotMat, @SumTotLabor,@SumTotExp,@SumTotOH" & vbCrLf
      sSql = sSql & "      End" & vbCrLf
      sSql = sSql & "      Close curMODet" & vbCrLf
      sSql = sSql & "      DEALLOCATE curMODet" & vbCrLf
      sSql = sSql & "      SET @level = @level - 1" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   --// update the Lower level cost detail" & vbCrLf
      sSql = sSql & "    UPDATE #tempMOPartsDetail SET SUMTOTMAL = LOTTOTMATL, SUMTOTLABOR = LOTTOTLABOR," & vbCrLf
      sSql = sSql & "       SUMTOTEXP = LOTTOTEXP, SUMTOTOH = BMTOTOH WHERE HASCHILD IS NULL" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   SET @SumTotMat  = 0" & vbCrLf
      sSql = sSql & "   SET @SumTotLabor  = 0" & vbCrLf
      sSql = sSql & "   SET @SumTotExp  = 0" & vbCrLf
      sSql = sSql & "   SET @SumTotOH  = 0" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   --// Udpate the Root total" & vbCrLf
      sSql = sSql & "    SELECT @SumTotMat = SUM(SUMTOTMAL), @SumTotLabor = SUM(SUMTOTLABOR)," & vbCrLf
      sSql = sSql & "         @SumTotExp = SUM(SUMTOTEXP) ,@SumTotOH = SUM(SUMTOTOH)" & vbCrLf
      sSql = sSql & "     FROM #tempMOPartsDetail WHERE SORTKEYLEVEL = 0 " & vbCrLf
      sSql = sSql & "      AND  RTRIM(INMOPART) <> RTRIM(INPART)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "    UPDATE #tempMOPartsDetail SET PARTSUM = INPART" & vbCrLf
      sSql = sSql & "      WHERE PARTSUM IS NULL" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "  ----  SELECT * FROM #tempMOPartsDetail WHERE SORTKEYLEVEL = 0 " & vbCrLf
      sSql = sSql & "      ----AND  RTRIM(INMOPART) = RTRIM(INPART)" & vbCrLf
      sSql = sSql & "   --// Reverse the partnumbers." & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   set @level = 0 " & vbCrLf
      sSql = sSql & "   set @RowCount = 1" & vbCrLf
      sSql = sSql & "   SET @PrevParent = ''" & vbCrLf
      sSql = sSql & "   DECLARE curAcctStruc CURSOR  FOR" & vbCrLf
      sSql = sSql & "      SELECT INMOPART, SortKey" & vbCrLf
      sSql = sSql & "      FROM #tempMOPartsDetail" & vbCrLf
      sSql = sSql & "         WHERE HASCHILD IS NULL --GLFSLEVEL = 8 --AND GLMASTER ='AA10'--GLTOPMaster = 1 AND " & vbCrLf
      sSql = sSql & "      ORDER BY SortKey" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   OPEN curAcctStruc" & vbCrLf
      sSql = sSql & "   FETCH NEXT FROM curAcctStruc INTO @ParentPart, @SortKey" & vbCrLf
      sSql = sSql & "   WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "    IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "    BEGIN" & vbCrLf
      sSql = sSql & "      if (@PrevParent <> @ParentPart)" & vbCrLf
      sSql = sSql & "      BEGIN" & vbCrLf
      sSql = sSql & "         UPDATE #tempMOPartsDetail SET " & vbCrLf
      sSql = sSql & "            SortKeyRev = RIGHT ('0000'+ Cast(@RowCount as varchar), 4) + char(36)+ @ParentPart" & vbCrLf
      sSql = sSql & "         WHERE INMOPART = @ParentPart AND HASCHILD IS NULL --GLFSLEVEL = 8 --AND GLTOPMaster = 1 " & vbCrLf
      sSql = sSql & "         SET @RowCount = @RowCount + 1" & vbCrLf
      sSql = sSql & "         SET @PrevParent = @ParentPart" & vbCrLf
      sSql = sSql & "      END" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "    End" & vbCrLf
      sSql = sSql & "    FETCH NEXT FROM curAcctStruc INTO @ParentPart, @SortKey" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "       " & vbCrLf
      sSql = sSql & "   Close curAcctStruc" & vbCrLf
      sSql = sSql & "   DEALLOCATE curAcctStruc" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   UPDATE #tempMOPartsDetail SET LOTMOPARTRUNKEY = @MOPartRunKey" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   INSERT INTO EsMOPartsCostDetail (LOTMOPARTRUNKEY, INMOPART,INMORUN,INPART,PARTSUM,LOTNUMBER,LOTUSERLOTID," & vbCrLf
      sSql = sSql & "      LOTTOTMATL,SUMTOTMAL, LOTTOTLABOR,SUMTOTLABOR, LOTTOTEXP, SUMTOTEXP, LOTTOTOH,SUMTOTOH,BMTOTOH," & vbCrLf
      sSql = sSql & "        LOTDATECOSTED, BMQTYREQD, LOTORGQTY, SORTKEYLEVEL,SortKey,SortKeyRev,HASCHILD, PICKQTY)" & vbCrLf
      sSql = sSql & "   SELECT LOTMOPARTRUNKEY,INMOPART,INMORUN,INPART,PARTSUM,LOTNUMBER,LOTUSERLOTID," & vbCrLf
      sSql = sSql & "      LOTTOTMATL,SUMTOTMAL, LOTTOTLABOR,SUMTOTLABOR, LOTTOTEXP, SUMTOTEXP, LOTTOTOH,SUMTOTOH,BMTOTOH," & vbCrLf
      sSql = sSql & "        LOTDATECOSTED, BMQTYREQD, LOTORGQTY, SORTKEYLEVEL,SortKey,SortKeyRev,HASCHILD, PICKQTY" & vbCrLf
      sSql = sSql & "   FROM #tempMOPartsDetail--WHERE SORTKEYLEVEL = 1" & vbCrLf
      sSql = sSql & "   order by SortKey--SortKeyRev      " & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   DROP table #tempMOPartsDetail " & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "END"
      
      ExecuteScript False, sSql
      
      If StoreProcedureExists("RptMOCostAll") Then
         sSql = "DROP PROCEDURE RptMOCostAll"
         ExecuteScript False, sSql
      End If

      sSql = "CREATE PROCEDURE [dbo].[RptMOCostAll]" & vbCrLf
      sSql = sSql & "      @MOPart as varchar(30),@MORun as int, @MOQty as int" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "AS " & vbCrLf
      sSql = sSql & "BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   declare @SumTotMat decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @SumTotLabor decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @SumTotExp decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @SumTotOH decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @level as integer" & vbCrLf
      sSql = sSql & "   declare @Part as varchar(30)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   declare @PrevParent  as varchar(30)" & vbCrLf
      sSql = sSql & "   declare @RowCount as integer" & vbCrLf
      sSql = sSql & "   declare @ChildPart as varchar(30)" & vbCrLf
      sSql = sSql & "   declare @ParentPart as varchar(30)" & vbCrLf
      sSql = sSql & "   declare @MOPart1 as varchar(30)" & vbCrLf
      sSql = sSql & "   declare @MoRun1 as varchar(20)" & vbCrLf
      sSql = sSql & "   declare @Part1 as varchar(30)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   declare @ChildKey as varchar(1024)" & vbCrLf
      sSql = sSql & "   declare @GLSortKey as varchar(1024)" & vbCrLf
      sSql = sSql & "   declare @SortKey as varchar(1024)" & vbCrLf
      sSql = sSql & "   declare @ParentLotNum as varchar(15)" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   declare @Maxlevel as int" & vbCrLf
      sSql = sSql & "   declare @LotRunNo as int" & vbCrLf
      sSql = sSql & "   declare @LotOrgQty as decimal(15,4)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   declare @LotUSpMat decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @LotUSpLabor decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @LotUSpExp decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @LotUSpOH decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @LotMatl decimal(15,4)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   declare @MOLotNum as varchar(15)" & vbCrLf
      sSql = sSql & "   declare @SplitLot as varchar(15)" & vbCrLf
      sSql = sSql & "   declare @cnt  as int" & vbCrLf
      sSql = sSql & "   declare @sumQty decimal(15,4)" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   --DROP TABLE #tempMOPartsDetail " & vbCrLf
      sSql = sSql & "-- DELETE FROM #tempMOPartsDetail " & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   CREATE TABLE #tempMOPartsDetail " & vbCrLf
      sSql = sSql & "   ( " & vbCrLf
      sSql = sSql & "      INMOPART Varchar(30) NULL, " & vbCrLf
      sSql = sSql & "      INMORUN int NULL , " & vbCrLf
      sSql = sSql & "      INPART varchar(30) NULL , " & vbCrLf
      sSql = sSql & "      LOTNUMBER varchar(15) NULL, " & vbCrLf
      sSql = sSql & "      LOTUSERLOTID varchar(40) NULL," & vbCrLf
      sSql = sSql & "      INTOTMATL decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      INTOTLABOR decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      INTOTEXP decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      INTOTOH decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      LOTTOTMATL decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      LOTTOTLABOR decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      LOTTOTEXP decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      LOTTOTOH decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      SUMTOTMAL decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      SUMTOTLABOR decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      SUMTOTEXP decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      SUMTOTOH decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      LOTDATECOSTED smalldatetime NULL," & vbCrLf
      sSql = sSql & "      SortKey varchar(512) NULL," & vbCrLf
      sSql = sSql & "      HASCHILD int NULL," & vbCrLf
      sSql = sSql & "      SORTKEYLEVEL tinyint NULL," & vbCrLf
      sSql = sSql & "      SortKeyRev varchar(512)," & vbCrLf
      sSql = sSql & "      PARTSUM varchar(40)," & vbCrLf
      sSql = sSql & "      BMQTYREQD decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      LOTORGQTY decimal(12,4) NULL," & vbCrLf
      sSql = sSql & "      BMTOTOH decimal(12,4) NULL," & vbCrLf
      sSql = sSql & "      LOTSPLITFROMSYS varchar(15)," & vbCrLf
      sSql = sSql & "      INVNO int NULL," & vbCrLf
      sSql = sSql & "      ITPSNUMBER varchar(8) NULL," & vbCrLf
      sSql = sSql & "      ITPSITEM smallint NULL," & vbCrLf
      sSql = sSql & "      PICKQTY decimal(12,4) NULL" & vbCrLf
      sSql = sSql & "   ) " & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "--ALTER TABLE #tempMOPartsDetail ADD PICKQTY decimal(12,4) NULL" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "--ALTER TABLE #tempMOPartsDetail ADD PARTSUM varchar(40)" & vbCrLf
      sSql = sSql & "--ALTER TABLE #tempMOPartsDetail ADD BMQTYREQD decimal(12,4) NULL, LOTORGQTY decimal(12,4) NULL" & vbCrLf
      sSql = sSql & "--ALTER TABLE #tempMOPartsDetail ADD BMTOTOH decimal(12,4) NULL" & vbCrLf
      sSql = sSql & "  " & vbCrLf
      sSql = sSql & "--   DELETE FROM #tempMOPartsDetail" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "      with cte" & vbCrLf
      sSql = sSql & "      as" & vbCrLf
      sSql = sSql & "      (select BMASSYPART, BMPARTREF,  BMQTYREQD,0 as level, cast('1' + char(36)+ BMPARTREF as varchar(max)) as SortKey" & vbCrLf
      sSql = sSql & "      from BmplTable" & vbCrLf
      sSql = sSql & "      where BMASSYPART = @MOPart" & vbCrLf
      sSql = sSql & "      union all" & vbCrLf
      sSql = sSql & "      select a.BMASSYPART, a.BMPARTREF, a.BMQTYREQD, level + 1," & vbCrLf
      sSql = sSql & "         cast(COALESCE(SortKey,'') + char(36) + COALESCE(a.BMPARTREF,'') as varchar(max))as SortKey" & vbCrLf
      sSql = sSql & "      from cte" & vbCrLf
      sSql = sSql & "         inner join BmplTable a" & vbCrLf
      sSql = sSql & "            on cte.BMPARTREF = a.BMASSYPART " & vbCrLf
      sSql = sSql & "      )" & vbCrLf
      sSql = sSql & "      INSERT INTO #tempMOPartsDetail(INMOPART,INPART,BMQTYREQD,SORTKEYLEVEL,SortKey)" & vbCrLf
      sSql = sSql & "      select BMASSYPART, BMPARTREF,BMQTYREQD,level,SortKey " & vbCrLf
      sSql = sSql & "         from cte order by SortKey " & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   END" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   SET @cnt = 0" & vbCrLf
      sSql = sSql & "print 'Update Start:' + cast(getdate() as char(25))" & vbCrLf
      sSql = sSql & "print 'Count :' + Convert(varchar(10), @cnt)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   UPDATE #tempMOPartsDetail SET INMORUN = @MORun, LOTNUMBER = b.INLOTNUMBER, " & vbCrLf
      sSql = sSql & "            LOTSPLITFROMSYS = c.LOTSPLITFROMSYS" & vbCrLf
      sSql = sSql & "      FROM dbo.LohdTable AS c INNER JOIN" & vbCrLf
      sSql = sSql & "              dbo.InvaTable AS b ON c.LOTNUMBER = b.INLOTNUMBER AND c.LOTPARTREF = b.INPART LEFT OUTER JOIN" & vbCrLf
      sSql = sSql & "              dbo.#tempMOPartsDetail AS d ON b.INMOPART = d.INMOPART AND b.INPART = d.INPART" & vbCrLf
      sSql = sSql & "      WHERE     (b.INMOPART = @MOPart) AND (b.INMORUN = @MORun) AND (b.INTYPE = 10) AND (d.SORTKEYLEVEL = 0)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   UPDATE #tempMOPartsDetail SET PICKQTY = sumqty * -1" & vbCrLf
      sSql = sSql & "      FROM #tempMOPartsDetail," & vbCrLf
      sSql = sSql & "   (SELECT SUM(b.INAQTY) sumqty, d.INMOPART mopart, d.INMORUN morun, d.LOTNUMBER lotnum, d.INPART subpart" & vbCrLf
      sSql = sSql & "   FROM dbo.LohdTable AS c INNER JOIN" & vbCrLf
      sSql = sSql & "           dbo.InvaTable AS b ON c.LOTNUMBER = b.INLOTNUMBER AND c.LOTPARTREF = b.INPART LEFT OUTER JOIN" & vbCrLf
      sSql = sSql & "           dbo.#tempMOPartsDetail AS d ON b.INMOPART = d.INMOPART AND b.INPART = d.INPART" & vbCrLf
      sSql = sSql & "   WHERE     b.INMOPART = @MOPart AND b.INMORUN  = @MORun AND (b.INTYPE = 10) AND (d.SORTKEYLEVEL = 0)" & vbCrLf
      sSql = sSql & "   GROUP BY d.INMOPART, d.INMORUN, d.LOTNUMBER, d.INPART" & vbCrLf
      sSql = sSql & "   ) as f" & vbCrLf
      sSql = sSql & "   WHERE INMOPART = f.mopart AND INMORUN = f.morun " & vbCrLf
      sSql = sSql & "    AND LOTNUMBER = lotnum AND INPART = subpart" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   --// Update the " & vbCrLf
      sSql = sSql & "   --// update the top level" & vbCrLf
      sSql = sSql & "   UPDATE #tempMOPartsDetail SET INMORUN = @MORun, LOTNUMBER = b.INLOTNUMBER, " & vbCrLf
      sSql = sSql & "            LOTUSERLOTID = c.LOTUSERLOTID," & vbCrLf
      sSql = sSql & "            INTOTMATL = b.INTOTMATL, INTOTLABOR = b.INTOTLABOR, " & vbCrLf
      sSql = sSql & "            INTOTEXP = b.INTOTEXP, INTOTOH = b.INTOTOH, " & vbCrLf
      sSql = sSql & "            LOTTOTMATL = (c.LOTTOTMATL * PICKQTY) / c.LOTORIGINALQTY, " & vbCrLf
      sSql = sSql & "            LOTTOTLABOR = (c.LOTTOTLABOR * PICKQTY) / c.LOTORIGINALQTY, " & vbCrLf
      sSql = sSql & "            LOTTOTEXP = (c.LOTTOTEXP * PICKQTY) / c.LOTORIGINALQTY, " & vbCrLf
      sSql = sSql & "            LOTTOTOH = (c.LOTTOTOH * PICKQTY) / c.LOTORIGINALQTY," & vbCrLf
      sSql = sSql & "            LOTDATECOSTED = c.LOTDATECOSTED, LOTORGQTY = c.LOTORIGINALQTY," & vbCrLf
      sSql = sSql & "            BMTOTOH = (c.LOTTOTOH * PICKQTY) / c.LOTORIGINALQTY," & vbCrLf
      sSql = sSql & "            LOTSPLITFROMSYS = c.LOTSPLITFROMSYS" & vbCrLf
      sSql = sSql & "      FROM dbo.LohdTable AS c INNER JOIN" & vbCrLf
      sSql = sSql & "              dbo.InvaTable AS b ON c.LOTNUMBER = b.INLOTNUMBER AND c.LOTPARTREF = b.INPART LEFT OUTER JOIN" & vbCrLf
      sSql = sSql & "              dbo.#tempMOPartsDetail AS d ON b.INMOPART = d.INMOPART AND b.INPART = d.INPART" & vbCrLf
      sSql = sSql & "      WHERE     (b.INMOPART = @MOPart) AND (b.INMORUN = @MORun) AND (b.INTYPE = 10) AND (d.SORTKEYLEVEL = 0)" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "print 'Update 2:' + cast(getdate() as char(25))" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   --FROM #tempMOPartsDetail d, InvaTable b, LohdTable c" & vbCrLf
      sSql = sSql & "   --WHERE d.INMOPART = b.INMOPART AND d.INPART = b.INPART " & vbCrLf
      sSql = sSql & "   -- AND b.INLOTNUMBER = c.LOTnumber" & vbCrLf
      sSql = sSql & "   -- and c.lotpartref = b.INPART" & vbCrLf
      sSql = sSql & "   -- and b.INMOPART = @MOPart AND b.INMORUN  = @MORun" & vbCrLf
      sSql = sSql & "   -- AND b.INTYPE = 10 AND SORTKEYLEVEL = 0" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   --// set the totals for " & vbCrLf
      sSql = sSql & "   SELECT @Maxlevel =  MAX(SORTKEYLEVEL) FROM #tempMOPartsDetail" & vbCrLf
      sSql = sSql & "   SET @level  = 1" & vbCrLf
      sSql = sSql & "   WHILE (@level <= @Maxlevel )" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "      DECLARE curMORun CURSOR  FOR" & vbCrLf
      sSql = sSql & "      SELECT DISTINCT INMOPART,INPART " & vbCrLf
      sSql = sSql & "         FROM #tempMOPartsDetail WHERE SORTKEYLEVEL = @level" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "      OPEN curMORun" & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM curMORun INTO @MOPart, @Part" & vbCrLf
      sSql = sSql & "      WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "      BEGIN" & vbCrLf
      sSql = sSql & "         IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "         BEGIN" & vbCrLf
      sSql = sSql & "         " & vbCrLf
      sSql = sSql & "         SELECT @ParentLotNum = LOTNUMBER FROM #tempMOPartsDetail WHERE" & vbCrLf
      sSql = sSql & "               INPART = @MOPart AND SORTKEYLEVEL = @level - 1" & vbCrLf
      sSql = sSql & "         " & vbCrLf
      sSql = sSql & "         SELECT @LotRunNo = LOTMORUNNO, @LotOrgQty = LOTORIGINALQTY " & vbCrLf
      sSql = sSql & "                  FROM lohdTable where LOTNUMBER = @ParentLotNum" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "         UPDATE #tempMOPartsDetail SET INMORUN = @LotRunNo, LOTNUMBER = b.INLOTNUMBER, " & vbCrLf
      sSql = sSql & "                  LOTSPLITFROMSYS = c.LOTSPLITFROMSYS" & vbCrLf
      sSql = sSql & "         FROM #tempMOPartsDetail d, InvaTable b, LohdTable c" & vbCrLf
      sSql = sSql & "         WHERE d.INMOPART = b.INMOPART AND d.INPART = b.INPART " & vbCrLf
      sSql = sSql & "            AND b.INLOTNUMBER = c.LOTnumber" & vbCrLf
      sSql = sSql & "            and c.lotpartref = b.INPART" & vbCrLf
      sSql = sSql & "            and b.INMOPART = @MOPart AND b.INMORUN  = @LotRunNo" & vbCrLf
      sSql = sSql & "            AND b.INTYPE = 10 AND SORTKEYLEVEL = @level" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "         UPDATE #tempMOPartsDetail SET PICKQTY = sumqty * -1" & vbCrLf
      sSql = sSql & "            FROM " & vbCrLf
      sSql = sSql & "         (SELECT SUM(b.INAQTY) sumqty, d.INMOPART mopart, d.INMORUN morun, d.LOTNUMBER lotnum, d.INPART subpart" & vbCrLf
      sSql = sSql & "         FROM dbo.LohdTable AS c INNER JOIN" & vbCrLf
      sSql = sSql & "                 dbo.InvaTable AS b ON c.LOTNUMBER = b.INLOTNUMBER AND c.LOTPARTREF = b.INPART LEFT OUTER JOIN" & vbCrLf
      sSql = sSql & "                 dbo.#tempMOPartsDetail AS d ON b.INMOPART = d.INMOPART AND b.INPART = d.INPART" & vbCrLf
      sSql = sSql & "         WHERE     b.INMOPART = @MOPart AND b.INMORUN  = @LotRunNo AND (b.INTYPE = 10) AND (d.SORTKEYLEVEL = @level)" & vbCrLf
      sSql = sSql & "         GROUP BY d.INMOPART, d.INMORUN, d.LOTNUMBER, d.INPART" & vbCrLf
      sSql = sSql & "         ) as f" & vbCrLf
      sSql = sSql & "         WHERE INMOPART = mopart AND INMORUN = morun " & vbCrLf
      sSql = sSql & "          AND LOTNUMBER = lotnum AND INPART = subpart" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "         --// update the top level" & vbCrLf
      sSql = sSql & "         UPDATE #tempMOPartsDetail SET INMORUN = @LotRunNo, LOTNUMBER = b.INLOTNUMBER, " & vbCrLf
      sSql = sSql & "                  LOTUSERLOTID = c.LOTUSERLOTID," & vbCrLf
      sSql = sSql & "                  INTOTMATL = b.INTOTMATL, INTOTLABOR = b.INTOTLABOR, " & vbCrLf
      sSql = sSql & "                  INTOTEXP = b.INTOTEXP, INTOTOH = b.INTOTOH, " & vbCrLf
      sSql = sSql & "                  LOTTOTMATL = (c.LOTTOTMATL * PICKQTY) / c.LOTORIGINALQTY, " & vbCrLf
      sSql = sSql & "                  LOTTOTLABOR = (c.LOTTOTLABOR * PICKQTY) / c.LOTORIGINALQTY, " & vbCrLf
      sSql = sSql & "                  LOTTOTEXP = (c.LOTTOTEXP * PICKQTY) / c.LOTORIGINALQTY, " & vbCrLf
      sSql = sSql & "                  LOTTOTOH = (c.LOTTOTOH * PICKQTY) / c.LOTORIGINALQTY," & vbCrLf
      sSql = sSql & "                  LOTDATECOSTED = c.LOTDATECOSTED, LOTORGQTY = @LotOrgQty," & vbCrLf
      sSql = sSql & "                  BMTOTOH = (c.LOTTOTOH * PICKQTY) / @LotOrgQty," & vbCrLf
      sSql = sSql & "                  LOTSPLITFROMSYS = c.LOTSPLITFROMSYS" & vbCrLf
      sSql = sSql & "         FROM #tempMOPartsDetail d, InvaTable b, LohdTable c" & vbCrLf
      sSql = sSql & "         WHERE d.INMOPART = b.INMOPART AND d.INPART = b.INPART " & vbCrLf
      sSql = sSql & "            AND b.INLOTNUMBER = c.LOTnumber" & vbCrLf
      sSql = sSql & "            and c.lotpartref = b.INPART" & vbCrLf
      sSql = sSql & "            and b.INMOPART = @MOPart AND b.INMORUN  = @LotRunNo" & vbCrLf
      sSql = sSql & "            AND b.INTYPE = 10 AND SORTKEYLEVEL = @level" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "      End" & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM curMORun INTO @MOPart, @Part" & vbCrLf
      sSql = sSql & "      End" & vbCrLf
      sSql = sSql & "      Close curMORun" & vbCrLf
      sSql = sSql & "      DEALLOCATE curMORun" & vbCrLf
      sSql = sSql & "      SET @level = @level + 1" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "print 'Update 2:'+ cast(getdate() as char(25))" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "  DECLARE curMOSplit CURSOR  FOR" & vbCrLf
      sSql = sSql & "   SELECT DISTINCT LOTNUMBER, LOTSPLITFROMSYS, LOTTOTMATL--, LOTTOTLABOR, LOTTOTEXP, LOTTOTOH" & vbCrLf
      sSql = sSql & "     FROM #tempMOPartsDetail WHERE LOTSPLITFROMSYS <> ''" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "  OPEN curMOSplit" & vbCrLf
      sSql = sSql & "  FETCH NEXT FROM curMOSplit INTO @MOLotNum, @SplitLot, @LotMatl" & vbCrLf
      sSql = sSql & "  WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "  BEGIN" & vbCrLf
      sSql = sSql & "     IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "     BEGIN" & vbCrLf
      sSql = sSql & "      " & vbCrLf
      sSql = sSql & "      print 'LotSplit LotNum:' + @SplitLot" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "      IF @LotMatl = 0" & vbCrLf
      sSql = sSql & "      BEGIN" & vbCrLf
      sSql = sSql & "         SELECT @LotUSpMat = (LOTTOTMATL / LOTORIGINALQTY), " & vbCrLf
      sSql = sSql & "               @LotUSpLabor = (LOTTOTLABOR / LOTORIGINALQTY)," & vbCrLf
      sSql = sSql & "               @LotUSpExp = (LOTTOTEXP / LOTORIGINALQTY), " & vbCrLf
      sSql = sSql & "               @LotUSpOH = (LOTTOTOH / LOTORIGINALQTY)" & vbCrLf
      sSql = sSql & "         FROM Lohdtable WHERE LOTNUMBER = @SplitLot" & vbCrLf
      sSql = sSql & "         " & vbCrLf
      sSql = sSql & "         UPDATE #tempMOPartsDetail SET LOTTOTMATL = (@LotUSpMat * PICKQTY), " & vbCrLf
      sSql = sSql & "                  LOTTOTLABOR = (@LotUSpLabor * PICKQTY), " & vbCrLf
      sSql = sSql & "                  LOTTOTEXP = (@LotUSpExp * PICKQTY), " & vbCrLf
      sSql = sSql & "                  LOTTOTOH = (@LotUSpOH * PICKQTY)" & vbCrLf
      sSql = sSql & "         WHERE LOTNUMBER = @MOLotNum AND LOTSPLITFROMSYS = @SplitLot" & vbCrLf
      sSql = sSql & "               " & vbCrLf
      sSql = sSql & "      END" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "   FETCH NEXT FROM curMOSplit INTO @MOLotNum, @SplitLot, @LotMatl" & vbCrLf
      sSql = sSql & "  End" & vbCrLf
      sSql = sSql & "  Close curMOSplit" & vbCrLf
      sSql = sSql & "  DEALLOCATE curMOSplit" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   SELECT @level =  MAX(SORTKEYLEVEL) FROM #tempMOPartsDetail" & vbCrLf
      sSql = sSql & "   WHILE (@level >= 0 )" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "      DECLARE curMODet CURSOR  FOR" & vbCrLf
      sSql = sSql & "      --SELECT INPART, LOTTOTMATL, LOTTOTLABOR, LOTTOTEXP , LOTTOTOH FROM #tempMOPartsDetail" & vbCrLf
      sSql = sSql & "      -- WHERE INPART = '775345149'" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "      SELECT INMOPART, " & vbCrLf
      sSql = sSql & "      SUM(IsNull(LOTTOTMATL, 0)), SUM(ISNULL(LOTTOTLABOR,0)) ," & vbCrLf
      sSql = sSql & "        Sum (IsNull(LOTTOTEXP, 0)) , SUM(IsNull(BMTOTOH, 0))" & vbCrLf
      sSql = sSql & "      From" & vbCrLf
      sSql = sSql & "         (SELECT DISTINCT INMOPART,INMORUN,INPART,LOTTOTMATL,LOTTOTLABOR," & vbCrLf
      sSql = sSql & "         LOTTOTEXP,LOTTOTOH,SUMTOTMAL,SUMTOTLABOR, SUMTOTEXP, SUMTOTOH,BMTOTOH" & vbCrLf
      sSql = sSql & "         FROM #tempMOPartsDetail WHERE SORTKEYLEVEL = @level) as foo" & vbCrLf
      sSql = sSql & "      group by INMOPART" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "      OPEN curMODet" & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM curMODet INTO @MOPart, @SumTotMat, @SumTotLabor,@SumTotExp,@SumTotOH" & vbCrLf
      sSql = sSql & "      WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "      BEGIN" & vbCrLf
      sSql = sSql & "         IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "         BEGIN" & vbCrLf
      sSql = sSql & "            " & vbCrLf
      sSql = sSql & "            print 'PartNum : ' + @MOPart" & vbCrLf
      sSql = sSql & "            print 'SumTotoh : ' + Convert(varchar(24), @SumTotOH)" & vbCrLf
      sSql = sSql & "            " & vbCrLf
      sSql = sSql & "            UPDATE #tempMOPartsDetail SET SUMTOTMAL = LOTTOTMATL + @SumTotMat, " & vbCrLf
      sSql = sSql & "            SUMTOTLABOR = LOTTOTLABOR + @SumTotLabor," & vbCrLf
      sSql = sSql & "               SUMTOTEXP = LOTTOTEXP + @SumTotExp, SUMTOTOH = (BMTOTOH + @SumTotOH) * @MOQty , " & vbCrLf
      sSql = sSql & "               HASCHILD = 1,PARTSUM = 'TOTAL ' + LTRIM(INPART)" & vbCrLf
      sSql = sSql & "            " & vbCrLf
      sSql = sSql & "            WHERE INPART = @MOPart AND SORTKEYLEVEL = @level - 1" & vbCrLf
      sSql = sSql & "            " & vbCrLf
      sSql = sSql & "      End" & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM curMODet INTO @MOPart, @SumTotMat, @SumTotLabor,@SumTotExp,@SumTotOH" & vbCrLf
      sSql = sSql & "      End" & vbCrLf
      sSql = sSql & "      Close curMODet" & vbCrLf
      sSql = sSql & "      DEALLOCATE curMODet" & vbCrLf
      sSql = sSql & "      SET @level = @level - 1" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   --// update the Lower level cost detail" & vbCrLf
      sSql = sSql & "    UPDATE #tempMOPartsDetail SET SUMTOTMAL = LOTTOTMATL, SUMTOTLABOR = LOTTOTLABOR," & vbCrLf
      sSql = sSql & "       SUMTOTEXP = LOTTOTEXP, SUMTOTOH = BMTOTOH WHERE HASCHILD IS NULL" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   SET @SumTotMat  = 0" & vbCrLf
      sSql = sSql & "   SET @SumTotLabor  = 0" & vbCrLf
      sSql = sSql & "   SET @SumTotExp  = 0" & vbCrLf
      sSql = sSql & "   SET @SumTotOH  = 0" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   --// Udpate the Root total" & vbCrLf
      sSql = sSql & "    SELECT @SumTotMat = SUM(SUMTOTMAL), @SumTotLabor = SUM(SUMTOTLABOR)," & vbCrLf
      sSql = sSql & "         @SumTotExp = SUM(SUMTOTEXP) ,@SumTotOH = SUM(SUMTOTOH)" & vbCrLf
      sSql = sSql & "     FROM #tempMOPartsDetail WHERE SORTKEYLEVEL = 0 " & vbCrLf
      sSql = sSql & "      AND  RTRIM(INMOPART) <> RTRIM(INPART)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "    UPDATE #tempMOPartsDetail SET PARTSUM = INPART" & vbCrLf
      sSql = sSql & "      WHERE PARTSUM IS NULL" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "  ----  SELECT * FROM #tempMOPartsDetail WHERE SORTKEYLEVEL = 0 " & vbCrLf
      sSql = sSql & "      ----AND  RTRIM(INMOPART) = RTRIM(INPART)" & vbCrLf
      sSql = sSql & "   --// Reverse the partnumbers." & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   set @level = 0 " & vbCrLf
      sSql = sSql & "   set @RowCount = 1" & vbCrLf
      sSql = sSql & "   SET @PrevParent = ''" & vbCrLf
      sSql = sSql & "   DECLARE curAcctStruc CURSOR  FOR" & vbCrLf
      sSql = sSql & "      SELECT INMOPART, SortKey" & vbCrLf
      sSql = sSql & "      FROM #tempMOPartsDetail" & vbCrLf
      sSql = sSql & "         WHERE HASCHILD IS NULL --GLFSLEVEL = 8 --AND GLMASTER ='AA10'--GLTOPMaster = 1 AND " & vbCrLf
      sSql = sSql & "      ORDER BY SortKey" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   OPEN curAcctStruc" & vbCrLf
      sSql = sSql & "   FETCH NEXT FROM curAcctStruc INTO @ParentPart, @SortKey" & vbCrLf
      sSql = sSql & "   WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "    IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "    BEGIN" & vbCrLf
      sSql = sSql & "      if (@PrevParent <> @ParentPart)" & vbCrLf
      sSql = sSql & "      BEGIN" & vbCrLf
      sSql = sSql & "         UPDATE #tempMOPartsDetail SET " & vbCrLf
      sSql = sSql & "            SortKeyRev = RIGHT ('0000'+ Cast(@RowCount as varchar), 4) + char(36)+ @ParentPart" & vbCrLf
      sSql = sSql & "         WHERE INMOPART = @ParentPart AND HASCHILD IS NULL --GLFSLEVEL = 8 --AND GLTOPMaster = 1 " & vbCrLf
      sSql = sSql & "         SET @RowCount = @RowCount + 1" & vbCrLf
      sSql = sSql & "         SET @PrevParent = @ParentPart" & vbCrLf
      sSql = sSql & "      END" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "    End" & vbCrLf
      sSql = sSql & "    FETCH NEXT FROM curAcctStruc INTO @ParentPart, @SortKey" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "       " & vbCrLf
      sSql = sSql & "   Close curAcctStruc" & vbCrLf
      sSql = sSql & "   DEALLOCATE curAcctStruc" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   SELECT LOTSPLITFROMSYS,INMOPART,INMORUN,INPART,PARTSUM,PICKQTY,SORTKEYLEVEL,LOTNUMBER,LOTUSERLOTID," & vbCrLf
      sSql = sSql & "      LOTTOTMATL,SUMTOTMAL, LOTTOTLABOR,SUMTOTLABOR, LOTTOTEXP, SUMTOTEXP, LOTTOTOH,SUMTOTOH,BMTOTOH," & vbCrLf
      sSql = sSql & "        LOTDATECOSTED, BMQTYREQD, LOTORGQTY, SORTKEYLEVEL,SortKey,SortKeyRev,HASCHILD      " & vbCrLf
      sSql = sSql & "   FROM #tempMOPartsDetail--WHERE SORTKEYLEVEL = 1" & vbCrLf
      sSql = sSql & "   order by SortKey--SortKeyRev      " & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   DROP table #tempMOPartsDetail " & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "END"
      
      ExecuteScript False, sSql
      
      ' update the version
      ExecuteScript False, "Update Version Set Version = " & newver
   
   End If
End Function


Private Function UpdateDatabase55()
   newver = 129
   If ver < newver Then
      
      If (TableExists("EsReportBook18")) Then
         sSql = "DROP TABLE EsReportBook18"
         ExecuteScript False, sSql
      End If
      
      
      If Not ColumnExists("VndrTable", "TAXNAME") Then
         sSql = "ALTER table dbo.VndrTable add TAXNAME char(40), TAXADDR char(160), TAXCITY char(18), TAXSTATE char(4), TAXZIP char (10), TAXCOUNTRY char(20), EN1099 tinyint"
         ExecuteScript False, sSql
      End If

      If (Not TableExists("WCSchView")) Then
         sSql = "CREATE TABLE [dbo].[WCSchView](" & vbCrLf _
                   & "    [WorkCenter] [varchar](15) NULL" & vbCrLf _
                  & "  ) ON [PRIMARY]"
         ExecuteScript False, sSql
      End If


      If StoreProcedureExists("RptRMFGoods") Then
         sSql = "DROP PROCEDURE RptRMFGoods"
         ExecuteScript False, sSql
      End If

      sSql = "CREATE PROCEDURE [dbo].[RptRMFGoods] " & vbCrLf
      sSql = sSql & "       @ReportDate as varchar(16), @PartClass as Varchar(16), " & vbCrLf
      sSql = sSql & "       @PartCode as varchar(8), @lotHDOnly as int, @PartType1 as Integer, " & vbCrLf
      sSql = sSql & "       @PartType2 as Integer, @PartType3 as Integer, @PartType4 as Integer " & vbCrLf
      sSql = sSql & "       AS        " & vbCrLf
      sSql = sSql & "       BEGIN      " & vbCrLf
      sSql = sSql & "         declare @partRef as varchar(30)   " & vbCrLf
      sSql = sSql & "         declare @partType as int           " & vbCrLf
      sSql = sSql & "         declare @partDesc as varchar(30)     " & vbCrLf
      sSql = sSql & "         declare @partExDesc as varchar(3072)    " & vbCrLf
      sSql = sSql & "         declare @rptRemQty as decimal(12,4)  " & vbCrLf
      sSql = sSql & "         declare @deltaQty as decimal(12,4)   " & vbCrLf
      sSql = sSql & "         declare @lotRemQty as decimal(12,4)  " & vbCrLf
      sSql = sSql & "         declare @lotOrgQty as decimal(12,4)  " & vbCrLf
      sSql = sSql & "         declare @tmpInvQty as decimal(12,4)  " & vbCrLf
      sSql = sSql & "         declare @tmpLastInvQty as decimal(12,4)    " & vbCrLf
      sSql = sSql & "         declare @rptInvcost decimal(12,4)    " & vbCrLf
      sSql = sSql & "         declare @lastInvcost decimal(12,4)   " & vbCrLf
      sSql = sSql & "         declare @orgInvcost decimal(12,4)    " & vbCrLf
      sSql = sSql & "         declare @tmpInvCost decimal(12,4)    " & vbCrLf
      sSql = sSql & "         declare @tmpLastInvCost decimal(12,4)   " & vbCrLf
      sSql = sSql & "         declare @lastQty as decimal(12,4)    " & vbCrLf
      sSql = sSql & "         declare @SumQty as decimal(12,4)" & vbCrLf
      sSql = sSql & "         declare @PSNum as varchar(12)" & vbCrLf
      sSql = sSql & "      " & vbCrLf
      sSql = sSql & "         declare @orgQty as decimal(12,4)  " & vbCrLf
      sSql = sSql & "         declare @rptQty as decimal(12,4)  " & vbCrLf
      sSql = sSql & "         declare @rptCreditACC varchar(12)    " & vbCrLf
      sSql = sSql & "       declare @rptDebitACC varchar(12)" & vbCrLf
      sSql = sSql & "       declare @rptACC varchar(12)   " & vbCrLf
      sSql = sSql & "       declare @CurACC varchar(12)   " & vbCrLf
      sSql = sSql & "       declare @tmpCreditAcc varchar(12)   " & vbCrLf
      sSql = sSql & "       declare @tmpDebitAcc varchar(12) " & vbCrLf
      sSql = sSql & "       declare @tmplastCreditAcc varchar(12)  " & vbCrLf
      sSql = sSql & "       declare @tmpLastDebitAcc varchar(12)   " & vbCrLf
      sSql = sSql & "       declare @lastCreditACC varchar(12)  " & vbCrLf
      sSql = sSql & "       declare @lastDebitACC varchar(12)   " & vbCrLf
      sSql = sSql & "       declare @lastACC varchar(12)  " & vbCrLf
      sSql = sSql & "       declare @orgCreditACC varchar(12)" & vbCrLf
      sSql = sSql & "       declare @orgDebitACC varchar(12) " & vbCrLf
      sSql = sSql & "       declare @orgACC varchar(12)   " & vbCrLf
      sSql = sSql & "       declare @OrgInvNum as int  " & vbCrLf
      sSql = sSql & "       declare @rptInvNum as int  " & vbCrLf
      sSql = sSql & "       declare @LastInvNum as int " & vbCrLf
      sSql = sSql & "       declare @tmpInvNum as int  " & vbCrLf
      sSql = sSql & "       declare @tmpLastInvNum as int " & vbCrLf
      sSql = sSql & "       declare @LotNumber varchar(51)   " & vbCrLf
      sSql = sSql & "       declare @LotNum varchar(51)   " & vbCrLf
      sSql = sSql & "       " & vbCrLf
      sSql = sSql & "       declare @LotUserID varchar(51)   " & vbCrLf
      sSql = sSql & "       declare @lotAcualDate as smalldatetime " & vbCrLf
      sSql = sSql & "       declare @lotCostedDate as smalldatetime   " & vbCrLf
      sSql = sSql & "       declare @curDate as smalldatetime   " & vbCrLf
      sSql = sSql & "       declare @AcualDate as smalldatetime " & vbCrLf
      sSql = sSql & "       declare @CostedDate as smalldatetime   " & vbCrLf
      sSql = sSql & "       declare @tmpINVAdate  as smalldatetime   " & vbCrLf
      sSql = sSql & "       declare @tmpLastINVAdate  as smalldatetime   " & vbCrLf
      sSql = sSql & "       declare @unitcost as decimal(12,4)  " & vbCrLf
      sSql = sSql & "       declare @partStdCost as decimal(12,4)  " & vbCrLf
      sSql = sSql & "       declare @LotUnitCost as decimal(12,4)  " & vbCrLf
      sSql = sSql & "       declare @lotTotMatl as decimal(12,4)   " & vbCrLf
      sSql = sSql & "       declare @lotTotLabor as decimal(12,4)  " & vbCrLf
      sSql = sSql & "       declare @lotTotExp as decimal(12,4) " & vbCrLf
      sSql = sSql & "       declare @lotTotOH as decimal(12,4)  " & vbCrLf
      sSql = sSql & "       declare @partActCost as int   " & vbCrLf
      sSql = sSql & "       declare @partLotTrack as int  " & vbCrLf
      sSql = sSql & "       declare @flgStdCost as int " & vbCrLf
      sSql = sSql & "       declare @flgLdCost as int  " & vbCrLf
      sSql = sSql & "       declare @flgInvCost as int " & vbCrLf
      sSql = sSql & "       declare @flgLdRQErr as int " & vbCrLf
      sSql = sSql & "       declare @flgOrgAcc as int  " & vbCrLf
      sSql = sSql & "       declare @flgRptAcc as int  " & vbCrLf
      sSql = sSql & "       declare @flgLastAcc as int " & vbCrLf
      sSql = sSql & "      " & vbCrLf
      sSql = sSql & "      " & vbCrLf
      sSql = sSql & "         IF (@PartClass = 'ALL')" & vbCrLf
      sSql = sSql & "         BEGIN " & vbCrLf
      sSql = sSql & "            SET @PartClass = ''  " & vbCrLf
      sSql = sSql & "         End            " & vbCrLf
      sSql = sSql & "         IF (@PartCode = 'ALL')  " & vbCrLf
      sSql = sSql & "         BEGIN " & vbCrLf
      sSql = sSql & "            SET @PartCode = ''      " & vbCrLf
      sSql = sSql & "       End                     " & vbCrLf
      sSql = sSql & "          IF (@PartType1 = 1)     " & vbCrLf
      sSql = sSql & "            SET @PartType1 = 1    " & vbCrLf
      sSql = sSql & "         Else                    " & vbCrLf
      sSql = sSql & "           SET @PartType1 = 0    " & vbCrLf
      sSql = sSql & "         IF (@PartType2 = 1)     " & vbCrLf
      sSql = sSql & "           SET @PartType2 = 2    " & vbCrLf
      sSql = sSql & "         Else                    " & vbCrLf
      sSql = sSql & "           SET @PartType2 = 0    " & vbCrLf
      sSql = sSql & "          IF (@PartType3 = 1)    " & vbCrLf
      sSql = sSql & "              SET @PartType3 = 3 " & vbCrLf
      sSql = sSql & "          Else                   " & vbCrLf
      sSql = sSql & "              SET @PartType3 = 0 " & vbCrLf
      sSql = sSql & "                                 " & vbCrLf
      sSql = sSql & "          IF (@PartType4 = 1)    " & vbCrLf
      sSql = sSql & "              SET @PartType4 = 4 " & vbCrLf
      sSql = sSql & "          Else                   " & vbCrLf
      sSql = sSql & "              SET @PartType4 = 0 " & vbCrLf
      sSql = sSql & "            " & vbCrLf
      sSql = sSql & "      -- DELETE FROM tempRMFGoods" & vbCrLf
      sSql = sSql & "      " & vbCrLf
      sSql = sSql & "         CREATE TABLE #tempRMFGoods(   " & vbCrLf
      sSql = sSql & "         [LOTNUMBER] [varchar](15) NULL,  " & vbCrLf
      sSql = sSql & "         [PARTNUM] [varchar](30) NULL, " & vbCrLf
      sSql = sSql & "         [PALEVEL] [int] NULL,         " & vbCrLf
      sSql = sSql & "         [PADESC] [varchar](30) NULL,  " & vbCrLf
      sSql = sSql & "         [PAEXTDESC] [varchar](3072) NULL,   " & vbCrLf
      sSql = sSql & "         [LOTUSERLOTID] [char](40) NULL,     " & vbCrLf
      sSql = sSql & "         [ORGINNUMBER] [int] NULL,           " & vbCrLf
      sSql = sSql & "         [RPTINNUMBER] [int] NULL,           " & vbCrLf
      sSql = sSql & "         [CURINNUMBER] [int] NULL,           " & vbCrLf
      sSql = sSql & "         [ACTUALDATE] [smalldatetime] NULL,  " & vbCrLf
      sSql = sSql & "         [RPTDATEQTY] [decimal](12, 4) NULL, " & vbCrLf
      sSql = sSql & "         [UNITCOST] [decimal](12, 4) NULL,   " & vbCrLf
      sSql = sSql & "         [PASTDCOST] [decimal](12, 4) NULL,  " & vbCrLf
      sSql = sSql & "         [LOTUNITCOST] [decimal](12, 4) NULL,   " & vbCrLf
      sSql = sSql & "         [INAMT] [decimal](12, 4) NULL,         " & vbCrLf
      sSql = sSql & "         [ORGCOST] [decimal](12, 4) NULL,       " & vbCrLf
      sSql = sSql & "         [STDCOST] [decimal](12, 4) NULL,       " & vbCrLf
      sSql = sSql & "         [LSTACOST] [decimal](12, 4) NULL,      " & vbCrLf
      sSql = sSql & "         [RPTCOST] [decimal](12, 4) NULL,       " & vbCrLf
      sSql = sSql & "         [CURCOST] [decimal](12, 4) NULL,       " & vbCrLf
      sSql = sSql & "         [COSTEDDATE] [smalldatetime] NULL,     " & vbCrLf
      sSql = sSql & "         [RPTACCOUNT] [char](12) NULL,          " & vbCrLf
      sSql = sSql & "         [ORIGINALACC] [char](12) NULL,         " & vbCrLf
      sSql = sSql & "         [LASTACTVITYACC] [char](12) NULL,      " & vbCrLf
      sSql = sSql & "         [CURRENTACC] [char](12) NULL, " & vbCrLf
      sSql = sSql & "         [PACLASS] [char](4) NULL,  " & vbCrLf
      sSql = sSql & "         [PAPRODCODE] [char](6) NULL,  " & vbCrLf
      sSql = sSql & "         [flgStdCost] [int] NULL,   " & vbCrLf
      sSql = sSql & "         [flgLdCost] [int] NULL,    " & vbCrLf
      sSql = sSql & "         [flgInvCost] [int] NULL,   " & vbCrLf
      sSql = sSql & "         [flgLdRQErr] [int] NULL,   " & vbCrLf
      sSql = sSql & "         [flgRptAcc] [int] NULL,    " & vbCrLf
      sSql = sSql & "         [flgOrgAcc] [int] NULL,    " & vbCrLf
      sSql = sSql & "         [flgLastAcc] [int] NULL    " & vbCrLf
      sSql = sSql & "      )                             " & vbCrLf
      sSql = sSql & "                                    " & vbCrLf
      sSql = sSql & "       DECLARE curLotHd CURSOR LOCAL " & vbCrLf
      sSql = sSql & "       FOR                           " & vbCrLf
      sSql = sSql & "       SELECT LOTNUMBER, LOTUSERLOTID, PARTREF, PADESC, PAEXTDESC, " & vbCrLf
      sSql = sSql & "          LOTADATE,LOTORIGINALQTY, LOTREMAININGQTY, LOTUNITCOST, LOTDATECOSTED,   " & vbCrLf
      sSql = sSql & "          PACLASS , PAPRODCODE, PASTDCOST, PAUSEACTUALCOST, PALOTTRACK, PALEVEL   " & vbCrLf
      sSql = sSql & "       From ViewLohdPartTable  " & vbCrLf
      sSql = sSql & "       WHERE ViewLohdPartTable.LOTADATE  < DATEADD(dd, 1 , @ReportDate)  " & vbCrLf
      sSql = sSql & "          AND ViewLohdPartTable.PACLASS LIKE '%' + @PartClass + '%'      " & vbCrLf
      sSql = sSql & "          AND ViewLohdPartTable.PAPRODCODE LIKE '%' + @PartCode + '%'    " & vbCrLf
      sSql = sSql & "          AND ViewLohdPartTable.PALEVEL IN (@PartType1, @PartType2, @PartType3, @PartType4)   " & vbCrLf
      sSql = sSql & "          --AND PARTREF IN ('NAS1578V3T9','BACB28AP06P018','BACB30NT3K22') " & vbCrLf
      sSql = sSql & "      " & vbCrLf
      sSql = sSql & "       OPEN curLotHd                                                     " & vbCrLf
      sSql = sSql & "       FETCH NEXT FROM curLotHd INTO @LotNumber, @LotUserID, @partRef,   " & vbCrLf
      sSql = sSql & "          @partDesc, @partExDesc, @lotAcualDate, @lotOrgQty,             " & vbCrLf
      sSql = sSql & "          @lotRemQty,@LotUnitCost, @lotCostedDate,                       " & vbCrLf
      sSql = sSql & "          @PartClass, @PartCode, @partStdCost, @partActCost, @partLotTrack, @partType   " & vbCrLf
      sSql = sSql & "                                                                      " & vbCrLf
      sSql = sSql & "       WHILE (@@FETCH_STATUS <> -1)                                   " & vbCrLf
      sSql = sSql & "       BEGIN                                                          " & vbCrLf
      sSql = sSql & "       IF (@@FETCH_STATUS <> -2)     " & vbCrLf
      sSql = sSql & "       BEGIN                         " & vbCrLf
      sSql = sSql & "          SET @flgLdRQErr = 0        " & vbCrLf
      sSql = sSql & "       IF (@lotRemQty < 0.0000)      " & vbCrLf
      sSql = sSql & "       BEGIN                         " & vbCrLf
      sSql = sSql & "          SET @lotRemQty = 0.0000    " & vbCrLf
      sSql = sSql & "          SET @flgLdRQErr  = 1       " & vbCrLf
      sSql = sSql & "       End                           " & vbCrLf
      sSql = sSql & "       SET @curDate = GETDATE()      " & vbCrLf
      sSql = sSql & "                                     " & vbCrLf
      sSql = sSql & "       SELECT @deltaQty = ISNULL(SUM(LOIQUANTITY), 0.0000)   " & vbCrLf
      sSql = sSql & "       From LoitTable                                        " & vbCrLf
      sSql = sSql & "       WHERE LOIADATE BETWEEN DATEADD(dd, 1 ,@ReportDate) AND DATEADD(dd, 1 ,@curDate)  " & vbCrLf
      sSql = sSql & "          AND LOIPARTREF = @partRef                    " & vbCrLf
      sSql = sSql & "          AND LOINUMBER = @LotNumber                   " & vbCrLf
      sSql = sSql & "       SET @rptRemQty = @lotRemQty + (@deltaQty * -1)  " & vbCrLf
      sSql = sSql & "       IF @rptRemQty < 0.0000           " & vbCrLf
      sSql = sSql & "       SET @rptRemQty = @rptRemQty * -1 " & vbCrLf
      sSql = sSql & "       SET @flgStdCost = 0     " & vbCrLf
      sSql = sSql & "       SET @flgLdCost = 0      " & vbCrLf
      sSql = sSql & "       SET @flgInvCost = 0     " & vbCrLf
      sSql = sSql & "       SET @flgOrgAcc = 0      " & vbCrLf
      sSql = sSql & "       SET @flgRptAcc = 0      " & vbCrLf
      sSql = sSql & "       SET @flgLastAcc = 0     " & vbCrLf
      sSql = sSql & "                               " & vbCrLf
      sSql = sSql & "       DECLARE curInv CURSOR   " & vbCrLf
      sSql = sSql & "       LOCAL                   " & vbCrLf
      sSql = sSql & "       Scroll                  " & vbCrLf
      sSql = sSql & "       FOR                     " & vbCrLf
      sSql = sSql & "       SELECT INNUMBER, INAMT, INAQTY, ISNULL(INCREDITACCT,0), ISNULL(INDEBITACCT, 0), INADATE   " & vbCrLf
      sSql = sSql & "           From InvaTable, LoitTable                          " & vbCrLf
      sSql = sSql & "       WHERE InvaTable.INPART = @partRef                  " & vbCrLf
      sSql = sSql & "          AND LoitTable.LOINUMBER = @LotNumber            " & vbCrLf
      sSql = sSql & "          AND InvaTable.INPART = LoitTable.LOIPARTREF     " & vbCrLf
      sSql = sSql & "          AND InvaTable.INNUMBER = LoitTable.LOIACTIVITY  " & vbCrLf
      sSql = sSql & "       ORDER BY INADATE ASC          " & vbCrLf
      sSql = sSql & "                                     " & vbCrLf
      sSql = sSql & "       OPEN curInv                   " & vbCrLf
      sSql = sSql & "       FETCH FIRST FROM curInv INTO @tmpInvNum, @tmpInvCost, @tmpInvQty, " & vbCrLf
      sSql = sSql & "       @tmpCreditAcc, @tmpDebitAcc, @tmpINVAdate " & vbCrLf
      sSql = sSql & "       IF (@@FETCH_STATUS <> -1)  " & vbCrLf
      sSql = sSql & "       BEGIN                      " & vbCrLf
      sSql = sSql & "       IF (@@FETCH_STATUS <> -2)  " & vbCrLf
      sSql = sSql & "       BEGIN                      " & vbCrLf
      sSql = sSql & "          SET @orgInvcost = @tmpInvCost " & vbCrLf
      sSql = sSql & "          SET @orgQty = @tmpInvQty      " & vbCrLf
      sSql = sSql & "          SET @orgCreditACC = @tmpCreditAcc   " & vbCrLf
      sSql = sSql & "          SET @orgDebitACC = @tmpDebitAcc  " & vbCrLf
      sSql = sSql & "          SET @OrgInvNum = @tmpInvNum      " & vbCrLf
      sSql = sSql & "       End                                 " & vbCrLf
      sSql = sSql & "       FETCH LAST FROM curInv INTO @tmpLastInvNum, @tmpLastInvCost, @tmpLastInvQty,  " & vbCrLf
      sSql = sSql & "       @tmplastCreditAcc, @tmpLastDebitAcc, @tmpLastINVAdate " & vbCrLf
      sSql = sSql & "       IF (@@FETCH_STATUS <> -2)  " & vbCrLf
      sSql = sSql & "       BEGIN                      " & vbCrLf
      sSql = sSql & "       SET @lastInvcost = @tmpLastInvCost  " & vbCrLf
      sSql = sSql & "       SET @lastQty = @tmpLastInvQty    " & vbCrLf
      sSql = sSql & "       SET @lastCreditACC = @tmplastCreditAcc " & vbCrLf
      sSql = sSql & "       SET @lastDebitACC = @tmpLastDebitAcc   " & vbCrLf
      sSql = sSql & "       SET @LastInvNum = @tmpLastInvNum       " & vbCrLf
      sSql = sSql & "       IF @tmpLastINVAdate > DATEADD(dd, 1, @ReportDate)  " & vbCrLf
      sSql = sSql & "       BEGIN                                              " & vbCrLf
      sSql = sSql & "         SELECT TOP 1 @rptInvNum = INNUMBER, @rptInvcost = INAMT, " & vbCrLf
      sSql = sSql & "            @rptQty = INAQTY, @rptCreditACC = ISNULL(INCREDITACCT, 0),  " & vbCrLf
      sSql = sSql & "            @rptDebitACC = ISNULL(INDEBITACCT, 0)     " & vbCrLf
      sSql = sSql & "         From InvaTable, LoitTable                 " & vbCrLf
      sSql = sSql & "            WHERE INADATE < DATEADD(dd, 1, @ReportDate)  " & vbCrLf
      sSql = sSql & "               AND InvaTable.INPART = @partRef              " & vbCrLf
      sSql = sSql & "               AND LoitTable.LOINUMBER = @LotNumber         " & vbCrLf
      sSql = sSql & "               AND InvaTable.INPART = LoitTable.LOIPARTREF  " & vbCrLf
      sSql = sSql & "               AND InvaTable.INNUMBER = LoitTable.LOIACTIVITY  " & vbCrLf
      sSql = sSql & "               ORDER BY INADATE DESC                           " & vbCrLf
      sSql = sSql & "        End                                          " & vbCrLf
      sSql = sSql & "        Else                                         " & vbCrLf
      sSql = sSql & "        BEGIN                                        " & vbCrLf
      sSql = sSql & "        SET @rptInvNum = @tmpLastInvNum              " & vbCrLf
      sSql = sSql & "                                        " & vbCrLf
      sSql = sSql & "                                           " & vbCrLf
      sSql = sSql & "       SET @rptInvcost = @tmpLastInvCost   " & vbCrLf
      sSql = sSql & "       SET @rptQty = @tmpLastInvQty        " & vbCrLf
      sSql = sSql & "       SET @rptCreditACC = @tmplastCreditAcc  " & vbCrLf
      sSql = sSql & "       SET @rptDebitACC = @tmpLastDebitAcc    " & vbCrLf
      sSql = sSql & "       End                                 " & vbCrLf
      sSql = sSql & "       End                                 " & vbCrLf
      sSql = sSql & "       End                                 " & vbCrLf
      sSql = sSql & "       CLOSE curInv   --// close the cursor   " & vbCrLf
      sSql = sSql & "       DEALLOCATE curInv          " & vbCrLf
      sSql = sSql & "       IF (@partActCost = 0)      " & vbCrLf
      sSql = sSql & "       BEGIN                      " & vbCrLf
      sSql = sSql & "       SET @unitcost = @partStdCost  " & vbCrLf
      sSql = sSql & "       SET @flgStdCost = 1        " & vbCrLf
      sSql = sSql & "       End                        " & vbCrLf
      sSql = sSql & "       Else                       " & vbCrLf
      sSql = sSql & "       BEGIN                      " & vbCrLf
      sSql = sSql & "       IF @lotHDOnly = 1          " & vbCrLf
      sSql = sSql & "       BEGIN                      " & vbCrLf
      sSql = sSql & "       SET @unitcost = @LotUnitCost  " & vbCrLf
      sSql = sSql & "       SET @flgLdCost = 1            " & vbCrLf
      sSql = sSql & "       End                           " & vbCrLf
      sSql = sSql & "       Else                          " & vbCrLf
      sSql = sSql & "       BEGIN                         " & vbCrLf
      sSql = sSql & "       IF @lotCostedDate < DATEADD(dd, 1, @ReportDate) " & vbCrLf
      sSql = sSql & "          BEGIN                            " & vbCrLf
      sSql = sSql & "          SET @unitcost = @LotUnitCost     " & vbCrLf
      sSql = sSql & "          SET @flgLdCost = 1   " & vbCrLf
      sSql = sSql & "          End                  " & vbCrLf
      sSql = sSql & "          Else                 " & vbCrLf
      sSql = sSql & "          BEGIN                " & vbCrLf
      sSql = sSql & "          SET @unitcost = @rptInvcost   " & vbCrLf
      sSql = sSql & "          SET @flgInvCost = 1           " & vbCrLf
      sSql = sSql & "          End                        " & vbCrLf
      sSql = sSql & "          END --LotHD only           " & vbCrLf
      sSql = sSql & "          END --Part Cost            " & vbCrLf
      sSql = sSql & "          SELECT @CurACC = dbo.fnGetPartInvAccount(@partRef) " & vbCrLf
      sSql = sSql & "          -- Lastest < report account#        " & vbCrLf
      sSql = sSql & "          IF @rptQty >= 0.0000                " & vbCrLf
      sSql = sSql & "          SET @rptACC = @rptDebitACC          " & vbCrLf
      sSql = sSql & "          Else                                " & vbCrLf
      sSql = sSql & "          SET @rptACC = @rptCreditACC         " & vbCrLf
      sSql = sSql & "          IF ((@rptACC = '') OR (@rptACC = NULL))      " & vbCrLf
      sSql = sSql & "          BEGIN                   " & vbCrLf
      sSql = sSql & "          SET @rptACC = @CurACC   " & vbCrLf
      sSql = sSql & "          SET @flgRptAcc = 1      " & vbCrLf
      sSql = sSql & "          End                     " & vbCrLf
      sSql = sSql & "          -- last record          " & vbCrLf
      sSql = sSql & "          IF @lastQty >= 0.0000      " & vbCrLf
      sSql = sSql & "          SET @lastACC = @lastDebitACC  " & vbCrLf
      sSql = sSql & "          Else                          " & vbCrLf
      sSql = sSql & "          SET @lastACC = @lastCreditACC " & vbCrLf
      sSql = sSql & "          IF ((@lastACC = '') OR (@lastACC = NULL)) " & vbCrLf
      sSql = sSql & "          BEGIN                   " & vbCrLf
      sSql = sSql & "          SET @lastACC = @CurACC  " & vbCrLf
      sSql = sSql & "          SET @flgLastAcc = 1     " & vbCrLf
      sSql = sSql & "          End                     " & vbCrLf
      sSql = sSql & "          -- Lastest < report account#  " & vbCrLf
      sSql = sSql & "          IF @orgQty >= 0.0000          " & vbCrLf
      sSql = sSql & "          SET @orgACC = @orgDebitACC    " & vbCrLf
      sSql = sSql & "          Else                          " & vbCrLf
      sSql = sSql & "          SET @orgACC = @orgCreditACC      " & vbCrLf
      sSql = sSql & "          IF ((@orgACC = '') OR (@orgACC = NULL))   " & vbCrLf
      sSql = sSql & "          BEGIN                    " & vbCrLf
      sSql = sSql & "          SET @orgACC = @CurACC      " & vbCrLf
      sSql = sSql & "          SET @flgOrgAcc = 1      " & vbCrLf
      sSql = sSql & "          End                     " & vbCrLf
      sSql = sSql & "          -- Insert to the temp table   " & vbCrLf
      sSql = sSql & "          INSERT INTO #tempRMFGoods     " & vbCrLf
      sSql = sSql & "          (PARTNUM, PALEVEL, PADESC, PAEXTDESC, LOTNUMBER, LOTUSERLOTID, " & vbCrLf
      sSql = sSql & "          ORGINNUMBER, RPTINNUMBER, CURINNUMBER, ACTUALDATE,RPTDATEQTY, COSTEDDATE,  " & vbCrLf
      sSql = sSql & "          UNITCOST,PASTDCOST, LOTUNITCOST, ORGCOST, STDCOST, " & vbCrLf
      sSql = sSql & "          LSTACOST, RPTCOST, CURCOST, RPTACCOUNT,ORIGINALACC,   " & vbCrLf
      sSql = sSql & "          LASTACTVITYACC, CURRENTACC, PACLASS,PAPRODCODE,    " & vbCrLf
      sSql = sSql & "          flgStdCost, flgLdCost, flgInvCost, flgLdRQErr,  " & vbCrLf
      sSql = sSql & "          flgRptAcc, flgOrgAcc, flgLastAcc)      " & vbCrLf
      sSql = sSql & "          VALUES (@partRef, @partType, @partDesc, @partExDesc, @LotNumber,@LotUserID, @OrgInvNum,   " & vbCrLf
      sSql = sSql & "          @rptInvNum, @LastInvNum, @lotAcualDate,@rptRemQty,@lotCostedDate, " & vbCrLf
      sSql = sSql & "          @unitcost,@partStdCost, @LotUnitCost, @orgInvcost, @partStdCost,  " & vbCrLf
      sSql = sSql & "          @lastInvcost,@rptInvcost, @LotUnitCost, @rptACC, @orgACC, @lastACC,  " & vbCrLf
      sSql = sSql & "          @CurACC, @PartClass,@PartCode,@flgStdCost, @flgLdCost, @flgInvCost,  " & vbCrLf
      sSql = sSql & "          @flgLdRQErr, @flgRptAcc, @flgOrgAcc, @flgLastAcc)                    " & vbCrLf
      sSql = sSql & "          SET @rptRemQty = NULL   " & vbCrLf
      sSql = sSql & "          SET @deltaQty = NULL    " & vbCrLf
      sSql = sSql & "          SET @lotRemQty = NULL   " & vbCrLf
      sSql = sSql & "          SET @lotOrgQty = NULL   " & vbCrLf
      sSql = sSql & "          SET @tmpInvQty = NULL   " & vbCrLf
      sSql = sSql & "          SET @tmpLastInvQty  = NULL " & vbCrLf
      sSql = sSql & "          SET @rptInvcost = NULL  " & vbCrLf
      sSql = sSql & "          SET @lastInvcost = NULL " & vbCrLf
      sSql = sSql & "          SET @orgInvcost = NULL  " & vbCrLf
      sSql = sSql & "          SET @tmpInvCost = NULL  " & vbCrLf
      sSql = sSql & "          SET @unitcost = NULL    " & vbCrLf
      sSql = sSql & "          SET @tmpLastInvCost = NULL " & vbCrLf
      sSql = sSql & "          SET @lastQty = NULL  " & vbCrLf
      sSql = sSql & "          SET @orgQty = NULL   " & vbCrLf
      sSql = sSql & "          SET @rptQty  = NULL  " & vbCrLf
      sSql = sSql & "          SET @rptCreditACC = NULL   " & vbCrLf
      sSql = sSql & "          SET @rptDebitACC  = NULL   " & vbCrLf
      sSql = sSql & "         SET @rptACC  = NULL     " & vbCrLf
      sSql = sSql & "         SET @tmpCreditAcc  = NULL  " & vbCrLf
      sSql = sSql & "         SET @tmpDebitAcc = NULL    " & vbCrLf
      sSql = sSql & "         SET @tmplastCreditAcc = NULL  " & vbCrLf
      sSql = sSql & "         SET @tmpLastDebitAcc = NULL   " & vbCrLf
      sSql = sSql & "         SET @lastCreditACC = NULL     " & vbCrLf
      sSql = sSql & "         SET @lastDebitACC = NULL      " & vbCrLf
      sSql = sSql & "         SET @lastACC  = NULL          " & vbCrLf
      sSql = sSql & "         SET @orgCreditACC  = NULL     " & vbCrLf
      sSql = sSql & "         SET @orgDebitACC  = NULL      " & vbCrLf
      sSql = sSql & "         SET @orgACC  = NULL           " & vbCrLf
      sSql = sSql & "         SET @OrgInvNum = NULL         " & vbCrLf
      sSql = sSql & "         SET @rptInvNum = NULL         " & vbCrLf
      sSql = sSql & "         SET @LastInvNum = NULL        " & vbCrLf
      sSql = sSql & "         End                     " & vbCrLf
      sSql = sSql & "         FETCH NEXT FROM curLotHd INTO @LotNumber, @LotUserID, @partRef,   " & vbCrLf
      sSql = sSql & "         @partDesc, @partExDesc, @lotAcualDate, @lotOrgQty,                " & vbCrLf
      sSql = sSql & "         @lotRemQty,@LotUnitCost, @lotCostedDate,                          " & vbCrLf
      sSql = sSql & "         @PartClass, @PartCode, @partStdCost, @partActCost, @partLotTrack, @partType   " & vbCrLf
      sSql = sSql & "         End                                    " & vbCrLf
      sSql = sSql & "         CLOSE curLotHd   --// close the cursor " & vbCrLf
      sSql = sSql & "         DEALLOCATE curLotHd                    " & vbCrLf
      sSql = sSql & "                                                 " & vbCrLf
      sSql = sSql & "         " & vbCrLf
      sSql = sSql & "         DECLARE curLotNumPS CURSOR  FOR" & vbCrLf
      sSql = sSql & "            SELECT LOIPSNUMBER,LOINUMBER, (SUM(LOIQUANTITY) * -1) SumQty FROM loitTable,pshdTable " & vbCrLf
      sSql = sSql & "               WHERE LOIPSNUMBER = psnumber AND PSPRINTED IS NOT NULL AND psshipped = 0 " & vbCrLf
      sSql = sSql & "            GROUP BY LOIPSNUMBER,LOINUMBER" & vbCrLf
      sSql = sSql & "            HAVING SUM(LOIQUANTITY) < 0" & vbCrLf
      sSql = sSql & "      " & vbCrLf
      sSql = sSql & "         OPEN curLotNumPS" & vbCrLf
      sSql = sSql & "         FETCH NEXT FROM curLotNumPS INTO @PSNum, @LotNum, @SumQty" & vbCrLf
      sSql = sSql & "         WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "         BEGIN" & vbCrLf
      sSql = sSql & "            IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "            BEGIN" & vbCrLf
      sSql = sSql & "               " & vbCrLf
      sSql = sSql & "               --print 'Lot:' + @LotNum + 'Qty:' + Convert(varchar(20), @SumQty)" & vbCrLf
      sSql = sSql & "               UPDATE #tempRMFGoods SET RPTDATEQTY = RPTDATEQTY + @SumQty WHERE LOTNUMBER = @LotNum" & vbCrLf
      sSql = sSql & "               " & vbCrLf
      sSql = sSql & "            End" & vbCrLf
      sSql = sSql & "            FETCH NEXT FROM curLotNumPS INTO @PSNum, @LotNum, @SumQty" & vbCrLf
      sSql = sSql & "         End" & vbCrLf
      sSql = sSql & "         " & vbCrLf
      sSql = sSql & "         Close curLotNumPS" & vbCrLf
      sSql = sSql & "         DEALLOCATE curLotNumPS" & vbCrLf
      sSql = sSql & "         " & vbCrLf
      sSql = sSql & "         SELECT * FROM #tempRMFGoods            " & vbCrLf
      sSql = sSql & "         " & vbCrLf
      sSql = sSql & "         DROP table #tempRMFGoods            " & vbCrLf
      sSql = sSql & "                  " & vbCrLf
      sSql = sSql & "      End "
      
      ExecuteScript False, sSql
      
      
      If StoreProcedureExists("PivotWCSchDate") Then
         sSql = "DROP PROCEDURE PivotWCSchDate"
         ExecuteScript False, sSql
      End If
      
      sSql = "CREATE PROCEDURE [dbo].[PivotWCSchDate] " & vbCrLf
      sSql = sSql & "   @StartDate as varchar(12),@EndDate as varchar(12) " & vbCrLf
      sSql = sSql & "AS " & vbCrLf
      sSql = sSql & "BEGIN  " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   --delete from tempWCSch " & vbCrLf
      sSql = sSql & "   CREATE TABLE #tempWCSch(    " & vbCrLf
      sSql = sSql & "      [SEQNUM] integer NULL,   " & vbCrLf
      sSql = sSql & "      [OPCENTER] [varchar](30) NULL,  " & vbCrLf
      sSql = sSql & "      [RUNREF] [varchar](30) NULL,  " & vbCrLf
      sSql = sSql & "      [RUNNO] int NULL,  " & vbCrLf
      sSql = sSql & "      [OPNO] varchar(5) NULL,  " & vbCrLf
      sSql = sSql & "      [RUNSCHED] datetime NULL,  " & vbCrLf
      sSql = sSql & "      [RUNQTY] int NULL, " & vbCrLf
      sSql = sSql & "      [RUNPRIORITY] int NULL, " & vbCrLf
      sSql = sSql & "        [RUMCOMP] varchar(512) NULL  " & vbCrLf
      sSql = sSql & "   )                              " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   INSERT INTO #tempWCSch (SEQNUM, OPCENTER,RUNREF , RUNNO, OPNO, RUNSCHED, RUNQTY,RUNPRIORITY,RUMCOMP) " & vbCrLf
      sSql = sSql & "   SELECT DISTINCT ROW_NUMBER() OVER(PARTITION BY OPCENTER ORDER BY OPCENTER DESC) AS SEQNUM,  " & vbCrLf
      sSql = sSql & "         OPCENTER,RUNREF , RUNNO, OPNO, RUNSCHED, RUNQTY,RUNPRIORITY,   RTRIM(RUNREF) + SPACE(2) + Convert(varchar(13), RUNNO) +  " & vbCrLf
      sSql = sSql & "            SPACE(2) + Convert(varchar(5), OPNO)  +  " & vbCrLf
      sSql = sSql & "            SPACE(2) + Convert(varchar(10), RUNSCHED, 101)  +  " & vbCrLf
      sSql = sSql & "      SPACE(2) + Convert(varchar(10), CONVERT(int, ROUND(RUNQTY, 0))) +  " & vbCrLf
      sSql = sSql & "      SPACE(2) + Convert(varchar(10), OPRUNTIME ) " & vbCrLf
      sSql = sSql & "   FROM RnopTable, RunsTable, WCSchView " & vbCrLf
      sSql = sSql & "   WHERE (OPREF = RUNREF AND OPRUN = RUNNO)   " & vbCrLf
      sSql = sSql & "      AND WorkCenter = RTRIM(OPCENTER) " & vbCrLf
      sSql = sSql & "      AND (OPCOMPLETE=0 AND OPCENTER LIKE '%' AND   " & vbCrLf
      sSql = sSql & "      RUNSCHED BETWEEN @StartDate AND  @EndDate)   " & vbCrLf
      sSql = sSql & "   ORDER BY OPCENTER " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   declare @SQL as varchar(8000) " & vbCrLf
      sSql = sSql & "   declare @OPCenter as varchar(12) " & vbCrLf
      sSql = sSql & "   declare @RunSch as datetime " & vbCrLf
      sSql = sSql & "   declare @WCCenter as varchar(512) " & vbCrLf
      sSql = sSql & "    " & vbCrLf
      sSql = sSql & "   SET @SQL = NULL " & vbCrLf
      sSql = sSql & "   SET @SQL = 'SELECT SEQNUM '  " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   DECLARE curWCShc CURSOR FOR " & vbCrLf
      sSql = sSql & "     SELECT RTRIM(OPCENTER), MIN(RUNSCHED) FROM #tempWCSch " & vbCrLf
      sSql = sSql & "   GROUP BY OPCENTER " & vbCrLf
      sSql = sSql & "      OPEN curWCShc " & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM curWCShc INTO @OPCenter, @RunSch " & vbCrLf
      sSql = sSql & "      WHILE (@@FETCH_STATUS <> -1) " & vbCrLf
      sSql = sSql & "      BEGIN " & vbCrLf
      sSql = sSql & "         IF (@@FETCH_STATUS <> -2) " & vbCrLf
      sSql = sSql & "         BEGIN " & vbCrLf
      sSql = sSql & "             " & vbCrLf
      sSql = sSql & "            --INSERT INTO #tempWC (WorkCenter) VALUES (@OPCenter) " & vbCrLf
      sSql = sSql & "            SET @SQL =  @SQL + ','  + " & vbCrLf
      sSql = sSql & "                  ' MAX(CASE WHEN RTRIM(OPCENTER) = ''' + @OPCenter + '''' + " & vbCrLf
      sSql = sSql & "                     ' THEN RUMCOMP END) as ''' +  @OPCenter + '''' " & vbCrLf
      sSql = sSql & "             " & vbCrLf
      sSql = sSql & "            FETCH NEXT FROM curWCShc INTO @OPCenter,@RunSch " & vbCrLf
      sSql = sSql & "         END " & vbCrLf
      sSql = sSql & "      END " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "      CLOSE curWCShc --// close the cursor " & vbCrLf
      sSql = sSql & "      DEALLOCATE curWCShc " & vbCrLf
      sSql = sSql & "       " & vbCrLf
      sSql = sSql & "          " & vbCrLf
      sSql = sSql & "      SET @SQL =  @SQL + 'FROM #tempWCSch WHERE OPCENTER IN (SELECT DISTINCT WorkCenter FROM WCSchView) GROUP BY SEQNUM' " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "          " & vbCrLf
      sSql = sSql & "   print @SQL " & vbCrLf
      sSql = sSql & "      EXEC(@SQL)   " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   Drop table #tempWCSch " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "END "
      
      ExecuteScript False, sSql

      If Not TableExists("[MatCertTable]") Then
         sSql = "CREATE TABLE [dbo].[MatCertTable](" & vbCrLf
         sSql = sSql & "   [MATCERTID] [int] NOT NULL," & vbCrLf
         sSql = sSql & "   [TENSILEFORMID] [int] NOT NULL," & vbCrLf
         sSql = sSql & "   [CUSTOMER] [varchar](24) NOT NULL," & vbCrLf
         sSql = sSql & "   [MOPARTNUM] [varchar](30) NOT NULL," & vbCrLf
         sSql = sSql & "   [MORUN] [int] NOT NULL," & vbCrLf
         sSql = sSql & "   [ALLOYTEMP] [varchar](24) NULL," & vbCrLf
         sSql = sSql & "   [ALLOYSPEC] [varchar](24) NULL," & vbCrLf
         sSql = sSql & "   [CASTDATE] [datetime] NULL," & vbCrLf
         sSql = sSql & "   [REVISION] [varchar](24) NULL," & vbCrLf
         sSql = sSql & "   [QTY] [decimal](18, 2) NULL," & vbCrLf
         sSql = sSql & "   [PONUMBER] [int] NULL," & vbCrLf
         sSql = sSql & "   [HEATTREATID] [int] NULL," & vbCrLf
         sSql = sSql & "   [SPECIFICAION] [varchar](24) NULL," & vbCrLf
         sSql = sSql & "   [INSPBY] [varchar](24) NULL," & vbCrLf
         sSql = sSql & "   [SAMPLPLAN] [varchar](24) NULL," & vbCrLf
         sSql = sSql & "   [PENETRANTLOG] [varchar](24) NULL," & vbCrLf
         sSql = sSql & "   [QTYINSP] [varchar](12) NULL," & vbCrLf
         sSql = sSql & "   [QTYACCEP] [varchar](12) NULL," & vbCrLf
         sSql = sSql & "   [QTYREJ] [varchar](12) NULL," & vbCrLf
         sSql = sSql & "   [LIQUIDPENINSP] [smallint] NULL," & vbCrLf
         sSql = sSql & "   [XRAYRPTATT] [smallint] NULL," & vbCrLf
         sSql = sSql & "   [XRAYLOGNUM] [varchar](24) NULL," & vbCrLf
         sSql = sSql & "   [DIMRPTATT] [smallint] NULL," & vbCrLf
         sSql = sSql & "   [DIMCERTNUM] [varchar](24) NULL," & vbCrLf
         sSql = sSql & "   [HWFCERTRPTATT] [smallint] NULL," & vbCrLf
         sSql = sSql & "   [HWFCERTNUM] [varchar](24) NULL," & vbCrLf
         sSql = sSql & "   [HEATNUM] [varchar](24) NULL," & vbCrLf
         sSql = sSql & "   [CHEMIMPDATE] [datetime] NULL" & vbCrLf
         sSql = sSql & ") ON [PRIMARY]"
         
         ExecuteScript False, sSql
      End If


      If Not TableExists("[MatCertTable]") Then
         
         sSql = "CREATE TABLE [dbo].[MatCertTable](" & vbCrLf
         sSql = sSql & "   [MATCERTID] [int] NOT NULL," & vbCrLf
         sSql = sSql & "   [TENSILEFORMID] [int] NOT NULL," & vbCrLf
         sSql = sSql & "   [CUSTOMER] [varchar](24) NOT NULL," & vbCrLf
         sSql = sSql & "   [MOPARTNUM] [varchar](30) NOT NULL," & vbCrLf
         sSql = sSql & "   [MORUN] [int] NOT NULL," & vbCrLf
         sSql = sSql & "   [ALLOYTEMP] [varchar](24) NULL," & vbCrLf
         sSql = sSql & "   [ALLOYSPEC] [varchar](24) NULL," & vbCrLf
         sSql = sSql & "   [CASTDATE] [datetime] NULL," & vbCrLf
         sSql = sSql & "   [REVISION] [varchar](24) NULL," & vbCrLf
         sSql = sSql & "   [QTY] [decimal](18, 2) NULL," & vbCrLf
         sSql = sSql & "   [PONUMBER] [int] NULL," & vbCrLf
         sSql = sSql & "   [HEATTREATID] [int] NULL," & vbCrLf
         sSql = sSql & "   [SPECIFICAION] [varchar](24) NULL," & vbCrLf
         sSql = sSql & "   [INSPBY] [varchar](24) NULL," & vbCrLf
         sSql = sSql & "   [SAMPLPLAN] [varchar](24) NULL," & vbCrLf
         sSql = sSql & "   [PENETRANTLOG] [varchar](24) NULL," & vbCrLf
         sSql = sSql & "   [QTYINSP] [varchar](12) NULL," & vbCrLf
         sSql = sSql & "   [QTYACCEP] [varchar](12) NULL," & vbCrLf
         sSql = sSql & "   [QTYREJ] [varchar](12) NULL," & vbCrLf
         sSql = sSql & "   [LIQUIDPENINSP] [smallint] NULL," & vbCrLf
         sSql = sSql & "   [XRAYRPTATT] [smallint] NULL," & vbCrLf
         sSql = sSql & "   [XRAYLOGNUM] [varchar](24) NULL," & vbCrLf
         sSql = sSql & "   [DIMRPTATT] [smallint] NULL," & vbCrLf
         sSql = sSql & "   [DIMCERTNUM] [varchar](24) NULL," & vbCrLf
         sSql = sSql & "   [HWFCERTRPTATT] [smallint] NULL," & vbCrLf
         sSql = sSql & "   [HWFCERTNUM] [varchar](24) NULL," & vbCrLf
         sSql = sSql & "   [HEATNUM] [varchar](24) NULL," & vbCrLf
         sSql = sSql & "   [CHEMIMPDATE] [datetime] NULL" & vbCrLf
         sSql = sSql & ") ON [PRIMARY]"
         
         ExecuteScript False, sSql
      End If

      If Not TableExists("[HeatTrtCertTable]") Then
         
         sSql = "CREATE TABLE [dbo].[HeatTrtCertTable](" & vbCrLf
         sSql = sSql & "   [MATCERTID] [int] NOT NULL," & vbCrLf
         sSql = sSql & "   [HEATTRTID] [int] NOT NULL," & vbCrLf
         sSql = sSql & "   [MATCERTHEATNUM] [int] NOT NULL," & vbCrLf
         sSql = sSql & "   [HEATTREATDATE] [datetime] NULL," & vbCrLf
         sSql = sSql & "   [HEATTREATLOAD] [varchar](24) NULL," & vbCrLf
         sSql = sSql & "   [BRINELLHARNESS] [varchar](24) NULL" & vbCrLf
         sSql = sSql & ") ON [PRIMARY]"
         
         ExecuteScript False, sSql
      End If

      If Not TableExists("[CertUsrSec]") Then
         
         sSql = "CREATE TABLE [dbo].[CertUsrSec](" & vbCrLf
         sSql = sSql & "   [USRNAME] [nchar](24) NOT NULL," & vbCrLf
         sSql = sSql & "   [USRPASS] [varchar](24) NOT NULL," & vbCrLf
         sSql = sSql & "   [CERTRPTID] [int] NOT NULL," & vbCrLf
         sSql = sSql & "   [USRSIG] [image] NULL," & vbCrLf
         sSql = sSql & "   [USRFULLNAME] [varchar](48) NULL," & vbCrLf
         sSql = sSql & "   [USRNICKNAME] [varchar](12) NULL," & vbCrLf
         sSql = sSql & "   [USRINITIAL] [varchar](12) NULL," & vbCrLf
         sSql = sSql & "   [ACTIVE] [smallint] NULL," & vbCrLf
         sSql = sSql & "   [SECROLE] [varchar](24) NULL" & vbCrLf
         sSql = sSql & ") ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]"
         
         ExecuteScript False, sSql
      End If

      If Not TableExists("[CertReports]") Then
         
         sSql = "CREATE TABLE [dbo].[CertReports](" & vbCrLf
         sSql = sSql & "   [REPORTID] [int] IDENTITY(1,1) NOT NULL," & vbCrLf
         sSql = sSql & "   [REPORTNAME] [varchar](48) NOT NULL," & vbCrLf
         sSql = sSql & "   [REPORTCODE] [varchar](12) NOT NULL" & vbCrLf
         sSql = sSql & ") ON [PRIMARY]"
         
         ExecuteScript False, sSql
      End If

      If Not TableExists("[HeatTreatHdTable]") Then
         
         sSql = "CREATE TABLE [dbo].[HeatTreatHdTable](" & vbCrLf
         sSql = sSql & "   [FURNACENUM] [varchar](24) NULL," & vbCrLf
         sSql = sSql & "   [SOLUTION_HRS] [decimal](18, 2) NULL," & vbCrLf
         sSql = sSql & "   [SOLUTION_TEMP] [decimal](18, 2) NULL," & vbCrLf
         sSql = sSql & "   [RISE_TIME] [varchar](8) NULL," & vbCrLf
         sSql = sSql & "   [SOLUTION_TIME] [varchar](8) NULL," & vbCrLf
         sSql = sSql & "   [DROP_TIME] [varchar](8) NULL," & vbCrLf
         sSql = sSql & "   [HOURS_RUN] [decimal](18, 2) NULL," & vbCrLf
         sSql = sSql & "   [DROPDATE] [datetime] NULL," & vbCrLf
         sSql = sSql & "   [QUENCH_DELAY] [decimal](18, 2) NULL," & vbCrLf
         sSql = sSql & "   [QUENCH_DWELL] [decimal](18, 2) NULL," & vbCrLf
         sSql = sSql & "   [QUENCH_BEFTEMP] [decimal](18, 2) NULL," & vbCrLf
         sSql = sSql & "   [QUENCH_AFTTEMP] [decimal](18, 2) NULL," & vbCrLf
         sSql = sSql & "   [QUENCY_BY] [varchar](24) NULL," & vbCrLf
         sSql = sSql & "   [AGE_OVEN] [varchar](16) NULL," & vbCrLf
         sSql = sSql & "   [AGE_HRS] [decimal](18, 2) NULL," & vbCrLf
         sSql = sSql & "   [AGE_TEMP] [decimal](18, 2) NULL," & vbCrLf
         sSql = sSql & "   [AGE_DELAYHRS] [decimal](18, 2) NULL," & vbCrLf
         sSql = sSql & "   [AGE_PULLDATE] [datetime] NULL," & vbCrLf
         sSql = sSql & "   [AGE_STARTSOAK] [varchar](24) NULL," & vbCrLf
         sSql = sSql & "   [AGE_ENDTIME] [varchar](8) NULL," & vbCrLf
         sSql = sSql & "   [AGE_HRSRUN] [decimal](18, 2) NULL," & vbCrLf
         sSql = sSql & "   [AGE_RECBY] [varchar](24) NULL," & vbCrLf
         sSql = sSql & "   [LOADINFO_DATE] [datetime] NULL," & vbCrLf
         sSql = sSql & "   [LOADINFO_NUM] [varchar](24) NULL," & vbCrLf
         sSql = sSql & "   [ALLOY] [varchar](24) NULL," & vbCrLf
         sSql = sSql & "   [LOADINFO_RECBY] [varchar](24) NULL," & vbCrLf
         sSql = sSql & "   [ACCEPTEDBY] [varchar](24) NULL," & vbCrLf
         sSql = sSql & "   [HEATTREATID] [int] NULL" & vbCrLf
         sSql = sSql & ") ON [PRIMARY]"

         ExecuteScript False, sSql
      End If

      If Not TableExists("[HeatTrtDtlTable]") Then
         
         sSql = "CREATE TABLE [dbo].[HeatTrtDtlTable](" & vbCrLf
         sSql = sSql & "   [HEATTDETAILNUM] [int] NOT NULL," & vbCrLf
         sSql = sSql & "   [HT_SPECIFICATION] [varchar](24) NULL," & vbCrLf
         sSql = sSql & "   [TESTBARS] [smallint] NULL," & vbCrLf
         sSql = sSql & "   [BRINELLS] [varchar](24) NULL," & vbCrLf
         sSql = sSql & "   [BRINELLS_BY] [varchar](24) NULL," & vbCrLf
         sSql = sSql & "   [CUST] [varchar](24) NULL," & vbCrLf
         sSql = sSql & "   [AGE_OVEN] [varchar](24) NULL," & vbCrLf
         sSql = sSql & "   [PARTNUMBER] [varchar](15) NULL," & vbCrLf
         sSql = sSql & "   [RUN] [int] NULL," & vbCrLf
         sSql = sSql & "   [QTY] [decimal](18, 2) NULL," & vbCrLf
         sSql = sSql & "   [JIG] [smallint] NULL," & vbCrLf
         sSql = sSql & "   [JIG_ACCQTY] [decimal](18, 2) NULL," & vbCrLf
         sSql = sSql & "   [JIG_REJQTY] [decimal](18, 2) NULL," & vbCrLf
         sSql = sSql & "   [JIG_BY] [varchar](24) NULL," & vbCrLf
         sSql = sSql & "   [JIG_DATE] [datetime] NULL," & vbCrLf
         sSql = sSql & "   [HEATNUM] [varchar](12) NULL," & vbCrLf
         sSql = sSql & "   [HEATDATE] [varchar](12) NULL," & vbCrLf
         sSql = sSql & "   [HEATPOTNUM] [varchar](1) NULL," & vbCrLf
         sSql = sSql & "   [QTYBY] [varchar](12) NULL," & vbCrLf
         sSql = sSql & "   [HEATNUM1] [varchar](12) NULL," & vbCrLf
         sSql = sSql & "   [HEATDATE1] [varchar](12) NULL," & vbCrLf
         sSql = sSql & "   [HEATPOTNUM1] [varchar](1) NULL," & vbCrLf
         sSql = sSql & "   [HEATTREATID] [int] NULL," & vbCrLf
         sSql = sSql & "   [HEATNUM2] [varchar](12) NULL," & vbCrLf
         sSql = sSql & "   [HEATDATE2] [varchar](12) NULL," & vbCrLf
         sSql = sSql & "   [HEATNUM3] [varchar](12) NULL," & vbCrLf
         sSql = sSql & "   [HEATDATE3] [varchar](12) NULL" & vbCrLf
         sSql = sSql & ") ON [PRIMARY]"
         
         ExecuteScript False, sSql
      End If

      If Not TableExists("[MeltersLogTable]") Then
         
         sSql = "CREATE TABLE [dbo].[MeltersLogTable](" & vbCrLf
         sSql = sSql & "   [MELTERLOGID] [int] NOT NULL," & vbCrLf
         sSql = sSql & "   [MELTERDATE] [datetime] NOT NULL," & vbCrLf
         sSql = sSql & "   [HEATNUM] [varchar](12) NOT NULL," & vbCrLf
         sSql = sSql & "   [MOPARTNUM] [varchar](15) NULL," & vbCrLf
         sSql = sSql & "   [MORUN] [int] NULL," & vbCrLf
         sSql = sSql & "   [GOODCASTING] [int] NULL," & vbCrLf
         sSql = sSql & "   [TESTBARS] [varchar](12) NULL," & vbCrLf
         sSql = sSql & "   [MELTERBY] [varchar](12) NULL," & vbCrLf
         sSql = sSql & "   [NOTES] [varchar](1024) NULL," & vbCrLf
         sSql = sSql & "   [MOPOSITION] [varchar](1) NULL" & vbCrLf
         sSql = sSql & ") ON [PRIMARY]"

         ExecuteScript False, sSql
         
      End If

      If Not TableExists("[MatCertRunsTable]") Then
         
         sSql = "CREATE TABLE [dbo].[MatCertRunsTable](" & vbCrLf
         sSql = sSql & "   [MATCERTID] [int] NOT NULL," & vbCrLf
         sSql = sSql & "   [MOPARTNUM] [varchar](30) NOT NULL," & vbCrLf
         sSql = sSql & "   [MORUN] [int] NOT NULL," & vbCrLf
         sSql = sSql & "   [POTLETTER] [varchar](1) NULL" & vbCrLf
         sSql = sSql & ") ON [PRIMARY]"

         ExecuteScript False, sSql
      End If

      If Not TableExists("[TnRunsTable]") Then
         
         sSql = "CREATE TABLE [dbo].[TnRunsTable](" & vbCrLf
         sSql = sSql & "   [TENSILEFORMID] [int] NOT NULL," & vbCrLf
         sSql = sSql & "   [MOPARTNUM] [varchar](30) NOT NULL," & vbCrLf
         sSql = sSql & "   [MORUN] [int] NOT NULL" & vbCrLf
         sSql = sSql & ") ON [PRIMARY]"

         ExecuteScript False, sSql
      End If
      
      If StoreProcedureExists("RptPSMOs") Then
         sSql = "DROP PROCEDURE RptPSMOs"
         ExecuteScript False, sSql
      End If
      
      sSql = "CREATE PROCEDURE [dbo].[RptPSMOs]" & vbCrLf
      sSql = sSql & "   @InvNo as integer, @PSNum as varchar(30), @PSItem as integer" & vbCrLf
      sSql = sSql & "AS " & vbCrLf
      sSql = sSql & "BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   declare @SumTotMat decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @SumTotLabor decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @SumTotExp decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @SumTotOH decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @level as integer" & vbCrLf
      sSql = sSql & "   declare @Part as varchar(30)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   declare @LotNum as varchar(15)" & vbCrLf
      sSql = sSql & "   declare @MOPart as varchar(30)" & vbCrLf
      sSql = sSql & "   declare @MORun as int" & vbCrLf
      sSql = sSql & "   declare @LotOrgQty as decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @MOPartRunKey as Varchar(30)" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   DECLARE curAllMOsRun CURSOR  FOR" & vbCrLf
      sSql = sSql & "    SELECT distinct LOINUMBER, LOTMOPARTREF, LOTMORUNNO,LOTORIGINALQTY  FROM " & vbCrLf
      sSql = sSql & "       LohdTable, LoitTable, PshdTable" & vbCrLf
      sSql = sSql & "    WHERE LohdTable.LOTNUMBER = LoitTable.LOINUMBER AND" & vbCrLf
      sSql = sSql & "       LoitTable.LOIPSNUMBER = @PSNum AND" & vbCrLf
      sSql = sSql & "       LoitTable.LOIPSITEM = @PSItem AND" & vbCrLf
      sSql = sSql & "       (LoitTable.LOITYPE = 33 OR" & vbCrLf
      sSql = sSql & "       LoitTable.LOITYPE = 25) AND" & vbCrLf
      sSql = sSql & "       PshdTable.PSCANCELED <> 1" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   OPEN curAllMOsRun" & vbCrLf
      sSql = sSql & "   FETCH NEXT FROM curAllMOsRun INTO @LotNum, @MOPart, @MORun,@LotOrgQty" & vbCrLf
      sSql = sSql & "   WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "     IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "     BEGIN" & vbCrLf
      sSql = sSql & "       Exec RptMOCostDetail @MOPart, @MORun, @LotOrgQty" & vbCrLf
      sSql = sSql & "       SET @MOPartRunKey = RTRIM(@MOPart) + '_' + Convert(varchar(10), @MORun)" & vbCrLf
      sSql = sSql & "                      " & vbCrLf
      sSql = sSql & "       UPDATE EsMOPartsCostDetail SET INVNO = @InvNo, ITPSNUMBER = @PSNum, ITPSITEM = @PSItem" & vbCrLf
      sSql = sSql & "          WHERE LOTMOPARTRUNKEY = @MOPartRunKey" & vbCrLf
      sSql = sSql & "       " & vbCrLf
      sSql = sSql & "    End" & vbCrLf
      sSql = sSql & "    FETCH NEXT FROM curAllMOsRun INTO @LotNum, @MOPart, @MORun,@LotOrgQty" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "   Close curAllMOsRun" & vbCrLf
      sSql = sSql & "   DEALLOCATE curAllMOsRun" & vbCrLf
      sSql = sSql & "  " & vbCrLf
      sSql = sSql & "   --SELECT LOTMOPARTRUNKEY, INVNO, ITPSNUMBER, ITPSITEM, INMOPART,INMORUN,INPART,PARTSUM,SORTKEYLEVEL,LOTNUMBER,LOTUSERLOTID," & vbCrLf
      sSql = sSql & "   --   LOTTOTMATL,SUMTOTMAL, LOTTOTLABOR,SUMTOTLABOR, LOTTOTEXP, SUMTOTEXP, LOTTOTOH,SUMTOTOH,BMTOTOH," & vbCrLf
      sSql = sSql & "   --     LOTDATECOSTED, BMQTYREQD, LOTORGQTY, SORTKEYLEVEL,SortKey,SortKeyRev,HASCHILD      " & vbCrLf
      sSql = sSql & "   --FROM EsMOPartsCostDetail --WHERE LOTMOPARTRUNKEY IS NOT NULL --SORTKEYLEVEL = 1" & vbCrLf
      sSql = sSql & "   --order by LOTMOPARTRUNKEY,SortKey--SortKeyRev      " & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   --DROP table tempMOPartsDetail   " & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "END"

      ExecuteScript False, sSql
      
      
      If StoreProcedureExists("RptMOCostDetail") Then
         sSql = "DROP PROCEDURE RptMOCostDetail"
         ExecuteScript False, sSql
      End If
      
      sSql = "CREATE PROCEDURE [dbo].[RptMOCostDetail]" & vbCrLf
      sSql = sSql & "      @MOPart as varchar(30),@MORun as int, @MOQty as decimal(15,4)" & vbCrLf
      sSql = sSql & "AS " & vbCrLf
      sSql = sSql & "BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   declare @SumTotMat decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @SumTotLabor decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @SumTotExp decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @SumTotOH decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @level as integer" & vbCrLf
      sSql = sSql & "   declare @Part as varchar(30)" & vbCrLf
      sSql = sSql & "   declare @PrevParent  as varchar(30)" & vbCrLf
      sSql = sSql & "   declare @RowCount as integer" & vbCrLf
      sSql = sSql & "   declare @ChildPart as varchar(30)" & vbCrLf
      sSql = sSql & "   declare @ParentPart as varchar(30)" & vbCrLf
      sSql = sSql & "   declare @MOPart1 as varchar(30)" & vbCrLf
      sSql = sSql & "   declare @MoRun1 as varchar(20)" & vbCrLf
      sSql = sSql & "   declare @Part1 as varchar(30)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   declare @ChildKey as varchar(1024)" & vbCrLf
      sSql = sSql & "   declare @GLSortKey as varchar(1024)" & vbCrLf
      sSql = sSql & "   declare @SortKey as varchar(1024)" & vbCrLf
      sSql = sSql & "   declare @ParentLotNum as varchar(15)" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   declare @Maxlevel as int" & vbCrLf
      sSql = sSql & "   declare @LotRunNo as int" & vbCrLf
      sSql = sSql & "   declare @LotOrgQty as decimal(15,4)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   declare @LotUSpMat decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @LotUSpLabor decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @LotUSpExp decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @LotUSpOH decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @LotMatl decimal(15,4)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   declare @MOLotNum as varchar(15)" & vbCrLf
      sSql = sSql & "   declare @SplitLot as varchar(15)" & vbCrLf
      sSql = sSql & "   declare @cnt  as int" & vbCrLf
      sSql = sSql & "   declare @sumQty decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @MOPartRunKey as Varchar(30)" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   --DROP TABLE #tempMOPartsDetail " & vbCrLf
      sSql = sSql & "-- DELETE FROM #tempMOPartsDetail " & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   SET @MOPartRunKey = RTRIM(@MOPart) + '_' + Convert(varchar(10), @MORun)" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   CREATE TABLE #tempMOPartsDetail " & vbCrLf
      sSql = sSql & "   ( " & vbCrLf
      sSql = sSql & "      LOTMOPARTRUNKEY varchar(50) NULL," & vbCrLf
      sSql = sSql & "      INMOPART Varchar(30) NULL, " & vbCrLf
      sSql = sSql & "      INMORUN int NULL , " & vbCrLf
      sSql = sSql & "      INPART varchar(30) NULL , " & vbCrLf
      sSql = sSql & "      LOTNUMBER varchar(15) NULL, " & vbCrLf
      sSql = sSql & "      LOTUSERLOTID varchar(40) NULL," & vbCrLf
      sSql = sSql & "      INTOTMATL decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      INTOTLABOR decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      INTOTEXP decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      INTOTOH decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      LOTTOTMATL decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      LOTTOTLABOR decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      LOTTOTEXP decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      LOTTOTOH decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      SUMTOTMAL decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      SUMTOTLABOR decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      SUMTOTEXP decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      SUMTOTOH decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      LOTDATECOSTED smalldatetime NULL," & vbCrLf
      sSql = sSql & "      SortKey varchar(512) NULL," & vbCrLf
      sSql = sSql & "      HASCHILD int NULL," & vbCrLf
      sSql = sSql & "      SORTKEYLEVEL tinyint NULL," & vbCrLf
      sSql = sSql & "      SortKeyRev varchar(512)," & vbCrLf
      sSql = sSql & "      PARTSUM varchar(40)," & vbCrLf
      sSql = sSql & "      BMQTYREQD decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      LOTORGQTY decimal(12,4) NULL," & vbCrLf
      sSql = sSql & "      BMTOTOH decimal(12,4) NULL," & vbCrLf
      sSql = sSql & "      LOTSPLITFROMSYS varchar(15)," & vbCrLf
      sSql = sSql & "      INVNO int NULL," & vbCrLf
      sSql = sSql & "      ITPSNUMBER varchar(8) NULL," & vbCrLf
      sSql = sSql & "      ITPSITEM smallint NULL," & vbCrLf
      sSql = sSql & "      PICKQTY decimal(12,4) NULL" & vbCrLf
      sSql = sSql & "   ) " & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "      with cte" & vbCrLf
      sSql = sSql & "      as" & vbCrLf
      sSql = sSql & "      (select BMASSYPART, BMPARTREF,  BMQTYREQD,0 as level, cast('1' + char(36)+ BMPARTREF as varchar(max)) as SortKey" & vbCrLf
      sSql = sSql & "      from BmplTable" & vbCrLf
      sSql = sSql & "      where BMASSYPART = @MOPart" & vbCrLf
      sSql = sSql & "      union all" & vbCrLf
      sSql = sSql & "      select a.BMASSYPART, a.BMPARTREF, a.BMQTYREQD, level + 1," & vbCrLf
      sSql = sSql & "         cast(COALESCE(SortKey,'') + char(36) + COALESCE(a.BMPARTREF,'') as varchar(max))as SortKey" & vbCrLf
      sSql = sSql & "      from cte" & vbCrLf
      sSql = sSql & "         inner join BmplTable a" & vbCrLf
      sSql = sSql & "            on cte.BMPARTREF = a.BMASSYPART " & vbCrLf
      sSql = sSql & "      )" & vbCrLf
      sSql = sSql & "      INSERT INTO #tempMOPartsDetail(INMOPART,INPART,BMQTYREQD,SORTKEYLEVEL,SortKey)" & vbCrLf
      sSql = sSql & "      select BMASSYPART, BMPARTREF,BMQTYREQD,level,SortKey " & vbCrLf
      sSql = sSql & "         from cte order by SortKey " & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   END" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   SET @cnt = 0" & vbCrLf
      sSql = sSql & "print 'Update Start:' + cast(getdate() as char(25))" & vbCrLf
      sSql = sSql & "print 'Count :' + Convert(varchar(10), @cnt)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   UPDATE #tempMOPartsDetail SET INMORUN = @MORun, LOTNUMBER = b.INLOTNUMBER, " & vbCrLf
      sSql = sSql & "            LOTSPLITFROMSYS = c.LOTSPLITFROMSYS" & vbCrLf
      sSql = sSql & "      FROM dbo.LohdTable AS c INNER JOIN" & vbCrLf
      sSql = sSql & "              dbo.InvaTable AS b ON c.LOTNUMBER = b.INLOTNUMBER AND c.LOTPARTREF = b.INPART LEFT OUTER JOIN" & vbCrLf
      sSql = sSql & "              dbo.#tempMOPartsDetail AS d ON b.INMOPART = d.INMOPART AND b.INPART = d.INPART" & vbCrLf
      sSql = sSql & "      WHERE     (b.INMOPART = @MOPart) AND (b.INMORUN = @MORun) AND (b.INTYPE = 10) AND (d.SORTKEYLEVEL = 0)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   UPDATE #tempMOPartsDetail SET PICKQTY = sumqty * -1" & vbCrLf
      sSql = sSql & "      FROM #tempMOPartsDetail," & vbCrLf
      sSql = sSql & "   (SELECT SUM(b.INAQTY) sumqty, d.INMOPART mopart, d.INMORUN morun, d.LOTNUMBER lotnum, d.INPART subpart" & vbCrLf
      sSql = sSql & "   FROM dbo.LohdTable AS c INNER JOIN" & vbCrLf
      sSql = sSql & "           dbo.InvaTable AS b ON c.LOTNUMBER = b.INLOTNUMBER AND c.LOTPARTREF = b.INPART LEFT OUTER JOIN" & vbCrLf
      sSql = sSql & "           dbo.#tempMOPartsDetail AS d ON b.INMOPART = d.INMOPART AND b.INPART = d.INPART" & vbCrLf
      sSql = sSql & "   WHERE     b.INMOPART = @MOPart AND b.INMORUN  = @MORun AND (b.INTYPE = 10) AND (d.SORTKEYLEVEL = 0)" & vbCrLf
      sSql = sSql & "   GROUP BY d.INMOPART, d.INMORUN, d.LOTNUMBER, d.INPART" & vbCrLf
      sSql = sSql & "   ) as f" & vbCrLf
      sSql = sSql & "   WHERE INMOPART = f.mopart AND INMORUN = f.morun " & vbCrLf
      sSql = sSql & "    AND LOTNUMBER = lotnum AND INPART = subpart" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   --// Update the " & vbCrLf
      sSql = sSql & "   --// update the top level" & vbCrLf
      sSql = sSql & "   UPDATE #tempMOPartsDetail SET INMORUN = @MORun, LOTNUMBER = b.INLOTNUMBER, " & vbCrLf
      sSql = sSql & "            LOTUSERLOTID = c.LOTUSERLOTID," & vbCrLf
      sSql = sSql & "            INTOTMATL = b.INTOTMATL, INTOTLABOR = b.INTOTLABOR, " & vbCrLf
      sSql = sSql & "            INTOTEXP = b.INTOTEXP, INTOTOH = b.INTOTOH, " & vbCrLf
      sSql = sSql & "            LOTTOTMATL = (c.LOTTOTMATL * PICKQTY) / c.LOTORIGINALQTY, " & vbCrLf
      sSql = sSql & "            LOTTOTLABOR = (c.LOTTOTLABOR * PICKQTY) / c.LOTORIGINALQTY, " & vbCrLf
      sSql = sSql & "            LOTTOTEXP = (c.LOTTOTEXP * PICKQTY) / c.LOTORIGINALQTY, " & vbCrLf
      sSql = sSql & "            LOTTOTOH = (c.LOTTOTOH * PICKQTY) / c.LOTORIGINALQTY," & vbCrLf
      sSql = sSql & "            LOTDATECOSTED = c.LOTDATECOSTED, LOTORGQTY = c.LOTORIGINALQTY," & vbCrLf
      sSql = sSql & "            BMTOTOH = (c.LOTTOTOH * PICKQTY) / c.LOTORIGINALQTY," & vbCrLf
      sSql = sSql & "            LOTSPLITFROMSYS = c.LOTSPLITFROMSYS" & vbCrLf
      sSql = sSql & "      FROM dbo.LohdTable AS c INNER JOIN" & vbCrLf
      sSql = sSql & "              dbo.InvaTable AS b ON c.LOTNUMBER = b.INLOTNUMBER AND c.LOTPARTREF = b.INPART LEFT OUTER JOIN" & vbCrLf
      sSql = sSql & "              dbo.#tempMOPartsDetail AS d ON b.INMOPART = d.INMOPART AND b.INPART = d.INPART" & vbCrLf
      sSql = sSql & "      WHERE     (b.INMOPART = @MOPart) AND (b.INMORUN = @MORun) AND (b.INTYPE = 10) AND (d.SORTKEYLEVEL = 0)" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "print 'Update 2:' + cast(getdate() as char(25))" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   --FROM #tempMOPartsDetail d, InvaTable b, LohdTable c" & vbCrLf
      sSql = sSql & "   --WHERE d.INMOPART = b.INMOPART AND d.INPART = b.INPART " & vbCrLf
      sSql = sSql & "   -- AND b.INLOTNUMBER = c.LOTnumber" & vbCrLf
      sSql = sSql & "   -- and c.lotpartref = b.INPART" & vbCrLf
      sSql = sSql & "   -- and b.INMOPART = @MOPart AND b.INMORUN  = @MORun" & vbCrLf
      sSql = sSql & "   -- AND b.INTYPE = 10 AND SORTKEYLEVEL = 0" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   --// set the totals for " & vbCrLf
      sSql = sSql & "   SELECT @Maxlevel =  MAX(SORTKEYLEVEL) FROM #tempMOPartsDetail" & vbCrLf
      sSql = sSql & "   SET @level  = 1" & vbCrLf
      sSql = sSql & "   WHILE (@level <= @Maxlevel )" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "      DECLARE curMORun CURSOR  FOR" & vbCrLf
      sSql = sSql & "      SELECT DISTINCT INMOPART,INPART " & vbCrLf
      sSql = sSql & "         FROM #tempMOPartsDetail WHERE SORTKEYLEVEL = @level" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "      OPEN curMORun" & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM curMORun INTO @MOPart, @Part" & vbCrLf
      sSql = sSql & "      WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "      BEGIN" & vbCrLf
      sSql = sSql & "         IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "         BEGIN" & vbCrLf
      sSql = sSql & "         " & vbCrLf
      sSql = sSql & "         SELECT @ParentLotNum = LOTNUMBER FROM #tempMOPartsDetail WHERE" & vbCrLf
      sSql = sSql & "               INPART = @MOPart AND SORTKEYLEVEL = @level - 1" & vbCrLf
      sSql = sSql & "         " & vbCrLf
      sSql = sSql & "         SELECT @LotRunNo = LOTMORUNNO, @LotOrgQty = LOTORIGINALQTY " & vbCrLf
      sSql = sSql & "                  FROM lohdTable where LOTNUMBER = @ParentLotNum" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "         UPDATE #tempMOPartsDetail SET INMORUN = @LotRunNo, LOTNUMBER = b.INLOTNUMBER, " & vbCrLf
      sSql = sSql & "                  LOTSPLITFROMSYS = c.LOTSPLITFROMSYS" & vbCrLf
      sSql = sSql & "         FROM #tempMOPartsDetail d, InvaTable b, LohdTable c" & vbCrLf
      sSql = sSql & "         WHERE d.INMOPART = b.INMOPART AND d.INPART = b.INPART " & vbCrLf
      sSql = sSql & "            AND b.INLOTNUMBER = c.LOTnumber" & vbCrLf
      sSql = sSql & "            and c.lotpartref = b.INPART" & vbCrLf
      sSql = sSql & "            and b.INMOPART = @MOPart AND b.INMORUN  = @LotRunNo" & vbCrLf
      sSql = sSql & "            AND b.INTYPE = 10 AND SORTKEYLEVEL = @level" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "         UPDATE #tempMOPartsDetail SET PICKQTY = sumqty * -1" & vbCrLf
      sSql = sSql & "            FROM " & vbCrLf
      sSql = sSql & "         (SELECT SUM(b.INAQTY) sumqty, d.INMOPART mopart, d.INMORUN morun, d.LOTNUMBER lotnum, d.INPART subpart" & vbCrLf
      sSql = sSql & "         FROM dbo.LohdTable AS c INNER JOIN" & vbCrLf
      sSql = sSql & "                 dbo.InvaTable AS b ON c.LOTNUMBER = b.INLOTNUMBER AND c.LOTPARTREF = b.INPART LEFT OUTER JOIN" & vbCrLf
      sSql = sSql & "                 dbo.#tempMOPartsDetail AS d ON b.INMOPART = d.INMOPART AND b.INPART = d.INPART" & vbCrLf
      sSql = sSql & "         WHERE     b.INMOPART = @MOPart AND b.INMORUN  = @LotRunNo AND (b.INTYPE = 10) AND (d.SORTKEYLEVEL = @level)" & vbCrLf
      sSql = sSql & "         GROUP BY d.INMOPART, d.INMORUN, d.LOTNUMBER, d.INPART" & vbCrLf
      sSql = sSql & "         ) as f" & vbCrLf
      sSql = sSql & "         WHERE INMOPART = mopart AND INMORUN = morun " & vbCrLf
      sSql = sSql & "          AND LOTNUMBER = lotnum AND INPART = subpart" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "print 'MO Part :'+ @MOPart" & vbCrLf
      sSql = sSql & "print 'MO Run :'+ Convert(varchar(10), @LotRunNo)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "         --// update the top level" & vbCrLf
      sSql = sSql & "         UPDATE #tempMOPartsDetail SET INMORUN = @LotRunNo, LOTNUMBER = b.INLOTNUMBER, " & vbCrLf
      sSql = sSql & "                  LOTUSERLOTID = c.LOTUSERLOTID," & vbCrLf
      sSql = sSql & "                  INTOTMATL = b.INTOTMATL, INTOTLABOR = b.INTOTLABOR, " & vbCrLf
      sSql = sSql & "                  INTOTEXP = b.INTOTEXP, INTOTOH = b.INTOTOH, " & vbCrLf
      sSql = sSql & "                  LOTTOTMATL = (c.LOTTOTMATL * PICKQTY) / c.LOTORIGINALQTY, " & vbCrLf
      sSql = sSql & "                  LOTTOTLABOR = (c.LOTTOTLABOR * PICKQTY) / c.LOTORIGINALQTY, " & vbCrLf
      sSql = sSql & "                  LOTTOTEXP = (c.LOTTOTEXP * PICKQTY) / c.LOTORIGINALQTY, " & vbCrLf
      sSql = sSql & "                  LOTTOTOH = (c.LOTTOTOH * PICKQTY) / c.LOTORIGINALQTY," & vbCrLf
      sSql = sSql & "                  LOTDATECOSTED = c.LOTDATECOSTED, LOTORGQTY = @LotOrgQty," & vbCrLf
      sSql = sSql & "                  BMTOTOH = (c.LOTTOTOH * PICKQTY) / @LotOrgQty," & vbCrLf
      sSql = sSql & "                  LOTSPLITFROMSYS = c.LOTSPLITFROMSYS" & vbCrLf
      sSql = sSql & "         FROM #tempMOPartsDetail d, InvaTable b, LohdTable c" & vbCrLf
      sSql = sSql & "         WHERE d.INMOPART = b.INMOPART AND d.INPART = b.INPART " & vbCrLf
      sSql = sSql & "            AND b.INLOTNUMBER = c.LOTnumber" & vbCrLf
      sSql = sSql & "            and c.lotpartref = b.INPART" & vbCrLf
      sSql = sSql & "            and b.INMOPART = @MOPart AND b.INMORUN  = @LotRunNo" & vbCrLf
      sSql = sSql & "            AND b.INTYPE = 10 AND SORTKEYLEVEL = @level" & vbCrLf
      sSql = sSql & "            AND c.LOTORIGINALQTY <> 0" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "      End" & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM curMORun INTO @MOPart, @Part" & vbCrLf
      sSql = sSql & "      End" & vbCrLf
      sSql = sSql & "      Close curMORun" & vbCrLf
      sSql = sSql & "      DEALLOCATE curMORun" & vbCrLf
      sSql = sSql & "      SET @level = @level + 1" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "print 'Update 2:'+ cast(getdate() as char(25))" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "  DECLARE curMOSplit CURSOR  FOR" & vbCrLf
      sSql = sSql & "   SELECT DISTINCT LOTNUMBER, LOTSPLITFROMSYS, LOTTOTMATL--, LOTTOTLABOR, LOTTOTEXP, LOTTOTOH" & vbCrLf
      sSql = sSql & "     FROM #tempMOPartsDetail WHERE LOTSPLITFROMSYS <> ''" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "  OPEN curMOSplit" & vbCrLf
      sSql = sSql & "  FETCH NEXT FROM curMOSplit INTO @MOLotNum, @SplitLot, @LotMatl" & vbCrLf
      sSql = sSql & "  WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "  BEGIN" & vbCrLf
      sSql = sSql & "     IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "     BEGIN" & vbCrLf
      sSql = sSql & "      " & vbCrLf
      sSql = sSql & "      print 'LotSplit LotNum:' + @SplitLot" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "      IF @LotMatl = 0" & vbCrLf
      sSql = sSql & "      BEGIN" & vbCrLf
      sSql = sSql & "         SELECT @LotUSpMat = (LOTTOTMATL / LOTORIGINALQTY), " & vbCrLf
      sSql = sSql & "               @LotUSpLabor = (LOTTOTLABOR / LOTORIGINALQTY)," & vbCrLf
      sSql = sSql & "               @LotUSpExp = (LOTTOTEXP / LOTORIGINALQTY), " & vbCrLf
      sSql = sSql & "               @LotUSpOH = (LOTTOTOH / LOTORIGINALQTY)" & vbCrLf
      sSql = sSql & "         FROM Lohdtable WHERE LOTNUMBER = @SplitLot" & vbCrLf
      sSql = sSql & "         AND LOTORIGINALQTY <> 0" & vbCrLf
      sSql = sSql & "         " & vbCrLf
      sSql = sSql & "         UPDATE #tempMOPartsDetail SET LOTTOTMATL = (@LotUSpMat * PICKQTY), " & vbCrLf
      sSql = sSql & "                  LOTTOTLABOR = (@LotUSpLabor * PICKQTY), " & vbCrLf
      sSql = sSql & "                  LOTTOTEXP = (@LotUSpExp * PICKQTY), " & vbCrLf
      sSql = sSql & "                  LOTTOTOH = (@LotUSpOH * PICKQTY)" & vbCrLf
      sSql = sSql & "         WHERE LOTNUMBER = @MOLotNum AND LOTSPLITFROMSYS = @SplitLot" & vbCrLf
      sSql = sSql & "               " & vbCrLf
      sSql = sSql & "      END" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "   FETCH NEXT FROM curMOSplit INTO @MOLotNum, @SplitLot, @LotMatl" & vbCrLf
      sSql = sSql & "  End" & vbCrLf
      sSql = sSql & "  Close curMOSplit" & vbCrLf
      sSql = sSql & "  DEALLOCATE curMOSplit" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   SELECT @level =  MAX(SORTKEYLEVEL) FROM #tempMOPartsDetail" & vbCrLf
      sSql = sSql & "   WHILE (@level >= 0 )" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "      DECLARE curMODet CURSOR  FOR" & vbCrLf
      sSql = sSql & "      --SELECT INPART, LOTTOTMATL, LOTTOTLABOR, LOTTOTEXP , LOTTOTOH FROM #tempMOPartsDetail" & vbCrLf
      sSql = sSql & "      -- WHERE INPART = '775345149'" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "      SELECT INMOPART, " & vbCrLf
      sSql = sSql & "      SUM(IsNull(LOTTOTMATL, 0)), SUM(ISNULL(LOTTOTLABOR,0)) ," & vbCrLf
      sSql = sSql & "        Sum (IsNull(LOTTOTEXP, 0)) , SUM(IsNull(BMTOTOH, 0))" & vbCrLf
      sSql = sSql & "      From" & vbCrLf
      sSql = sSql & "         (SELECT DISTINCT INMOPART,INMORUN,INPART,LOTTOTMATL,LOTTOTLABOR," & vbCrLf
      sSql = sSql & "         LOTTOTEXP,LOTTOTOH,SUMTOTMAL,SUMTOTLABOR, SUMTOTEXP, SUMTOTOH,BMTOTOH" & vbCrLf
      sSql = sSql & "         FROM #tempMOPartsDetail WHERE SORTKEYLEVEL = @level) as foo" & vbCrLf
      sSql = sSql & "      group by INMOPART" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "      OPEN curMODet" & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM curMODet INTO @MOPart, @SumTotMat, @SumTotLabor,@SumTotExp,@SumTotOH" & vbCrLf
      sSql = sSql & "      WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "      BEGIN" & vbCrLf
      sSql = sSql & "         IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "         BEGIN" & vbCrLf
      sSql = sSql & "            " & vbCrLf
      sSql = sSql & "            print 'PartNum : ' + @MOPart" & vbCrLf
      sSql = sSql & "            print 'SumTotoh : ' + Convert(varchar(24), @SumTotOH)" & vbCrLf
      sSql = sSql & "            " & vbCrLf
      sSql = sSql & "            UPDATE #tempMOPartsDetail SET SUMTOTMAL = LOTTOTMATL + @SumTotMat, " & vbCrLf
      sSql = sSql & "            SUMTOTLABOR = LOTTOTLABOR + @SumTotLabor," & vbCrLf
      sSql = sSql & "               SUMTOTEXP = LOTTOTEXP + @SumTotExp, SUMTOTOH = (BMTOTOH + @SumTotOH) * @MOQty , " & vbCrLf
      sSql = sSql & "               HASCHILD = 1,PARTSUM = 'TOTAL ' + LTRIM(INPART)" & vbCrLf
      sSql = sSql & "            " & vbCrLf
      sSql = sSql & "            WHERE INPART = @MOPart AND SORTKEYLEVEL = @level - 1" & vbCrLf
      sSql = sSql & "            " & vbCrLf
      sSql = sSql & "      End" & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM curMODet INTO @MOPart, @SumTotMat, @SumTotLabor,@SumTotExp,@SumTotOH" & vbCrLf
      sSql = sSql & "      End" & vbCrLf
      sSql = sSql & "      Close curMODet" & vbCrLf
      sSql = sSql & "      DEALLOCATE curMODet" & vbCrLf
      sSql = sSql & "      SET @level = @level - 1" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   --// update the Lower level cost detail" & vbCrLf
      sSql = sSql & "    UPDATE #tempMOPartsDetail SET SUMTOTMAL = LOTTOTMATL, SUMTOTLABOR = LOTTOTLABOR," & vbCrLf
      sSql = sSql & "       SUMTOTEXP = LOTTOTEXP, SUMTOTOH = BMTOTOH WHERE HASCHILD IS NULL" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   SET @SumTotMat  = 0" & vbCrLf
      sSql = sSql & "   SET @SumTotLabor  = 0" & vbCrLf
      sSql = sSql & "   SET @SumTotExp  = 0" & vbCrLf
      sSql = sSql & "   SET @SumTotOH  = 0" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   --// Udpate the Root total" & vbCrLf
      sSql = sSql & "    SELECT @SumTotMat = SUM(SUMTOTMAL), @SumTotLabor = SUM(SUMTOTLABOR)," & vbCrLf
      sSql = sSql & "         @SumTotExp = SUM(SUMTOTEXP) ,@SumTotOH = SUM(SUMTOTOH)" & vbCrLf
      sSql = sSql & "     FROM #tempMOPartsDetail WHERE SORTKEYLEVEL = 0 " & vbCrLf
      sSql = sSql & "      AND  RTRIM(INMOPART) <> RTRIM(INPART)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "    UPDATE #tempMOPartsDetail SET PARTSUM = INPART" & vbCrLf
      sSql = sSql & "      WHERE PARTSUM IS NULL" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "  ----  SELECT * FROM #tempMOPartsDetail WHERE SORTKEYLEVEL = 0 " & vbCrLf
      sSql = sSql & "      ----AND  RTRIM(INMOPART) = RTRIM(INPART)" & vbCrLf
      sSql = sSql & "   --// Reverse the partnumbers." & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   set @level = 0 " & vbCrLf
      sSql = sSql & "   set @RowCount = 1" & vbCrLf
      sSql = sSql & "   SET @PrevParent = ''" & vbCrLf
      sSql = sSql & "   DECLARE curAcctStruc CURSOR  FOR" & vbCrLf
      sSql = sSql & "      SELECT INMOPART, SortKey" & vbCrLf
      sSql = sSql & "      FROM #tempMOPartsDetail" & vbCrLf
      sSql = sSql & "         WHERE HASCHILD IS NULL --GLFSLEVEL = 8 --AND GLMASTER ='AA10'--GLTOPMaster = 1 AND " & vbCrLf
      sSql = sSql & "      ORDER BY SortKey" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   OPEN curAcctStruc" & vbCrLf
      sSql = sSql & "   FETCH NEXT FROM curAcctStruc INTO @ParentPart, @SortKey" & vbCrLf
      sSql = sSql & "   WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "    IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "    BEGIN" & vbCrLf
      sSql = sSql & "      if (@PrevParent <> @ParentPart)" & vbCrLf
      sSql = sSql & "      BEGIN" & vbCrLf
      sSql = sSql & "         UPDATE #tempMOPartsDetail SET " & vbCrLf
      sSql = sSql & "            SortKeyRev = RIGHT ('0000'+ Cast(@RowCount as varchar), 4) + char(36)+ @ParentPart" & vbCrLf
      sSql = sSql & "         WHERE INMOPART = @ParentPart AND HASCHILD IS NULL --GLFSLEVEL = 8 --AND GLTOPMaster = 1 " & vbCrLf
      sSql = sSql & "         SET @RowCount = @RowCount + 1" & vbCrLf
      sSql = sSql & "         SET @PrevParent = @ParentPart" & vbCrLf
      sSql = sSql & "      END" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "    End" & vbCrLf
      sSql = sSql & "    FETCH NEXT FROM curAcctStruc INTO @ParentPart, @SortKey" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "       " & vbCrLf
      sSql = sSql & "   Close curAcctStruc" & vbCrLf
      sSql = sSql & "   DEALLOCATE curAcctStruc" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   UPDATE #tempMOPartsDetail SET LOTMOPARTRUNKEY = @MOPartRunKey" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   INSERT INTO EsMOPartsCostDetail (LOTMOPARTRUNKEY, INMOPART,INMORUN,INPART,PARTSUM,LOTNUMBER,LOTUSERLOTID," & vbCrLf
      sSql = sSql & "      LOTTOTMATL,SUMTOTMAL, LOTTOTLABOR,SUMTOTLABOR, LOTTOTEXP, SUMTOTEXP, LOTTOTOH,SUMTOTOH,BMTOTOH," & vbCrLf
      sSql = sSql & "        LOTDATECOSTED, BMQTYREQD, LOTORGQTY, SORTKEYLEVEL,SortKey,SortKeyRev,HASCHILD, PICKQTY)" & vbCrLf
      sSql = sSql & "   SELECT LOTMOPARTRUNKEY,INMOPART,INMORUN,INPART,PARTSUM,LOTNUMBER,LOTUSERLOTID," & vbCrLf
      sSql = sSql & "      LOTTOTMATL,SUMTOTMAL, LOTTOTLABOR,SUMTOTLABOR, LOTTOTEXP, SUMTOTEXP, LOTTOTOH,SUMTOTOH,BMTOTOH," & vbCrLf
      sSql = sSql & "        LOTDATECOSTED, BMQTYREQD, LOTORGQTY, SORTKEYLEVEL,SortKey,SortKeyRev,HASCHILD, PICKQTY" & vbCrLf
      sSql = sSql & "   FROM #tempMOPartsDetail--WHERE SORTKEYLEVEL = 1" & vbCrLf
      sSql = sSql & "   order by SortKey--SortKeyRev      " & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   DROP table #tempMOPartsDetail " & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "END"
      
      ExecuteScript False, sSql
      
      
      ' update the version
      ExecuteScript False, "Update Version Set Version = " & newver
   
   End If
End Function


Private Function UpdateDatabase56()
   newver = 130
   If ver < newver Then

      If (TableExists("TnbarTable")) Then
         sSql = "DROP TABLE TnbarTable"
         ExecuteScript False, sSql
      End If
      
      sSql = "CREATE TABLE [dbo].[TnbarTable](" & vbCrLf
      sSql = sSql & "   [TNSNFORMID] [int] NOT NULL," & vbCrLf
      sSql = sSql & "   [TNSERIALNUM] [int] NOT NULL," & vbCrLf
      sSql = sSql & "   [YIELDSTR] [decimal](18, 2) NULL," & vbCrLf
      sSql = sSql & "   [TENSILESTR] [decimal](18, 2) NULL," & vbCrLf
      sSql = sSql & "   [ELONGATION] [decimal](18, 2) NULL," & vbCrLf
      sSql = sSql & "   [MIN] [varchar](24) NULL," & vbCrLf
      sSql = sSql & "   [PASSFAIL] [smallint] NULL," & vbCrLf
      sSql = sSql & "   [LABTESTED] [smallint] NULL," & vbCrLf
      sSql = sSql & "   [FRACTUREMIDGL] [varchar](24) NULL," & vbCrLf
      sSql = sSql & "   [BARINSP] [smallint] NULL," & vbCrLf
      sSql = sSql & "   [MACHINED] [smallint] NULL," & vbCrLf
      sSql = sSql & "   [BARNUM] [int] NULL," & vbCrLf
      sSql = sSql & "   [CUSTOMER] [varchar](24) NULL," & vbCrLf
      sSql = sSql & "   [MOPARTNUM] [varchar](30) NULL," & vbCrLf
      sSql = sSql & "   [MORUN] [int] NULL," & vbCrLf
      sSql = sSql & "   [ALLOYTEMP] [varchar](24) NULL," & vbCrLf
      sSql = sSql & "   [ALLOYSPEC] [varchar](24) NULL," & vbCrLf
      sSql = sSql & "   [FURNACE] [varchar](26) NULL," & vbCrLf
      sSql = sSql & "   [CASTDATE] [datetime] NULL," & vbCrLf
      sSql = sSql & "   [HEATNUM] [varchar](24) NULL" & vbCrLf
      sSql = sSql & ") ON [PRIMARY]"
      
      ExecuteScript False, sSql
      
      
      If (TableExists("TntshdTable")) Then
         sSql = "DROP TABLE TntshdTable"
         ExecuteScript False, sSql
      End If
      
      sSql = "CREATE TABLE [dbo].[TntshdTable](" & vbCrLf
      sSql = sSql & "   [TENSILEFORMID] [int] NOT NULL," & vbCrLf
      sSql = sSql & "   [TEMPERATURE] [decimal](18, 2) NULL," & vbCrLf
      sSql = sSql & "   [NUMOFBARSPULLED] [int] NULL," & vbCrLf
      sSql = sSql & "   [REPORTNUM] [int] NULL," & vbCrLf
      sSql = sSql & "   [OPERATOR] [varchar](24) NULL," & vbCrLf
      sSql = sSql & "   [TESTDATE] [datetime] NULL," & vbCrLf
      sSql = sSql & "   [INSPECTOR] [varchar](10) NULL," & vbCrLf
      sSql = sSql & "   [HUMIDITY] [decimal](18, 2) NULL" & vbCrLf
      sSql = sSql & ") ON [PRIMARY]" & vbCrLf
      
      ExecuteScript False, sSql
      
      If Not ColumnExists("TnRunsTable", "TNSERIALNUM") Then
         sSql = "ALTER TABLE TnRunsTable ADD TNSERIALNUM int"
         ExecuteScript False, sSql
      End If

      If Not ColumnExists("Comntable", "COLASTHTLOADNUM") Then
         sSql = "ALTER TABLE Comntable ADD COLASTHTLOADNUM int"
         ExecuteScript False, sSql
         
         sSql = "UPDATE Comntable set COLASTHTLOADNUM = 5000"
         ExecuteScript False, sSql
         
      End If

      If Not ColumnExists("Comntable", "COLASTTNSERIALNUM") Then
         sSql = "ALTER TABLE Comntable ADD COLASTTNSERIALNUM int"
         ExecuteScript False, sSql
         
         sSql = "UPDATE Comntable set COLASTTNSERIALNUM = 3000"
         ExecuteScript False, sSql
         
      End If

      If (TableExists("HeatTreatHdTable")) Then
         sSql = "DROP TABLE HeatTreatHdTable"
         ExecuteScript False, sSql
      End If

      sSql = "CREATE TABLE [dbo].[HeatTreatHdTable](" & vbCrLf
      sSql = sSql & "   [FURNACENUM] [varchar](24) NULL," & vbCrLf
      sSql = sSql & "   [SOLUTION_HRS] [decimal](18, 2) NULL," & vbCrLf
      sSql = sSql & "   [SOLUTION_TEMP] [decimal](18, 2) NULL," & vbCrLf
      sSql = sSql & "   [RISE_TIME] [varchar](8) NULL," & vbCrLf
      sSql = sSql & "   [SOLUTION_TIME] [varchar](8) NULL," & vbCrLf
      sSql = sSql & "   [DROP_TIME] [varchar](8) NULL," & vbCrLf
      sSql = sSql & "   [DROPDATE] [datetime] NULL," & vbCrLf
      sSql = sSql & "   [QUENCH_DELAY] [decimal](18, 2) NULL," & vbCrLf
      sSql = sSql & "   [QUENCH_DWELL] [decimal](18, 2) NULL," & vbCrLf
      sSql = sSql & "   [QUENCH_BEFTEMP] [decimal](18, 2) NULL," & vbCrLf
      sSql = sSql & "   [QUENCH_AFTTEMP] [decimal](18, 2) NULL," & vbCrLf
      sSql = sSql & "   [QUENCY_BY] [varchar](24) NULL," & vbCrLf
      sSql = sSql & "   [AGE_OVEN] [varchar](16) NULL," & vbCrLf
      sSql = sSql & "   [AGE_TEMP] [decimal](18, 2) NULL," & vbCrLf
      sSql = sSql & "   [AGE_PULLDATE] [datetime] NULL," & vbCrLf
      sSql = sSql & "   [AGE_STARTSOAK] [varchar](24) NULL," & vbCrLf
      sSql = sSql & "   [AGE_ENDTIME] [varchar](8) NULL," & vbCrLf
      sSql = sSql & "   [AGE_RECBY] [varchar](24) NULL," & vbCrLf
      sSql = sSql & "   [LOADINFO_DATE] [datetime] NULL," & vbCrLf
      sSql = sSql & "   [ALLOY] [varchar](24) NULL," & vbCrLf
      sSql = sSql & "   [LOADINFO_RECBY] [varchar](24) NULL," & vbCrLf
      sSql = sSql & "   [ACCEPTEDBY] [varchar](24) NULL," & vbCrLf
      sSql = sSql & "   [HEATTREATID] [int] NULL," & vbCrLf
      sSql = sSql & "   [WORKZONE] [varchar](16) NULL," & vbCrLf
      sSql = sSql & "   [LOADINFO_NUM] [int] NULL," & vbCrLf
      sSql = sSql & "   [LOADINFO_STRNUM] [varchar](24) NULL," & vbCrLf
      sSql = sSql & "   [HOURS_RUN] [varchar](16) NULL," & vbCrLf
      sSql = sSql & "   [AGE_HRS] [varchar](16) NULL," & vbCrLf
      sSql = sSql & "   [AGE_DELAYHRS] [varchar](16) NULL," & vbCrLf
      sSql = sSql & "   [AGE_HRSRUN] [varchar](16) NULL" & vbCrLf
      sSql = sSql & ") ON [PRIMARY]"

      ExecuteScript False, sSql

      If (TableExists("ChmImpTable")) Then
         sSql = "DROP TABLE ChmImpTable"
         ExecuteScript False, sSql
      End If

      sSql = "CREATE TABLE [dbo].[ChmImpTable](" & vbCrLf
      sSql = sSql & "   [CHEMDATAID] [int] IDENTITY(1,1) NOT NULL," & vbCrLf
      sSql = sSql & "   [IMPORTFILEID] [int] NOT NULL," & vbCrLf
      sSql = sSql & "   [HEATNUM] [varchar](24) NOT NULL," & vbCrLf
      sSql = sSql & "   [DATE] [datetime] NULL," & vbCrLf
      sSql = sSql & "   [TIME] [varchar](12) NULL," & vbCrLf
      sSql = sSql & "   [DATEFORMAT] [datetime] NULL," & vbCrLf
      sSql = sSql & "   [Al] [decimal](18, 4) NULL," & vbCrLf
      sSql = sSql & "   [Be] [decimal](18, 4) NULL," & vbCrLf
      sSql = sSql & "   [Ca] [decimal](18, 4) NULL," & vbCrLf
      sSql = sSql & "   [Cr] [decimal](18, 4) NULL," & vbCrLf
      sSql = sSql & "   [Cu] [decimal](18, 4) NULL," & vbCrLf
      sSql = sSql & "   [Fe] [decimal](18, 4) NULL," & vbCrLf
      sSql = sSql & "   [Mg] [decimal](18, 4) NULL," & vbCrLf
      sSql = sSql & "   [Mn] [decimal](18, 4) NULL," & vbCrLf
      sSql = sSql & "   [Na] [decimal](18, 4) NULL," & vbCrLf
      sSql = sSql & "   [Ni] [decimal](18, 4) NULL," & vbCrLf
      sSql = sSql & "   [Si] [decimal](18, 4) NULL," & vbCrLf
      sSql = sSql & "   [Sn] [decimal](18, 4) NULL," & vbCrLf
      sSql = sSql & "   [Sr] [decimal](18, 4) NULL," & vbCrLf
      sSql = sSql & "   [V] [decimal](18, 4) NULL," & vbCrLf
      sSql = sSql & "   [Ti] [decimal](18, 4) NULL," & vbCrLf
      sSql = sSql & "   [Zn] [decimal](18, 4) NULL," & vbCrLf
      sSql = sSql & "   [Zr] [decimal](18, 4) NULL," & vbCrLf
      sSql = sSql & "   [Bi] [decimal](18, 4) NULL," & vbCrLf
      sSql = sSql & "   [In] [decimal](18, 4) NULL," & vbCrLf
      sSql = sSql & "   [B] [decimal](18, 4) NULL," & vbCrLf
      sSql = sSql & "   [Pb] [decimal](18, 4) NULL" & vbCrLf
      sSql = sSql & ") ON [PRIMARY]"
      
      ExecuteScript False, sSql

      If StoreProcedureExists("MaterialMORunList") Then
         sSql = "DROP PROCEDURE MaterialMORunList"
         ExecuteScript False, sSql
      End If
      
      sSql = "CREATE PROCEDURE [dbo].[MaterialMORunList]" & vbCrLf
      sSql = sSql & "   @MatID as int,@MOPartNum as varchar(30)" & vbCrLf
      sSql = sSql & "AS " & vbCrLf
      sSql = sSql & "BEGIN  " & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "declare @RunPot as varchar(8)" & vbCrLf
      sSql = sSql & "declare @RunList as varchar(48)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "SET @RunList = ''" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   DECLARE curRun CURSOR FOR " & vbCrLf
      sSql = sSql & "      SELECT CONVERT(varchar(8), MORUN) + POTLETTER FROM MatCertRunsTable" & vbCrLf
      sSql = sSql & "         WHERE MATCERTID = @MatID AND MOPARTNUM = @MOPartNum" & vbCrLf
      sSql = sSql & "      OPEN curRun " & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM curRun INTO @RunPot" & vbCrLf
      sSql = sSql & "      WHILE (@@FETCH_STATUS <> -1) " & vbCrLf
      sSql = sSql & "      BEGIN " & vbCrLf
      sSql = sSql & "         IF (@@FETCH_STATUS <> -2) " & vbCrLf
      sSql = sSql & "         BEGIN " & vbCrLf
      sSql = sSql & "             SET " & vbCrLf
      sSql = sSql & "             IF (@RunList = '')" & vbCrLf
      sSql = sSql & "            SET @RunList = Convert(varchar(10), @RunPot)" & vbCrLf
      sSql = sSql & "             ELSE" & vbCrLf
      sSql = sSql & "            SET @RunList = @RunList + ',' + @RunPot" & vbCrLf
      sSql = sSql & "            " & vbCrLf
      sSql = sSql & "            FETCH NEXT FROM curRun INTO @RunPot" & vbCrLf
      sSql = sSql & "         END " & vbCrLf
      sSql = sSql & "      END " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "      CLOSE curRun --// close the cursor " & vbCrLf
      sSql = sSql & "      DEALLOCATE curRun " & vbCrLf
      sSql = sSql & "       " & vbCrLf
      sSql = sSql & " SELECT @RunList" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "END "
   
      ExecuteScript False, sSql

      If StoreProcedureExists("TensileMORunList") Then
         sSql = "DROP PROCEDURE TensileMORunList"
         ExecuteScript False, sSql
      End If

      sSql = "CREATE PROCEDURE [dbo].[TensileMORunList] " & vbCrLf
      sSql = sSql & "   @TenFormID as int,@MOPartNum as varchar(30)," & vbCrLf
      sSql = sSql & "   @TenSerNum as Int " & vbCrLf
      sSql = sSql & "AS " & vbCrLf
      sSql = sSql & "BEGIN  " & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "declare @Run as int" & vbCrLf
      sSql = sSql & "declare @RunList as varchar(24)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "SET @RunList = ''" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   DECLARE curRun CURSOR FOR " & vbCrLf
      sSql = sSql & "      SELECT DISTINCT MORUN FROM TnRunsTable" & vbCrLf
      sSql = sSql & "   WHERE TENSILEFORMID = @TenFormID AND MOPARTNUM = @MOPartNum AND TNSERIALNUM = @TenSerNum" & vbCrLf
      sSql = sSql & "      OPEN curRun " & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM curRun INTO @Run" & vbCrLf
      sSql = sSql & "      WHILE (@@FETCH_STATUS <> -1) " & vbCrLf
      sSql = sSql & "      BEGIN " & vbCrLf
      sSql = sSql & "         IF (@@FETCH_STATUS <> -2) " & vbCrLf
      sSql = sSql & "         BEGIN " & vbCrLf
      sSql = sSql & "             " & vbCrLf
      sSql = sSql & "             IF (@RunList = '')" & vbCrLf
      sSql = sSql & "            SET @RunList = Convert(varchar(10), @Run)" & vbCrLf
      sSql = sSql & "             ELSE" & vbCrLf
      sSql = sSql & "            SET @RunList = @RunList + ',' + Convert(varchar(10), @Run)" & vbCrLf
      sSql = sSql & "            " & vbCrLf
      sSql = sSql & "            FETCH NEXT FROM curRun INTO @Run" & vbCrLf
      sSql = sSql & "         END " & vbCrLf
      sSql = sSql & "      END " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "      CLOSE curRun --// close the cursor " & vbCrLf
      sSql = sSql & "      DEALLOCATE curRun " & vbCrLf
      sSql = sSql & "       " & vbCrLf
      sSql = sSql & " SELECT @RunList" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "END "
         
      ExecuteScript False, sSql

      ' update the version
      ExecuteScript False, "Update Version Set Version = " & newver
   
   End If
End Function


Private Function UpdateDatabase57()

   newver = 131
   If ver < newver Then
      
      If Not ColumnExists("ComnTable", "COHIDEINACTIVEPART") Then
         sSql = "ALTER TABLE dbo.ComnTable ADD COHIDEINACTIVEPART tinyint NULL, COHIDEOBSOLETEPART tinyint NULL"
         ExecuteScript False, sSql
      End If

      If Not ColumnExists("ComnTable", "ENABLEMELTERSLOG") Then
         sSql = "ALTER TABLE dbo.ComnTable add ENABLEMELTERSLOG int null"
         ExecuteScript False, sSql
      End If
      
      If Not ColumnExists("HeatTreatHdTable", "SOLUTION_HRS") Then
         
         sSql = "ALTER TABLE dbo.HeatTreatHdTable ALTER COLUMN [SOLUTION_HRS] [varchar](24) NULL"
         ExecuteScript False, sSql
         sSql = "ALTER TABLE dbo.HeatTreatHdTable ALTER COLUMN [SOLUTION_TEMP] [varchar](24) NULL"
         ExecuteScript False, sSql
         sSql = "ALTER TABLE dbo.HeatTreatHdTable ALTER COLUMN [SOLUTION_TIME] [varchar](24) NULL"
         ExecuteScript False, sSql
         sSql = "ALTER TABLE dbo.HeatTreatHdTable ALTER COLUMN [RISE_TIME] [varchar](24) NULL"
         ExecuteScript False, sSql
         sSql = "ALTER TABLE dbo.HeatTreatHdTable ALTER COLUMN [QUENCH_DELAY] int NULL"
         ExecuteScript False, sSql
         sSql = "ALTER TABLE dbo.HeatTreatHdTable ALTER COLUMN [QUENCH_DWELL] int NULL"
         ExecuteScript False, sSql
         sSql = "ALTER TABLE dbo.HeatTreatHdTable ALTER COLUMN [QUENCH_BEFTEMP] int NULL"
         ExecuteScript False, sSql
         sSql = "ALTER TABLE dbo.HeatTreatHdTable ALTER COLUMN [QUENCH_AFTTEMP] int NULL"
         ExecuteScript False, sSql
         sSql = "ALTER TABLE dbo.HeatTreatHdTable ALTER COLUMN [AGE_TEMP] int NULL"
         ExecuteScript False, sSql
         sSql = "ALTER TABLE dbo.HeatTreatHdTable ALTER COLUMN [DROPDATE] varchar(12) NULL"
         ExecuteScript False, sSql
         sSql = "ALTER TABLE dbo.HeatTreatHdTable ALTER COLUMN [DROP_TIME] varchar(24) NULL"
         ExecuteScript False, sSql
         sSql = "ALTER TABLE dbo.HeatTreatHdTable ALTER COLUMN ALLOY    varchar(64) NULL"
         ExecuteScript False, sSql
      
      End If
      
      If Not ColumnExists("HeatTrtDtlTable", "AGE_TEMP") Then
         sSql = "ALTER TABLE dbo.HeatTrtDtlTable ADD [AGE_TEMP] [int] NULL"
         ExecuteScript False, sSql
         sSql = "ALTER TABLE dbo.HeatTrtDtlTable ADD [AGE_PULLDATE] [datetime] NULL"
         ExecuteScript False, sSql
         sSql = "ALTER TABLE dbo.HeatTrtDtlTable ADD [AGE_STARTSOAK] [varchar](24) NULL"
         ExecuteScript False, sSql
         sSql = "ALTER TABLE dbo.HeatTrtDtlTable ADD [AGE_ENDTIME] [varchar](8) NULL"
         ExecuteScript False, sSql
         sSql = "ALTER TABLE dbo.HeatTrtDtlTable ADD [AGE_RECBY] [varchar](24) NULL"
         ExecuteScript False, sSql
         sSql = "ALTER TABLE dbo.HeatTrtDtlTable ADD [AGE_HRS] [varchar](16) NULL"
         ExecuteScript False, sSql
         sSql = "ALTER TABLE dbo.HeatTrtDtlTable ADD [AGE_DELAYHRS] [varchar](16) NULL"
         ExecuteScript False, sSql
         sSql = "ALTER TABLE dbo.HeatTrtDtlTable ADD [AGE_HRSRUN] [varchar](16) NULL"
         ExecuteScript False, sSql

         sSql = "ALTER TABLE dbo.HeatTrtDtlTable ALTER COLUMN [QTY] Int"
         ExecuteScript False, sSql
      
      End If


      If Not ColumnExists("HeatTreatHdTable", "CLNLINESS_CHK") Then
         sSql = "ALTER TABLE dbo.HeatTreatHdTable ADD CLNLINESS_CHK [varchar](24) NULL"
         ExecuteScript False, sSql
      End If
      
      
      If StoreProcedureExists("PivotWCSchDate") Then
         sSql = "DROP PROCEDURE PivotWCSchDate"
         ExecuteScript False, sSql
      End If

      sSql = "CREATE PROCEDURE [dbo].[PivotWCSchDate]  " & vbCrLf
      sSql = sSql & "   @StartDate as varchar(12),@EndDate as varchar(12)  " & vbCrLf
      sSql = sSql & "AS  " & vbCrLf
      sSql = sSql & "BEGIN   " & vbCrLf
      sSql = sSql & "  " & vbCrLf
      sSql = sSql & "   declare @CurDate as datetime " & vbCrLf
      sSql = sSql & "   declare @SeqNum as int " & vbCrLf
      sSql = sSql & "   declare @OPCenter as varchar(30) " & vbCrLf
      sSql = sSql & "   declare @prevOpCnt as varchar(30) " & vbCrLf
      sSql = sSql & "   declare @RunRef as varchar(30) " & vbCrLf
      sSql = sSql & "   declare @RunNo as int " & vbCrLf
      sSql = sSql & "   declare @OpNo  as varchar(5) " & vbCrLf
      sSql = sSql & "   declare @RunSch  as datetime " & vbCrLf
      sSql = sSql & "   declare @OpCalShc as datetime " & vbCrLf
      sSql = sSql & "   declare @OpTotHrs  as decimal(15,2) " & vbCrLf
      sSql = sSql & "    " & vbCrLf
      sSql = sSql & "   declare @TotWChrs as decimal(15,2) " & vbCrLf
      sSql = sSql & "   declare @RemOpHrs as decimal(15,2) " & vbCrLf
      sSql = sSql & "    " & vbCrLf
      sSql = sSql & "   --DROP TABLE #tempWCSch  " & vbCrLf
      sSql = sSql & "   --delete from #tempWCSch  " & vbCrLf
      sSql = sSql & "   CREATE TABLE #tempWCSch(     " & vbCrLf
      sSql = sSql & "      [SEQNUM] integer NULL,    " & vbCrLf
      sSql = sSql & "      [OPCENTER] [varchar](30) NULL,   " & vbCrLf
      sSql = sSql & "      [RUNREF] [varchar](30) NULL,   " & vbCrLf
      sSql = sSql & "      [RUNNO] int NULL,   " & vbCrLf
      sSql = sSql & "      [OPNO] varchar(5) NULL,   " & vbCrLf
      sSql = sSql & "      [RUNSCHED] datetime NULL,   " & vbCrLf
      sSql = sSql & "      [RUNQTY] int NULL,  " & vbCrLf
      sSql = sSql & "   OPYIELD decimal(9,4) NULL,  " & vbCrLf
      sSql = sSql & "   OPSETUP decimal(9,4) NULL,  " & vbCrLf
      sSql = sSql & "   OPQHRS decimal(9,4) NULL,  " & vbCrLf
      sSql = sSql & "   OPMHRS decimal(9,4) NULL,  " & vbCrLf
      sSql = sSql & "   OPSUHRS decimal(9,4) NULL, " & vbCrLf
      sSql = sSql & "   OPUNITHRS decimal(9,4) NULL, " & vbCrLf
      sSql = sSql & "      OPTOTHRS decimal(9,4) NULL, " & vbCrLf
      sSql = sSql & "      OPCALSCHED datetime NULL, " & vbCrLf
      sSql = sSql & "      OPCOMT varchar(64) NULL, " & vbCrLf
      sSql = sSql & "      [RUNPRIORITY] int NULL,  " & vbCrLf
      sSql = sSql & "        [RUMCOMP] varchar(512) NULL, " & vbCrLf
      sSql = sSql & "        [SOCUST] varchar(10) NULL " & vbCrLf
      sSql = sSql & "   )                               " & vbCrLf
      sSql = sSql & "  " & vbCrLf
      sSql = sSql & "   INSERT INTO #tempWCSch (SEQNUM, OPCENTER,RUNREF , RUNNO, OPNO, RUNSCHED, RUNQTY,  " & vbCrLf
      sSql = sSql & "      OPYIELD, OPSETUP, OPQHRS, OPMHRS, OPSUHRS,  " & vbCrLf
      sSql = sSql & "      OPUNITHRS, OPTOTHRS, RUNPRIORITY,SOCUST,RUMCOMP, OPCOMT)  " & vbCrLf
      sSql = sSql & "   SELECT DISTINCT ROW_NUMBER() OVER(PARTITION BY OPCENTER ORDER BY OPCENTER DESC, RUNSCHED) AS SEQNUM,   " & vbCrLf
      sSql = sSql & "         OPCENTER,RUNREF , RUNNO, OPNO, RUNSCHED, RUNQTY, " & vbCrLf
      sSql = sSql & "         OPYIELD, OPSETUP, OPQHRS, OPMHRS, OPSUHRS,  " & vbCrLf
      sSql = sSql & "       OPUNITHRS, ROUND((((RUNQTY - OPYIELD) * (OPUNITHRS)) + (OPSETUP)), 4), " & vbCrLf
      sSql = sSql & "         RUNPRIORITY,SOCUST,  RTRIM(RUNREF) + SPACE(2) + Convert(varchar(13), RUNNO) +   " & vbCrLf
      sSql = sSql & "            SPACE(2) + Convert(varchar(5), OPNO)  +   " & vbCrLf
      sSql = sSql & "            SPACE(2) + Convert(varchar(10), RUNSCHED, 101)  +   " & vbCrLf
      sSql = sSql & "      SPACE(2) + Convert(varchar(10), CONVERT(int, ROUND(RUNQTY, 0))) +   " & vbCrLf
      sSql = sSql & "      SPACE(2) + Convert(varchar(10), OPSUHRS) + " & vbCrLf
      sSql = sSql & "      SPACE(2) + Convert(varchar(10), SOCUST) " & vbCrLf
      sSql = sSql & "      , SUBSTRING(OPCOMT, 1, 64) " & vbCrLf
      sSql = sSql & "   FROM RnopTable, RunsTable, WCSchView, rnaltable, sohdtable " & vbCrLf
      sSql = sSql & "   WHERE (OPREF = RUNREF AND OPRUN = RUNNO)    " & vbCrLf
      sSql = sSql & "      AND WorkCenter = RTRIM(OPCENTER)  " & vbCrLf
      sSql = sSql & "      AND RAREF = RUNREF AND RARUN = RUNNO AND RASO = SONUMBER " & vbCrLf
      sSql = sSql & "      AND (OPCOMPLETE=0 AND OPCENTER LIKE '%' AND    " & vbCrLf
      sSql = sSql & "      RUNSCHED BETWEEN @StartDate AND  @EndDate)    " & vbCrLf
      sSql = sSql & "   ORDER BY OPCENTER , RUNSCHED " & vbCrLf
      sSql = sSql & "    " & vbCrLf
      sSql = sSql & "   SET @CurDate = NULL " & vbCrLf
      sSql = sSql & "   SET @TotWChrs = 0.0 " & vbCrLf
      sSql = sSql & "   SET @RemOpHrs = 0.0 " & vbCrLf
      sSql = sSql & "   SET @prevOpCnt = '' " & vbCrLf
      sSql = sSql & "    " & vbCrLf
      sSql = sSql & "    DECLARE curWCShc CURSOR FOR  " & vbCrLf
      sSql = sSql & "     SELECT SEQNUM, OPCENTER,RUNREF, RUNNO, OPNO, CONVERT(varchar(12), RUNSCHED, 101), OPTOTHRS--,OPCALSCHED " & vbCrLf
      sSql = sSql & "         FROM #tempWCSch --WHERE OPCENTER = 'ABRAZE'  " & vbCrLf
      sSql = sSql & "         ORDER BY OPCENTER, RUNSCHED  " & vbCrLf
      sSql = sSql & "      OPEN curWCShc  " & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM curWCShc INTO @SeqNum, @OPCenter, @RunRef, @RunNo, @OpNo, @RunSch,@OpTotHrs " & vbCrLf
      sSql = sSql & "      WHILE (@@FETCH_STATUS <> -1)  " & vbCrLf
      sSql = sSql & "      BEGIN  " & vbCrLf
      sSql = sSql & "         IF (@@FETCH_STATUS <> -2)  " & vbCrLf
      sSql = sSql & "         BEGIN  " & vbCrLf
      sSql = sSql & "                " & vbCrLf
      sSql = sSql & "         IF (@prevOpCnt <> @OPCenter) " & vbCrLf
      sSql = sSql & "         BEGIN " & vbCrLf
      sSql = sSql & "            SET @CurDate = NULL " & vbCrLf
      sSql = sSql & "            SET @TotWChrs = 0.0 " & vbCrLf
      sSql = sSql & "            SET @RemOpHrs = 0.0 " & vbCrLf
      sSql = sSql & "            SET @prevOpCnt = @OPCenter " & vbCrLf
      sSql = sSql & "         END       " & vbCrLf
      sSql = sSql & "         --// get the Hours for the day " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "         IF (@TotWChrs <= 0) " & vbCrLf
      sSql = sSql & "         BEGIN " & vbCrLf
      sSql = sSql & "            IF (@CurDate IS NULL) " & vbCrLf
      sSql = sSql & "            BEGIN " & vbCrLf
      sSql = sSql & "               SET @CurDate = @RunSch " & vbCrLf
      sSql = sSql & "            END " & vbCrLf
      sSql = sSql & "            ELSE " & vbCrLf
      sSql = sSql & "               SET @CurDate = DATEADD(day, 1, @CurDate) " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "                " & vbCrLf
      sSql = sSql & "            select TOP 1 @TotWChrs = (WCCSHH1 + WCCSHH2 + WCCSHH3 + WCCSHH4), @CurDate = WCCDATE " & vbCrLf
      sSql = sSql & "               from wcclTable where WCCCENTER = @OPCenter --'ABRAZE' -- " & vbCrLf
      sSql = sSql & "                  AND WCCDATE >= @CurDate  " & vbCrLf
      sSql = sSql & "            AND (WCCSHH1 + WCCSHH2 + WCCSHH3 + WCCSHH4) > 0 " & vbCrLf
      sSql = sSql & "             " & vbCrLf
      sSql = sSql & "            SET @TotWChrs = @TotWChrs - @RemOpHrs " & vbCrLf
      sSql = sSql & "         END " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "         IF (@TotWChrs > 0.0) " & vbCrLf
      sSql = sSql & "         BEGIN " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "            SET @OpCalShc = @CurDate " & vbCrLf
      sSql = sSql & "            IF (@RunSch <= @OpCalShc) " & vbCrLf
      sSql = sSql & "            BEGIN  " & vbCrLf
      sSql = sSql & "               UPDATE #tempWCSch SET OPCALSCHED = @CurDate WHERE OPCENTER = @OPCenter " & vbCrLf
      sSql = sSql & "                        AND RUNREF = @RunRef AND RUNNO = @RunNo AND OPNO =  @OpNo " & vbCrLf
      sSql = sSql & "            END  " & vbCrLf
      sSql = sSql & "            ELSE " & vbCrLf
      sSql = sSql & "            BEGIN " & vbCrLf
      sSql = sSql & "               UPDATE #tempWCSch SET OPCALSCHED = @RunSch WHERE OPCENTER = @OPCenter " & vbCrLf
      sSql = sSql & "                        AND RUNREF = @RunRef AND RUNNO = @RunNo AND OPNO =  @OpNo " & vbCrLf
      sSql = sSql & "               SET @CurDate = @RunSch " & vbCrLf
      sSql = sSql & "                " & vbCrLf
      sSql = sSql & "            END  " & vbCrLf
      sSql = sSql & "            --// only if schedue date is less than current date " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "            SET @RemOpHrs = @OpTotHrs - @TotWChrs " & vbCrLf
      sSql = sSql & "            --SET @TotWChrs = @TotWChrs - @OpTotHrs " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "            if (@RemOpHrs > 8) " & vbCrLf
      sSql = sSql & "            BEGIN " & vbCrLf
      sSql = sSql & "                " & vbCrLf
      sSql = sSql & "               WHILE (@RemOpHrs > 8) " & vbCrLf
      sSql = sSql & "               BEGIN " & vbCrLf
      sSql = sSql & "                   " & vbCrLf
      sSql = sSql & "                  SET @CurDate = DATEADD(day, 1, @CurDate) " & vbCrLf
      sSql = sSql & "                   " & vbCrLf
      sSql = sSql & "                  select TOP 1 @TotWChrs = (WCCSHH1 + WCCSHH2 + WCCSHH3 + WCCSHH4), @CurDate = WCCDATE " & vbCrLf
      sSql = sSql & "                     from wcclTable where WCCCENTER = @OPCenter AND WCCDATE >= @CurDate  " & vbCrLf
      sSql = sSql & "                  AND (WCCSHH1 + WCCSHH2 + WCCSHH3 + WCCSHH4) > 0 " & vbCrLf
      sSql = sSql & "                   " & vbCrLf
      sSql = sSql & "                  IF (@@ROWCOUNT = 0) " & vbCrLf
      sSql = sSql & "                  BEGIN " & vbCrLf
      sSql = sSql & "                     SET @RemOpHrs = 0.0 " & vbCrLf
      sSql = sSql & "                     SET @TotWChrs = 0.0 " & vbCrLf
      sSql = sSql & "                  END                      " & vbCrLf
      sSql = sSql & "                  SET @RemOpHrs = @RemOpHrs - @TotWChrs " & vbCrLf
      sSql = sSql & "                   " & vbCrLf
      sSql = sSql & "                  IF (@RemOpHrs > 60) " & vbCrLf
      sSql = sSql & "                     SET @RemOpHrs = 0.0 " & vbCrLf
      sSql = sSql & "                   " & vbCrLf
      sSql = sSql & "               END " & vbCrLf
      sSql = sSql & "               --// Back one day as we increase one day in the top " & vbCrLf
      sSql = sSql & "               SET @CurDate = DATEADD(day, -1, @CurDate) " & vbCrLf
      sSql = sSql & "               SET @TotWChrs = 0.0 " & vbCrLf
      sSql = sSql & "            END " & vbCrLf
      sSql = sSql & "          " & vbCrLf
      sSql = sSql & "         END  " & vbCrLf
      sSql = sSql & "            --// Tot hrs " & vbCrLf
      sSql = sSql & "         SET @prevOpCnt = @OPCenter  " & vbCrLf
      sSql = sSql & "          " & vbCrLf
      sSql = sSql & "            FETCH NEXT FROM curWCShc INTO @SeqNum, @OPCenter, @RunRef, @RunNo, @OpNo, @RunSch,@OpTotHrs " & vbCrLf
      sSql = sSql & "         END  " & vbCrLf
      sSql = sSql & "      END  " & vbCrLf
      sSql = sSql & "  " & vbCrLf
      sSql = sSql & "      CLOSE curWCShc --// close the cursor  " & vbCrLf
      sSql = sSql & "      DEALLOCATE curWCShc  " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   declare @SQL as varchar(8000)  " & vbCrLf
      sSql = sSql & "   declare @WCCenter as varchar(512)  " & vbCrLf
      sSql = sSql & "   declare @RumComp as varchar(512) " & vbCrLf
      sSql = sSql & "   declare @Comp as varchar(48) " & vbCrLf
      sSql = sSql & "    " & vbCrLf
      sSql = sSql & "   SET @SQL = NULL  " & vbCrLf
      sSql = sSql & "   SET @SQL = 'SELECT SEQNUM '   " & vbCrLf
      sSql = sSql & "  " & vbCrLf
      sSql = sSql & "  " & vbCrLf
      sSql = sSql & "   DECLARE curWCShc CURSOR FOR  " & vbCrLf
      sSql = sSql & "     SELECT RTRIM(OPCENTER), MIN(RUNSCHED) FROM #tempWCSch  " & vbCrLf
      sSql = sSql & "   GROUP BY OPCENTER  " & vbCrLf
      sSql = sSql & "      OPEN curWCShc  " & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM curWCShc INTO @OPCenter, @RunSch  " & vbCrLf
      sSql = sSql & "      WHILE (@@FETCH_STATUS <> -1)  " & vbCrLf
      sSql = sSql & "      BEGIN  " & vbCrLf
      sSql = sSql & "         IF (@@FETCH_STATUS <> -2)  " & vbCrLf
      sSql = sSql & "         BEGIN  " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "            --INSERT INTO #tempWC (WorkCenter) VALUES (@OPCenter)  " & vbCrLf
      sSql = sSql & "            SET @SQL =  @SQL + ','  +  " & vbCrLf
      sSql = sSql & "                  ' MAX(CASE WHEN RTRIM(OPCENTER) = ''' + @OPCenter + '''' +  " & vbCrLf
      sSql = sSql & "                     ' THEN (RUMCOMP + SPACE(2) +  Convert(varchar(12), ISNULL(OPCALSCHED, RUNSCHED), 101) + SPACE(2) +  OPCOMT) END) as ''' +  @OPCenter + ''''  " & vbCrLf
      sSql = sSql & "              " & vbCrLf
      sSql = sSql & "            FETCH NEXT FROM curWCShc INTO @OPCenter,@RunSch  " & vbCrLf
      sSql = sSql & "         END  " & vbCrLf
      sSql = sSql & "      END  " & vbCrLf
      sSql = sSql & "  " & vbCrLf
      sSql = sSql & "      CLOSE curWCShc --// close the cursor  " & vbCrLf
      sSql = sSql & "      DEALLOCATE curWCShc  " & vbCrLf
      sSql = sSql & "        " & vbCrLf
      sSql = sSql & "           " & vbCrLf
      sSql = sSql & "      SET @SQL =  @SQL + 'FROM #tempWCSch WHERE OPCENTER IN (SELECT DISTINCT WorkCenter FROM WCSchView) GROUP BY SEQNUM'  " & vbCrLf
      sSql = sSql & "  " & vbCrLf
      sSql = sSql & "  " & vbCrLf
      sSql = sSql & "           " & vbCrLf
      sSql = sSql & "   print @SQL  " & vbCrLf
      sSql = sSql & "      EXEC(@SQL)    " & vbCrLf
      sSql = sSql & "  " & vbCrLf
      sSql = sSql & "   Drop table #tempWCSch  " & vbCrLf
      sSql = sSql & "  " & vbCrLf
      sSql = sSql & "END  "

      ExecuteScript False, sSql

      If StoreProcedureExists("rptPivotWCSchDate") Then
         sSql = "DROP PROCEDURE rptPivotWCSchDate"
         ExecuteScript False, sSql
      End If

      sSql = "CREATE PROCEDURE [dbo].[rptPivotWCSchDate]  " & vbCrLf
      sSql = sSql & "   @StartDate as varchar(12),@EndDate as varchar(12)  " & vbCrLf
      sSql = sSql & "AS  " & vbCrLf
      sSql = sSql & "BEGIN   " & vbCrLf
      sSql = sSql & "  " & vbCrLf
      sSql = sSql & "   declare @CurDate as datetime " & vbCrLf
      sSql = sSql & "   declare @SeqNum as int " & vbCrLf
      sSql = sSql & "   declare @OPCenter as varchar(30) " & vbCrLf
      sSql = sSql & "   declare @prevOpCnt as varchar(30) " & vbCrLf
      sSql = sSql & "   declare @RunRef as varchar(30) " & vbCrLf
      sSql = sSql & "   declare @RunNo as int " & vbCrLf
      sSql = sSql & "   declare @OpNo  as varchar(5) " & vbCrLf
      sSql = sSql & "   declare @RunSch  as datetime " & vbCrLf
      sSql = sSql & "   declare @OpCalShc as datetime " & vbCrLf
      sSql = sSql & "   declare @OpTotHrs  as decimal(15,2) " & vbCrLf
      sSql = sSql & "    " & vbCrLf
      sSql = sSql & "   declare @TotWChrs as decimal(15,2) " & vbCrLf
      sSql = sSql & "   declare @RemOpHrs as decimal(15,2) " & vbCrLf
      sSql = sSql & "    " & vbCrLf
      sSql = sSql & "   --DROP TABLE #tempWCSch  " & vbCrLf
      sSql = sSql & "   --delete from #tempWCSch  " & vbCrLf
      sSql = sSql & "   CREATE TABLE #tempWCSch(     " & vbCrLf
      sSql = sSql & "      [SEQNUM] integer NULL,    " & vbCrLf
      sSql = sSql & "      [OPCENTER] [varchar](30) NULL,   " & vbCrLf
      sSql = sSql & "      [RUNREF] [varchar](30) NULL,   " & vbCrLf
      sSql = sSql & "      [RUNNO] int NULL,   " & vbCrLf
      sSql = sSql & "      [OPNO] varchar(5) NULL,   " & vbCrLf
      sSql = sSql & "      [RUNSCHED] datetime NULL,   " & vbCrLf
      sSql = sSql & "      [RUNQTY] int NULL,  " & vbCrLf
      sSql = sSql & "   OPYIELD decimal(9,4) NULL,  " & vbCrLf
      sSql = sSql & "   OPSETUP decimal(9,4) NULL,  " & vbCrLf
      sSql = sSql & "   OPQHRS decimal(9,4) NULL,  " & vbCrLf
      sSql = sSql & "   OPMHRS decimal(9,4) NULL,  " & vbCrLf
      sSql = sSql & "   OPSUHRS decimal(9,4) NULL, " & vbCrLf
      sSql = sSql & "   OPUNITHRS decimal(9,4) NULL, " & vbCrLf
      sSql = sSql & "      OPTOTHRS decimal(9,4) NULL, " & vbCrLf
      sSql = sSql & "      OPCALSCHED datetime NULL, " & vbCrLf
      sSql = sSql & "      OPCOMT varchar(64) NULL, " & vbCrLf
      sSql = sSql & "      [RUNPRIORITY] int NULL,  " & vbCrLf
      sSql = sSql & "        [RUMCOMP] varchar(512) NULL, " & vbCrLf
      sSql = sSql & "        [SOCUST] varchar(10) NULL " & vbCrLf
      sSql = sSql & "   )                               " & vbCrLf
      sSql = sSql & "  " & vbCrLf
      sSql = sSql & "   INSERT INTO #tempWCSch (SEQNUM, OPCENTER,RUNREF , RUNNO, OPNO, RUNSCHED, RUNQTY,  " & vbCrLf
      sSql = sSql & "      OPYIELD, OPSETUP, OPQHRS, OPMHRS, OPSUHRS,  " & vbCrLf
      sSql = sSql & "      OPUNITHRS, OPTOTHRS, RUNPRIORITY,SOCUST,RUMCOMP, OPCOMT)  " & vbCrLf
      sSql = sSql & "   SELECT DISTINCT ROW_NUMBER() OVER(PARTITION BY OPCENTER ORDER BY OPCENTER DESC, RUNSCHED) AS SEQNUM,   " & vbCrLf
      sSql = sSql & "         OPCENTER,RUNREF , RUNNO, OPNO, RUNSCHED, RUNQTY, " & vbCrLf
      sSql = sSql & "         OPYIELD, OPSETUP, OPQHRS, OPMHRS, OPSUHRS,  " & vbCrLf
      sSql = sSql & "       OPUNITHRS, ROUND((((RUNQTY - OPYIELD) * (OPUNITHRS)) + (OPSETUP)), 4), " & vbCrLf
      sSql = sSql & "         RUNPRIORITY,SOCUST,  RTRIM(RUNREF) + SPACE(2) + Convert(varchar(13), RUNNO) +   " & vbCrLf
      sSql = sSql & "            SPACE(2) + Convert(varchar(5), OPNO)  +   " & vbCrLf
      sSql = sSql & "            SPACE(2) + Convert(varchar(10), RUNSCHED, 101)  +   " & vbCrLf
      sSql = sSql & "      SPACE(2) + Convert(varchar(10), CONVERT(int, ROUND(RUNQTY, 0))) +   " & vbCrLf
      sSql = sSql & "      SPACE(2) + Convert(varchar(10), OPSUHRS) + " & vbCrLf
      sSql = sSql & "      SPACE(2) + Convert(varchar(10), SOCUST) " & vbCrLf
      sSql = sSql & "      , SUBSTRING(OPCOMT, 1, 64) " & vbCrLf
      sSql = sSql & "   FROM RnopTable, RunsTable, WCSchView, rnaltable, sohdtable " & vbCrLf
      sSql = sSql & "   WHERE (OPREF = RUNREF AND OPRUN = RUNNO)    " & vbCrLf
      sSql = sSql & "      AND WorkCenter = RTRIM(OPCENTER)  " & vbCrLf
      sSql = sSql & "      AND RAREF = RUNREF AND RARUN = RUNNO AND RASO = SONUMBER " & vbCrLf
      sSql = sSql & "      AND (OPCOMPLETE=0 AND OPCENTER LIKE '%' AND    " & vbCrLf
      sSql = sSql & "      RUNSCHED BETWEEN @StartDate AND  @EndDate)    " & vbCrLf
      sSql = sSql & "   ORDER BY OPCENTER , RUNSCHED " & vbCrLf
      sSql = sSql & "    " & vbCrLf
      sSql = sSql & "   SET @CurDate = NULL " & vbCrLf
      sSql = sSql & "   SET @TotWChrs = 0.0 " & vbCrLf
      sSql = sSql & "   SET @RemOpHrs = 0.0 " & vbCrLf
      sSql = sSql & "   SET @prevOpCnt = '' " & vbCrLf
      sSql = sSql & "    " & vbCrLf
      sSql = sSql & "    DECLARE curWCShc CURSOR FOR  " & vbCrLf
      sSql = sSql & "     SELECT SEQNUM, OPCENTER,RUNREF, RUNNO, OPNO, CONVERT(varchar(12), RUNSCHED, 101), OPTOTHRS--,OPCALSCHED " & vbCrLf
      sSql = sSql & "         FROM #tempWCSch --WHERE OPCENTER = 'ABRAZE'  " & vbCrLf
      sSql = sSql & "         ORDER BY OPCENTER, RUNSCHED  " & vbCrLf
      sSql = sSql & "      OPEN curWCShc  " & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM curWCShc INTO @SeqNum, @OPCenter, @RunRef, @RunNo, @OpNo, @RunSch,@OpTotHrs " & vbCrLf
      sSql = sSql & "      WHILE (@@FETCH_STATUS <> -1)  " & vbCrLf
      sSql = sSql & "      BEGIN  " & vbCrLf
      sSql = sSql & "         IF (@@FETCH_STATUS <> -2)  " & vbCrLf
      sSql = sSql & "         BEGIN  " & vbCrLf
      sSql = sSql & "                " & vbCrLf
      sSql = sSql & "--print 'PrevOPCnt:' + @prevOpCnt " & vbCrLf
      sSql = sSql & "--print 'CurOPCnt:' + @OPCenter " & vbCrLf
      sSql = sSql & "--print 'RunSchDate:' + Convert(varchar(48), @RunSch) " & vbCrLf
      sSql = sSql & "         IF (@prevOpCnt <> @OPCenter) " & vbCrLf
      sSql = sSql & "         BEGIN " & vbCrLf
      sSql = sSql & "            SET @CurDate = NULL " & vbCrLf
      sSql = sSql & "            SET @TotWChrs = 0.0 " & vbCrLf
      sSql = sSql & "            SET @RemOpHrs = 0.0 " & vbCrLf
      sSql = sSql & "            SET @prevOpCnt = @OPCenter " & vbCrLf
      sSql = sSql & "         END       " & vbCrLf
      sSql = sSql & "         --// get the Hours for the day " & vbCrLf
      sSql = sSql & "--print 'TotWhrs:' + Convert(varchar(48), @TotWChrs) " & vbCrLf
      sSql = sSql & "--print 'CurDate1:' + Convert(varchar(48), @CurDate) " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "         IF (@TotWChrs <= 0) " & vbCrLf
      sSql = sSql & "         BEGIN " & vbCrLf
      sSql = sSql & "            IF (@CurDate IS NULL) " & vbCrLf
      sSql = sSql & "            BEGIN " & vbCrLf
      sSql = sSql & "               SET @CurDate = @RunSch " & vbCrLf
      sSql = sSql & "--print 'CurDate3:' + Convert(varchar(10),@CurDate, 101) " & vbCrLf
      sSql = sSql & "            END " & vbCrLf
      sSql = sSql & "            ELSE " & vbCrLf
      sSql = sSql & "               SET @CurDate = DATEADD(day, 1, @CurDate) " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "--print 'CurDate4:' + Convert(varchar(10),@CurDate, 101) " & vbCrLf
      sSql = sSql & "                " & vbCrLf
      sSql = sSql & "            select TOP 1 @TotWChrs = (WCCSHH1 + WCCSHH2 + WCCSHH3 + WCCSHH4), @CurDate = WCCDATE " & vbCrLf
      sSql = sSql & "               from wcclTable where WCCCENTER = @OPCenter --'ABRAZE' -- " & vbCrLf
      sSql = sSql & "                  AND WCCDATE >= @CurDate  " & vbCrLf
      sSql = sSql & "            AND (WCCSHH1 + WCCSHH2 + WCCSHH3 + WCCSHH4) > 0 " & vbCrLf
      sSql = sSql & "             " & vbCrLf
      sSql = sSql & "            SET @TotWChrs = @TotWChrs - @RemOpHrs " & vbCrLf
      sSql = sSql & "         END " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "--print 'CurDate2:' + Convert(varchar(10),@CurDate, 101) " & vbCrLf
      sSql = sSql & "--print 'PartRef:' + @RunRef " & vbCrLf
      sSql = sSql & "--print 'Run:' + Convert(varchar(10),@RunNo) " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "         IF (@TotWChrs > 0.0) " & vbCrLf
      sSql = sSql & "         BEGIN " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "            SET @OpCalShc = @CurDate " & vbCrLf
      sSql = sSql & "            IF (@RunSch <= @OpCalShc) " & vbCrLf
      sSql = sSql & "            BEGIN  " & vbCrLf
      sSql = sSql & "               UPDATE #tempWCSch SET OPCALSCHED = @CurDate WHERE OPCENTER = @OPCenter " & vbCrLf
      sSql = sSql & "                        AND RUNREF = @RunRef AND RUNNO = @RunNo AND OPNO =  @OpNo " & vbCrLf
      sSql = sSql & "            END  " & vbCrLf
      sSql = sSql & "            ELSE " & vbCrLf
      sSql = sSql & "            BEGIN " & vbCrLf
      sSql = sSql & "               UPDATE #tempWCSch SET OPCALSCHED = @RunSch WHERE OPCENTER = @OPCenter " & vbCrLf
      sSql = sSql & "                        AND RUNREF = @RunRef AND RUNNO = @RunNo AND OPNO =  @OpNo " & vbCrLf
      sSql = sSql & "               SET @CurDate = @RunSch " & vbCrLf
      sSql = sSql & "                " & vbCrLf
      sSql = sSql & "            END  " & vbCrLf
      sSql = sSql & "            --// only if schedue date is less than current date " & vbCrLf
      sSql = sSql & "--print 'TotWhrs1:' + Convert(varchar(48), @TotWChrs) " & vbCrLf
      sSql = sSql & "             " & vbCrLf
      sSql = sSql & "            SET @RemOpHrs = @OpTotHrs - @TotWChrs " & vbCrLf
      sSql = sSql & "            --SET @TotWChrs = @TotWChrs - @OpTotHrs " & vbCrLf
      sSql = sSql & "--print 'TotWhrs2:' + Convert(varchar(48), @TotWChrs) " & vbCrLf
      sSql = sSql & "--print 'RemOpHrs:' + Convert(varchar(48), @RemOpHrs) " & vbCrLf
      sSql = sSql & "             " & vbCrLf
      sSql = sSql & "            if (@RemOpHrs > 8) " & vbCrLf
      sSql = sSql & "            BEGIN " & vbCrLf
      sSql = sSql & "                " & vbCrLf
      sSql = sSql & "               WHILE (@RemOpHrs > 8) " & vbCrLf
      sSql = sSql & "               BEGIN " & vbCrLf
      sSql = sSql & "                   " & vbCrLf
      sSql = sSql & "                  SET @CurDate = DATEADD(day, 1, @CurDate) " & vbCrLf
      sSql = sSql & "                   " & vbCrLf
      sSql = sSql & "                  select TOP 1 @TotWChrs = (WCCSHH1 + WCCSHH2 + WCCSHH3 + WCCSHH4), @CurDate = WCCDATE " & vbCrLf
      sSql = sSql & "                     from wcclTable where WCCCENTER = @OPCenter AND WCCDATE >= @CurDate  " & vbCrLf
      sSql = sSql & "                  AND (WCCSHH1 + WCCSHH2 + WCCSHH3 + WCCSHH4) > 0 " & vbCrLf
      sSql = sSql & "                   " & vbCrLf
      sSql = sSql & "--print 'CurDate10:' + Convert(varchar(10),@CurDate, 101) " & vbCrLf
      sSql = sSql & "--print 'TotWhrs3:' + Convert(varchar(48), @TotWChrs) " & vbCrLf
      sSql = sSql & "--print 'Count:' + Convert(varchar(48), @@ROWCOUNT) " & vbCrLf
      sSql = sSql & "                  IF (@@ROWCOUNT = 0) " & vbCrLf
      sSql = sSql & "                  BEGIN " & vbCrLf
      sSql = sSql & "                     SET @RemOpHrs = 0.0 " & vbCrLf
      sSql = sSql & "                     SET @TotWChrs = 0.0 " & vbCrLf
      sSql = sSql & "                  END                      " & vbCrLf
      sSql = sSql & "                  SET @RemOpHrs = @RemOpHrs - @TotWChrs " & vbCrLf
      sSql = sSql & "                   " & vbCrLf
      sSql = sSql & "--print 'RemOpHrs1:' + Convert(varchar(48), @RemOpHrs) " & vbCrLf
      sSql = sSql & "                  IF (@RemOpHrs > 60) " & vbCrLf
      sSql = sSql & "                     SET @RemOpHrs = 0.0 " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "--print 'Running Remain Op Hrs:' + Convert(varchar(10),@RemOpHrs) " & vbCrLf
      sSql = sSql & "                   " & vbCrLf
      sSql = sSql & "               END " & vbCrLf
      sSql = sSql & "               --// Back one day as we increase one day in the top " & vbCrLf
      sSql = sSql & "               SET @CurDate = DATEADD(day, -1, @CurDate) " & vbCrLf
      sSql = sSql & "               SET @TotWChrs = 0.0 " & vbCrLf
      sSql = sSql & "            END " & vbCrLf
      sSql = sSql & "          " & vbCrLf
      sSql = sSql & "         END  " & vbCrLf
      sSql = sSql & "            --// Tot hrs " & vbCrLf
      sSql = sSql & "         SET @prevOpCnt = @OPCenter  " & vbCrLf
      sSql = sSql & "          " & vbCrLf
      sSql = sSql & "            FETCH NEXT FROM curWCShc INTO @SeqNum, @OPCenter, @RunRef, @RunNo, @OpNo, @RunSch,@OpTotHrs " & vbCrLf
      sSql = sSql & "         END  " & vbCrLf
      sSql = sSql & "      END  " & vbCrLf
      sSql = sSql & "  " & vbCrLf
      sSql = sSql & "      CLOSE curWCShc --// close the cursor  " & vbCrLf
      sSql = sSql & "      DEALLOCATE curWCShc  " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "  " & vbCrLf
      sSql = sSql & "   SELECT SEQNUM, OPCENTER,RUNREF , RUNNO, OPNO, RUNSCHED, OPCALSCHED,RUNQTY,OPYIELD, OPSETUP,  " & vbCrLf
      sSql = sSql & "      OPQHRS, OPMHRS, OPSUHRS, OPUNITHRS, OPTOTHRS, RUNPRIORITY,SOCUST,RUMCOMP, OPCOMT " & vbCrLf
      sSql = sSql & "   FROM #tempWCSch ORDER BY OPCENTER, RUNSCHED " & vbCrLf
      sSql = sSql & "    " & vbCrLf
      sSql = sSql & "   Drop table #tempWCSch  " & vbCrLf
      sSql = sSql & "  " & vbCrLf
      sSql = sSql & "END  "
      
      ExecuteScript False, sSql

      If (TableExists("EsReportASNManifest")) Then
         sSql = "DROP TABLE EsReportASNManifest"
         ExecuteScript False, sSql
      End If

      sSql = "CREATE TABLE [dbo].[EsReportASNManifest](" & vbCrLf
      sSql = sSql & "   [PSSHIPNO] int NULL," & vbCrLf
      sSql = sSql & "   [PSPRESHIPNO] varchar(10) NULL," & vbCrLf
      sSql = sSql & "   [PSCUST][varchar](10) NULL," & vbCrLf
      sSql = sSql & "   [SHPFRMIDCODE] [varchar](9) NULL," & vbCrLf
      sSql = sSql & "   [PSSTNAME] [varchar](40) NULL," & vbCrLf
      sSql = sSql & "   [PSSTADR] [varchar](255) NULL," & vbCrLf
      sSql = sSql & "   [SOPO] [varchar](20) NULL," & vbCrLf
      sSql = sSql & "   [PSNUMBER] [varchar](8) NULL," & vbCrLf
      sSql = sSql & "   [PSCARTON] real NULL" & vbCrLf
      sSql = sSql & ") ON [PRIMARY]"

      ExecuteScript False, sSql
      
      If StoreProcedureExists("RptVendorDelPerformance") Then
         sSql = "DROP PROCEDURE RptVendorDelPerformance"
         ExecuteScript False, sSql
      End If

      sSql = "CREATE PROCEDURE [dbo].[RptVendorDelPerformance]" & vbCrLf
      sSql = sSql & "   @sVendorRef as VARCHAR(10)," & vbCrLf
      sSql = sSql & "   @sBeginDate as VARCHAR(10)," & vbCrLf
      sSql = sSql & "   @sEndDate as VARCHAR(10)," & vbCrLf
      sSql = sSql & "   @iAllowDaysEarly as INTEGER," & vbCrLf
      sSql = sSql & "   @iAllowDaysLate as INTEGER," & vbCrLf
      sSql = sSql & "   @iUseOriginalShipDate as INTEGER" & vbCrLf
      sSql = sSql & " AS " & vbCrLf
      sSql = sSql & " BEGIN " & vbCrLf
      sSql = sSql & "  -- SET NOCOUNT ON added to prevent extra result sets from" & vbCrLf
      sSql = sSql & "  -- interfering with SELECT statements." & vbCrLf
      sSql = sSql & "  SET NOCOUNT ON;" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "  IF (UPPER(@sVendorRef) = 'ALL') Or (UPPER(@sVendorRef) = '<ALL>')" & vbCrLf
      sSql = sSql & "     BEGIN " & vbCrLf
      sSql = sSql & "        SET @sVendorRef = ''" & vbCrLf
      sSql = sSql & "     End" & vbCrLf
      sSql = sSql & "     IF (@iAllowDaysEarly > 0)" & vbCrLf
      sSql = sSql & "     BEGIN " & vbCrLf
      sSql = sSql & "        SET @iAllowDaysEarly = @iAllowDaysEarly * -1" & vbCrLf
      sSql = sSql & "     End" & vbCrLf
      sSql = sSql & "     -- Insert statements for procedure here" & vbCrLf
      sSql = sSql & "  SELECT DISTINCT VEREF, VEBNAME, PINUMBER, PIRELEASE, PIITEM, PIREV, PIPART, PARTNUM, PIADATE, PIPDATE, PIPQTY, PIAQTY, PIONDOCKINSPDATE," & vbCrLf
      sSql = sSql & "            PIINSDATE , PIRECEIVED, PIONDOCKINSPECTED, PIODDELDATE, PIPORIGDATE, PIONDOCKQTYACC, PIONDOCKQTYREJ, PIODDELQTY, PIREJECTED, PIWASTE, PIONDOCKQTYWASTE, " & vbCrLf
      sSql = sSql & "            PIESTUNIT, ISNULL(INPQTY,0.0000) AS INPQTY, ISNULL(INAQTY,0.0000) AS INAQTY, ISNULL(INAMT,0.0000) AS INAMT, ISNULL(INPOITEM,0) AS INPOITEM," & vbCrLf
      sSql = sSql & "            ISNULL(INPOREV,'') AS INPOREV, ISNULL(INPONUMBER,0) AS INPONUMBER, ISNULL(INPORELEASE,0) AS INPORELEASE, ISNULL(INTYPE,0) AS INTYPE," & vbCrLf
      sSql = sSql & "         CASE WHEN ISNULL(PIODDELDATE, '')>'' THEN PIODDELDATE" & vbCrLf
      sSql = sSql & "         WHEN ISNULL(PIONDOCKINSPDATE,'')>'' THEN PIONDOCKINSPDATE" & vbCrLf
      sSql = sSql & "         ELSE PIADATE END AS 'DELIVERYDATE'," & vbCrLf
      sSql = sSql & "            CASE WHEN (ISNULL(PIRECEIVED,'')='') AND (ISNULL(PIINSDATE,'')='') AND (ISNULL(PIODDELDATE,'')='') THEN 'PO'" & vbCrLf
      sSql = sSql & "                 WHEN (ISNULL(PIRECEIVED,'')='') AND (ISNULL(PIINSDATE,'')='') THEN 'DEL'" & vbCrLf
      sSql = sSql & "                 WHEN (ISNULL(PIRECEIVED,'')='') THEN 'DOCK'" & vbCrLf
      sSql = sSql & "                 WHEN PIRECEIVED > '01/01/1900' THEN 'REC' ELSE '' END AS 'STATUS'," & vbCrLf
      sSql = sSql & "            CASE WHEN (@iUseOriginalShipDate=1) AND (ISNULL(PIPORIGDATE,''))='' THEN PIPDATE" & vbCrLf
      sSql = sSql & "                 WHEN (@iUseOriginalShipDate=1) THEN PIPORIGDATE" & vbCrLf
      sSql = sSql & "                 ELSE PIPDATE END AS 'DUEDATE'" & vbCrLf
      sSql = sSql & "     From VndrTable" & vbCrLf
      sSql = sSql & "     INNER JOIN PoitTable ON VEREF=PIVENDOR" & vbCrLf
      sSql = sSql & "     LEFT OUTER JOIN InvaTable ON INPONUMBER=PINUMBER AND INPORELEASE=PIRELEASE AND INPOREV=PIREV AND INPOITEM=PIITEM" & vbCrLf
      sSql = sSql & "     LEFT OUTER JOIN PartTable ON PARTREF=PIPART" & vbCrLf
      sSql = sSql & "  Where " & vbCrLf
      sSql = sSql & "     VEREF LIKE @sVendorRef + '%' AND INTYPE = 15" & vbCrLf
      sSql = sSql & "     AND" & vbCrLf
      sSql = sSql & "     ((PIADATE IS NOT NULL) OR (PIODDELDATE IS NOT NULL) OR (PIONDOCKINSPDATE IS NOT NULL))" & vbCrLf
      sSql = sSql & "  AND" & vbCrLf
      sSql = sSql & "  (" & vbCrLf
      sSql = sSql & "      (PIADATE IS NOT NULL AND PIADATE BETWEEN DateAdd(day, @iAllowDaysEarly, Cast(@sBeginDate AS DateTime)) AND DateAdd(day, @iAllowDaysLate, Cast(@sEndDate AS DateTime)))" & vbCrLf
      sSql = sSql & "  )" & vbCrLf
      sSql = sSql & " End"
      
      ExecuteScript False, sSql

      If Not ColumnExists("ASNInfoTable", "BOEINGPART") Then
         sSql = "ALTER TABLE dbo.ASNInfoTable  ADD [BOEINGPART] [smallint] NULL" _
                  & " CONSTRAINT DF_ASNInfoTable_BOEINGPART DEFAULT 0"
         ExecuteScript False, sSql
      End If

      ' update the version
      ExecuteScript False, "Update Version Set Version = " & newver
   
   End If
End Function


Private Function UpdateDatabase58()

   newver = 132
   If ver < newver Then

      If (TableExists("EsReportASNManifest")) Then
         sSql = "DROP TABLE EsReportASNManifest"
         ExecuteScript False, sSql
      End If

      sSql = "CREATE TABLE [dbo].[EsReportASNManifest](" & vbCrLf
      sSql = sSql & "   [PSSHIPNO] [int] NULL," & vbCrLf
      sSql = sSql & "   [PSCUST] [varchar](10) NULL," & vbCrLf
      sSql = sSql & "   [SHPFRMIDCODE] [varchar](9) NULL," & vbCrLf
      sSql = sSql & "   [PSSTNAME] [varchar](40) NULL," & vbCrLf
      sSql = sSql & "   [PSSTADR] [varchar](255) NULL," & vbCrLf
      sSql = sSql & "   [SOPO] [varchar](20) NULL," & vbCrLf
      sSql = sSql & "   [PSNUMBER] [varchar](8) NULL," & vbCrLf
      sSql = sSql & "   [PSCARTON] [real] NULL," & vbCrLf
      sSql = sSql & "   [PSPRESHIPNO] [varchar](10) NULL," & vbCrLf
      sSql = sSql & "   [PSBOXES] [smallint] NULL," & vbCrLf
      sSql = sSql & "   [PSGROSSLBS] [decimal](7, 2) NULL" & vbCrLf
      sSql = sSql & ") ON [PRIMARY]"

      ExecuteScript False, sSql

      If Not ColumnExists("ASNInfoTable", "BOEINGPART") Then
         sSql = "ALTER ASNInfoTable ADD BOEINGPART smallint null"
         ExecuteScript False, sSql
      End If

      If Not ColumnExists("ASNInfoTable", "LASTMANFSTNUM") Then
         sSql = "ALTER ASNInfoTable ADD BOEINGPART smallint null"
         ExecuteScript False, sSql
      End If

      
      If Not ColumnExists("ComnTable", "COIGNQYTRPTSO") Then
         sSql = "ALTER TABLE dbo.ComnTable ADD COIGNQYTRPTSO smallint null"
         ExecuteScript False, sSql
      End If

      If Not ColumnExists("ComnTable", "COTOPSUMACCT") Then
         sSql = "ALTER TABLE dbo.ComnTable ADD COTOPSUMACCT smallint null"
         ExecuteScript False, sSql
      End If


      If (Not TableExists("GlmsTopTable")) Then
         sSql = "CREATE TABLE [dbo].[GlmsTopTable](" & vbCrLf
         sSql = sSql & "   [COACCTREC] [tinyint] NOT NULL," & vbCrLf
         sSql = sSql & "   [COASSTTYPE] [tinyint] NULL," & vbCrLf
         sSql = sSql & "   [COASSTREF] [char](12) NULL," & vbCrLf
         sSql = sSql & "   [COASSTACCT] [char](12) NULL," & vbCrLf
         sSql = sSql & "   [COASSTDESC] [char](40) NULL," & vbCrLf
         sSql = sSql & "   [COLIABTYPE] [tinyint] NULL," & vbCrLf
         sSql = sSql & "   [COLIABREF] [char](12) NULL," & vbCrLf
         sSql = sSql & "   [COLIABACCT] [char](12) NULL," & vbCrLf
         sSql = sSql & "   [COLIABDESC] [char](40) NULL," & vbCrLf
         sSql = sSql & "   [COEQTYTYPE] [tinyint] NULL," & vbCrLf
         sSql = sSql & "   [COEQTYREF] [char](12) NULL," & vbCrLf
         sSql = sSql & "   [COEQTYACCT] [char](12) NULL," & vbCrLf
         sSql = sSql & "   [COEQTYDESC] [char](40) NULL," & vbCrLf
         sSql = sSql & "   [COINCMTYPE] [tinyint] NULL," & vbCrLf
         sSql = sSql & "   [COINCMREF] [char](12) NULL," & vbCrLf
         sSql = sSql & "   [COINCMACCT] [char](12) NULL," & vbCrLf
         sSql = sSql & "   [COINCMDESC] [char](40) NULL," & vbCrLf
         sSql = sSql & "   [COEXPNTYPE] [tinyint] NULL," & vbCrLf
         sSql = sSql & "   [COEXPNREF] [char](12) NULL," & vbCrLf
         sSql = sSql & "   [COEXPNACCT] [char](12) NULL," & vbCrLf
         sSql = sSql & "   [COEXPNDESC] [char](40) NULL," & vbCrLf
         sSql = sSql & "   [COCOGSTYPE] [tinyint] NULL," & vbCrLf
         sSql = sSql & "   [COCOGSREF] [char](12) NULL," & vbCrLf
         sSql = sSql & "   [COCOGSACCT] [char](12) NULL," & vbCrLf
         sSql = sSql & "   [COCOGSDESC] [char](40) NULL," & vbCrLf
         sSql = sSql & "   [COOINCTYPE] [tinyint] NULL," & vbCrLf
         sSql = sSql & "   [COOINCREF] [char](12) NULL," & vbCrLf
         sSql = sSql & "   [COOINCACCT] [char](12) NULL," & vbCrLf
         sSql = sSql & "   [COOINCDESC] [char](40) NULL," & vbCrLf
         sSql = sSql & "   [COOEXPTYPE] [tinyint] NULL," & vbCrLf
         sSql = sSql & "   [COOEXPREF] [char](12) NULL," & vbCrLf
         sSql = sSql & "   [COOEXPACCT] [char](12) NULL," & vbCrLf
         sSql = sSql & "   [COOEXPDESC] [char](40) NULL," & vbCrLf
         sSql = sSql & "   [COFDTXTYPE] [tinyint] NULL," & vbCrLf
         sSql = sSql & "   [COFDTXREF] [char](12) NULL," & vbCrLf
         sSql = sSql & "   [COFDTXACCT] [char](12) NULL," & vbCrLf
         sSql = sSql & "   [COFDTXDESC] [char](40) NULL," & vbCrLf
         sSql = sSql & " CONSTRAINT [PK_GlmsTopTable_ACCOUNTREF] PRIMARY KEY CLUSTERED " & vbCrLf
         sSql = sSql & "(" & vbCrLf
         sSql = sSql & "   [COACCTREC] ASC" & vbCrLf
         sSql = sSql & ")WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 80) ON [PRIMARY]" & vbCrLf
         sSql = sSql & ") ON [PRIMARY]" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "ALTER TABLE [dbo].[GlmsTopTable] ADD  CONSTRAINT [DF_GlmsTopTable_COACCTREC]  DEFAULT ((0)) FOR [COACCTREC]" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "ALTER TABLE [dbo].[GlmsTopTable] ADD  CONSTRAINT [DF_GlmsTopTable_COASSTTYPE]  DEFAULT ((0)) FOR [COASSTTYPE]" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "ALTER TABLE [dbo].[GlmsTopTable] ADD  CONSTRAINT [DF_GlmsTopTable_COASSTREF]  DEFAULT ('') FOR [COASSTREF]" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "ALTER TABLE [dbo].[GlmsTopTable] ADD  CONSTRAINT [DF_GlmsTopTable_COASSTACCT]  DEFAULT ('') FOR [COASSTACCT]" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "ALTER TABLE [dbo].[GlmsTopTable] ADD  CONSTRAINT [DF_GlmsTopTable_COASSTDESC]  DEFAULT ('') FOR [COASSTDESC]" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "ALTER TABLE [dbo].[GlmsTopTable] ADD  CONSTRAINT [DF_GlmsTopTable_COLIABTYPE]  DEFAULT ((0)) FOR [COLIABTYPE]" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "ALTER TABLE [dbo].[GlmsTopTable] ADD  CONSTRAINT [DF_GlmsTopTable_COLIABREF]  DEFAULT ('') FOR [COLIABREF]" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "ALTER TABLE [dbo].[GlmsTopTable] ADD  CONSTRAINT [DF_GlmsTopTable_COLIABACCT]  DEFAULT ('') FOR [COLIABACCT]" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "ALTER TABLE [dbo].[GlmsTopTable] ADD  CONSTRAINT [DF_GlmsTopTable_COLIABDESC]  DEFAULT ('') FOR [COLIABDESC]" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "ALTER TABLE [dbo].[GlmsTopTable] ADD  CONSTRAINT [DF_GlmsTopTable_COEQTYTYPE]  DEFAULT ((0)) FOR [COEQTYTYPE]" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "ALTER TABLE [dbo].[GlmsTopTable] ADD  CONSTRAINT [DF_GlmsTopTable_COEQTYREF]  DEFAULT ('') FOR [COEQTYREF]" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "ALTER TABLE [dbo].[GlmsTopTable] ADD  CONSTRAINT [DF_GlmsTopTable_COEQTYACCT]  DEFAULT ('') FOR [COEQTYACCT]" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "ALTER TABLE [dbo].[GlmsTopTable] ADD  CONSTRAINT [DF_GlmsTopTable_COEQTYDESC]  DEFAULT ('') FOR [COEQTYDESC]" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "ALTER TABLE [dbo].[GlmsTopTable] ADD  CONSTRAINT [DF_GlmsTopTable_COINCMTYPE]  DEFAULT ((0)) FOR [COINCMTYPE]" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "ALTER TABLE [dbo].[GlmsTopTable] ADD  CONSTRAINT [DF_GlmsTopTable_COINCMREF]  DEFAULT ('') FOR [COINCMREF]" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "ALTER TABLE [dbo].[GlmsTopTable] ADD  CONSTRAINT [DF_GlmsTopTable_COINCMACCT]  DEFAULT ('') FOR [COINCMACCT]" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "ALTER TABLE [dbo].[GlmsTopTable] ADD  CONSTRAINT [DF_GlmsTopTable_COINCMDESC]  DEFAULT ('') FOR [COINCMDESC]" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "ALTER TABLE [dbo].[GlmsTopTable] ADD  CONSTRAINT [DF_GlmsTopTable_COEXPNTYPE]  DEFAULT ((0)) FOR [COEXPNTYPE]" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "ALTER TABLE [dbo].[GlmsTopTable] ADD  CONSTRAINT [DF_GlmsTopTable_COEXPNREF]  DEFAULT ('') FOR [COEXPNREF]" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "ALTER TABLE [dbo].[GlmsTopTable] ADD  CONSTRAINT [DF_GlmsTopTable_COEXPNACCT]  DEFAULT ('') FOR [COEXPNACCT]" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "ALTER TABLE [dbo].[GlmsTopTable] ADD  CONSTRAINT [DF_GlmsTopTable_COEXPNDESC]  DEFAULT ('') FOR [COEXPNDESC]" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "ALTER TABLE [dbo].[GlmsTopTable] ADD  CONSTRAINT [DF_GlmsTopTable_COCOGSTYPE]  DEFAULT ((0)) FOR [COCOGSTYPE]" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "ALTER TABLE [dbo].[GlmsTopTable] ADD  CONSTRAINT [DF_GlmsTopTable_COCOGSREF]  DEFAULT ('') FOR [COCOGSREF]" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "ALTER TABLE [dbo].[GlmsTopTable] ADD  CONSTRAINT [DF_GlmsTopTable_COCOGSACCT]  DEFAULT ('') FOR [COCOGSACCT]" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "ALTER TABLE [dbo].[GlmsTopTable] ADD  CONSTRAINT [DF_GlmsTopTable_COCOGSDESC]  DEFAULT ('') FOR [COCOGSDESC]" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "ALTER TABLE [dbo].[GlmsTopTable] ADD  CONSTRAINT [DF_GlmsTopTable_COOINCTYPE]  DEFAULT ((0)) FOR [COOINCTYPE]" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "ALTER TABLE [dbo].[GlmsTopTable] ADD  CONSTRAINT [DF_GlmsTopTable_COOINCREF]  DEFAULT ('') FOR [COOINCREF]" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "ALTER TABLE [dbo].[GlmsTopTable] ADD  CONSTRAINT [DF_GlmsTopTable_COOINCACCT]  DEFAULT ('') FOR [COOINCACCT]" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "ALTER TABLE [dbo].[GlmsTopTable] ADD  CONSTRAINT [DF_GlmsTopTable_COOINCDESC]  DEFAULT ('') FOR [COOINCDESC]" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "ALTER TABLE [dbo].[GlmsTopTable] ADD  CONSTRAINT [DF_GlmsTopTable_COOEXPTYPE]  DEFAULT ((0)) FOR [COOEXPTYPE]" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "ALTER TABLE [dbo].[GlmsTopTable] ADD  CONSTRAINT [DF_GlmsTopTable_COOEXPREF]  DEFAULT ('') FOR [COOEXPREF]" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "ALTER TABLE [dbo].[GlmsTopTable] ADD  CONSTRAINT [DF_GlmsTopTable_COOEXPACCT]  DEFAULT ('') FOR [COOEXPACCT]" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "ALTER TABLE [dbo].[GlmsTopTable] ADD  CONSTRAINT [DF_GlmsTopTable_COOEXPDESC]  DEFAULT ('') FOR [COOEXPDESC]" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "ALTER TABLE [dbo].[GlmsTopTable] ADD  CONSTRAINT [DF_GlmsTopTable_COFDTXTYPE]  DEFAULT ((0)) FOR [COFDTXTYPE]" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "ALTER TABLE [dbo].[GlmsTopTable] ADD  CONSTRAINT [DF_GlmsTopTable_COFDTXREF]  DEFAULT ('') FOR [COFDTXREF]" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "ALTER TABLE [dbo].[GlmsTopTable] ADD  CONSTRAINT [DF_GlmsTopTable_COFDTXACCT]  DEFAULT ('') FOR [COFDTXACCT]" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "ALTER TABLE [dbo].[GlmsTopTable] ADD  CONSTRAINT [DF_GlmsTopTable_COFDTXDESC]  DEFAULT ('') FOR [COFDTXDESC]" & vbCrLf
         
         ExecuteScript False, sSql
      End If

      If (Not TableExists("GlacTopTable")) Then

         sSql = "CREATE TABLE [dbo].[GlacTopTable](" & vbCrLf
         sSql = sSql & "   [GLACCTREF] [char](12) NOT NULL," & vbCrLf
         sSql = sSql & "   [GLACCTNO] [char](12) NULL," & vbCrLf
         sSql = sSql & "   [GLDESCR] [char](40) NULL," & vbCrLf
         sSql = sSql & "   [GLMASTER] [char](12) NULL," & vbCrLf
         sSql = sSql & "   [GLTYPE] [int] NULL," & vbCrLf
         sSql = sSql & "   [GLINACTIVE] [tinyint] NULL," & vbCrLf
         sSql = sSql & "   [GLCASH] [tinyint] NULL," & vbCrLf
         sSql = sSql & "   [GLJOBREQ] [tinyint] NULL," & vbCrLf
         sSql = sSql & "   [GLBUREQ] [tinyint] NULL," & vbCrLf
         sSql = sSql & "   [GLDEBIT] [decimal](13, 2) NULL," & vbCrLf
         sSql = sSql & "   [GLCREDIT] [decimal](13, 2) NULL," & vbCrLf
         sSql = sSql & "   [GLFSLEVEL] [int] NULL," & vbCrLf
         sSql = sSql & "   [GLTOTAL] [decimal](13, 2) NULL," & vbCrLf
         sSql = sSql & "   [GLPERTOTAL] [decimal](13, 2) NULL," & vbCrLf
         sSql = sSql & "   [GLBUDGET] [decimal](13, 2) NULL," & vbCrLf
         sSql = sSql & "   [GLPERBUDGET] [decimal](13, 2) NULL," & vbCrLf
         sSql = sSql & "   [GLPREVTOTAL] [decimal](13, 2) NULL," & vbCrLf
         sSql = sSql & "   [GLDELETE] [tinyint] NULL," & vbCrLf
         sSql = sSql & "   [GLROLLACCT] [char](12) NULL," & vbCrLf
         sSql = sSql & "   [GLVENDOR] [char](10) NULL," & vbCrLf
         sSql = sSql & "   [GLRECDATE] [smalldatetime] NULL," & vbCrLf
         sSql = sSql & "   [GLRECBY] [char](3) NULL," & vbCrLf
         sSql = sSql & "   [GLRECBAL] [decimal](13, 2) NULL," & vbCrLf
         sSql = sSql & "   [GLLASTCHK] [char](12) NULL," & vbCrLf
         sSql = sSql & " CONSTRAINT [PK_GlacTopTable_GLACCTREF] PRIMARY KEY CLUSTERED " & vbCrLf
         sSql = sSql & "(" & vbCrLf
         sSql = sSql & "   [GLACCTREF] ASC" & vbCrLf
         sSql = sSql & ")WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 80) ON [PRIMARY]" & vbCrLf
         sSql = sSql & ") ON [PRIMARY]" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "ALTER TABLE [dbo].[GlacTopTable] ADD  CONSTRAINT [DF_GlacTopTable_GLACCTREF]  DEFAULT ('') FOR [GLACCTREF]" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "ALTER TABLE [dbo].[GlacTopTable] ADD  CONSTRAINT [DF_GlacTopTable_GLACCTNO]  DEFAULT ('') FOR [GLACCTNO]" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "ALTER TABLE [dbo].[GlacTopTable] ADD  CONSTRAINT [DF_GlacTopTable_GLDESCR]  DEFAULT ('') FOR [GLDESCR]" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "ALTER TABLE [dbo].[GlacTopTable] ADD  CONSTRAINT [DF_GlacTopTable_GLMASTER]  DEFAULT ('') FOR [GLMASTER]" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "ALTER TABLE [dbo].[GlacTopTable] ADD  CONSTRAINT [DF_GlacTopTable_GLTYPE]  DEFAULT ((0)) FOR [GLTYPE]" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "ALTER TABLE [dbo].[GlacTopTable] ADD  CONSTRAINT [DF_GlacTopTable_GLINACTIVE]  DEFAULT ((0)) FOR [GLINACTIVE]" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "ALTER TABLE [dbo].[GlacTopTable] ADD  CONSTRAINT [DF_GlacTopTable_GLCASH]  DEFAULT ((0)) FOR [GLCASH]" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "ALTER TABLE [dbo].[GlacTopTable] ADD  CONSTRAINT [DF_GlacTopTable_GLJOBREQ]  DEFAULT ((0)) FOR [GLJOBREQ]" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "ALTER TABLE [dbo].[GlacTopTable] ADD  CONSTRAINT [DF_GlacTopTable_GLBUREQ]  DEFAULT ((0)) FOR [GLBUREQ]" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "ALTER TABLE [dbo].[GlacTopTable] ADD  CONSTRAINT [DF_GlacTopTable_GLFSLEVEL]  DEFAULT ((0)) FOR [GLFSLEVEL]" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "ALTER TABLE [dbo].[GlacTopTable] ADD  CONSTRAINT [DF_GlacTopTable_GLDELETE]  DEFAULT ((0)) FOR [GLDELETE]" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "ALTER TABLE [dbo].[GlacTopTable] ADD  CONSTRAINT [DF_GlacTopTable_GLROLLACCT]  DEFAULT ('') FOR [GLROLLACCT]" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "ALTER TABLE [dbo].[GlacTopTable] ADD  CONSTRAINT [DF_GlacTopTable_GLVENDOR]  DEFAULT ('') FOR [GLVENDOR]" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "ALTER TABLE [dbo].[GlacTopTable] ADD  CONSTRAINT [DF_GlacTopTable_GLRECDATE]  DEFAULT ('') FOR [GLRECDATE]" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "ALTER TABLE [dbo].[GlacTopTable] ADD  CONSTRAINT [DF_GlacTopTable_GLRECBY]  DEFAULT ('') FOR [GLRECBY]" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "ALTER TABLE [dbo].[GlacTopTable] ADD  CONSTRAINT [DF_GlacTopTable_GLLASTCHK]  DEFAULT ('') FOR [GLLASTCHK]" & vbCrLf

         ExecuteScript False, sSql
      End If

      If (Not TableExists("GjitTopTable")) Then

         sSql = "CREATE TABLE [dbo].[GjitTopTable](" & vbCrLf
         sSql = sSql & "   [JINAME] [char](12) NOT NULL," & vbCrLf
         sSql = sSql & "   [JIDESC] [char](30) NULL," & vbCrLf
         sSql = sSql & "   [JITRAN] [int] NULL," & vbCrLf
         sSql = sSql & "   [JIREF] [int] NULL," & vbCrLf
         sSql = sSql & "   [JIACCOUNT] [char](12) NULL," & vbCrLf
         sSql = sSql & "   [JICHILDACCOUNT] [char](12) NULL," & vbCrLf
         sSql = sSql & "   [JIDEB] [decimal](13, 2) NULL," & vbCrLf
         sSql = sSql & "   [JICRD] [decimal](13, 2) NULL," & vbCrLf
         sSql = sSql & "   [JIDATE] [smalldatetime] NULL," & vbCrLf
         sSql = sSql & "   [JILASTREVBY] [char](3) NULL," & vbCrLf
         sSql = sSql & "   [JICLEAR] [smalldatetime] NULL" & vbCrLf
         sSql = sSql & ") ON [PRIMARY]" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "ALTER TABLE [dbo].[GjitTopTable]  WITH CHECK ADD  CONSTRAINT [FK_GjitTopTable_GjhdTable] FOREIGN KEY([JINAME])" & vbCrLf
         sSql = sSql & "REFERENCES [dbo].[GjhdTable] ([GJNAME])" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "ALTER TABLE [dbo].[GjitTopTable] CHECK CONSTRAINT [FK_GjitTopTable_GjhdTable]" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "ALTER TABLE [dbo].[GjitTopTable]  WITH CHECK ADD  CONSTRAINT [FK_GjitTopTable_GlacTopTable] FOREIGN KEY([JIACCOUNT])" & vbCrLf
         sSql = sSql & "REFERENCES [dbo].[GlacTopTable] ([GLACCTREF])" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "ALTER TABLE [dbo].[GjitTopTable] CHECK CONSTRAINT [FK_GjitTopTable_GlacTopTable]" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "ALTER TABLE [dbo].[GjitTopTable] ADD  CONSTRAINT [DF_GjitTopTable_JINAME]  DEFAULT ('') FOR [JINAME]" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "ALTER TABLE [dbo].[GjitTopTable] ADD  CONSTRAINT [DF_GjitTopTable_JIDESC]  DEFAULT ('') FOR [JIDESC]" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "ALTER TABLE [dbo].[GjitTopTable] ADD  CONSTRAINT [DF_GjitTopTable_JITRAN]  DEFAULT ('') FOR [JITRAN]" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "ALTER TABLE [dbo].[GjitTopTable] ADD  CONSTRAINT [DF_GjitTopTable_JIREF]  DEFAULT ((0)) FOR [JIREF]" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "ALTER TABLE [dbo].[GjitTopTable] ADD  CONSTRAINT [DF_GjitTopTable_JIACCOUNT]  DEFAULT ('') FOR [JIACCOUNT]" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "ALTER TABLE [dbo].[GjitTopTable] ADD  CONSTRAINT [DF_GjitTopTable_JIDATE]  DEFAULT (getdate()) FOR [JIDATE]" & vbCrLf
         sSql = sSql & "" & vbCrLf
         sSql = sSql & "ALTER TABLE [dbo].[GjitTopTable] ADD  CONSTRAINT [DF_GjitTopTable_JILASTREVBY]  DEFAULT ('') FOR [JILASTREVBY]" & vbCrLf

         ExecuteScript False, sSql
      End If

      If StoreProcedureExists("RptTopIncomeStatement") Then
         sSql = "DROP PROCEDURE RptTopIncomeStatement"
         ExecuteScript False, sSql
      End If

      sSql = "CREATE PROCEDURE [dbo].[RptTopIncomeStatement]" & vbCrLf
      sSql = sSql & "   @StartDate as varchar(12),@EndDate as varchar(12)," & vbCrLf
      sSql = sSql & "   @YearBeginDate as varchar(12), @InclIncAcct as varchar(1)" & vbCrLf
      sSql = sSql & "AS " & vbCrLf
      sSql = sSql & "BEGIN" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   declare @glAcctRef as varchar(10)" & vbCrLf
      sSql = sSql & "   declare @glMsAcct as varchar(10)" & vbCrLf
      sSql = sSql & "   declare @SumCurBal decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @SumYTD decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @SumPrevBal as decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @level as integer" & vbCrLf
      sSql = sSql & "   declare @TopLevelDesc as varchar(30)" & vbCrLf
      sSql = sSql & "   declare @InclInAcct as Integer" & vbCrLf
      sSql = sSql & "   declare @TopLevAcct as varchar(20)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   declare @PrevMaster as varchar(10)" & vbCrLf
      sSql = sSql & "   declare @RowCount as integer" & vbCrLf
      sSql = sSql & "   declare @GlMasterAcc as varchar(10)" & vbCrLf
      sSql = sSql & "   declare @GlChildAcct as varchar(10)" & vbCrLf
      sSql = sSql & "   declare @ChildKey as varchar(1024)" & vbCrLf
      sSql = sSql & "   declare @GLSortKey as varchar(1024)" & vbCrLf
      sSql = sSql & "   declare @SortKey as varchar(1024)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   DELETE FROM EsReportIncStatement" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   if (@InclIncAcct = '1')" & vbCrLf
      sSql = sSql & "      SET @InclInAcct = ''" & vbCrLf
      sSql = sSql & "   Else" & vbCrLf
      sSql = sSql & "      SET @InclInAcct = '0'" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   DECLARE balAcctStruc CURSOR  FOR" & vbCrLf
      sSql = sSql & "      SELECT '4', COINCMACCT, COINCMDESC FROM GlmsTopTable" & vbCrLf
      sSql = sSql & "      Union All" & vbCrLf
      sSql = sSql & "      SELECT '5', COCOGSACCT, COCOGSDESC FROM GlmsTopTable" & vbCrLf
      sSql = sSql & "      Union All" & vbCrLf
      sSql = sSql & "      SELECT '6', COEXPNACCT, COEXPNDESC FROM GlmsTopTable" & vbCrLf
      sSql = sSql & "      Union All" & vbCrLf
      sSql = sSql & "      SELECT '7', COOINCACCT, COOINCDESC FROM GlmsTopTable" & vbCrLf
      sSql = sSql & "      Union All" & vbCrLf
      sSql = sSql & "      SELECT '8', COOEXPACCT, COOEXPDESC FROM GlmsTopTable" & vbCrLf
      sSql = sSql & "      Union All" & vbCrLf
      sSql = sSql & "      SELECT '9', COFDTXACCT, COFDTXDESC FROM GlmsTopTable" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   OPEN balAcctStruc" & vbCrLf
      sSql = sSql & "   FETCH NEXT FROM balAcctStruc INTO @level,@TopLevAcct, @TopLevelDesc" & vbCrLf
      sSql = sSql & "   WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "      IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "      BEGIN" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "        With cte" & vbCrLf
      sSql = sSql & "        as " & vbCrLf
      sSql = sSql & "        (select GLACCTREF, GLDESCR, GLMASTER, GLFSLEVEL, 1 as level," & vbCrLf
      sSql = sSql & "          cast(cast(@level as varchar(4))+ char(36)+ GLACCTREF as varchar(max)) as SortKey" & vbCrLf
      sSql = sSql & "        From GlacTopTable" & vbCrLf
      sSql = sSql & "        where GLMASTER = cast(@TopLevAcct as varchar(20)) AND GLINACTIVE LIKE @InclInAcct" & vbCrLf
      sSql = sSql & "        Union All" & vbCrLf
      sSql = sSql & "        select a.GLACCTREF, a.GLDESCR, a.GLMASTER, a.GLFSLEVEL, level + 1," & vbCrLf
      sSql = sSql & "         cast(COALESCE(SortKey,'') + char(36) + COALESCE(a.GLACCTREF,'') as varchar(max))as SortKey" & vbCrLf
      sSql = sSql & "        From cte" & vbCrLf
      sSql = sSql & "          inner join GlacTopTable a" & vbCrLf
      sSql = sSql & "            on cte.GLACCTREF = a.GLMASTER" & vbCrLf
      sSql = sSql & "          WHERE GLINACTIVE LIKE @InclInAcct" & vbCrLf
      sSql = sSql & "        )" & vbCrLf
      sSql = sSql & "        INSERT INTO EsReportIncStatement(GLTOPMaster, GLTOPMASTERDESC, GLACCTREF, GLDESCR, GLMASTER, GLFSLEVEL,SORTKEYLEVEL,GLACCSORTKEY)" & vbCrLf
      sSql = sSql & "        select @level, @TopLevelDesc, GLACCTREF, GLDESCR, GLMASTER, GLFSLEVEL, level, SortKey" & vbCrLf
      sSql = sSql & "        from cte order by SortKey" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "      End" & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM balAcctStruc INTO @level,@TopLevAcct, @TopLevelDesc" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "   Close balAcctStruc" & vbCrLf
      sSql = sSql & "   DEALLOCATE balAcctStruc" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   UPDATE EsReportIncStatement SET CurrentBal = foo.Balance--, SUMCURBAL = foo.Balance" & vbCrLf
      sSql = sSql & "   From" & vbCrLf
      sSql = sSql & "       (SELECT SUM(GjitTopTable.JICRD) - SUM(GjitTopTable.JIDEB) as Balance, JIACCOUNT" & vbCrLf
      sSql = sSql & "         FROM GjhdTable INNER JOIN GjitTopTable ON GJNAME = JINAME" & vbCrLf
      sSql = sSql & "      WHERE GJPOST BETWEEN @StartDate AND @EndDate" & vbCrLf
      sSql = sSql & "         AND GjhdTable.GJPOSTED = 1" & vbCrLf
      sSql = sSql & "      GROUP BY JIACCOUNT) as foo" & vbCrLf
      sSql = sSql & "   Where foo.JIACCOUNT = GLACCTREF" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   UPDATE EsReportIncStatement SET YTD = foo.Balance--, SUMYTD = foo.Balance" & vbCrLf
      sSql = sSql & "   From" & vbCrLf
      sSql = sSql & "      (SELECT JIACCOUNT,SUM(GjitTopTable.JICRD) - SUM(GjitTopTable.JIDEB) AS Balance" & vbCrLf
      sSql = sSql & "         FROM GjhdTable INNER JOIN GjitTopTable ON GJNAME = JINAME" & vbCrLf
      sSql = sSql & "      WHERE (GJPOST BETWEEN @YearBeginDate AND @EndDate)" & vbCrLf
      sSql = sSql & "         AND GjhdTable.GJPOSTED = 1" & vbCrLf
      sSql = sSql & "      GROUP BY JIACCOUNT) as foo" & vbCrLf
      sSql = sSql & "   Where foo.JIACCOUNT = GLACCTREF" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   UPDATE EsReportIncStatement SET PreviousBal = foo.Balance--, SUMPREVBAL = foo.Balance" & vbCrLf
      sSql = sSql & "   From" & vbCrLf
      sSql = sSql & "      (SELECT JIACCOUNT,SUM(GjitTopTable.JICRD) - SUM(GjitTopTable.JIDEB) AS Balance" & vbCrLf
      sSql = sSql & "         FROM GjhdTable INNER JOIN GjitTopTable ON GJNAME = JINAME" & vbCrLf
      sSql = sSql & "      WHERE (GJPOST BETWEEN DATEADD(year, -1, @YearBeginDate) AND DATEADD(year, -1, @EndDate))" & vbCrLf
      sSql = sSql & "         AND GjhdTable.GJPOSTED = 1" & vbCrLf
      sSql = sSql & "      GROUP BY JIACCOUNT) as foo" & vbCrLf
      sSql = sSql & "   Where foo.JIACCOUNT = GLACCTREF" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   SELECT @level =  MAX(SORTKEYLEVEL) FROM EsReportIncStatement" & vbCrLf
      sSql = sSql & "   --set @level = 9" & vbCrLf
      sSql = sSql & "   WHILE (@level >= 1 )" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "      DECLARE curAcctStruc CURSOR  FOR" & vbCrLf
      sSql = sSql & "      SELECT GLMASTER, SUM(ISNULL(SUMCURBAL,0) + (ISNULL(CurrentBal,0))) ," & vbCrLf
      sSql = sSql & "         Sum (IsNull(SUMYTD, 0) + (IsNull(YTD, 0))), Sum(IsNull(SUMPREVBAL, 0) + (IsNull(PreviousBal, 0)))" & vbCrLf
      sSql = sSql & "      From" & vbCrLf
      sSql = sSql & "         (SELECT DISTINCT GLACCTREF, GLDESCR, GLMASTER," & vbCrLf
      sSql = sSql & "         CurrentBal , YTD, PreviousBal, SUMCURBAL, SUMYTD, SUMPREVBAL" & vbCrLf
      sSql = sSql & "         FROM EsReportIncStatement WHERE SORTKEYLEVEL = @level) as foo" & vbCrLf
      sSql = sSql & "      group by GLMASTER" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "      OPEN curAcctStruc" & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM curAcctStruc INTO @glMsAcct, @SumCurBal, @SumYTD, @SumPrevBal" & vbCrLf
      sSql = sSql & "      WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "      BEGIN" & vbCrLf
      sSql = sSql & "         IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "         BEGIN" & vbCrLf
      sSql = sSql & "            UPDATE EsReportIncStatement SET SUMCURBAL = @SumCurBal, SUMYTD = @SumYTD," & vbCrLf
      sSql = sSql & "               SUMPREVBAL = @SumPrevBal, GLDESCR = 'TOTAL ' + LTRIM(GLDESCR)," & vbCrLf
      sSql = sSql & "            HASCHILD = 1" & vbCrLf
      sSql = sSql & "            WHERE GLACCTREF = @glMsAcct" & vbCrLf
      sSql = sSql & "         End" & vbCrLf
      sSql = sSql & "         FETCH NEXT FROM curAcctStruc INTO @glMsAcct, @SumCurBal, @SumYTD, @SumPrevBal" & vbCrLf
      sSql = sSql & "      End" & vbCrLf
      sSql = sSql & "      Close curAcctStruc" & vbCrLf
      sSql = sSql & "      DEALLOCATE curAcctStruc" & vbCrLf
      sSql = sSql & "      SET @level = @level - 1" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   UPDATE EsReportIncStatement SET SUMCURBAL = CurrentBal WHERE SUMCURBAL IS NULL" & vbCrLf
      sSql = sSql & "   UPDATE EsReportIncStatement SET SUMPREVBAL = PreviousBal WHERE SUMPREVBAL IS NULL" & vbCrLf
      sSql = sSql & "   UPDATE EsReportIncStatement SET SUMYTD = YTD  WHERE SUMYTD IS NULL" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   set @level = 0 " & vbCrLf
      sSql = sSql & "   set @RowCount = 1" & vbCrLf
      sSql = sSql & "   SET @PrevMaster = ''" & vbCrLf
      sSql = sSql & "   DECLARE curAcctStruc CURSOR  FOR" & vbCrLf
      sSql = sSql & "      SELECT GLMASTER, GLACCSORTKEY" & vbCrLf
      sSql = sSql & "      FROM EsReportIncStatement " & vbCrLf
      sSql = sSql & "         WHERE HASCHILD IS NULL --GLFSLEVEL = 8 --AND GLMASTER ='AA10'--GLTOPMaster = 1 AND " & vbCrLf
      sSql = sSql & "      ORDER BY GLACCSORTKEY" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   OPEN curAcctStruc" & vbCrLf
      sSql = sSql & "   FETCH NEXT FROM curAcctStruc INTO @GlMasterAcc, @GLSortKey" & vbCrLf
      sSql = sSql & "   WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "    IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "    BEGIN" & vbCrLf
      sSql = sSql & "      if (@PrevMaster <> @GlMasterAcc)" & vbCrLf
      sSql = sSql & "      BEGIN" & vbCrLf
      sSql = sSql & "         UPDATE EsReportIncStatement SET " & vbCrLf
      sSql = sSql & "            SortKeyRev = RIGHT ('0000'+ Cast(@RowCount as varchar), 4) + char(36)+ @GlMasterAcc" & vbCrLf
      sSql = sSql & "         WHERE GLMASTER = @GlMasterAcc AND HASCHILD IS NULL --GLFSLEVEL = 8 --AND GLTOPMaster = 1 " & vbCrLf
      sSql = sSql & "         SET @RowCount = @RowCount + 1" & vbCrLf
      sSql = sSql & "         SET @PrevMaster = @GlMasterAcc" & vbCrLf
      sSql = sSql & "      END" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "    End" & vbCrLf
      sSql = sSql & "    FETCH NEXT FROM curAcctStruc INTO @GlMasterAcc, @GLSortKey" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "       " & vbCrLf
      sSql = sSql & "   Close curAcctStruc" & vbCrLf
      sSql = sSql & "   DEALLOCATE curAcctStruc" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "    SELECT @level = MAX(SORTKEYLEVEL) FROM EsReportIncStatement" & vbCrLf
      sSql = sSql & "   --set @level = 7" & vbCrLf
      sSql = sSql & "   WHILE (@level >= 1 )" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "      SET @PrevMaster = ''" & vbCrLf
      sSql = sSql & "        DECLARE curAcctStruc1 CURSOR  FOR" & vbCrLf
      sSql = sSql & "         SELECT DISTINCT GLACCTREF, GLMASTER, GLACCSORTKEY" & vbCrLf
      sSql = sSql & "         FROM EsReportIncStatement " & vbCrLf
      sSql = sSql & "            WHERE SORTKEYLEVEL = @level AND HASCHILD IS NOT NULL--GLTOPMaster = 1 AND " & vbCrLf
      sSql = sSql & "         order by GLACCSORTKEY" & vbCrLf
      sSql = sSql & "    " & vbCrLf
      sSql = sSql & "        OPEN curAcctStruc1" & vbCrLf
      sSql = sSql & "        FETCH NEXT FROM curAcctStruc1 INTO @GlChildAcct, @GlMasterAcc, @GLSortKey" & vbCrLf
      sSql = sSql & "        WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "        BEGIN" & vbCrLf
      sSql = sSql & "          IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "          BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "            if (@PrevMaster <> @GlChildAcct)" & vbCrLf
      sSql = sSql & "            BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   print 'Record' + @GlChildAcct + ':' + @GlMasterAcc" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "               SELECT TOP 1 @ChildKey = SortKeyRev,@SortKey = GLACCSORTKEY" & vbCrLf
      sSql = sSql & "               FROM EsReportIncStatement " & vbCrLf
      sSql = sSql & "                  WHERE SORTKEYLEVEL > @level AND GLMASTER = @GlChildAcct --GLTOPMaster = 1 AND " & vbCrLf
      sSql = sSql & "               order by GLACCSORTKEY desc" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "               UPDATE EsReportIncStatement SET " & vbCrLf
      sSql = sSql & "                  SortKeyRev = Cast(@ChildKey as varchar(512)) + char(36)+ @GlMasterAcc" & vbCrLf
      sSql = sSql & "               WHERE GLACCTREF = @GlChildAcct AND GLMASTER = @GlMasterAcc " & vbCrLf
      sSql = sSql & "                  AND SORTKEYLEVEL = @level --GLTOPMaster = 1 AND " & vbCrLf
      sSql = sSql & "               SET @PrevMaster = @GlChildAcct" & vbCrLf
      sSql = sSql & "            END" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "          End" & vbCrLf
      sSql = sSql & "          FETCH NEXT FROM curAcctStruc1 INTO @GlChildAcct, @GlMasterAcc, @GLSortKey" & vbCrLf
      sSql = sSql & "        End" & vbCrLf
      sSql = sSql & "               " & vbCrLf
      sSql = sSql & "        Close curAcctStruc1" & vbCrLf
      sSql = sSql & "        DEALLOCATE curAcctStruc1" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "        SET @level = @level - 1" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "  SELECT GLTOPMaster, GLTOPMASTERDESC, GLACCTREF, GLACCTNO, GLDESCR, GLMASTER, GLTYPE,GLINACTIVE, GLFSLEVEL," & vbCrLf
      sSql = sSql & "      SUMCURBAL , CurrentBal, SUMYTD, YTD, SUMPREVBAL, PreviousBal, SORTKEYLEVEL, GLACCSORTKEY" & vbCrLf
      sSql = sSql & "   FROM EsReportIncStatement ORDER BY SortKeyRev --GLTOPMASTER, GLACCSORTKEY desc, SortKeyLevel" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "End"
      
      ExecuteScript False, sSql
      
      If StoreProcedureExists("RptAcctTopBalanceSheet") Then
         sSql = "DROP PROCEDURE RptAcctTopBalanceSheet"
         ExecuteScript False, sSql
      End If

      sSql = "CREATE PROCEDURE [dbo].[RptAcctTopBalanceSheet]" & vbCrLf
      sSql = sSql & "   @StartDate as varchar(12),@EndDate as varchar(12)," & vbCrLf
      sSql = sSql & "   @InclInAcct as varchar(1)AS" & vbCrLf
      sSql = sSql & "BEGIN " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   declare @glAcctRef as varchar(10)" & vbCrLf
      sSql = sSql & "   declare @glMsAcct as varchar(10)" & vbCrLf
      sSql = sSql & "   declare @SumCurBal decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @SumPrevBal as decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @level as integer" & vbCrLf
      sSql = sSql & "   declare @TopLevelDesc as varchar(30)" & vbCrLf
      sSql = sSql & "   declare @TopLevAcct as varchar(20)" & vbCrLf
      sSql = sSql & "   declare @PrevMaster as varchar(10)" & vbCrLf
      sSql = sSql & "   declare @RowCount as integer" & vbCrLf
      sSql = sSql & "   declare @GlMasterAcc as varchar(10)" & vbCrLf
      sSql = sSql & "   declare @GlChildAcct as varchar(10)" & vbCrLf
      sSql = sSql & "   declare @ChildKey as varchar(1024)" & vbCrLf
      sSql = sSql & "   declare @GLSortKey as varchar(1024)" & vbCrLf
      sSql = sSql & "   declare @SortKey as varchar(1024)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   DELETE FROM EsReportBalanceSheet" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   if (@InclInAcct = '1')" & vbCrLf
      sSql = sSql & "      SET @InclInAcct = '%'" & vbCrLf
      sSql = sSql & "   Else" & vbCrLf
      sSql = sSql & "      SET @InclInAcct = '0'" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   DECLARE balAcctStruc CURSOR  FOR" & vbCrLf
      sSql = sSql & "      SELECT '1', COASSTACCT, COASSTDESC FROM GlmsTopTable" & vbCrLf
      sSql = sSql & "      Union All" & vbCrLf
      sSql = sSql & "      SELECT '2', COLIABACCT, COLIABDESC FROM GlmsTopTable" & vbCrLf
      sSql = sSql & "      Union All" & vbCrLf
      sSql = sSql & "      SELECT '3', COEQTYACCT, COEQTYDESC FROM GlmsTopTable" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   OPEN balAcctStruc" & vbCrLf
      sSql = sSql & "   FETCH NEXT FROM balAcctStruc INTO @level, @TopLevAcct, @TopLevelDesc" & vbCrLf
      sSql = sSql & "   WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "   BEGIN " & vbCrLf
      sSql = sSql & "      IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "      BEGIN " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "         With cte" & vbCrLf
      sSql = sSql & "         as" & vbCrLf
      sSql = sSql & "         (select GLACCTREF, GLDESCR, GLMASTER, GLFSLEVEL, 0 as level," & vbCrLf
      sSql = sSql & "            cast(cast(@level as varchar(4))+ char(36)+ GLACCTREF as varchar(max)) as SortKey" & vbCrLf
      sSql = sSql & "         From GlacTopTable" & vbCrLf
      sSql = sSql & "         where GLMASTER = cast(@TopLevAcct as varchar(20)) AND GLINACTIVE LIKE @InclInAcct" & vbCrLf
      sSql = sSql & "         Union All" & vbCrLf
      sSql = sSql & "         select a.GLACCTREF, a.GLDESCR, a.GLMASTER, a.GLFSLEVEL, level + 1," & vbCrLf
      sSql = sSql & "          cast(COALESCE(SortKey,'') + char(36) + COALESCE(a.GLACCTREF,'') as varchar(max))as SortKey" & vbCrLf
      sSql = sSql & "         From cte" & vbCrLf
      sSql = sSql & "            inner join GlacTopTable a" & vbCrLf
      sSql = sSql & "               on cte.GLACCTREF = a.GLMASTER" & vbCrLf
      sSql = sSql & "            WHERE GLINACTIVE LIKE @InclInAcct" & vbCrLf
      sSql = sSql & "         )" & vbCrLf
      sSql = sSql & "         INSERT INTO EsReportBalanceSheet (GLTOPMaster, GLTOPMASTERDESC, GLACCTREF, GLDESCR, GLMASTER, GLFSLEVEL,SORTKEYLEVEL,GLACCSORTKEY)" & vbCrLf
      sSql = sSql & "         select @level, @TopLevelDesc," & vbCrLf
      sSql = sSql & "         GLACCTREF , GLDESCR, GLMASTER, GLFSLEVEL, Level, SortKey" & vbCrLf
      sSql = sSql & "         from cte order by SortKey" & vbCrLf
      sSql = sSql & "         " & vbCrLf
      sSql = sSql & "      End" & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM balAcctStruc INTO @level, @TopLevAcct, @TopLevelDesc" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "   Close balAcctStruc" & vbCrLf
      sSql = sSql & "   DEALLOCATE balAcctStruc" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   UPDATE EsReportBalanceSheet SET CurrentBal = foo.Balance--, SUMCURBAL = foo.Balance" & vbCrLf
      sSql = sSql & "   From" & vbCrLf
      sSql = sSql & "       (SELECT SUM(GjitTopTable.JIDEB) - SUM(GjitTopTable.JICRD) as Balance, JIACCOUNT" & vbCrLf
      sSql = sSql & "         FROM GjhdTable INNER JOIN GjitTopTable ON GJNAME = JINAME" & vbCrLf
      sSql = sSql & "      WHERE GJPOST BETWEEN @StartDate AND @EndDate" & vbCrLf
      sSql = sSql & "         AND GjhdTable.GJPOSTED = 1" & vbCrLf
      sSql = sSql & "      GROUP BY JIACCOUNT) as foo" & vbCrLf
      sSql = sSql & "   Where foo.JIACCOUNT = GLACCTREF" & vbCrLf
      sSql = sSql & "  " & vbCrLf
      sSql = sSql & " UPDATE EsReportBalanceSheet SET PreviousBal = foo.Balance--, SUMPREVBAL = foo.Balance" & vbCrLf
      sSql = sSql & "   From" & vbCrLf
      sSql = sSql & "      (SELECT JIACCOUNT,SUM(GjitTopTable.JIDEB) - SUM(GjitTopTable.JICRD) AS Balance" & vbCrLf
      sSql = sSql & "         FROM GjhdTable INNER JOIN GjitTopTable ON GJNAME = JINAME" & vbCrLf
      sSql = sSql & "      WHERE (GJPOST  <  @StartDate)" & vbCrLf
      sSql = sSql & "         AND GjhdTable.GJPOSTED = 1" & vbCrLf
      sSql = sSql & "      GROUP BY JIACCOUNT) as foo" & vbCrLf
      sSql = sSql & "   Where foo.JIACCOUNT = GLACCTREF" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   set @level = 9" & vbCrLf
      sSql = sSql & "   WHILE (@level >= 1 )" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "      DECLARE curAcctStruc CURSOR  FOR" & vbCrLf
      sSql = sSql & "      SELECT GLMASTER, SUM(ISNULL(SUMCURBAL,0) + (ISNULL(CurrentBal,0))) ," & vbCrLf
      sSql = sSql & "         Sum (IsNull(SUMPREVBAL, 0) + (IsNull(PreviousBal, 0)))" & vbCrLf
      sSql = sSql & "      From" & vbCrLf
      sSql = sSql & "         (SELECT DISTINCT GLACCTREF, GLDESCR, GLMASTER," & vbCrLf
      sSql = sSql & "         CurrentBal , PreviousBal, SUMCURBAL, SUMPREVBAL" & vbCrLf
      sSql = sSql & "         FROM EsReportBalanceSheet WHERE SORTKEYLEVEL = @level) as foo" & vbCrLf
      sSql = sSql & "      group by GLMASTER" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "      OPEN curAcctStruc" & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM curAcctStruc INTO @glMsAcct, @SumCurBal, @SumPrevBal" & vbCrLf
      sSql = sSql & "      WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "      BEGIN" & vbCrLf
      sSql = sSql & "         IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "         BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "           UPDATE EsReportBalanceSheet SET SUMCURBAL = (ISNULL(SUMCURBAL, 0) + @SumCurBal)," & vbCrLf
      sSql = sSql & "               SUMPREVBAL = (ISNULL(SUMPREVBAL, 0) + @SumPrevBal), GLDESCR = 'TOTAL '+ LTRIM(GLDESCR)," & vbCrLf
      sSql = sSql & "            HASCHILD = 1" & vbCrLf
      sSql = sSql & "            WHERE GLACCTREF = @glMsAcct" & vbCrLf
      sSql = sSql & "         End" & vbCrLf
      sSql = sSql & "         FETCH NEXT FROM curAcctStruc INTO @glMsAcct, @SumCurBal, @SumPrevBal" & vbCrLf
      sSql = sSql & "      End" & vbCrLf
      sSql = sSql & "            " & vbCrLf
      sSql = sSql & "      Close curAcctStruc" & vbCrLf
      sSql = sSql & "      DEALLOCATE curAcctStruc" & vbCrLf
      sSql = sSql & "      " & vbCrLf
      sSql = sSql & "      SET @level = @level - 1" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   UPDATE EsReportBalanceSheet SET SUMCURBAL = CurrentBal WHERE SUMCURBAL IS NULL" & vbCrLf
      sSql = sSql & "   UPDATE EsReportBalanceSheet SET SUMPREVBAL = PreviousBal WHERE SUMPREVBAL IS NULL" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   set @level = 0" & vbCrLf
      sSql = sSql & "   set @RowCount = 1" & vbCrLf
      sSql = sSql & "   SET @PrevMaster = ''" & vbCrLf
      sSql = sSql & "   DECLARE curAcctStruc CURSOR  FOR" & vbCrLf
      sSql = sSql & "      SELECT GLMASTER, GLACCSORTKEY" & vbCrLf
      sSql = sSql & "      From EsReportBalanceSheet" & vbCrLf
      sSql = sSql & "         WHERE HASCHILD IS NULL --GLFSLEVEL = 8 --AND GLMASTER ='AA10'--GLTOPMaster = 1 AND" & vbCrLf
      sSql = sSql & "      ORDER BY GLACCSORTKEY" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   OPEN curAcctStruc" & vbCrLf
      sSql = sSql & "   FETCH NEXT FROM curAcctStruc INTO @GlMasterAcc, @GLSortKey" & vbCrLf
      sSql = sSql & "   WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "    IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "    BEGIN" & vbCrLf
      sSql = sSql & "      if (@PrevMaster <> @GlMasterAcc)" & vbCrLf
      sSql = sSql & "      BEGIN" & vbCrLf
      sSql = sSql & "         UPDATE EsReportBalanceSheet SET" & vbCrLf
      sSql = sSql & "            SortKeyRev = RIGHT ('0000'+ Cast(@RowCount as varchar), 4) + char(36)+ @GlMasterAcc" & vbCrLf
      sSql = sSql & "         WHERE GLMASTER = @GlMasterAcc AND HASCHILD IS NULL --GLFSLEVEL = 8 --AND GLTOPMaster = 1" & vbCrLf
      sSql = sSql & "         SET @RowCount = @RowCount + 1" & vbCrLf
      sSql = sSql & "         SET @PrevMaster = @GlMasterAcc" & vbCrLf
      sSql = sSql & "      End" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "    End" & vbCrLf
      sSql = sSql & "    FETCH NEXT FROM curAcctStruc INTO @GlMasterAcc, @GLSortKey" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "       " & vbCrLf
      sSql = sSql & "   Close curAcctStruc" & vbCrLf
      sSql = sSql & "   DEALLOCATE curAcctStruc" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   set @level = 8" & vbCrLf
      sSql = sSql & "   WHILE (@level >= 0)" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "      SET @PrevMaster = ''" & vbCrLf
      sSql = sSql & "        DECLARE curAcctStruc1 CURSOR  FOR" & vbCrLf
      sSql = sSql & "         SELECT DISTINCT GLACCTREF, GLMASTER, GLACCSORTKEY" & vbCrLf
      sSql = sSql & "         From EsReportBalanceSheet" & vbCrLf
      sSql = sSql & "            WHERE SORTKEYLEVEL = @level AND HASCHILD IS NOT NULL--GLTOPMaster = 1 AND" & vbCrLf
      sSql = sSql & "         order by GLACCSORTKEY" & vbCrLf
      sSql = sSql & "    " & vbCrLf
      sSql = sSql & "        OPEN curAcctStruc1" & vbCrLf
      sSql = sSql & "        FETCH NEXT FROM curAcctStruc1 INTO @GlChildAcct, @GlMasterAcc, @GLSortKey" & vbCrLf
      sSql = sSql & "        WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "        BEGIN" & vbCrLf
      sSql = sSql & "          IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "          BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "            if (@PrevMaster <> @GlChildAcct)" & vbCrLf
      sSql = sSql & "            BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   --Print 'Record' + @GlChildAcct + ':' + @GlMasterAcc" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "               SELECT TOP 1 @ChildKey = SortKeyRev,@SortKey = GLACCSORTKEY" & vbCrLf
      sSql = sSql & "               From EsReportBalanceSheet" & vbCrLf
      sSql = sSql & "                  WHERE SORTKEYLEVEL > @level AND GLMASTER = @GlChildAcct --GLTOPMaster = 1 AND" & vbCrLf
      sSql = sSql & "               order by GLACCSORTKEY desc" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "               UPDATE EsReportBalanceSheet SET" & vbCrLf
      sSql = sSql & "                  SortKeyRev = Cast(@ChildKey as varchar(512)) + char(36)+ @GlMasterAcc" & vbCrLf
      sSql = sSql & "   --          select * from EsReportBalanceSheet" & vbCrLf
      sSql = sSql & "               WHERE GLACCTREF = @GlChildAcct AND GLMASTER = @GlMasterAcc" & vbCrLf
      sSql = sSql & "                  AND SORTKEYLEVEL = @level --GLTOPMaster = 1 AND" & vbCrLf
      sSql = sSql & "               SET @PrevMaster = @GlChildAcct" & vbCrLf
      sSql = sSql & "            End" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "          End" & vbCrLf
      sSql = sSql & "          FETCH NEXT FROM curAcctStruc1 INTO @GlChildAcct, @GlMasterAcc, @GLSortKey" & vbCrLf
      sSql = sSql & "        End" & vbCrLf
      sSql = sSql & "               " & vbCrLf
      sSql = sSql & "        Close curAcctStruc1" & vbCrLf
      sSql = sSql & "        DEALLOCATE curAcctStruc1" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "        SET @level = @level - 1" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   SELECT GLTOPMaster, GLTOPMASTERDESC, GLACCTREF, GLACCTNO, GLDESCR, GLMASTER, GLTYPE,GLINACTIVE, GLFSLEVEL," & vbCrLf
      sSql = sSql & "      SUMCURBAL , CurrentBal, SUMPREVBAL, PreviousBal, SORTKEYLEVEL, GLACCSORTKEY, SortKeyRev,HASCHILD" & vbCrLf
      sSql = sSql & "   FROM EsReportBalanceSheet ORDER BY SortKeyRev --GLTOPMASTER, GLACCSORTKEY," & vbCrLf
      sSql = sSql & "End"
      
      ExecuteScript False, sSql
      
      
      If StoreProcedureExists("TrialBalanceTopGLPost") Then
         sSql = "DROP PROCEDURE TrialBalanceTopGLPost"
         ExecuteScript False, sSql
      End If

      sSql = "CREATE PROCEDURE [dbo].[TrialBalanceTopGLPost]" & vbCrLf
      sSql = sSql & "    @StartDate as Varchar(16), @EndDate as varchar(16)," & vbCrLf
      sSql = sSql & "    @StartAcc as Varchar(16), @EndAcc as varchar(16)," & vbCrLf
      sSql = sSql & "   @IncludeInActiveAcc as varchar(2)" & vbCrLf
      sSql = sSql & "    AS                              " & vbCrLf
      sSql = sSql & "   BEGIN " & vbCrLf
      sSql = sSql & "   declare @GLDESCR as varchar(40)" & vbCrLf
      sSql = sSql & "   declare @Inv_GLDESCR as varchar(40)" & vbCrLf
      sSql = sSql & "   declare @GJPOST as varchar(16)" & vbCrLf
      sSql = sSql & "   declare @JINAME as varchar(12)" & vbCrLf
      sSql = sSql & "   declare @JIACCOUNT as varchar(12)" & vbCrLf
      sSql = sSql & "   declare @Inv_JIACCOUNT as varchar(12)" & vbCrLf
      sSql = sSql & "   declare @JIDEB as decimal(13,2)" & vbCrLf
      sSql = sSql & "   declare @JICRD as decimal(13,2)" & vbCrLf
      sSql = sSql & "   declare @JR_DCDEBIT as decimal(13,2)" & vbCrLf
      sSql = sSql & "   declare @JR_DCCREDIT as decimal(13,2)" & vbCrLf
      sSql = sSql & "   declare @JR_TotBal as decimal(13,2)" & vbCrLf
      sSql = sSql & "   declare @Acc_StartBal as decimal(13,2)" & vbCrLf
      sSql = sSql & "   declare @Acc_StartBal_Inv as decimal(13,2)" & vbCrLf
      sSql = sSql & "   declare @MJTYPE as varchar(2)" & vbCrLf
      sSql = sSql & "   declare @MJDESCRIPTION as varchar(30)" & vbCrLf
      sSql = sSql & "   declare @StrAcc as varchar (30)" & vbCrLf
      sSql = sSql & "   declare @iStartAcc as varchar(16)" & vbCrLf
      sSql = sSql & "   declare @iEndAcc as varchar(16)" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   IF (@StartAcc = 'ALL')" & vbCrLf
      sSql = sSql & "      SET @iStartAcc = '1'" & vbCrLf
      sSql = sSql & "   Else" & vbCrLf
      sSql = sSql & "      SET @iStartAcc = @StartAcc" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   IF (@EndAcc  = 'ALL')" & vbCrLf
      sSql = sSql & "      SET @iEndAcc = '9999'" & vbCrLf
      sSql = sSql & "   Else" & vbCrLf
      sSql = sSql & "      SET @iEndAcc = @EndAcc" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   CREATE TABLE #tempGLPost" & vbCrLf
      sSql = sSql & "   (                       " & vbCrLf
      sSql = sSql & "      tGLDESCR varchar(40) NULL ," & vbCrLf
      sSql = sSql & "      tGJPOST varchar(16) NULL ," & vbCrLf
      sSql = sSql & "      tJINAME varchar(12) NULL ," & vbCrLf
      sSql = sSql & "      tJIACCOUNT varchar(12) NULL ," & vbCrLf
      sSql = sSql & "      tAcc_StartBal decimal (13,2) NULL," & vbCrLf
      sSql = sSql & "      tJIDEB decimal(13,2) NULL ," & vbCrLf
      sSql = sSql & "      tJICRD decimal(13,2) NULL ," & vbCrLf
      sSql = sSql & "      tJR_DCDEBIT decimal(13,2) NULL ," & vbCrLf
      sSql = sSql & "      tJR_DCCREDIT decimal(13,2)NULL ," & vbCrLf
      sSql = sSql & "      tJR_TotBal decimal(13,2) NULL ," & vbCrLf
      sSql = sSql & "      tGJ_TotBal decimal(13,2) NULL ," & vbCrLf
      sSql = sSql & "      tMJTYPE varchar(2) NULL ," & vbCrLf
      sSql = sSql & "      tMJDESCRIPTION varchar(30) NULL," & vbCrLf
      sSql = sSql & "   )" & vbCrLf
      sSql = sSql & "   IF (@IncludeInActiveAcc = '1')" & vbCrLf
      sSql = sSql & "      DECLARE curGJ CURSOR" & vbCrLf
      sSql = sSql & "      LOCAL" & vbCrLf
      sSql = sSql & "      Scroll " & vbCrLf
      sSql = sSql & "      FOR" & vbCrLf
      sSql = sSql & "         SELECT DISTINCT GLDESCR, GJPOST," & vbCrLf
      sSql = sSql & "          JINAME , JIACCOUNT" & vbCrLf
      sSql = sSql & "           From GjitTopTable, GlacTopTable, GjhdTable" & vbCrLf
      sSql = sSql & "         Where JIACCOUNT = GLACCTREF" & vbCrLf
      sSql = sSql & "          AND GJNAME = JINAME AND (GJPOSTED = 1)" & vbCrLf
      sSql = sSql & "          AND GJPOST BETWEEN @StartDate AND @EndDate" & vbCrLf
      sSql = sSql & "          AND  JIACCOUNT BETWEEN @iStartAcc AND @iEndAcc" & vbCrLf
      sSql = sSql & "   Else" & vbCrLf
      sSql = sSql & "      DECLARE curGJ CURSOR" & vbCrLf
      sSql = sSql & "      LOCAL" & vbCrLf
      sSql = sSql & "      Scroll " & vbCrLf
      sSql = sSql & "      FOR" & vbCrLf
      sSql = sSql & "         SELECT DISTINCT GLDESCR, GJPOST," & vbCrLf
      sSql = sSql & "          JINAME , JIACCOUNT" & vbCrLf
      sSql = sSql & "           From GjitTopTable, GlacTopTable, GjhdTable" & vbCrLf
      sSql = sSql & "         Where JIACCOUNT = GLACCTREF" & vbCrLf
      sSql = sSql & "          AND GJNAME = JINAME" & vbCrLf
      sSql = sSql & "          AND GLINACTIVE = 0  AND (GJPOSTED = 1)" & vbCrLf
      sSql = sSql & "          AND GJPOST BETWEEN @StartDate AND @EndDate" & vbCrLf
      sSql = sSql & "          AND  JIACCOUNT BETWEEN @iStartAcc AND @iEndAcc" & vbCrLf
      sSql = sSql & "     OPEN curGJ" & vbCrLf
      sSql = sSql & "     FETCH NEXT FROM curGJ INTO @GLDESCR,@GJPOST,@JINAME,@JIACCOUNT" & vbCrLf
      sSql = sSql & "     WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "     BEGIN " & vbCrLf
      sSql = sSql & "         IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "         BEGIN " & vbCrLf
      sSql = sSql & "          SELECT @Acc_StartBal = SUM(JIDEB) - SUM(JICRD)" & vbCrLf
      sSql = sSql & "              From GjitTopTable, GlacTopTable, GjhdTable" & vbCrLf
      sSql = sSql & "           Where JIACCOUNT = GLACCTREF And " & vbCrLf
      sSql = sSql & "                GJNAME = JINAME And (GJPOSTED = 1)" & vbCrLf
      sSql = sSql & "                AND JIACCOUNT = @JIACCOUNT" & vbCrLf
      sSql = sSql & "                AND GJPOST < @StartDate" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "          SELECT @JIDEB = SUM(JIDEB), @JICRD = SUM(JICRD)" & vbCrLf
      sSql = sSql & "              From GjitTopTable, GlacTopTable" & vbCrLf
      sSql = sSql & "           Where JIACCOUNT = GLACCTREF And " & vbCrLf
      sSql = sSql & "                JINAME = @JINAME" & vbCrLf
      sSql = sSql & "                AND JIACCOUNT = @JIACCOUNT" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "          SELECT @JR_DCDEBIT = SUM(DCDEBIT) , @JR_DCCREDIT = SUM(DCCREDIT)," & vbCrLf
      sSql = sSql & "              @JR_TotBal = SUM(DCDEBIT) - SUM(DCCREDIT)," & vbCrLf
      sSql = sSql & "             @MJTYPE = MJTYPE, @MJDESCRIPTION = MJDESCRIPTION" & vbCrLf
      sSql = sSql & "          From jritTable, jrhdtable" & vbCrLf
      sSql = sSql & "          Where MJGLJRNL = DCHEAD And " & vbCrLf
      sSql = sSql & "             DCHEAD = @JINAME" & vbCrLf
      sSql = sSql & "             AND DCACCTNO = @JIACCOUNT" & vbCrLf
      sSql = sSql & "          GROUP BY DCHEAD,DCACCTNO,MJTYPE, MJDESCRIPTION" & vbCrLf
      sSql = sSql & "          " & vbCrLf
      sSql = sSql & "        INSERT INTO #tempGLPost(tGLDESCR, tGJPOST, tJINAME, tJIACCOUNT, tAcc_StartBal, tJIDEB, tJICRD," & vbCrLf
      sSql = sSql & "             tJR_DCDEBIT,tJR_DCCREDIT, tJR_TotBal, tGJ_TotBal, tMJTYPE, tMJDESCRIPTION )" & vbCrLf
      sSql = sSql & "          VALUES (@GLDESCR, @GJPOST, @JINAME, @JIACCOUNT, @Acc_StartBal, @JIDEB, @JICRD," & vbCrLf
      sSql = sSql & "             @JR_DCDEBIT, @JR_DCCREDIT, @JR_TotBal, @JIDEB - @JICRD, @MJTYPE, @MJDESCRIPTION)" & vbCrLf
      sSql = sSql & "       End" & vbCrLf
      sSql = sSql & "       FETCH NEXT FROM curGJ INTO @GLDESCR,@GJPOST,@JINAME,@JIACCOUNT" & vbCrLf
      sSql = sSql & "    End" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   CLOSE curGJ   --// close the cursor" & vbCrLf
      sSql = sSql & "   DEALLOCATE curGJ" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   --// Now all the un balanced accounts" & vbCrLf
      sSql = sSql & "   IF (@IncludeInActiveAcc = '1')" & vbCrLf
      sSql = sSql & "      DECLARE curInActiveAcc CURSOR" & vbCrLf
      sSql = sSql & "      LOCAL" & vbCrLf
      sSql = sSql & "      Scroll " & vbCrLf
      sSql = sSql & "      FOR" & vbCrLf
      sSql = sSql & "         SELECT DISTINCT GLDESCR, JIACCOUNT" & vbCrLf
      sSql = sSql & "           From GjitTopTable, GlacTopTable, GjhdTable" & vbCrLf
      sSql = sSql & "         Where JIACCOUNT = GLACCTREF" & vbCrLf
      sSql = sSql & "          AND GJNAME = JINAME" & vbCrLf
      sSql = sSql & "          AND (JIACCOUNT IN (SELECT DISTINCT JIACCOUNT" & vbCrLf
      sSql = sSql & "                  From GjitTopTable, GlacTopTable, GjhdTable" & vbCrLf
      sSql = sSql & "                  Where JIACCOUNT = GLACCTREF And " & vbCrLf
      sSql = sSql & "                  GJNAME = JINAME And (GJPOSTED = 1)" & vbCrLf
      sSql = sSql & "                  AND GJPOST < @StartDate" & vbCrLf
      sSql = sSql & "                  GROUP BY JIACCOUNT" & vbCrLf
      sSql = sSql & "                  HAVING (SUM(JIDEB) - SUM(JICRD)) <> 0))" & vbCrLf
      sSql = sSql & "         AND JIACCOUNT NOT IN" & vbCrLf
      sSql = sSql & "         (" & vbCrLf
      sSql = sSql & "         SELECT DISTINCT  JIACCOUNT" & vbCrLf
      sSql = sSql & "         From GjitTopTable, GlacTopTable, GjhdTable" & vbCrLf
      sSql = sSql & "         Where JIACCOUNT = GLACCTREF" & vbCrLf
      sSql = sSql & "          AND GJNAME = JINAME" & vbCrLf
      sSql = sSql & "          AND GJPOST BETWEEN @StartDate AND @EndDate" & vbCrLf
      sSql = sSql & "          AND  JIACCOUNT BETWEEN @iStartAcc AND @iEndAcc" & vbCrLf
      sSql = sSql & "         )" & vbCrLf
      sSql = sSql & "         AND  JIACCOUNT BETWEEN @iStartAcc AND @iEndAcc" & vbCrLf
      sSql = sSql & "         order by JIACCOUNT" & vbCrLf
      sSql = sSql & "   Else" & vbCrLf
      sSql = sSql & "      DECLARE curInActiveAcc CURSOR" & vbCrLf
      sSql = sSql & "      LOCAL" & vbCrLf
      sSql = sSql & "      Scroll " & vbCrLf
      sSql = sSql & "      FOR" & vbCrLf
      sSql = sSql & "         SELECT DISTINCT GLDESCR, JIACCOUNT" & vbCrLf
      sSql = sSql & "           From GjitTopTable, GlacTopTable, GjhdTable" & vbCrLf
      sSql = sSql & "         Where JIACCOUNT = GLACCTREF" & vbCrLf
      sSql = sSql & "          AND GJNAME = JINAME" & vbCrLf
      sSql = sSql & "          AND (JIACCOUNT IN (SELECT DISTINCT JIACCOUNT" & vbCrLf
      sSql = sSql & "                  From GjitTopTable, GlacTopTable, GjhdTable" & vbCrLf
      sSql = sSql & "                  Where JIACCOUNT = GLACCTREF And " & vbCrLf
      sSql = sSql & "                  GJNAME = JINAME And (GJPOSTED = 1)" & vbCrLf
      sSql = sSql & "                  AND GJPOST < @StartDate" & vbCrLf
      sSql = sSql & "                  GROUP BY JIACCOUNT" & vbCrLf
      sSql = sSql & "                  HAVING (SUM(JIDEB) - SUM(JICRD)) <> 0))" & vbCrLf
      sSql = sSql & "         AND JIACCOUNT NOT IN" & vbCrLf
      sSql = sSql & "         (" & vbCrLf
      sSql = sSql & "         SELECT DISTINCT  JIACCOUNT" & vbCrLf
      sSql = sSql & "         From GjitTopTable, GlacTopTable, GjhdTable" & vbCrLf
      sSql = sSql & "         Where JIACCOUNT = GLACCTREF" & vbCrLf
      sSql = sSql & "          AND GJNAME = JINAME" & vbCrLf
      sSql = sSql & "          AND GJPOST BETWEEN @StartDate AND @EndDate" & vbCrLf
      sSql = sSql & "          AND  JIACCOUNT BETWEEN @iStartAcc AND @iEndAcc" & vbCrLf
      sSql = sSql & "         )" & vbCrLf
      sSql = sSql & "         AND  JIACCOUNT BETWEEN @iStartAcc AND @iEndAcc" & vbCrLf
      sSql = sSql & "         order by JIACCOUNT" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "     OPEN curInActiveAcc" & vbCrLf
      sSql = sSql & "     FETCH NEXT FROM curInActiveAcc INTO @Inv_GLDESCR, @Inv_JIACCOUNT" & vbCrLf
      sSql = sSql & "     WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "     BEGIN " & vbCrLf
      sSql = sSql & "         IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "         BEGIN " & vbCrLf
      sSql = sSql & "          SELECT @Acc_StartBal_Inv = SUM(JIDEB) - SUM(JICRD)" & vbCrLf
      sSql = sSql & "              From GjitTopTable, GlacTopTable, GjhdTable" & vbCrLf
      sSql = sSql & "           Where JIACCOUNT = GLACCTREF And " & vbCrLf
      sSql = sSql & "                GJNAME = JINAME And (GJPOSTED = 1)" & vbCrLf
      sSql = sSql & "                AND JIACCOUNT = @Inv_JIACCOUNT" & vbCrLf
      sSql = sSql & "                AND GJPOST < @StartDate" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "        INSERT INTO #tempGLPost(tGLDESCR, tJIACCOUNT, tAcc_StartBal )" & vbCrLf
      sSql = sSql & "          VALUES (@Inv_GLDESCR, @Inv_JIACCOUNT , @Acc_StartBal_Inv)" & vbCrLf
      sSql = sSql & "       End" & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM curInActiveAcc INTO @Inv_GLDESCR, @Inv_JIACCOUNT" & vbCrLf
      sSql = sSql & "    End" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   CLOSE curInActiveAcc   --// close the cursor" & vbCrLf
      sSql = sSql & "   DEALLOCATE curInActiveAcc" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   SELECT tGLDESCR GLDESCR, tGJPOST GJPOST, tJINAME JINAME," & vbCrLf
      sSql = sSql & "      tJIACCOUNT JIACCOUNT, tAcc_StartBal AS StartingBalance, tJIDEB AS GL_JIDEB," & vbCrLf
      sSql = sSql & "      tJICRD AS GL_JICRD, tJR_DCDEBIT JR_DCDEBIT," & vbCrLf
      sSql = sSql & "      tJR_DCCREDIT JR_DCCREDIT, tGJ_TotBal GJ_TotBal," & vbCrLf
      sSql = sSql & "      tJR_TotBal JR_TotBal, tMJTYPE MJTYPE," & vbCrLf
      sSql = sSql & "      tMJDESCRIPTION MJDESCRIPTION" & vbCrLf
      sSql = sSql & "   FROM #tempGLPost order by tGLDESCR" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   DROP table #tempGLPost" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "End"
      
      ExecuteScript False, sSql
      
      
      If StoreProcedureExists("GLJritTopSummary") Then
         sSql = "DROP PROCEDURE GLJritTopSummary"
         ExecuteScript False, sSql
      End If

      sSql = "CREATE PROCEDURE [dbo].[GLJritTopSummary]" & vbCrLf
      sSql = sSql & "   @StartDate as varchar(12),@EndDate as varchar(12)" & vbCrLf
      sSql = sSql & "AS " & vbCrLf
      sSql = sSql & "BEGIN" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   DELETE FROM [FusionDB].[dbo].[GjitTopTable] WHERE JIDATE between  @StartDate AND @EndDate " & vbCrLf
      sSql = sSql & "    " & vbCrLf
      sSql = sSql & "   --// insert from [MPSBDB] account are prepended by .0" & vbCrLf
      sSql = sSql & "   INSERT INTO [FusionDB].[dbo].GjitTopTable (JINAME,JIDESC,JITRAN,JIREF,JIACCOUNT,JICHILDACCOUNT," & vbCrLf
      sSql = sSql & "      JIDEB,JICRD,JIDATE,JILASTREVBY,JICLEAR)" & vbCrLf
      sSql = sSql & "   SELECT   a.JINAME,a.JIDESC,a.JITRAN, a.JIREF," & vbCrLf
      sSql = sSql & "      REPLACE(a.JIACCOUNT, '.0', '.1'), a.JIACCOUNT," & vbCrLf
      sSql = sSql & "      a.JIDEB,a.JICRD,a.JIDATE,a.JILASTREVBY,a.JICLEAR FROM [MPSBDB].[dbo].GjitTable a" & vbCrLf
      sSql = sSql & "   WHERE a.JIDATE between  @StartDate AND @EndDate" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   --// insert from [FusionDB] account..they are not account prefix ( so just add .1 for the top level account)" & vbCrLf
      sSql = sSql & "   INSERT INTO [FusionDB].[dbo].GjitTopTable (JINAME,JIDESC,JITRAN,JIREF,JIACCOUNT,JICHILDACCOUNT," & vbCrLf
      sSql = sSql & "      JIDEB,JICRD,JIDATE,JILASTREVBY,JICLEAR)" & vbCrLf
      sSql = sSql & "   SELECT   a.JINAME,a.JIDESC,a.JITRAN, a.JIREF," & vbCrLf
      sSql = sSql & "      RTRIM(a.JIACCOUNT) + '.1', a.JIACCOUNT," & vbCrLf
      sSql = sSql & "      a.JIDEB,a.JICRD,a.JIDATE,a.JILASTREVBY,a.JICLEAR FROM [FusionDb].[dbo].GjitTable a" & vbCrLf
      sSql = sSql & "   WHERE a.JIDATE between  @StartDate AND @EndDate" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "End"
      
      ExecuteScript False, sSql
      
      ' update the version
      ExecuteScript False, "Update Version Set Version = " & newver
   
   End If
End Function


Private Function UpdateDatabase59()

   newver = 133
   If ver < newver Then

      sSql = "ALTER PROCEDURE [dbo].[WIPCalculatedOH]" & vbCrLf
      sSql = sSql & "   @CutOffDate as datetime" & vbCrLf
      sSql = sSql & "AS " & vbCrLf
      sSql = sSql & "BEGIN" & vbCrLf
      sSql = sSql & "   declare @MOPart as varchar(30)" & vbCrLf
      sSql = sSql & "   declare @MORun as int" & vbCrLf
      sSql = sSql & "   declare @MOQty as decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @CalTotOH as decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @TotMOOH as decimal (15,4)" & vbCrLf
      sSql = sSql & "   declare @OH as decimal(15,4)" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   DECLARE curWIP CURSOR  FOR" & vbCrLf
      sSql = sSql & "     SELECT DISTINCT WIPRUNREF,WIPRUNNO, WIPRUNQTY, WIPOH" & vbCrLf
      sSql = sSql & "     FROM EsReportWIPOH" & vbCrLf
      sSql = sSql & "   OPEN curWIP" & vbCrLf
      sSql = sSql & "   FETCH NEXT FROM curWIP INTO @MOPart, @MORun, @MOQty, @OH" & vbCrLf
      sSql = sSql & "   WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "      IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "      BEGIN" & vbCrLf
      sSql = sSql & "      " & vbCrLf
      sSql = sSql & "         --Print 'PartNum:' + @MOPart + ' Run:' + Convert(varchar(10), @MORun)" & vbCrLf
      sSql = sSql & "         " & vbCrLf
      sSql = sSql & "         EXECUTE GetMOOverHead_WIP @MOPart, @MORun, @MOQty, @CutOffDate, @OH, @CalTotOH = @TotMOOH OUTPUT;" & vbCrLf
      sSql = sSql & "         " & vbCrLf
      sSql = sSql & "         --print 'TotOH:' + Convert(varchar(10), @TotMOOH)" & vbCrLf
      sSql = sSql & "         " & vbCrLf
      sSql = sSql & "         UPDATE EsReportWIPOH SET WIPCALOH = @TotMOOH" & vbCrLf
      sSql = sSql & "            WHERE WIPRUNREF = @MOPart AND WIPRUNNO = @MORun" & vbCrLf
      sSql = sSql & "      End" & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM curWIP INTO @MOPart, @MORun, @MOQty, @OH" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "      " & vbCrLf
      sSql = sSql & "   Close curWIP" & vbCrLf
      sSql = sSql & "   DEALLOCATE curWIP" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   UPDATE EsReportWIPOH  SET WIPCALOH = WIPOH WHERE WIPOH <> WIPCALOH " & vbCrLf
      sSql = sSql & "   AND WIPCALOH = 0 AND WIPOH <> 0" & vbCrLf
      sSql = sSql & "END"
      
      ExecuteScript False, sSql
      
      
      sSql = "ALTER PROCEDURE [dbo].[GetMOOverHead_WIP]" & vbCrLf
      sSql = sSql & "      @MOPart as varchar(30),@MORun as int," & vbCrLf
      sSql = sSql & "      @MOQty as decimal(15,4), @CutoffDate as Datetime,@OH as decimal(15,4), " & vbCrLf
      sSql = sSql & "      @CalTotOH decimal(15,4) OUTPUT" & vbCrLf
      sSql = sSql & "AS " & vbCrLf
      sSql = sSql & "BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   declare @SumTotMat decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @SumTotLabor decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @SumTotExp decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @SumTotOH decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @LotTotOH decimal (15,4)" & vbCrLf
      sSql = sSql & "   declare @level as integer" & vbCrLf
      sSql = sSql & "   declare @Part as varchar(30)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   declare @PrevParent  as varchar(30)" & vbCrLf
      sSql = sSql & "   declare @RowCount as integer" & vbCrLf
      sSql = sSql & "   declare @ChildPart as varchar(30)" & vbCrLf
      sSql = sSql & "   declare @ParentPart as varchar(30)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   declare @ChildKey as varchar(1024)" & vbCrLf
      sSql = sSql & "   declare @GLSortKey as varchar(1024)" & vbCrLf
      sSql = sSql & "   declare @SortKey as varchar(1024)" & vbCrLf
      sSql = sSql & "   declare @ParentLotNum as varchar(15)" & vbCrLf
      sSql = sSql & "   declare @Maxlevel as int" & vbCrLf
      sSql = sSql & "   declare @LotRunNo as int" & vbCrLf
      sSql = sSql & "   declare @LotOrgQty as decimal(15,4)" & vbCrLf
      sSql = sSql & "   --declare @MOPart as varchar(30)" & vbCrLf
      sSql = sSql & "   --declare @MORun as int" & vbCrLf
      sSql = sSql & "   --declare @MOQty as decimal(15,4)" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   CREATE TABLE #tempMOPartsDetail " & vbCrLf
      sSql = sSql & "   ( " & vbCrLf
      sSql = sSql & "      INMOPART Varchar(30) NULL, " & vbCrLf
      sSql = sSql & "      INMORUN int NULL , " & vbCrLf
      sSql = sSql & "      INPART varchar(30) NULL , " & vbCrLf
      sSql = sSql & "      LOTNUMBER varchar(15) NULL, " & vbCrLf
      sSql = sSql & "      INTOTMATL decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      INTOTLABOR decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      INTOTEXP decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      INTOTOH decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      LOTTOTMATL decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      LOTTOTLABOR decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      LOTTOTEXP decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      LOTTOTOH decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      SUMTOTMAL decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      SUMTOTLABOR decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      SUMTOTEXP decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      SUMTOTOH decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      LOTDATECOSTED smalldatetime NULL," & vbCrLf
      sSql = sSql & "      SortKey varchar(512) NULL," & vbCrLf
      sSql = sSql & "      HASCHILD int NULL," & vbCrLf
      sSql = sSql & "      SORTKEYLEVEL tinyint NULL," & vbCrLf
      sSql = sSql & "      SortKeyRev varchar(512)," & vbCrLf
      sSql = sSql & "      PARTSUM varchar(40)," & vbCrLf
      sSql = sSql & "      BMQTYREQD decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      LOTORGQTY decimal(12,4) NULL," & vbCrLf
      sSql = sSql & "      BMTOTOH decimal(12,4) NULL," & vbCrLf
      sSql = sSql & "      PICKEDDATE datetime" & vbCrLf
      sSql = sSql & "   ) " & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "      with cte" & vbCrLf
      sSql = sSql & "      as" & vbCrLf
      sSql = sSql & "      (select BMASSYPART, BMPARTREF,  BMQTYREQD,0 as level, cast('1' + char(36)+ BMPARTREF as varchar(max)) as SortKey" & vbCrLf
      sSql = sSql & "      from BmplTable" & vbCrLf
      sSql = sSql & "      where BMASSYPART = @MOPart" & vbCrLf
      sSql = sSql & "      union all" & vbCrLf
      sSql = sSql & "      select a.BMASSYPART, a.BMPARTREF, a.BMQTYREQD, level + 1," & vbCrLf
      sSql = sSql & "         cast(COALESCE(SortKey,'') + char(36) + COALESCE(a.BMPARTREF,'') as varchar(max))as SortKey" & vbCrLf
      sSql = sSql & "      from cte" & vbCrLf
      sSql = sSql & "         inner join BmplTable a" & vbCrLf
      sSql = sSql & "            on cte.BMPARTREF = a.BMASSYPART " & vbCrLf
      sSql = sSql & "      )" & vbCrLf
      sSql = sSql & "      INSERT INTO #tempMOPartsDetail(INMOPART,INPART,BMQTYREQD,SORTKEYLEVEL,SortKey)" & vbCrLf
      sSql = sSql & "      select BMASSYPART, BMPARTREF,BMQTYREQD,level,SortKey " & vbCrLf
      sSql = sSql & "         from cte order by SortKey " & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   END" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "print 'TopLevel:' + @MOPart + ' RUN:' + convert(varchar(10), @MORun)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   --// update the top level" & vbCrLf
      sSql = sSql & "   UPDATE #tempMOPartsDetail SET INMORUN = @MORun, LOTNUMBER = b.INLOTNUMBER, " & vbCrLf
      sSql = sSql & "            INTOTMATL = b.INTOTMATL, INTOTLABOR = b.INTOTLABOR, " & vbCrLf
      sSql = sSql & "            INTOTEXP = b.INTOTEXP, INTOTOH = b.INTOTOH, " & vbCrLf
      sSql = sSql & "            LOTTOTMATL = c.LOTTOTMATL, LOTTOTLABOR = c.LOTTOTLABOR, " & vbCrLf
      sSql = sSql & "            LOTTOTEXP = c.LOTTOTEXP, LOTTOTOH = c.LOTTOTOH," & vbCrLf
      sSql = sSql & "            LOTDATECOSTED = c.LOTDATECOSTED, LOTORGQTY = c.LOTORIGINALQTY," & vbCrLf
      sSql = sSql & "            BMTOTOH = (c.LOTTOTOH * BMQTYREQD) / c.LOTORIGINALQTY," & vbCrLf
      sSql = sSql & "            PICKEDDATE = INADATE" & vbCrLf
      sSql = sSql & "   FROM #tempMOPartsDetail d, InvaTable b, LohdTable c" & vbCrLf
      sSql = sSql & "   WHERE d.INMOPART = b.INMOPART AND d.INPART = b.INPART " & vbCrLf
      sSql = sSql & "      AND b.INLOTNUMBER = c.LOTnumber" & vbCrLf
      sSql = sSql & "      and c.lotpartref = b.INPART" & vbCrLf
      sSql = sSql & "      and b.INMOPART = @MOPart AND b.INMORUN  = @MORun" & vbCrLf
      sSql = sSql & "      AND b.INTYPE = 10 AND SORTKEYLEVEL = 0" & vbCrLf
      sSql = sSql & "      AND c.LOTORIGINALQTY <> 0  AND INADATE <= @CutoffDate" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   --// set the totals for " & vbCrLf
      sSql = sSql & "   SELECT @Maxlevel =  MAX(SORTKEYLEVEL) FROM #tempMOPartsDetail" & vbCrLf
      sSql = sSql & "   SET @level  = 1" & vbCrLf
      sSql = sSql & "   WHILE (@level <= @Maxlevel )" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "      DECLARE curMORun CURSOR  FOR" & vbCrLf
      sSql = sSql & "      SELECT DISTINCT INMOPART,INPART " & vbCrLf
      sSql = sSql & "         FROM #tempMOPartsDetail WHERE SORTKEYLEVEL = @level" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "      OPEN curMORun" & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM curMORun INTO @MOPart, @Part" & vbCrLf
      sSql = sSql & "      WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "      BEGIN" & vbCrLf
      sSql = sSql & "         IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "         BEGIN" & vbCrLf
      sSql = sSql & "         " & vbCrLf
      sSql = sSql & "         SELECT @ParentLotNum = LOTNUMBER FROM #tempMOPartsDetail  WHERE" & vbCrLf
      sSql = sSql & "               INPART = @MOPart AND SORTKEYLEVEL = @level - 1" & vbCrLf
      sSql = sSql & "         " & vbCrLf
      sSql = sSql & "         SELECT @LotRunNo = LOTMORUNNO, @LotOrgQty = LOTORIGINALQTY " & vbCrLf
      sSql = sSql & "                  FROM lohdTable where LOTNUMBER = @ParentLotNum" & vbCrLf
      sSql = sSql & "         " & vbCrLf
      sSql = sSql & "--print 'InLoopLevel:' + @MOPart + ' RUN:' + convert(varchar(10), @LotRunNo)" & vbCrLf
      sSql = sSql & "         --// update the top level" & vbCrLf
      sSql = sSql & "         UPDATE #tempMOPartsDetail SET INMORUN = @LotRunNo, LOTNUMBER = b.INLOTNUMBER, " & vbCrLf
      sSql = sSql & "                  INTOTMATL = b.INTOTMATL, INTOTLABOR = b.INTOTLABOR, " & vbCrLf
      sSql = sSql & "                  INTOTEXP = b.INTOTEXP, INTOTOH = b.INTOTOH, " & vbCrLf
      sSql = sSql & "                  LOTTOTMATL = c.LOTTOTMATL, LOTTOTLABOR = c.LOTTOTLABOR, " & vbCrLf
      sSql = sSql & "                  LOTTOTEXP = c.LOTTOTEXP, LOTTOTOH = c.LOTTOTOH," & vbCrLf
      sSql = sSql & "                  LOTDATECOSTED = c.LOTDATECOSTED, LOTORGQTY = @LotOrgQty," & vbCrLf
      sSql = sSql & "                  BMTOTOH = (c.LOTTOTOH * BMQTYREQD) / @LotOrgQty," & vbCrLf
      sSql = sSql & "              PICKEDDATE = INADATE" & vbCrLf
      sSql = sSql & "         FROM #tempMOPartsDetail d, InvaTable b, LohdTable c" & vbCrLf
      sSql = sSql & "         WHERE d.INMOPART = b.INMOPART AND d.INPART = b.INPART " & vbCrLf
      sSql = sSql & "            AND b.INLOTNUMBER = c.LOTnumber" & vbCrLf
      sSql = sSql & "            and c.lotpartref = b.INPART" & vbCrLf
      sSql = sSql & "            and b.INMOPART = @MOPart AND b.INMORUN  = @LotRunNo" & vbCrLf
      sSql = sSql & "            AND b.INTYPE = 10 AND SORTKEYLEVEL = @level" & vbCrLf
      sSql = sSql & "            AND c.LOTORIGINALQTY <> 0 AND INADATE <= @CutoffDate" & vbCrLf
      sSql = sSql & "      End" & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM curMORun INTO @MOPart, @Part" & vbCrLf
      sSql = sSql & "      End" & vbCrLf
      sSql = sSql & "      Close curMORun" & vbCrLf
      sSql = sSql & "      DEALLOCATE curMORun" & vbCrLf
      sSql = sSql & "      SET @level = @level + 1" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   SELECT @level =  MAX(SORTKEYLEVEL) FROM #tempMOPartsDetail" & vbCrLf
      sSql = sSql & "   WHILE (@level >= 0 )" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "      DECLARE curMODet CURSOR  FOR" & vbCrLf
      sSql = sSql & "      --SELECT INPART, LOTTOTMATL, LOTTOTLABOR, LOTTOTEXP , LOTTOTOH FROM #tempMOPartsDetail" & vbCrLf
      sSql = sSql & "      -- WHERE INPART = '775345149'" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "      SELECT INMOPART, " & vbCrLf
      sSql = sSql & "      SUM(IsNull(LOTTOTMATL, 0)), SUM(ISNULL(LOTTOTLABOR,0)) ," & vbCrLf
      sSql = sSql & "        Sum (IsNull(LOTTOTEXP, 0)) , SUM(IsNull(BMTOTOH, 0))" & vbCrLf
      sSql = sSql & "      From" & vbCrLf
      sSql = sSql & "         (SELECT DISTINCT INMOPART,INMORUN,INPART,LOTTOTMATL,LOTTOTLABOR," & vbCrLf
      sSql = sSql & "         LOTTOTEXP,LOTTOTOH,SUMTOTMAL,SUMTOTLABOR, SUMTOTEXP, SUMTOTOH,BMTOTOH" & vbCrLf
      sSql = sSql & "         FROM #tempMOPartsDetail WHERE SORTKEYLEVEL = @level) as foo" & vbCrLf
      sSql = sSql & "      group by INMOPART" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "      OPEN curMODet" & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM curMODet INTO @MOPart, @SumTotMat, @SumTotLabor,@SumTotExp,@SumTotOH" & vbCrLf
      sSql = sSql & "      WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "      BEGIN" & vbCrLf
      sSql = sSql & "         IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "         BEGIN" & vbCrLf
      sSql = sSql & "            " & vbCrLf
      sSql = sSql & "            print 'PartNum : ' + @MOPart" & vbCrLf
      sSql = sSql & "            print 'SumTotoh : ' + Convert(varchar(24), @SumTotOH)" & vbCrLf
      sSql = sSql & "            Print 'MO Qty :' + Convert(varchar(24), @MOQty)" & vbCrLf
      sSql = sSql & "            " & vbCrLf
      sSql = sSql & "            UPDATE #tempMOPartsDetail SET SUMTOTMAL = LOTTOTMATL + @SumTotMat, " & vbCrLf
      sSql = sSql & "            SUMTOTLABOR = LOTTOTLABOR + @SumTotLabor," & vbCrLf
      sSql = sSql & "               SUMTOTEXP = LOTTOTEXP + @SumTotExp, SUMTOTOH = (BMTOTOH + @SumTotOH) * @MOQty , " & vbCrLf
      sSql = sSql & "               HASCHILD = 1,PARTSUM = 'TOTAL ' + LTRIM(INPART)" & vbCrLf
      sSql = sSql & "            " & vbCrLf
      sSql = sSql & "            WHERE INPART = @MOPart AND SORTKEYLEVEL = @level - 1" & vbCrLf
      sSql = sSql & "            " & vbCrLf
      sSql = sSql & "      End" & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM curMODet INTO @MOPart, @SumTotMat, @SumTotLabor,@SumTotExp,@SumTotOH" & vbCrLf
      sSql = sSql & "      End" & vbCrLf
      sSql = sSql & "      Close curMODet" & vbCrLf
      sSql = sSql & "      DEALLOCATE curMODet" & vbCrLf
      sSql = sSql & "      SET @level = @level - 1" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   --// update the Lower level cost detail" & vbCrLf
      sSql = sSql & "    UPDATE #tempMOPartsDetail SET SUMTOTMAL = LOTTOTMATL, SUMTOTLABOR = LOTTOTLABOR," & vbCrLf
      sSql = sSql & "       SUMTOTEXP = LOTTOTEXP, SUMTOTOH = BMTOTOH WHERE HASCHILD IS NULL" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   SET @SumTotMat  = 0" & vbCrLf
      sSql = sSql & "   SET @SumTotLabor  = 0" & vbCrLf
      sSql = sSql & "   SET @SumTotExp  = 0" & vbCrLf
      sSql = sSql & "   SET @SumTotOH  = 0" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   --// Udpate the Root total" & vbCrLf
      sSql = sSql & "    SELECT @SumTotMat = SUM(SUMTOTMAL), @SumTotLabor = SUM(SUMTOTLABOR)," & vbCrLf
      sSql = sSql & "         @SumTotExp = SUM(SUMTOTEXP) ,@SumTotOH = SUM(SUMTOTOH)" & vbCrLf
      sSql = sSql & "     FROM #tempMOPartsDetail WHERE SORTKEYLEVEL = 0 " & vbCrLf
      sSql = sSql & "      AND  RTRIM(INMOPART) <> RTRIM(INPART)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "    UPDATE #tempMOPartsDetail SET PARTSUM = INPART" & vbCrLf
      sSql = sSql & "      WHERE PARTSUM IS NULL" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "  ----  SELECT * FROM #tempMOPartsDetail WHERE SORTKEYLEVEL = 0 " & vbCrLf
      sSql = sSql & "      ----AND  RTRIM(INMOPART) = RTRIM(INPART)" & vbCrLf
      sSql = sSql & "   --// Reverse the partnumbers." & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   set @level = 0 " & vbCrLf
      sSql = sSql & "   set @RowCount = 1" & vbCrLf
      sSql = sSql & "   SET @PrevParent = ''" & vbCrLf
      sSql = sSql & "   DECLARE curAcctStruc CURSOR  FOR" & vbCrLf
      sSql = sSql & "      SELECT INMOPART, SortKey" & vbCrLf
      sSql = sSql & "      FROM #tempMOPartsDetail " & vbCrLf
      sSql = sSql & "         WHERE HASCHILD IS NULL --GLFSLEVEL = 8 --AND GLMASTER ='AA10'--GLTOPMaster = 1 AND " & vbCrLf
      sSql = sSql & "      ORDER BY SortKey" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   OPEN curAcctStruc" & vbCrLf
      sSql = sSql & "   FETCH NEXT FROM curAcctStruc INTO @ParentPart, @SortKey" & vbCrLf
      sSql = sSql & "   WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "    IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "    BEGIN" & vbCrLf
      sSql = sSql & "      if (@PrevParent <> @ParentPart)" & vbCrLf
      sSql = sSql & "      BEGIN" & vbCrLf
      sSql = sSql & "         UPDATE #tempMOPartsDetail SET " & vbCrLf
      sSql = sSql & "            SortKeyRev = RIGHT ('0000'+ Cast(@RowCount as varchar), 4) + char(36)+ @ParentPart" & vbCrLf
      sSql = sSql & "         WHERE INMOPART = @ParentPart AND HASCHILD IS NULL --GLFSLEVEL = 8 --AND GLTOPMaster = 1 " & vbCrLf
      sSql = sSql & "         SET @RowCount = @RowCount + 1" & vbCrLf
      sSql = sSql & "         SET @PrevParent = @ParentPart" & vbCrLf
      sSql = sSql & "      END" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "    End" & vbCrLf
      sSql = sSql & "    FETCH NEXT FROM curAcctStruc INTO @ParentPart, @SortKey" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "       " & vbCrLf
      sSql = sSql & "   Close curAcctStruc" & vbCrLf
      sSql = sSql & "   DEALLOCATE curAcctStruc" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   SELECT @level =  MAX(SORTKEYLEVEL) FROM #tempMOPartsDetail" & vbCrLf
      sSql = sSql & "   --set @level = 7" & vbCrLf
      sSql = sSql & "   WHILE (@level >= 0 )" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "      SET @PrevParent = ''" & vbCrLf
      sSql = sSql & "        DECLARE curAcctStruc1 CURSOR  FOR" & vbCrLf
      sSql = sSql & "         SELECT DISTINCT INPART, INMOPART, SortKey" & vbCrLf
      sSql = sSql & "         FROM #tempMOPartsDetail " & vbCrLf
      sSql = sSql & "            WHERE SORTKEYLEVEL = @level AND HASCHILD IS NOT NULL--GLTOPMaster = 1 AND " & vbCrLf
      sSql = sSql & "         order by SortKey" & vbCrLf
      sSql = sSql & "    " & vbCrLf
      sSql = sSql & "        OPEN curAcctStruc1" & vbCrLf
      sSql = sSql & "        FETCH NEXT FROM curAcctStruc1 INTO @ChildPart, @ParentPart, @SortKey" & vbCrLf
      sSql = sSql & "        WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "        BEGIN" & vbCrLf
      sSql = sSql & "          IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "          BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "            if (@PrevParent <> @ChildPart)" & vbCrLf
      sSql = sSql & "            BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   --print 'Record' + @ChildPart + ':' + @ParentPart" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "               SELECT TOP 1 @ChildKey = SortKeyRev,@SortKey = SortKey" & vbCrLf
      sSql = sSql & "               FROM #tempMOPartsDetail " & vbCrLf
      sSql = sSql & "                  WHERE SORTKEYLEVEL > @level AND INMOPART = @ChildPart --GLTOPMaster = 1 AND " & vbCrLf
      sSql = sSql & "               order by SortKey desc" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "               UPDATE #tempMOPartsDetail SET " & vbCrLf
      sSql = sSql & "                  SortKeyRev = Cast(@ChildKey as varchar(256)) + char(36)+ @ParentPart" & vbCrLf
      sSql = sSql & "               WHERE INPART = @ChildPart AND INMOPART = @ParentPart " & vbCrLf
      sSql = sSql & "                  AND SORTKEYLEVEL = @level --GLTOPMaster = 1 AND " & vbCrLf
      sSql = sSql & "               " & vbCrLf
      sSql = sSql & "               SET @PrevParent = @ChildPart" & vbCrLf
      sSql = sSql & "            END" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "          End" & vbCrLf
      sSql = sSql & "         FETCH NEXT FROM curAcctStruc1 INTO @ChildPart, @ParentPart, @SortKey" & vbCrLf
      sSql = sSql & "        End" & vbCrLf
      sSql = sSql & "               " & vbCrLf
      sSql = sSql & "        Close curAcctStruc1" & vbCrLf
      sSql = sSql & "        DEALLOCATE curAcctStruc1" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "        SET @level = @level - 1" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   SELECT @LotTotOH = LOTTOTOH from lohdTable " & vbCrLf
      sSql = sSql & "   where lotpartref = @MOPart  AND LOTMORUNNO = @MORun " & vbCrLf
      sSql = sSql & "         AND LOTADATE <= @CutoffDate" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   IF @LotTotOH IS NULL" & vbCrLf
      sSql = sSql & "   SET @LotTotOH = @OH" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   SELECT @CalTotOH = SUM(ISNULL(BMTOTOH, 0)) + ISNULL(@LotTotOH, 0) FROM #tempMOPartsDetail" & vbCrLf
      sSql = sSql & "         WHERE SORTKEYLEVEL = 0" & vbCrLf
      sSql = sSql & "   print 'GetMOOverHead: CalOH:' + convert(varchar(10), @CalTotOH)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   --select * from #tempMOPartsDetail " & vbCrLf
      sSql = sSql & "   DROP table #tempMOPartsDetail " & vbCrLf
      sSql = sSql & "END"
      
      ExecuteScript False, sSql
      
      If (TableExists("RjitEmpTable")) Then
         sSql = "DROP TABLE RjitEmpTable"
         ExecuteScript False, sSql
      End If
      
      sSql = "CREATE TABLE [dbo].[RjitEmpTable](" & vbCrLf
      sSql = sSql & "   [RITREF] [char](12) NOT NULL," & vbCrLf
      sSql = sSql & "   [RITITM] [smallint] NOT NULL," & vbCrLf
      sSql = sSql & "   [PREMNUMBER] [int] NOT NULL" & vbCrLf
      sSql = sSql & " CONSTRAINT [PK_RjitEmpTable_RITREF] PRIMARY KEY CLUSTERED " & vbCrLf
      sSql = sSql & "(" & vbCrLf
      sSql = sSql & "   [RITREF] ASC," & vbCrLf
      sSql = sSql & "   [RITITM] ASC," & vbCrLf
      sSql = sSql & "   [PREMNUMBER] ASC" & vbCrLf
      sSql = sSql & ")WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 80) ON [PRIMARY]" & vbCrLf
      sSql = sSql & ") ON [PRIMARY]"
      
      ExecuteScript False, sSql
      
      'sSql = "ALTER TABLE [dbo].[RjitEmpTable]  WITH CHECK ADD  CONSTRAINT [FK_RjitEmpTable_RjhdTable] FOREIGN KEY([RITREF]) REFERENCES [dbo].[RjhdTable] ([REJREF])"
      'Execute False, sSql
      
      'sSql = "ALTER TABLE [dbo].[RjitEmpTable] CHECK CONSTRAINT [FK_RjitEmpTable_RjhdTable]"
      'Execute False, sSql
      
      sSql = "ALTER TABLE [dbo].[RjitEmpTable] ADD  CONSTRAINT [DF_RjitEmpTable_RITREF]  DEFAULT ('') FOR [RITREF]"
      ExecuteScript False, sSql
      
      sSql = "ALTER TABLE [dbo].[RjitEmpTable] ADD  CONSTRAINT [DF_RjitEmpTable_RITITM]  DEFAULT (0) FOR [RITITM]"
      ExecuteScript False, sSql
      
      If Not ColumnExists("RjitTable", "RITCUSTQTY") Then
         sSql = "ALTER TABLE RjitTable ADD RITREV varchar(1020), RITMATTYPE varchar(1020), " & vbCrLf
         sSql = sSql & "         RITCUSTQTY decimal(12, 4), RITLASTOP smallint," & vbCrLf
         sSql = sSql & "         RITPERCOMP decimal(12, 4)"
         
         ExecuteScript False, sSql
      End If

      
      sSql = "ALTER procedure [dbo].[ExplodedUsedOn]" & vbCrLf
      sSql = sSql & "(" & vbCrLf
      sSql = sSql & "   @PartRef varchar(30),      -- explode places this part is used" & vbCrLf
      sSql = sSql & "   @BomRev varchar(4)   " & vbCrLf
      sSql = sSql & ")" & vbCrLf
      sSql = sSql & "as" & vbCrLf
      sSql = sSql & "create table #temp" & vbCrLf
      sSql = sSql & "(" & vbCrLf
      sSql = sSql & "   UsedOnID int identity," & vbCrLf
      sSql = sSql & "   UsedOnLevel int," & vbCrLf
      sSql = sSql & "   IndentedLevel varchar(10)," & vbCrLf
      sSql = sSql & "   UsedOnPartRef varchar(30)," & vbCrLf
      sSql = sSql & "   UsedOnPartNum varchar(30)," & vbCrLf
      sSql = sSql & "   UsedOnQty decimal(12,3)," & vbCrLf
      sSql = sSql & "   UsedOnUnits varchar(2)," & vbCrLf
      sSql = sSql & "   ExplodedQty decimal(12,3)," & vbCrLf
      sSql = sSql & "   ExplodedUnits varchar(2)," & vbCrLf
      sSql = sSql & "   UsedOnConversion decimal(12,3)," & vbCrLf
      sSql = sSql & "   UsedOnPartType int," & vbCrLf
      sSql = sSql & "   ChildPartRef varchar(30)," & vbCrLf
      sSql = sSql & "   SortKey varchar(80)" & vbCrLf
      sSql = sSql & ")" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "declare @level int" & vbCrLf
      sSql = sSql & "set @level = 0" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "declare @RevLike as varchar(5)" & vbCrLf
      sSql = sSql & "set @RevLike = @BomRev + '%'" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "insert #temp (UsedOnLevel, IndentedLevel, UsedOnPartRef, UsedOnPartNum, UsedOnQty, UsedOnUnits," & vbCrLf
      sSql = sSql & "   ExplodedQty, ExplodedUnits, UsedOnConversion, UsedonPartType, SortKey)" & vbCrLf
      sSql = sSql & "   select @level, '0         '," & vbCrLf
      sSql = sSql & "   PARTREF, PARTNUM, 1, PAUNITS, 1, PAUNITS, 0, PALEVEL, '00000'" & vbCrLf
      sSql = sSql & "   from PartTable where PARTREF = @PartRef" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "-- keep exploding until no more" & vbCrLf
      sSql = sSql & "declare @LevelPrefix varchar(10)" & vbCrLf
      sSql = sSql & "set @LevelPrefix = '>'" & vbCrLf
      sSql = sSql & "declare @ct int" & vbCrLf
      sSql = sSql & "set @ct = 1" & vbCrLf
      sSql = sSql & "while @ct > 0 and @level < 10" & vbCrLf
      sSql = sSql & "begin" & vbCrLf
      sSql = sSql & "   print 'level ' + cast(@level as varchar(10)) + ' rows: ' + cast(@ct as varchar(10))" & vbCrLf
      sSql = sSql & "   insert #temp(UsedOnLevel, IndentedLevel, UsedOnPartRef, UsedOnPartNum, UsedOnQty, UsedOnUnits, " & vbCrLf
      sSql = sSql & "   ExplodedQty, ExplodedUnits," & vbCrLf
      sSql = sSql & "   UsedOnConversion, UsedOnPartType, ChildPartRef, SortKey)" & vbCrLf
      sSql = sSql & "   select @level + 1,  @LevelPrefix + CAST(@level + 1 as CHAR(1)) + REPLICATE(' ', 9 - len(@LevelPrefix))," & vbCrLf
      sSql = sSql & "   BMASSYPART, BMASSYPART, BMQTYREQD, BMUNITS," & vbCrLf
      sSql = sSql & "   ExplodedQty * BMQTYREQD / case when BMCONVERSION = 0 then 1 else BMCONVERSION end, ExplodedUnits, " & vbCrLf
      sSql = sSql & "   BMCONVERSION, PALEVEL, BMPARTREF, SortKey" & vbCrLf
      sSql = sSql & "   from BmplTable" & vbCrLf
      sSql = sSql & "   join #temp on BMPARTREF = UsedOnPartRef and BMREV LIKE @RevLike" & vbCrLf
      sSql = sSql & "   and UsedOnLevel = @level" & vbCrLf
      sSql = sSql & "   join PartTable on BMPARTREF = PARTREF" & vbCrLf
      sSql = sSql & "   order by BMPARTREF" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   set @ct = @@ROWCOUNT" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   update #temp set SortKey = SortKey + + replicate('0',5-len(cast(UsedOnID as varchar(5))))" & vbCrLf
      sSql = sSql & "   + cast(UsedOnID as varchar(5))" & vbCrLf
      sSql = sSql & "   where UsedOnLevel = @level + 1" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   set @level = @level + 1" & vbCrLf
      sSql = sSql & "   set @LevelPrefix = @LevelPrefix + '>'" & vbCrLf
      sSql = sSql & "end" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "select * from #temp order by SortKey" & vbCrLf
      sSql = sSql & "drop table #temp"
      
      ExecuteScript False, sSql
      
      
      If Not ColumnExists("PartTable", "PAITARRPT") Then
         sSql = "ALTER TABLE PartTable ADD PAITARRPT smallint NULL, PAEARRPT smallint NULL"
         ExecuteScript False, sSql
         
         sSql = "ALTER TABLE [dbo].[PartTable] ADD  CONSTRAINT [DF__PartTable__PAITARRPT]  DEFAULT ('') FOR [PAITARRPT]"
         ExecuteScript False, sSql
         
         sSql = "ALTER TABLE [dbo].[PartTable] ADD  CONSTRAINT [DF__PartTable__PAEARRPT]  DEFAULT ('') FOR [PAEARRPT]"
         ExecuteScript False, sSql
         
      End If
      
      ' update the version
      ExecuteScript False, "Update Version Set Version = " & newver
   
   End If
End Function

Private Function UpdateDatabase60()

   newver = 134
   If ver < newver Then

      If (Not TableExists("LolcTable")) Then
         sSql = "CREATE TABLE [dbo].[LolcTable]([LOTEXLOCATION] [varchar](4) NOT NULL) ON [PRIMARY]"
         ExecuteScript False, sSql
      End If

      If (Not TableExists("vw_LotInvQty")) Then
         
         sSql = "CREATE VIEW [dbo].[vw_LotInvQty]" & vbCrLf
         sSql = sSql & "AS" & vbCrLf
         sSql = sSql & "SELECT DISTINCT TOP (100) PERCENT g.LOINUMBER, g.LOIPARTREF, g.LOTUSERLOTID, g.LOTPARTREF, g.LOTDATECOSTED, g.LOTTOTLABOR, g.LOTTOTMATL," & vbCrLf
         sSql = sSql & "g.LOTTOTEXP , g.LOTTOTOH, f.INAMT, g.LOTUNITCOST, f.INPSNUMBER, f.INPSITEM, f.INPART, f.INLOTNUMBER, f.INAQTY, g.LOIQUANTITY" & vbCrLf
         sSql = sSql & "FROM (SELECT     SUM(dbo.LoitTable.LOIQUANTITY) AS LOIQUANTITY, dbo.LoitTable.LOINUMBER, dbo.LoitTable.LOIPARTREF, dbo.LohdTable.LOTUNITCOST," & vbCrLf
         sSql = sSql & "dbo.LoitTable.LOIPSNUMBER, dbo.LoitTable.LOIPSITEM, dbo.LohdTable.LOTUSERLOTID, dbo.LohdTable.LOTPARTREF," & vbCrLf
         sSql = sSql & "    dbo.LohdTable.LOTDATECOSTED, dbo.LohdTable.LOTTOTLABOR, dbo.LohdTable.LOTTOTMATL, dbo.LohdTable.LOTTOTEXP," & vbCrLf
         sSql = sSql & "    dbo.LohdTable.LOTTOTOH FROM  dbo.LoitTable INNER JOIN" & vbCrLf
         sSql = sSql & " dbo.LohdTable ON dbo.LoitTable.LOIPARTREF = dbo.LohdTable.LOTPARTREF AND" & vbCrLf
         sSql = sSql & "   dbo.LoitTable.LOINUMBER = dbo.LohdTable.lotNumber" & vbCrLf
         sSql = sSql & "GROUP BY dbo.LoitTable.LOINUMBER, dbo.LoitTable.LOIPARTREF, dbo.LohdTable.LOTUNITCOST, dbo.LoitTable.LOIPSNUMBER," & vbCrLf
         sSql = sSql & "dbo.LoitTable.LOIPSITEM, dbo.LohdTable.LOTUSERLOTID, dbo.LohdTable.LOTPARTREF, dbo.LohdTable.LOTDATECOSTED," & vbCrLf
         sSql = sSql & "dbo.LohdTable.LOTTOTLABOR, dbo.LohdTable.LOTTOTMATL, dbo.LohdTable.LOTTOTEXP, dbo.LohdTable.LOTTOTOH) AS g INNER JOIN" & vbCrLf
         sSql = sSql & "(SELECT     SUM(INAQTY) AS INAQTY, MAX(INAMT) AS INAMT, INPSNUMBER, INPSITEM, INPART, INLOTNUMBER" & vbCrLf
         sSql = sSql & "From dbo.InvaTable" & vbCrLf
         sSql = sSql & "WHERE      (INTYPE IN (24, 25, 26, 4, 3, 33))" & vbCrLf
         sSql = sSql & "GROUP BY INPSNUMBER, INPSITEM, INPART, INLOTNUMBER) AS f ON g.LOIPARTREF = f.INPART AND g.LOINUMBER = f.INLOTNUMBER AND" & vbCrLf
         sSql = sSql & "g.LOIPSNUMBER = f.INPSNUMBER And g.LOIPSITEM = f.INPSITEM" & vbCrLf
         sSql = sSql & "ORDER BY g.LOIPARTREF"
         
         ExecuteScript False, sSql
      End If
      
      If (Not TableExists("Vw_Sales_New")) Then
         sSql = "CREATE VIEW [dbo].[Vw_Sales_New]" & vbCrLf
         sSql = sSql & "AS" & vbCrLf
         sSql = sSql & "SELECT DISTINCT TOP (100) PERCENT dbo.CihdTable.INVCANCELED, dbo.CihdTable.INVTYPE, dbo.CihdTable.INVPRE, dbo.CihdTable.INVNO, dbo.CihdTable.INVCUST, " & vbCrLf
         sSql = sSql & "      dbo.CustTable.CUNUMBER, dbo.CustTable.CUNAME, dbo.CihdTable.INVDATE, dbo.CihdTable.INVPIF, dbo.PshdTable.PSCANCELED, " & vbCrLf
         sSql = sSql & "      dbo.PshdTable.PSTYPE, dbo.PsitTable.PIPACKSLIP, dbo.PsitTable.PIITNO, dbo.SoitTable.ITPSSHIPPED, " & vbCrLf
         sSql = sSql & "      dbo.SohdTable.SOSALESMAN AS PSSoSalesman, SohdTable_1.SOSALESMAN AS SOSoSlsmn, dbo.SohdTable.SOPO AS PSSoPo, " & vbCrLf
         sSql = sSql & "      SohdTable_1.SOPO AS SOSoPo, dbo.SohdTable.SODIVISION AS PSSoDiv, SohdTable_1.SODIVISION AS SOSoDiv, " & vbCrLf
         sSql = sSql & "      dbo.SohdTable.SOREGION AS PSSoReg, SohdTable_1.SOREGION AS SOSoReg, dbo.SohdTable.SOBUSUNIT AS PSSoBu, " & vbCrLf
         sSql = sSql & "      SohdTable_1.SOBUSUNIT AS SOSoBu, dbo.SprsTable.SPLAST AS PSSlsmnLast, SprsTable_1.SPLAST AS SOSlsmnLast, " & vbCrLf
         sSql = sSql & "      dbo.SprsTable.SPFIRST AS PSSlsmnFirst, SprsTable_1.SPFIRST AS SOSlsmnFirst, dbo.SprsTable.SPMIDD AS PSSlsmnInit, " & vbCrLf
         sSql = sSql & "      SprsTable_1.SPMIDD AS SOSlsmnInit, dbo.SohdTable.SOTYPE AS SOSoType, SohdTable_1.SOTYPE AS PSSoType, dbo.SoitTable.ITSO, " & vbCrLf
         sSql = sSql & "      dbo.SoitTable.ITNUMBER, dbo.SoitTable.ITREV, dbo.SoitTable.ITPART, dbo.PartTable.PARTNUM, dbo.PartTable.PADESC, dbo.PartTable.PALEVEL, " & vbCrLf
         sSql = sSql & "      dbo.PartTable.PALOTTRACK, dbo.PartTable.PAUSEACTUALCOST, dbo.PartTable.PAUNITS, dbo.PartTable.PAMAKEBUY, dbo.PartTable.PAFAMILY, " & vbCrLf
         sSql = sSql & "      dbo.PartTable.PAPRODCODE, dbo.PcodTable.PCDESC, dbo.PartTable.PACLASS, dbo.PclsTable.CCDESC, dbo.SoitTable.ITQTY, " & vbCrLf
         sSql = sSql & "      dbo.SoitTable.ITDOLLARS, dbo.SoitTable.ITADJUST, dbo.SoitTable.ITDISCAMOUNT, dbo.SoitTable.ITCOMMISSION, dbo.SoitTable.ITBOOKDATE, " & vbCrLf
         sSql = sSql & "      dbo.SoitTable.ITSCHED, dbo.SoitTable.ITACTUAL, dbo.SoitTable.ITCANCELDATE, dbo.SoitTable.ITCANCELED, dbo.SoitTable.ITREVACCT, " & vbCrLf
         sSql = sSql & "      dbo.GlacTable.GLACCTNO AS RevAcct, dbo.GlacTable.GLDESCR AS RevAcctDesc, dbo.SoitTable.ITCGSACCT, dbo.SoitTable.ITDISACCT, " & vbCrLf
         sSql = sSql & "      dbo.SoitTable.ITSTATE, dbo.SoitTable.ITTAXCODE, dbo.PartTable.PASTDCOST, dbo.PartTable.PATOTCOST, dbo.PartTable.PATOTLABOR, " & vbCrLf
         sSql = sSql & "      dbo.PartTable.PATOTMATL, dbo.PartTable.PATOTEXP, dbo.PartTable.PATOTOH, dbo.vw_LotInvQty.*" & vbCrLf
         sSql = sSql & "FROM  dbo.PsitTable LEFT OUTER JOIN" & vbCrLf
         sSql = sSql & "      dbo.vw_LotInvQty ON dbo.PsitTable.PIPACKSLIP = dbo.vw_LotInvQty.INPSNUMBER AND " & vbCrLf
         sSql = sSql & "      dbo.PsitTable.PIITNO = dbo.vw_LotInvQty.INPSITEM LEFT OUTER JOIN" & vbCrLf
         sSql = sSql & "      dbo.PshdTable ON dbo.PsitTable.PIPACKSLIP = dbo.PshdTable.PSNUMBER RIGHT OUTER JOIN" & vbCrLf
         sSql = sSql & "      dbo.GlacTable RIGHT OUTER JOIN" & vbCrLf
         sSql = sSql & "      dbo.SprsTable RIGHT OUTER JOIN" & vbCrLf
         sSql = sSql & "      dbo.SoitTable LEFT OUTER JOIN" & vbCrLf
         sSql = sSql & "      dbo.SohdTable ON dbo.SoitTable.ITSO = dbo.SohdTable.SONUMBER ON " & vbCrLf
         sSql = sSql & "      dbo.SprsTable.SPNUMBER = dbo.SohdTable.SOSALESMAN RIGHT OUTER JOIN" & vbCrLf
         sSql = sSql & "      dbo.CustTable RIGHT OUTER JOIN" & vbCrLf
         sSql = sSql & "      dbo.CihdTable ON dbo.CustTable.CUREF = dbo.CihdTable.INVCUST ON dbo.SoitTable.ITINVOICE = dbo.CihdTable.INVNO LEFT OUTER JOIN" & vbCrLf
         sSql = sSql & "      dbo.SprsTable AS SprsTable_1 RIGHT OUTER JOIN" & vbCrLf
         sSql = sSql & "      dbo.SohdTable AS SohdTable_1 ON SprsTable_1.SPNUMBER = SohdTable_1.SOSALESMAN ON " & vbCrLf
         sSql = sSql & "      dbo.CihdTable.INVSO = SohdTable_1.SONUMBER LEFT OUTER JOIN" & vbCrLf
         sSql = sSql & "      dbo.PcodTable RIGHT OUTER JOIN" & vbCrLf
         sSql = sSql & "      dbo.PclsTable RIGHT OUTER JOIN" & vbCrLf
         sSql = sSql & "      dbo.PartTable ON dbo.PclsTable.CCREF = dbo.PartTable.PACLASS ON dbo.PcodTable.PCREF = dbo.PartTable.PAPRODCODE ON " & vbCrLf
         sSql = sSql & "      dbo.SoitTable.ITPART = dbo.PartTable.PARTREF ON dbo.GlacTable.GLACCTREF = dbo.SoitTable.ITREVACCT ON " & vbCrLf
         sSql = sSql & "      dbo.PsitTable.PISONUMBER = dbo.SoitTable.ITSO AND dbo.PsitTable.PISOITEM = dbo.SoitTable.ITNUMBER AND " & vbCrLf
         sSql = sSql & "      dbo.PsitTable.PISOREV = dbo.SoitTable.ITREV" & vbCrLf
         sSql = sSql & "ORDER BY dbo.CihdTable.INVDATE, dbo.CihdTable.INVNO, dbo.SoitTable.ITSO, dbo.SoitTable.ITNUMBER, dbo.SoitTable.ITREV"
         
         ExecuteScript False, sSql
      End If

      If StoreProcedureExists("BalanceLotQtyToLotHd") Then
         sSql = "DROP PROCEDURE BalanceLotQtyToLotHd"
         ExecuteScript False, sSql
      End If

      sSql = "CREATE PROCEDURE [dbo].[BalanceLotQtyToLotHd] @PartRef as varchar(30), @LotCurNum as varchar(15), " & vbCrLf
      sSql = sSql & "   @sumLdQty as decimal(15,4), @sumLiQty as decimal(15,4), @LotUnitCost as decimal(15,4), " & vbCrLf
      sSql = sSql & "   @tDate as varchar(12), @tDebitAcct as varchar(12), @tCreditAcct as varchar(12)" & vbCrLf
      sSql = sSql & "AS BEGIN  " & vbCrLf
      sSql = sSql & "   declare @CurSubQty as decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @lCounter as int" & vbCrLf
      sSql = sSql & "   declare @MaxLoiRec as int" & vbCrLf
      sSql = sSql & "         " & vbCrLf
      sSql = sSql & "   IF (@sumLdQty > @sumLiQty)" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "      SET @CurSubQty = @sumLdQty - @sumLiQty" & vbCrLf
      sSql = sSql & "   END" & vbCrLf
      sSql = sSql & "   ELSE" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "      SET @CurSubQty = (@sumLiQty - @sumLdQty) * -1" & vbCrLf
      sSql = sSql & "   END" & vbCrLf
      sSql = sSql & "                        " & vbCrLf
      sSql = sSql & "   SELECT @lCounter = MAX(INNUMBER) + 1 FROM InvaTable" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   INSERT INTO InvaTable (INTYPE,INPART,INREF1,INREF2,INADATE,INPDATE," & vbCrLf
      sSql = sSql & "      INPQTY,INAQTY,INAMT,INCREDITACCT,INDEBITACCT,INNUMBER,INUSER, INLOTNUMBER) " & vbCrLf
      sSql = sSql & "   VALUES(19,@PartRef,'Manual Adj - LADM','', " & vbCrLf
      sSql = sSql & "      @tDate ,CONVERT(varchar(12), GETDATE(), 101)," & vbCrLf
      sSql = sSql & "        @CurSubQty, @CurSubQty,  @LotUnitCost,@tCreditAcct,@tDebitAcct,  @lCounter,'LAD', @LotCurNum)" & vbCrLf
      sSql = sSql & "                    " & vbCrLf
      sSql = sSql & "   SELECT @MaxLoiRec = MAX(LOIRECORD) + 1 FROM loitTable " & vbCrLf
      sSql = sSql & "         WHERE LOINUMBER = @LotCurNum" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   INSERT INTO LOITTable (LOINUMBER,LOIRECORD,LOITYPE,LOIPARTREF,LOIADATE,LOIPDATE,LOIQUANTITY," & vbCrLf
      sSql = sSql & "         LOIACTIVITY,LOIUNITS, LOICOMMENT)" & vbCrLf
      sSql = sSql & "      VALUES (@LotCurnum,@MaxLoiRec,19,@PartRef,@tDate," & vbCrLf
      sSql = sSql & "         CONVERT(varchar(12), GETDATE(),101) ,@CurSubQty," & vbCrLf
      sSql = sSql & "         @lCounter, 'EA', 'Manual Inventory Adj - LADM') " & vbCrLf
      sSql = sSql & "END "
      
      ExecuteScript False, sSql

      If StoreProcedureExists("UpdateLotQtyToActualQty") Then
         sSql = "DROP PROCEDURE UpdateLotQtyToActualQty"
         ExecuteScript False, sSql
      End If

      sSql = "CREATE PROCEDURE [dbo].[UpdateLotQtyToActualQty]" & vbCrLf
      sSql = sSql & "   @tPartRef as varchar(30), @tDate as varchar(12), @tPAQOH as decimal(15,4), @tLOTREMQTY  as decimal(15,4), " & vbCrLf
      sSql = sSql & "   @tActualQtyCnt  as decimal(15,4), @tDebitAcct as varchar(12), @tCreditAcct as varchar(12)" & vbCrLf
      sSql = sSql & "AS " & vbCrLf
      sSql = sSql & "BEGIN  " & vbCrLf
      sSql = sSql & "   declare @RunningLotQty as decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @LotCurRem as decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @CurSubQty as decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @LotUnitCost as decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @LotCurNum as varchar(15)" & vbCrLf
      sSql = sSql & "   declare @lCounter as int" & vbCrLf
      sSql = sSql & "   declare @MaxLoiRec as int" & vbCrLf
      sSql = sSql & "   declare @lotdate as datetime " & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   IF (@tLOTREMQTY > @tActualQtyCnt)" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "       SET @RunningLotQty = @tLOTREMQTY - @tActualQtyCnt" & vbCrLf
      sSql = sSql & "      " & vbCrLf
      sSql = sSql & "       DECLARE curLots CURSOR FOR " & vbCrLf
      sSql = sSql & "        select DISTINCT LOTNUMBER, LOTREMAININGQTY, LOTUNITCOST,LOTADATE  from LohdTable " & vbCrLf
      sSql = sSql & "               WHERE LOTPARTREF = @tPartRef AND LOTREMAININGQTY > 0 ORDER BY LOTADATE" & vbCrLf
      sSql = sSql & "        OPEN curLots" & vbCrLf
      sSql = sSql & "        FETCH NEXT FROM curLots INTO @LotCurNum, @LotCurRem, @LotUnitCost, @lotdate" & vbCrLf
      sSql = sSql & "        WHILE (@@FETCH_STATUS <> -1) " & vbCrLf
      sSql = sSql & "        BEGIN " & vbCrLf
      sSql = sSql & "          IF (@@FETCH_STATUS <> -2) " & vbCrLf
      sSql = sSql & "          BEGIN " & vbCrLf
      sSql = sSql & "            IF @RunningLotQty > 0.0000" & vbCrLf
      sSql = sSql & "            BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "               IF (@RunningLotQty > @LotCurRem)" & vbCrLf
      sSql = sSql & "               BEGIN" & vbCrLf
      sSql = sSql & "                  SET @CurSubQty = @LotCurRem" & vbCrLf
      sSql = sSql & "                  SET @RunningLotQty = @RunningLotQty - @LotCurRem" & vbCrLf
      sSql = sSql & "               END" & vbCrLf
      sSql = sSql & "               ELSE" & vbCrLf
      sSql = sSql & "               BEGIN" & vbCrLf
      sSql = sSql & "                  SET @CurSubQty = @RunningLotQty" & vbCrLf
      sSql = sSql & "                  SET @RunningLotQty = 0.0000" & vbCrLf
      sSql = sSql & "               END" & vbCrLf
      sSql = sSql & "               " & vbCrLf
      sSql = sSql & "               SELECT @lCounter = MAX(INNUMBER) + 1 FROM InvaTable" & vbCrLf
      sSql = sSql & "               " & vbCrLf
      sSql = sSql & "               INSERT INTO InvaTable (INTYPE,INPART,INREF1,INREF2,INADATE,INPDATE," & vbCrLf
      sSql = sSql & "                  INPQTY,INAQTY,INAMT,INCREDITACCT,INDEBITACCT,INNUMBER,INUSER, INLOTNUMBER) " & vbCrLf
      sSql = sSql & "               VALUES(19,@tPartRef,'Manual Adj - ADM','', " & vbCrLf
      sSql = sSql & "                  @tDate,CONVERT(varchar(12), GETDATE(), 101) ," & vbCrLf
      sSql = sSql & "                    -@CurSubQty, -@CurSubQty,  @LotUnitCost,@tCreditAcct,@tDebitAcct,  " & vbCrLf
      sSql = sSql & "                    @lCounter,'ADM', @LotCurRem)" & vbCrLf
      sSql = sSql & "                                " & vbCrLf
      sSql = sSql & "               SELECT @MaxLoiRec = MAX(LOIRECORD) + 1 FROM loitTable " & vbCrLf
      sSql = sSql & "                     WHERE LOINUMBER = @LotCurNum" & vbCrLf
      sSql = sSql & "               " & vbCrLf
      sSql = sSql & "               INSERT INTO LOITTable (LOINUMBER,LOIRECORD,LOITYPE,LOIPARTREF,LOIADATE," & vbCrLf
      sSql = sSql & "                  LOIPDATE,LOIQUANTITY, LOIACTIVITY,LOIUNITS, LOICOMMENT)" & vbCrLf
      sSql = sSql & "                  VALUES (@LotCurnum,@MaxLoiRec,19,@tPartRef,@tDate," & vbCrLf
      sSql = sSql & "                     CONVERT(varchar(12), GETDATE(),101) ,-@CurSubQty," & vbCrLf
      sSql = sSql & "                     @lCounter, 'EA', 'Manual Inventory Adjustment - ADM') " & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "               UPDATE lohdtable SET LOTREMAININGQTY = LOTREMAININGQTY - @CurSubQty " & vbCrLf
      sSql = sSql & "                        WHERE lotnumber = @LotCurnum" & vbCrLf
      sSql = sSql & "               " & vbCrLf
      sSql = sSql & "            END" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "            FETCH NEXT FROM curLots INTO @LotCurNum, @LotCurRem, @LotUnitCost, @lotdate" & vbCrLf
      sSql = sSql & "          END" & vbCrLf
      sSql = sSql & "         " & vbCrLf
      sSql = sSql & "        END" & vbCrLf
      sSql = sSql & "        CLOSE  curLots" & vbCrLf
      sSql = sSql & "        DEALLOCATE curLots" & vbCrLf
      sSql = sSql & "   END" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   ELSE" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "      SET @CurSubQty = @tActualQtyCnt - @tLOTREMQTY" & vbCrLf
      sSql = sSql & "      " & vbCrLf
      sSql = sSql & "      select TOP 1 @LotCurNum = LOTNUMBER, @LotCurRem = LOTREMAININGQTY, @LotUnitCost = LOTUNITCOST  " & vbCrLf
      sSql = sSql & "            FROM LohdTable WHERE LOTPARTREF = @tPartRef ORDER BY LOTADATE DESC" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "      SELECT @lCounter = MAX(INNUMBER) + 1 FROM InvaTable" & vbCrLf
      sSql = sSql & "               " & vbCrLf
      sSql = sSql & "      INSERT INTO InvaTable (INTYPE,INPART,INREF1,INREF2,INADATE,INPDATE," & vbCrLf
      sSql = sSql & "         INPQTY,INAQTY,INAMT,INCREDITACCT,INDEBITACCT,INNUMBER,INUSER) " & vbCrLf
      sSql = sSql & "      VALUES(19,@tPartRef,'Manual Adj - ADM','', " & vbCrLf
      sSql = sSql & "         @tDate,CONVERT(varchar(12), GETDATE(), 101)," & vbCrLf
      sSql = sSql & "           @CurSubQty, @CurSubQty,  @LotUnitCost,@tCreditAcct,@tDebitAcct,  @lCounter,'ADM')" & vbCrLf
      sSql = sSql & "                                " & vbCrLf
      sSql = sSql & "      SELECT @MaxLoiRec = MAX(LOIRECORD) + 1 FROM loitTable " & vbCrLf
      sSql = sSql & "            WHERE LOINUMBER = @LotCurNum" & vbCrLf
      sSql = sSql & "               " & vbCrLf
      sSql = sSql & "      INSERT INTO LOITTable (LOINUMBER,LOIRECORD,LOITYPE,LOIPARTREF,LOIADATE,LOIPDATE,LOIQUANTITY," & vbCrLf
      sSql = sSql & "            LOIACTIVITY,LOIUNITS, LOICOMMENT)" & vbCrLf
      sSql = sSql & "         VALUES (@LotCurnum,@MaxLoiRec,19,@tPartRef,@tDate," & vbCrLf
      sSql = sSql & "            CONVERT(varchar(12), GETDATE(),101) ,@CurSubQty," & vbCrLf
      sSql = sSql & "            @lCounter, 'EA', 'Manual Inventory Adjustment - ADM') " & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "      UPDATE lohdtable SET LOTREMAININGQTY = LOTREMAININGQTY + @CurSubQty WHERE lotnumber = @LotCurnum" & vbCrLf
      sSql = sSql & "   END" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "    UPDATE parttable SET PAQOH = @tActualQtyCnt, PALOTQTYREMAINING = @tActualQtyCnt WHERE partref = @tPartRef" & vbCrLf
      sSql = sSql & "END "
      
      ExecuteScript False, sSql

      ' update the version
      ExecuteScript False, "Update Version Set Version = " & newver
   
   End If
End Function

Private Function UpdateDatabase61()

   newver = 135
   If ver < newver Then

      If (Not TableExists("ASNMfestTable")) Then
         sSql = "CREATE TABLE [dbo].[ASNMfestTable](" & vbCrLf
         sSql = sSql & "[SUPPLIER_ID] [varchar](55) NOT NULL," & vbCrLf
         sSql = sSql & "[BUYER_ID] [varchar](55) NOT NULL," & vbCrLf
         sSql = sSql & "[PO_PREFIX] [varchar](6) NOT NULL," & vbCrLf
         sSql = sSql & "[SHIPPING_PREFIX] [varchar](6) NOT NULL," & vbCrLf
         sSql = sSql & "[SHIPPING_ID] [varchar](12) NULL" & vbCrLf
         sSql = sSql & ") ON [PRIMARY]"
         
         ExecuteScript False, sSql
      
      End If
      
      If (Not TableExists("tempMrplPartShort")) Then
         sSql = "CREATE TABLE [dbo].[tempMrplPartShort](" & vbCrLf
         sSql = sSql & "   [BMASSYPART] [varchar](30) NULL," & vbCrLf
         sSql = sSql & "   [BMPARTREF] [varchar](30) NULL," & vbCrLf
         sSql = sSql & "   [BMQTYREQD] [decimal](12, 4) NULL," & vbCrLf
         sSql = sSql & "   [PAQOH] [decimal](12, 4) NULL," & vbCrLf
         sSql = sSql & "   [PAQRUNTOT] [decimal](12, 4) NULL," & vbCrLf
         sSql = sSql & "   [SortKey] [varchar](512) NULL," & vbCrLf
         sSql = sSql & "   [HASCHILD] [int] NULL," & vbCrLf
         sSql = sSql & "   [SORTKEYLEVEL] [tinyint] NULL," & vbCrLf
         sSql = sSql & "   [SortKeyRev] [varchar](512) NULL," & vbCrLf
         sSql = sSql & "   [PAQSHORT] [decimal](12, 4) NULL," & vbCrLf
         sSql = sSql & "   [MRP_PARTQTYRQD] [decimal](12, 4) NULL," & vbCrLf
         sSql = sSql & "   [BMSEQUENCE] [int] NULL," & vbCrLf
         sSql = sSql & "   [RUNNO] [int] NULL," & vbCrLf
         sSql = sSql & "   [MRP_ACTIONDATE] [datetime] NULL" & vbCrLf
         sSql = sSql & ") ON [PRIMARY]"
         
         ExecuteScript False, sSql
      
      End If
      
      If (Not TableExists("vw_RnopPivot")) Then
      
         sSql = "CREATE VIEW [dbo].[vw_RnopPivot]" & vbCrLf
         sSql = sSql & "AS" & vbCrLf
         sSql = sSql & "SELECT dbo.RnopTable.OPREF, dbo.RnopTable.OPRUN, MAX(CASE WHEN RTRIM(OPNO) = '10' THEN OPCENTER END) AS 'OPNO1', " & vbCrLf
         sSql = sSql & "      MAX(CASE WHEN RTRIM(OPNO) = '20' THEN OPCENTER END) AS 'OPNO2', MAX(CASE WHEN RTRIM(OPNO) = '30' THEN OPCENTER END) " & vbCrLf
         sSql = sSql & "      AS 'OPNO3', MAX(CASE WHEN RTRIM(OPNO) = '40' THEN OPCENTER END) AS 'OPNO4', MAX(CASE WHEN RTRIM(OPNO) = '50' THEN OPCENTER END)" & vbCrLf
         sSql = sSql & "       AS 'OPNO5', MAX(CASE WHEN RTRIM(OPNO) = '60' THEN OPCENTER END) AS 'OPNO6', MAX(CASE WHEN RTRIM(OPNO) " & vbCrLf
         sSql = sSql & "      = '70' THEN OPCENTER END) AS 'OPNO7', MAX(CASE WHEN RTRIM(OPNO) = '80' THEN OPCENTER END) AS 'OPNO8', " & vbCrLf
         sSql = sSql & "      MAX(CASE WHEN RTRIM(OPNO) = '90' THEN OPCENTER END) AS 'OPNO9', MAX(CASE WHEN RTRIM(OPNO) = '100' THEN OPCENTER END) " & vbCrLf
         sSql = sSql & "      AS 'OPNO10', MAX(CASE WHEN RTRIM(OPNO) = '110' THEN OPCENTER END) AS 'OPNO11', MAX(CASE WHEN RTRIM(OPNO) " & vbCrLf
         sSql = sSql & "      = '120' THEN OPCENTER END) AS 'OPNO12', MAX(CASE WHEN RTRIM(OPNO) = '130' THEN OPCENTER END) AS 'OPNO13', " & vbCrLf
         sSql = sSql & "      MAX(CASE WHEN RTRIM(OPNO) = '140' THEN OPCENTER END) AS 'OPNO14', MAX(CASE WHEN RTRIM(OPNO) = '150' THEN OPCENTER END) " & vbCrLf
         sSql = sSql & "      AS 'OPNO15', MAX(CASE WHEN RTRIM(OPNO) = '160' THEN OPCENTER END) AS 'OPNO16', MAX(CASE WHEN RTRIM(OPNO) " & vbCrLf
         sSql = sSql & "      = '170' THEN OPCENTER END) AS 'OPNO17', MAX(CASE WHEN RTRIM(OPNO) = '180' THEN OPCENTER END) AS 'OPNO18', " & vbCrLf
         sSql = sSql & "      MAX(CASE WHEN RTRIM(OPNO) = '190' THEN OPCENTER END) AS 'OPNO19', MAX(CASE WHEN RTRIM(OPNO) = '200' THEN OPCENTER END) " & vbCrLf
         sSql = sSql & "      AS 'OPNO20', MAX(CASE WHEN RTRIM(OPNO) = '201' THEN OPCENTER END) AS 'OPNO21', MAX(CASE WHEN RTRIM(OPNO) " & vbCrLf
         sSql = sSql & "      = '202' THEN OPCENTER END) AS 'OPNO22', MAX(CASE WHEN RTRIM(OPNO) = '203' THEN OPCENTER END) AS 'OPNO23', " & vbCrLf
         sSql = sSql & "      MAX(CASE WHEN RTRIM(OPNO) = '204' THEN OPCENTER END) AS 'OPNO24', MAX(CASE WHEN RTRIM(OPNO) = '205' THEN OPCENTER END) " & vbCrLf
         sSql = sSql & "      AS 'OPNO25', MAX(CASE WHEN RTRIM(OPNO) = '206' THEN OPCENTER END) AS 'OPNO26', MAX(CASE WHEN RTRIM(OPNO) " & vbCrLf
         sSql = sSql & "      = '207' THEN OPCENTER END) AS 'OPNO27'" & vbCrLf
         sSql = sSql & "FROM dbo.RnopTable INNER JOIN" & vbCrLf
         sSql = sSql & "   dbo.RunsTable ON dbo.RnopTable.OPREF = dbo.RunsTable.RUNREF AND dbo.RnopTable.OPRUN = dbo.RunsTable.RUNNO" & vbCrLf
         sSql = sSql & "WHERE (dbo.RunsTable.RUNSTATUS <> 'CL') AND (dbo.RunsTable.RUNSTATUS <> 'CO') AND (dbo.RnopTable.OPCOMPDATE IS NULL)" & vbCrLf
         sSql = sSql & "GROUP BY dbo.RnopTable.OPREF, dbo.RnopTable.OPRUN"
         
         ExecuteScript False, sSql
      
      End If

      If (Not TableExists("vw_Mrpl_RunOP_Pivot")) Then
      
         sSql = "CREATE VIEW [dbo].[vw_Mrpl_RunOP_Pivot]" & vbCrLf
         sSql = sSql & "AS" & vbCrLf
         sSql = sSql & "SELECT MrpbaTable.MRPBOM_ROOTPARTREF, MrpbaTable.MRPBOM_PARTREF, MrplTable.MRP_PARTREF, MrplTable.MRP_PARTQTYRQD, " & vbCrLf
         sSql = sSql & "  MrplTable.MRP_PARTDATERQD, MrplTable.MRP_SOCUST, MrplTable.MRP_SONUM, MrplTable.MRP_COMMENT, PartTable.PAMAKEBUY, " & vbCrLf
         sSql = sSql & "  PartTable.PAQOH, SohdTable.SOSHIPDATE, dbo.RunsTable.RUNREF, dbo.RunsTable.RUNNO, dbo.vw_RnopPivot.OPNO1, dbo.vw_RnopPivot.OPNO2, " & vbCrLf
         sSql = sSql & "  dbo.vw_RnopPivot.OPNO3, dbo.vw_RnopPivot.OPNO4, dbo.vw_RnopPivot.OPNO5, dbo.vw_RnopPivot.OPNO6, dbo.vw_RnopPivot.OPNO7, " & vbCrLf
         sSql = sSql & "  dbo.vw_RnopPivot.OPNO8, dbo.vw_RnopPivot.OPNO9, dbo.RunsTable.RUNSCHED, dbo.RunsTable.RUNQTY, dbo.RunsTable.RUNSTATUS, " & vbCrLf
         sSql = sSql & "  dbo.vw_RnopPivot.OPNO10, dbo.vw_RnopPivot.OPNO11, dbo.vw_RnopPivot.OPNO12, dbo.vw_RnopPivot.OPNO13, dbo.vw_RnopPivot.OPNO14, " & vbCrLf
         sSql = sSql & "  dbo.vw_RnopPivot.OPNO15, dbo.vw_RnopPivot.OPNO16, dbo.vw_RnopPivot.OPNO17, dbo.vw_RnopPivot.OPNO18, dbo.vw_RnopPivot.OPNO20, " & vbCrLf
         sSql = sSql & "  dbo.vw_RnopPivot.OPNO19, dbo.vw_RnopPivot.OPNO21, dbo.vw_RnopPivot.OPNO22, dbo.vw_RnopPivot.OPNO23, dbo.vw_RnopPivot.OPNO24, " & vbCrLf
         sSql = sSql & "  dbo.vw_RnopPivot.OPNO25, dbo.vw_RnopPivot.OPNO26, dbo.vw_RnopPivot.OPNO27" & vbCrLf
         sSql = sSql & "FROM dbo.vw_RnopPivot INNER JOIN dbo.RunsTable ON dbo.vw_RnopPivot.OPREF = dbo.RunsTable.RUNREF " & vbCrLf
         sSql = sSql & "  AND dbo.vw_RnopPivot.OPRUN = dbo.RunsTable.RUNNO RIGHT OUTER JOIN" & vbCrLf
         sSql = sSql & "  dbo.MrpbaTable AS MrpbaTable INNER JOIN" & vbCrLf
         sSql = sSql & "  dbo.MrplTable AS MrplTable ON MrpbaTable.MRPBOM_PARTREF = MrplTable.MRP_PARTREF INNER JOIN" & vbCrLf
         sSql = sSql & "  dbo.PartTable AS PartTable ON MrplTable.MRP_PARTREF = PartTable.PARTREF ON " & vbCrLf
         sSql = sSql & "  dbo.RunsTable.RUNREF = MrpbaTable.MRPBOM_ROOTPARTREF LEFT OUTER JOIN" & vbCrLf
         sSql = sSql & "  dbo.SohdTable AS SohdTable ON MrplTable.MRP_SONUM = SohdTable.SONUMBER" & vbCrLf
         sSql = sSql & "WHERE (MrpbaTable.MRPBOM_LEVEL = 0) AND (MrplTable.MRP_TYPE = 11) AND (dbo.RunsTable.RUNSTATUS <> 'CL') AND " & vbCrLf
         sSql = sSql & "   (dbo.RunsTable.RUNSTATUS <> 'CO')"

         ExecuteScript False, sSql
      
      End If

      If StoreProcedureExists("RptMRPMOQtyShortage") Then
         sSql = "DROP PROCEDURE RptMRPMOQtyShortage"
         ExecuteScript False, sSql
      End If

      sSql = "CREATE PROCEDURE [dbo].[RptMRPMOQtyShortage]" & vbCrLf
      sSql = sSql & "      @InMOPart as varchar(30), @StartDate as datetime, @EndDate as datetime" & vbCrLf
      sSql = sSql & "AS " & vbCrLf
      sSql = sSql & "BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   declare @ChildKey as varchar(1024)" & vbCrLf
      sSql = sSql & "   declare @GLSortKey as varchar(1024)" & vbCrLf
      sSql = sSql & "   declare @SortKey as varchar(1024)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   declare @MOPart as varchar(30)" & vbCrLf
      sSql = sSql & "   declare @MORun as Integer" & vbCrLf
      sSql = sSql & "   declare @MOQtyRqd as decimal(12,4)" & vbCrLf
      sSql = sSql & "   declare @MOPartRqDt as datetime " & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   declare @Part as varchar(30)" & vbCrLf
      sSql = sSql & "   declare @PAQOH as decimal(12,4)" & vbCrLf
      sSql = sSql & "   declare @RunTot as decimal(12,4)" & vbCrLf
      sSql = sSql & "   declare @AssyPart as varchar(30)" & vbCrLf
      sSql = sSql & "   declare @BMQtyReq as decimal(12,4)" & vbCrLf
      sSql = sSql & "   declare @PartDateQrd as datetime" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   --DROP TABLE #tempMOPartsDetail " & vbCrLf
      sSql = sSql & "   DELETE FROM tempMrplPartShort" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "  BEGIN" & vbCrLf
      sSql = sSql & "   IF (@InMOPart = '')" & vbCrLf
      sSql = sSql & "      SET @InMOPart = @InMOPart + '%'" & vbCrLf
      sSql = sSql & "  " & vbCrLf
      sSql = sSql & "  DECLARE curMrpExp CURSOR  FOR" & vbCrLf
      sSql = sSql & "   SELECT MRP_PARTREF,0 as RUNNO, MRP_PARTQTYRQD, MRP_ACTIONDATE" & vbCrLf
      sSql = sSql & "   FROM MrplTable, PartTable   " & vbCrLf
      sSql = sSql & "   WHERE MRP_PARTREF = PartRef   " & vbCrLf
      sSql = sSql & "      AND MrplTable.MRP_PARTREF LIKE @InMOPart" & vbCrLf
      sSql = sSql & "      AND MrplTable.MRP_PARTPRODCODE LIKE '%'  " & vbCrLf
      sSql = sSql & "      AND MrplTable.MRP_PARTCLASS LIKE '%'  " & vbCrLf
      sSql = sSql & "      AND MrplTable.MRP_POBUYER LIKE '%'  " & vbCrLf
      sSql = sSql & "      AND MrplTable.MRP_PARTDATERQD BETWEEN @StartDate AND @EndDate" & vbCrLf
      sSql = sSql & "      AND MrplTable.MRP_TYPE IN (6, 5)   " & vbCrLf
      sSql = sSql & "      AND PartTable.PAMAKEBUY ='M'" & vbCrLf
      sSql = sSql & "   UNION" & vbCrLf
      sSql = sSql & "      SELECT DISTINCT RUNREF, RUNNO, RUNQTY,RUNSCHED  as MRP_ACTIONDATE FROM RunsTable WHERE " & vbCrLf
      sSql = sSql & "         RUNREF LIKE @InMOPart AND RUNSTATUS = 'SC'" & vbCrLf
      sSql = sSql & "         AND RUNPKSTART BETWEEN @StartDate  AND @EndDate order by MRP_ACTIONDATE" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "  OPEN curMrpExp" & vbCrLf
      sSql = sSql & "  FETCH NEXT FROM curMrpExp INTO @MOPart, @MORun, @MOQtyRqd, @MOPartRqDt" & vbCrLf
      sSql = sSql & "  WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "  BEGIN" & vbCrLf
      sSql = sSql & "     IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "     BEGIN" & vbCrLf
      sSql = sSql & "      with cte" & vbCrLf
      sSql = sSql & "      as (select BMASSYPART,BMPARTREF,BMPARTREV, BMQTYREQD , RTrim(BMUNITS) BMUNITS, " & vbCrLf
      sSql = sSql & "            BMCONVERSION, BMSEQUENCE, 0 as level," & vbCrLf
      sSql = sSql & "            cast(LTRIM(RTrim(BMASSYPART)) + char(36)+ COALESCE(cast(BMSEQUENCE as varchar(4)), '') + LTRIM(RTrim(BMPARTREF)) as varchar(max)) as SortKey" & vbCrLf
      sSql = sSql & "         from BmplTable" & vbCrLf
      sSql = sSql & "         where BMASSYPART = @MOPart" & vbCrLf
      sSql = sSql & "         union all" & vbCrLf
      sSql = sSql & "         select a.BMASSYPART,a.BMPARTREF,a.BMPARTREV, a.BMQTYREQD , RTrim(a.BMUNITS) BMUNITS, " & vbCrLf
      sSql = sSql & "            a.BMCONVERSION, a.BMSEQUENCE, level + 1," & vbCrLf
      sSql = sSql & "            cast(COALESCE(SortKey,'') + char(36) + COALESCE(cast(a.BMSEQUENCE as varchar(4)), '') + COALESCE(LTRIM(RTrim(a.BMPARTREF)) ,'') as varchar(max))as SortKey" & vbCrLf
      sSql = sSql & "         from cte" & vbCrLf
      sSql = sSql & "            inner join BmplTable a" & vbCrLf
      sSql = sSql & "               on cte.BMPARTREF = a.BMASSYPART" & vbCrLf
      sSql = sSql & "      ) " & vbCrLf
      sSql = sSql & "     INSERT INTO tempMrplPartShort(BMASSYPART,BMPARTREF,BMQTYREQD," & vbCrLf
      sSql = sSql & "      SORTKEYLEVEL,BMSEQUENCE, SortKey, PAQOH, RUNNO,MRP_PARTQTYRQD, MRP_ACTIONDATE)" & vbCrLf
      sSql = sSql & "     select BMASSYPART, BMPARTREF,BMQTYREQD,level,BMSEQUENCE, SortKey, PAQOH, @MORun, @MOQtyRqd, @MOPartRqDt" & vbCrLf
      sSql = sSql & "       from cte, PartTable WHERE PARTREF = BMPARTREF  AND BMPARTREF <> 'NULL' order by SortKey,BMSEQUENCE" & vbCrLf
      sSql = sSql & "        " & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "   FETCH NEXT FROM curMrpExp INTO @MOPart, @MORun, @MOQtyRqd, @MOPartRqDt" & vbCrLf
      sSql = sSql & "  End" & vbCrLf
      sSql = sSql & "  Close curMrpExp" & vbCrLf
      sSql = sSql & "  DEALLOCATE curMrpExp" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "  DECLARE curRunTot CURSOR  FOR" & vbCrLf
      sSql = sSql & "  select DISTINCT BMPARTREF, PAQOH from tempMrplPartShort order by BMPARTREF" & vbCrLf
      sSql = sSql & "  OPEN curRunTot" & vbCrLf
      sSql = sSql & "  FETCH NEXT FROM curRunTot INTO @Part, @PAQOH" & vbCrLf
      sSql = sSql & "  WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "  BEGIN" & vbCrLf
      sSql = sSql & "     IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "     BEGIN" & vbCrLf
      sSql = sSql & "        SET @RunTot = 0.0000" & vbCrLf
      sSql = sSql & "        SET @RunTot = @PAQOH" & vbCrLf
      sSql = sSql & "        DECLARE curRunTot1 CURSOR  FOR" & vbCrLf
      sSql = sSql & "         select DISTINCT BMASSYPART, BMQTYREQD, MRP_ACTIONDATE from tempMrplPartShort " & vbCrLf
      sSql = sSql & "            WHERE BMPARTREF = @Part" & vbCrLf
      sSql = sSql & "         order by BMASSYPART, MRP_ACTIONDATE " & vbCrLf
      sSql = sSql & "        OPEN curRunTot1" & vbCrLf
      sSql = sSql & "        FETCH NEXT FROM curRunTot1 INTO @AssyPart, @BMQtyReq, @PartDateQrd" & vbCrLf
      sSql = sSql & "        WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "        BEGIN" & vbCrLf
      sSql = sSql & "          IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "          BEGIN" & vbCrLf
      sSql = sSql & "            --Set @RunTot = ROUND(@RunTot,4)" & vbCrLf
      sSql = sSql & "            Set @RunTot = @RunTot -  @BMQtyReq" & vbCrLf
      sSql = sSql & "            UPDATE tempMrplPartShort SET PAQRUNTOT = @RunTot WHERE " & vbCrLf
      sSql = sSql & "               BMASSYPART = @AssyPart AND BMPARTREF = @Part AND MRP_ACTIONDATE = @PartDateQrd" & vbCrLf
      sSql = sSql & "          END" & vbCrLf
      sSql = sSql & "          FETCH NEXT FROM curRunTot1 INTO @AssyPart, @BMQtyReq, @PartDateQrd" & vbCrLf
      sSql = sSql & "        End" & vbCrLf
      sSql = sSql & "        Close curRunTot1" & vbCrLf
      sSql = sSql & "        DEALLOCATE curRunTot1" & vbCrLf
      sSql = sSql & "    END" & vbCrLf
      sSql = sSql & "    FETCH NEXT FROM curRunTot INTO @Part, @PAQOH" & vbCrLf
      sSql = sSql & "  End" & vbCrLf
      sSql = sSql & "  Close curRunTot" & vbCrLf
      sSql = sSql & "  DEALLOCATE curRunTot" & vbCrLf
      sSql = sSql & " END" & vbCrLf
      sSql = sSql & "END"

      ExecuteScript False, sSql

      If Not ColumnExists("ComnTable", "ALLOWOVERQTYCOMP") Then
         sSql = "ALTER TABLE ComnTable ADD ALLOWOVERQTYCOMP tinyint null"
         ExecuteScript False, sSql
      End If

      If Not ColumnExists("DdocTable", "DOLOC") Then
         sSql = "alter table dbo.DdocTable alter column DOLOC char(6)"
         ExecuteScript False, sSql
      End If


      ' update the version
      ExecuteScript False, "Update Version Set Version = " & newver
   
   End If
End Function

Private Function UpdateDatabase62()

   newver = 136
   If ver < newver Then

      If (Not TableExists("CshpviaTable")) Then
         
         sSql = "CREATE TABLE [dbo].[CshpviaTable](" & vbCrLf
         sSql = sSql & "   [SHPVIA] [Char](8), " & vbCrLf
         sSql = sSql & "   [SHPVDESC] [char](30) NULL," & vbCrLf
         sSql = sSql & "   [SHPVCOMT] [varchar](255) NULL," & vbCrLf
         sSql = sSql & " CONSTRAINT [PK_CshpViaTable_SHPVIA] PRIMARY KEY CLUSTERED" & vbCrLf
         sSql = sSql & "(" & vbCrLf
         sSql = sSql & "   [SHPVIA] Asc" & vbCrLf
         sSql = sSql & ")WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 80) ON [PRIMARY]" & vbCrLf
         sSql = sSql & ") ON [PRIMARY]"
         
         ExecuteScript False, sSql
      
         sSql = "ALTER TABLE [dbo].[CshpViaTable] ADD  CONSTRAINT [DF_CshpViaTable_SHIPREF]  DEFAULT ('') FOR [SHPVIA]"
         ExecuteScript False, sSql

         sSql = "ALTER TABLE [dbo].[CshpViaTable] ADD  CONSTRAINT [DF_CshpViaTable_SHIPDESC]  DEFAULT ('') FOR [SHPVDESC]"
         ExecuteScript False, sSql

         sSql = "ALTER TABLE [dbo].[CshpViaTable] ADD  CONSTRAINT [DF_CshpViaTable_SHIPCOMT]  DEFAULT ('') FOR [SHPVCOMT]"
         ExecuteScript False, sSql
      
      End If

      If Not StoreProcedureExists("Qry_FillSPVia") Then
         sSql = "CREATE PROCEDURE [dbo].[Qry_FillSPVia] AS" & vbCrLf
         sSql = sSql & "SELECT SHPVIA,SHPVDESC FROM CshpviaTable" & vbCrLf
         sSql = sSql & "ORDER BY SHPVIA"
         
         ExecuteScript False, sSql
      End If

      If StoreProcedureExists("RptInvMovFromWIP") Then
         sSql = "DROP PROCEDURE RptInvMovFromWIP"
         ExecuteScript False, sSql
      End If

      sSql = "CREATE PROCEDURE [dbo].[RptInvMovFromWIP]" & vbCrLf
      sSql = sSql & " @StartDate as varchar(16), @EndDate as Varchar(16), " & vbCrLf
      sSql = sSql & " @PartType1 as Integer, @PartType2 as Integer, @PartType3 as Integer, @PartType4 as Integer " & vbCrLf
      sSql = sSql & "AS " & vbCrLf
      sSql = sSql & "BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   IF (@PartType1 = 1)     " & vbCrLf
      sSql = sSql & "      SET @PartType1 = 1    " & vbCrLf
      sSql = sSql & "   Else                    " & vbCrLf
      sSql = sSql & "      SET @PartType1 = 0    " & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   IF (@PartType2 = 1)     " & vbCrLf
      sSql = sSql & "      SET @PartType2 = 2    " & vbCrLf
      sSql = sSql & "   Else                    " & vbCrLf
      sSql = sSql & "      SET @PartType2 = 0    " & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   IF (@PartType3 = 1)    " & vbCrLf
      sSql = sSql & "      SET @PartType3 = 3 " & vbCrLf
      sSql = sSql & "   Else                   " & vbCrLf
      sSql = sSql & "      SET @PartType3 = 0 " & vbCrLf
      sSql = sSql & "                          " & vbCrLf
      sSql = sSql & "   IF (@PartType4 = 1)    " & vbCrLf
      sSql = sSql & "      SET @PartType4 = 4 " & vbCrLf
      sSql = sSql & "   Else                   " & vbCrLf
      sSql = sSql & "      SET @PartType4 = 0 " & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   SELECT InvaTable.INTYPE,InvaTable.INLOTNUMBER,InvaTable.INPART, InvaTable.INREF2, " & vbCrLf
      sSql = sSql & "      InvaTable.INAQTY, InvaTable.INAMT, LohdTable.LOTORIGINALQTY, LohdTable.LOTTOTMATL, INTOTMATL, " & vbCrLf
      sSql = sSql & "      LohdTable.LOTTOTLABOR, INTOTLABOR, LohdTable.LOTTOTEXP, INTOTEXP, LohdTable.LOTTOTOH, INTOTOH," & vbCrLf
      sSql = sSql & "      LOTDATECOSTED, INDEBITACCT, INCREDITACCT" & vbCrLf
      sSql = sSql & "   FROM" & vbCrLf
      sSql = sSql & "      (PartTable PartTable INNER JOIN InvaTable InvaTable ON" & vbCrLf
      sSql = sSql & "         PartTable.PARTREF = InvaTable.INPART)" & vbCrLf
      sSql = sSql & "       LEFT OUTER JOIN LohdTable LohdTable ON" & vbCrLf
      sSql = sSql & "         InvaTable.INLOTNUMBER = LohdTable.LOTNUMBER" & vbCrLf
      sSql = sSql & "   WHERE" & vbCrLf
      sSql = sSql & "      InvaTable.INTYPE = 6 and " & vbCrLf
      sSql = sSql & "      Inadate between @StartDate and @EndDate " & vbCrLf
      sSql = sSql & "         AND PALEVEL IN (@PartType1, @PartType2, @PartType3, @PartType4)" & vbCrLf
      sSql = sSql & "   --    AND INPART = 'MX000075'" & vbCrLf
      sSql = sSql & "      AND INLOTNUMBER NOT IN (SELECT a.INLOTNUMBER  FROM InvaTable a where " & vbCrLf
      sSql = sSql & "         a.INPART = InvaTable.INPART" & vbCrLf
      sSql = sSql & "         --a.INPART = 'MX000075' " & vbCrLf
      sSql = sSql & "         AND a.INTYPE IN (6,38) AND a.Inadate between @StartDate and @EndDate" & vbCrLf
      sSql = sSql & "   GROUP BY INLOTNUMBER " & vbCrLf
      sSql = sSql & "   HAVING COUNT(INLOTNUMBER) > 1)" & vbCrLf
      sSql = sSql & "   ORDER BY" & vbCrLf
      sSql = sSql & "      PartTable.PALEVEL ASC," & vbCrLf
      sSql = sSql & "      PartTable.PACLASS ASC" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "END"
         
      ExecuteScript False, sSql
         
      If Not ColumnExists("DdocTable", "DOLOC") Then
         sSql = "alter table dbo.DdocTable alter column DOLOC char(6) NULL"
         ExecuteScript False, sSql
      End If
         
      If Not ColumnExists("EsReportLots01h", "LotExpDate") Then
         sSql = "ALTER TABLE dbo.EsReportLots01h ADD LotExpDate smalldatetime null"
         ExecuteScript False, sSql
      End If
         
      ' update the version
      ExecuteScript False, "Update Version Set Version = " & newver
   
   End If
End Function

Private Function UpdateDatabase63()

   newver = 137
   If ver < newver Then

      clsADOCon.ADOErrNum = 0
      
      sSql = "ALTER PROCEDURE [dbo].[BackLogBySchedDate]" & vbCrLf
      sSql = sSql & "    @BegDate as varchar(16), @EndDate as varchar(16), @Customer as varchar(10)," & vbCrLf
      sSql = sSql & "    @PartClass as Varchar(16),@PartCode as varchar(8),@SalesPer as varchar(4)" & vbCrLf
      sSql = sSql & "    AS                                               " & vbCrLf
      sSql = sSql & "    BEGIN                           " & vbCrLf
      sSql = sSql & "       declare @SoType as varchar(1)   " & vbCrLf
      sSql = sSql & "       declare @SoText as varchar(6)   " & vbCrLf
      sSql = sSql & "       declare @ItSo as int            " & vbCrLf
      sSql = sSql & "       declare @ItRev as char(2)       " & vbCrLf
      sSql = sSql & "       declare @ItNum as int           " & vbCrLf
      sSql = sSql & "       declare @ItQty as decimal(12,4) " & vbCrLf
      sSql = sSql & "       declare @PaLotRemQty as decimal(12,4)   " & vbCrLf
      sSql = sSql & "       declare @PartRem as decimal(12,4)       " & vbCrLf
      sSql = sSql & "       declare @RunningTot as decimal(12,4)    " & vbCrLf
      sSql = sSql & "       declare @ItDollars as decimal(12,4)     " & vbCrLf
      sSql = sSql & "       declare @ItSched as smalldatetime       " & vbCrLf
      sSql = sSql & "       declare @CusName as varchar(10)         " & vbCrLf
      sSql = sSql & "       declare @PartNum as varchar(30)         " & vbCrLf
      sSql = sSql & "       declare @CurPartNum as varchar(30)      " & vbCrLf
      sSql = sSql & "       declare @PartDesc as varchar(30)        " & vbCrLf
      sSql = sSql & "       declare @PartLoc as varchar(4)          " & vbCrLf
      sSql = sSql & "       declare @PartExDesc as varchar(3072)    " & vbCrLf
      sSql = sSql & "       declare @ItCanceled as tinyint          " & vbCrLf
      sSql = sSql & "       declare @ItPSNum as varchar(8)          " & vbCrLf
      sSql = sSql & "       declare @ItInvoice as int " & vbCrLf
      sSql = sSql & "       declare @ItPSShipped as tinyint   " & vbCrLf
      sSql = sSql & "       " & vbCrLf
      sSql = sSql & "       IF (@Customer = 'ALL')                      " & vbCrLf
      sSql = sSql & "             SET @Customer = ''                      " & vbCrLf
      sSql = sSql & "       IF (@PartClass = 'ALL')                     " & vbCrLf
      sSql = sSql & "          SET @PartClass = ''                     " & vbCrLf
      sSql = sSql & "       IF (@PartCode = 'ALL')                      " & vbCrLf
      sSql = sSql & "         SET @PartCode = ''                      " & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "       IF (@SalesPer = 'ALL')                      " & vbCrLf
      sSql = sSql & "         SET @SalesPer = ''                      " & vbCrLf
      sSql = sSql & "        " & vbCrLf
      sSql = sSql & "      CREATE TABLE #tempBackLogInfo               " & vbCrLf
      sSql = sSql & "                (SOTYPE varchar(1) NULL,        " & vbCrLf
      sSql = sSql & "                SOTEXT varchar(6) NULL,         " & vbCrLf
      sSql = sSql & "                ITSO Int NULL,                  " & vbCrLf
      sSql = sSql & "               ITREV char(2) NULL,              " & vbCrLf
      sSql = sSql & "                ITNUMBER int NULL,              " & vbCrLf
      sSql = sSql & "                ITQTY decimal(12,4) NULL,       " & vbCrLf
      sSql = sSql & "                PALOTQTYREMAINING decimal(12,4) NULL,   " & vbCrLf
      sSql = sSql & "                RUNQTYTOT decimal(12,4) NULL,   " & vbCrLf
      sSql = sSql & "                ITDOLLARS decimal(12,4) NULL,   " & vbCrLf
      sSql = sSql & "                ITSCHED smalldatetime NULL,     " & vbCrLf
      sSql = sSql & "                CUNICKNAME varchar(10) NULL,    " & vbCrLf
      sSql = sSql & "                PARTNUM varchar(30) NULL,       " & vbCrLf
      sSql = sSql & "               PADESC varchar(30) NULL,     " & vbCrLf
      sSql = sSql & "                PAEXTDESC varchar(3072) NULL,   " & vbCrLf
      sSql = sSql & "                PALOCATION varchar(4) NULL,     " & vbCrLf
      sSql = sSql & "                ITCANCELED tinyint NULL,        " & vbCrLf
      sSql = sSql & "                ITPSNUMBER varchar(8) NULL, ITINVOICE int NULL, " & vbCrLf
      sSql = sSql & "                ITPSSHIPPED tinyint NULL)       " & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "        DECLARE curbackLog CURSOR   FOR                             " & vbCrLf
      sSql = sSql & "        SELECT SohdTable.SOTYPE, SohdTable.SOTEXT,                  " & vbCrLf
      sSql = sSql & "            SoitTable.ITSO, SoitTable.ITREV, SoitTable.ITNUMBER,    " & vbCrLf
      sSql = sSql & "            SoitTable.ITQTY, PartTable.PALOTQTYREMAINING,           " & vbCrLf
      sSql = sSql & "            SoitTable.ITDOLLARS,SoitTable.ITSCHED, CustTable.CUNICKNAME,    " & vbCrLf
      sSql = sSql & "            PartTable.PARTNUM, PartTable.PADESC, PartTable.PAEXTDESC,       " & vbCrLf
      sSql = sSql & "            PartTable.PALOCATION, SoitTable.ITCANCELED,                     " & vbCrLf
      sSql = sSql & "            SoitTable.ITPSNUMBER , SoitTable.ITINVOICE, SoitTable.ITPSSHIPPED   " & vbCrLf
      sSql = sSql & "        From SohdTable, SoitTable, CustTable, PartTable             " & vbCrLf
      sSql = sSql & "        WHERE SohdTable.SOCUST = CustTable.CUREF AND                " & vbCrLf
      sSql = sSql & "            SohdTable.SONUMBER =SoitTable.ITSO AND                  " & vbCrLf
      sSql = sSql & "            SoitTable.ITPART=PartTable.PARTREF AND                  " & vbCrLf
      sSql = sSql & "            SoitTable.ITCANCELED=0 AND SoitTable.ITPSNUMBER=''      " & vbCrLf
      sSql = sSql & "            AND SoitTable.ITINVOICE=0 AND SoitTable.ITPSSHIPPED=0   " & vbCrLf
      sSql = sSql & "            AND CUREF LIKE '%' + @Customer + '%'                    " & vbCrLf
      sSql = sSql & "            AND SOSALESMAN LIKE '%' + @SalesPer + '%'" & vbCrLf
      sSql = sSql & "            AND SoitTable.ITSCHED BETWEEN @BegDate AND @EndDate     " & vbCrLf
      sSql = sSql & "            AND PartTable.PACLASS LIKE '%' + @PartClass + '%'       " & vbCrLf
      sSql = sSql & "            AND PartTable.PAPRODCODE LIKE '%' + @PartCode + '%'     " & vbCrLf
      sSql = sSql & "        ORDER BY partnum, ITSCHED                                   " & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "        OPEN curbackLog                                                " & vbCrLf
      sSql = sSql & "        FETCH NEXT FROM curbackLog INTO @SoType, @SoText, @ItSo,  @ItRev, @ItNum, @ItQty, @PaLotRemQty, " & vbCrLf
      sSql = sSql & "                        @ItDollars,@ItSched, @CusName, @PartNum,        " & vbCrLf
      sSql = sSql & "                        @PartDesc, @PartExDesc, @PartLoc, @ItCanceled,  " & vbCrLf
      sSql = sSql & "                        @ItPSNum, @ItInvoice, @ItPSShipped              " & vbCrLf
      sSql = sSql & "        SET @CurPartNum = @PartNum                                      " & vbCrLf
      sSql = sSql & "        SET @RunningTot = 0                                             " & vbCrLf
      sSql = sSql & "        WHILE (@@FETCH_STATUS <> -1)                                    " & vbCrLf
      sSql = sSql & "        BEGIN                                                           " & vbCrLf
      sSql = sSql & "            IF (@@FETCH_STATUS <> -2)                                   " & vbCrLf
      sSql = sSql & "            BEGIN                                                       " & vbCrLf
      sSql = sSql & "                IF  @CurPartNum <> @PartNum                             " & vbCrLf
      sSql = sSql & "               BEGIN                                                    " & vbCrLf
      sSql = sSql & "                    SET @RunningTot = @ItQty                            " & vbCrLf
      sSql = sSql & "                    set @CurPartNum = @PartNum                          " & vbCrLf
      sSql = sSql & "                End                                                     " & vbCrLf
      sSql = sSql & "                Else                                                    " & vbCrLf
      sSql = sSql & "                BEGIN                                                   " & vbCrLf
      sSql = sSql & "                    SET @RunningTot = @RunningTot + @ItQty              " & vbCrLf
      sSql = sSql & "                End                                                     " & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "                SET @PartRem = @PaLotRemQty - @RunningTot                       " & vbCrLf
      sSql = sSql & "                INSERT INTO #tempBackLogInfo (SOTYPE, SOTEXT, ITSO, ITREV,      " & vbCrLf
      sSql = sSql & "                    ITNUMBER,ITQTY, PALOTQTYREMAINING,RUNQTYTOT, ITDOLLARS,     " & vbCrLf
      sSql = sSql & "                    ITSCHED,CUNICKNAME, PARTNUM, PADESC,PAEXTDESC,PALOCATION,   " & vbCrLf
      sSql = sSql & "                         ITCANCELED, ITPSNUMBER, ITINVOICE, ITPSSHIPPED)             " & vbCrLf
      sSql = sSql & "                VALUES (@SoType, @SoText, @ItSo, @ItRev,@ItNum, @ItQty,@PaLotRemQty,@PartRem, @ItDollars,@ItSched,@CusName, " & vbCrLf
      sSql = sSql & "                    @PartNum,@PartDesc,@PartExDesc,@PartLoc, @ItCanceled,@ItPSNum,@ItInvoice,@ItPSShipped)  " & vbCrLf
      sSql = sSql & "            End                                                                 " & vbCrLf
      sSql = sSql & "            FETCH NEXT FROM curbackLog INTO @SoType, @SoText, @ItSo,            " & vbCrLf
      sSql = sSql & "                @ItRev, @ItNum, @ItQty, @PaLotRemQty,                           " & vbCrLf
      sSql = sSql & "                @ItDollars,@ItSched, @CusName, @PartNum,                        " & vbCrLf
      sSql = sSql & "                @PartDesc, @PartExDesc, @PartLoc, @ItCanceled,                  " & vbCrLf
      sSql = sSql & "                @ItPSNum, @ItInvoice, @ItPSShipped                              " & vbCrLf
      sSql = sSql & "        End                                                                     " & vbCrLf
      sSql = sSql & "        CLOSE curbackLog   --// close the cursor                                " & vbCrLf
      sSql = sSql & "        DEALLOCATE curbackLog                                                   " & vbCrLf
      sSql = sSql & "        -- select data for the report                                           " & vbCrLf
      sSql = sSql & "        SELECT SOTYPE, SOTEXT, ITSO, ITREV,                                     " & vbCrLf
      sSql = sSql & "            ITNUMBER,ITQTY, PALOTQTYREMAINING,RUNQTYTOT, ITDOLLARS,             " & vbCrLf
      sSql = sSql & "            ITSCHED,CUNICKNAME, PARTNUM, PADESC,PAEXTDESC, PALOCATION,          " & vbCrLf
      sSql = sSql & "            ITCANCELED , ITPSNUMBER, ITINVOICE, ITPSSHIPPED                     " & vbCrLf
      sSql = sSql & "        FROM #tempBackLogInfo                                                   " & vbCrLf
      sSql = sSql & "        ORDER BY ITSCHED                                                        " & vbCrLf
      sSql = sSql & "        -- drop the temp table                                                  " & vbCrLf
      sSql = sSql & "        DROP table #tempBackLogInfo                                             " & vbCrLf
      sSql = sSql & "   End                                                                     "
      
      ExecuteScript False, sSql
      
      If (TableExists("vw_RunAllocTable")) Then
         ExecuteScript False, "drop view vw_RunAllocTable"
      End If
      
      sSql = "CREATE VIEW [dbo].[vw_RunAllocTable]" & vbCrLf
      sSql = sSql & "AS " & vbCrLf
      sSql = sSql & "SELECT dbo.RunsTable.RUNSTATUS, dbo.RnalTable.RASO, dbo.RnalTable.RASOITEM, dbo.RnalTable.RASOREV, dbo.RunsTable.RUNREF, " & vbCrLf
      sSql = sSql & "  dbo.RunsTable.RUNNO, dbo.RunsTable.RUNFROZEN, dbo.RunsTable.RUNSCHED, dbo.RunsTable.RUNCOMPLETE, dbo.RunsTable.RUNDIVISION, " & vbCrLf
      sSql = sSql & "  dbo.RunsTable.RUNPKSTART, dbo.RunsTable.RUNMATL, dbo.RunsTable.RUNTYPE, dbo.RunsTable.RUNCOMMENTS, dbo.RunsTable.RUNLABOR, " & vbCrLf
      sSql = sSql & "  dbo.RunsTable.RUNSTDCOST, dbo.RunsTable.RUNPURGED, dbo.RunsTable.RUNQTY, dbo.RunsTable.RUNYIELD, dbo.RunsTable.RUNSTART, " & vbCrLf
      sSql = sSql & "  dbo.RunsTable.RUNENGREV, dbo.RunsTable.RUNPLDATE, dbo.RunsTable.RUNPKQTY, dbo.RunsTable.RUNSTATUS AS Expr1, " & vbCrLf
      sSql = sSql & "  dbo.RunsTable.RUNOPCUR, dbo.RunsTable.RUNPRIORITY, dbo.RunsTable.RUNREV, dbo.RunsTable.RUNEXP, dbo.RunsTable.RUNAPPURGED, " & vbCrLf
      sSql = sSql & "  dbo.RunsTable.RUNPKPURGED, dbo.RunsTable.RUNBUDLAB, dbo.RunsTable.RUNBUDMAT, dbo.RunsTable.RUNBUDEXP, " & vbCrLf
      sSql = sSql & "  dbo.RunsTable.RUNBUDOH, dbo.RunsTable.RUNBUDHRS, dbo.RunsTable.RUNCHARGED, dbo.RunsTable.RUNCOST, dbo.RunsTable.RUNOHCOST, " & vbCrLf
      sSql = sSql & "  dbo.RunsTable.RUNCMATL, dbo.RunsTable.RUNCEXP, dbo.RunsTable.RUNCHRS, dbo.RunsTable.RUNCLAB, dbo.RunsTable.RUNAPPDT, " & vbCrLf
      sSql = sSql & "  dbo.RunsTable.RUNAPPBY, dbo.RunsTable.RUNFINCOMP, dbo.RunsTable.RUNCLOSED, dbo.RunsTable.RUNREVBY, dbo.RunsTable.RUNREVDT, " & vbCrLf
      sSql = sSql & "  dbo.RunsTable.RUNCREATE, dbo.RunsTable.RUNPRINTED, dbo.RunsTable.RUNPDATE, dbo.RunsTable.RUNRELEASED, " & vbCrLf
      sSql = sSql & "  dbo.RunsTable.RUNLOTNUMBER, dbo.RunsTable.RUNPARTIALQTY, dbo.RunsTable.RUNPARTIALDATE, dbo.RunsTable.RUNSCRAP, " & vbCrLf
      sSql = sSql & "  dbo.RunsTable.RUNREWORK, dbo.RunsTable.RUNREMAININGQTY, dbo.RunsTable.RUNCANCELED, dbo.RunsTable.RUNCANCELEDBY, " & vbCrLf
      sSql = sSql & "  dbo.RunsTable.RUNLASTSPLITREF, dbo.RunsTable.RUNLASTSPLITRUNNO, dbo.RunsTable.RUNSPLITFROMREF, " & vbCrLf
      sSql = sSql & "  dbo.RunsTable.RUNSPLITFROMRUNNO, dbo.RunsTable.RUNRTNUM, dbo.RunsTable.RUNRTDESC, dbo.RunsTable.RUNRTBY, " & vbCrLf
      sSql = sSql & "  dbo.RunsTable.RUNRTAPPBY, dbo.RunsTable.RUNRTAPPDATE, dbo.RunsTable.RUNMAINTCOSTED" & vbCrLf
      sSql = sSql & "FROM dbo.RunsTable LEFT OUTER JOIN " & vbCrLf
      sSql = sSql & "  dbo.RnalTable ON dbo.RunsTable.RUNREF = dbo.RnalTable.RAREF AND dbo.RunsTable.RUNNO = dbo.RnalTable.RARUN" & vbCrLf
      
      ExecuteScript False, sSql

      If (Not TableExists("SprCusTable")) Then
         sSql = "CREATE TABLE SprCusTable" & vbCrLf
         sSql = sSql & "( " & vbCrLf
         sSql = sSql & "  SPCUSNUM VarChar(4), " & vbCrLf
         sSql = sSql & "  CUREF VarChar(10)" & vbCrLf
         sSql = sSql & ")"
      
         ExecuteScript False, sSql
         
      End If
      
      If StoreProcedureExists("RptMORunOptDetail") Then
         sSql = "DROP PROCEDURE RptMORunOptDetail"
         ExecuteScript False, sSql
      End If

      sSql = "CREATE PROCEDURE [dbo].[RptMORunOptDetail]" & vbCrLf
      sSql = sSql & "      @MOPart as varchar(30),@cutoffDt as varchar(10)" & vbCrLf
      sSql = sSql & "AS " & vbCrLf
      sSql = sSql & "BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   --delete from tempRunOpDet" & vbCrLf
      sSql = sSql & "   CREATE TABLE #tempRunOpDet" & vbCrLf
      sSql = sSql & "   ( " & vbCrLf
      sSql = sSql & "      RUNREF Varchar(30) NULL, " & vbCrLf
      sSql = sSql & "      RUNNO int Null, " & vbCrLf
      sSql = sSql & "      NextOPNO smallint NULL," & vbCrLf
      sSql = sSql & "      NextOPSHOP varchar(12) NULL," & vbCrLf
      sSql = sSql & "      NextOPCENTER varchar(12) NULL," & vbCrLf
      sSql = sSql & "      PONUMBER int NULL   " & vbCrLf
      sSql = sSql & "   ) " & vbCrLf
      sSql = sSql & "   INSERT INTO #tempRunOpDet(RUNREF, RUNNO, NextOPNO, NextOPSHOP, NextOPCENTER)" & vbCrLf
      sSql = sSql & "   select runstable.Runref, runstable.runno, f.NextOPNO, f.NextOPSHOP, f.NextOPCENTER from runstable," & vbCrLf
      sSql = sSql & "      (select a.runref, a.runno, b.OPNO NextOPNO, OPSHOP NextOPSHOP, OPCENTER NextOPCENTER," & vbCrLf
      sSql = sSql & "            ROW_NUMBER() OVER (PARTITION BY opref, oprun" & vbCrLf
      sSql = sSql & "                          ORDER BY opref DESC, oprun) as rn" & vbCrLf
      sSql = sSql & "         from runstable a,rnopTable b" & vbCrLf
      sSql = sSql & "         where a.runref = b.opref and " & vbCrLf
      sSql = sSql & "            a.runno = b.oprun and b.opno > a.runopcur" & vbCrLf
      sSql = sSql & "      ) as f" & vbCrLf
      sSql = sSql & "   where RunsTable.RUNSCHED <= @cutoffDt AND " & vbCrLf
      sSql = sSql & "      RunsTable.RUNSTATUS NOT IN ('CA','CL','CO') and RunsTable.runref =  @MOPart" & vbCrLf
      sSql = sSql & "      and RunsTable.runref =  f.runref AND RunsTable.runno = f.runno" & vbCrLf
      sSql = sSql & "      and f.rn = 1" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   UPDATE a SET a.PONUMBER = poitTable.PINUMBER" & vbCrLf
      sSql = sSql & "   from #tempRunOpDet a, ShopTable, poitTable WHERE SHPREF = nextOPSHOP " & vbCrLf
      sSql = sSql & "      AND SHPSERVICE = 1 AND PIRUNPART = RUNREF AND PIRUNNO = RUNNO" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   SELECT a.NextOPNO, a.NextOPSHOP, a.NextOPCENTER, a.PONUMBER, RnopTable.OPSHOP as CurOPShop," & vbCrLf
      sSql = sSql & "      RnopTable.OPCENTER as CurOPCenter, RunsTable.*" & vbCrLf
      sSql = sSql & "      FROM runstable, RnopTable, #tempRunOpDet a" & vbCrLf
      sSql = sSql & "      Where A.Runref = runstable.Runref And A.Runno = runstable.Runno" & vbCrLf
      sSql = sSql & "         AND RnopTable.OPREF = RunsTable.runref" & vbCrLf
      sSql = sSql & "         AND RnopTable.OPRUN = RunsTable.runno" & vbCrLf
      sSql = sSql & "         and RunsTable.runopcur = RnopTable.OPNO" & vbCrLf
      sSql = sSql & "      " & vbCrLf
      sSql = sSql & "   DROP table #tempRunOpDet " & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "END" & vbCrLf
      
      ExecuteScript False, sSql
      
      
      If StoreProcedureExists("RptEarlyLateDates") Then
         sSql = "DROP PROCEDURE RptEarlyLateDates"
         ExecuteScript False, sSql
      End If
      
      sSql = "CREATE PROCEDURE [dbo].[RptEarlyLateDates]  " & vbCrLf
      sSql = sSql & " @StartDate as varchar(16), @EndDate as Varchar(16), " & vbCrLf
      sSql = sSql & " @PartType1 as Integer, @PartType2 as Integer, @PartType3 as Integer, @PartType4 as Integer " & vbCrLf
      sSql = sSql & "AS  " & vbCrLf
      sSql = sSql & "BEGIN   " & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   declare @mrpMOPickDt as datetime " & vbCrLf
      sSql = sSql & "   declare @mrpDateRqd as datetime " & vbCrLf
      sSql = sSql & "   declare @mrpMORef as varchar(30) " & vbCrLf
      sSql = sSql & "   declare @mrpComment as varchar(80) " & vbCrLf
      sSql = sSql & "   declare @mrpCat as varchar(24) " & vbCrLf
      sSql = sSql & "   declare @mrpType as int " & vbCrLf
      sSql = sSql & "   declare @mrpMORun as int " & vbCrLf
      sSql = sSql & "   declare @RemOpHrs as decimal(15,2) " & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   IF (@PartType1 = 1)     " & vbCrLf
      sSql = sSql & "      SET @PartType1 = 1    " & vbCrLf
      sSql = sSql & "   Else                    " & vbCrLf
      sSql = sSql & "      SET @PartType1 = 0    " & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   IF (@PartType2 = 1)     " & vbCrLf
      sSql = sSql & "      SET @PartType2 = 2    " & vbCrLf
      sSql = sSql & "   Else                    " & vbCrLf
      sSql = sSql & "      SET @PartType2 = 0    " & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   IF (@PartType3 = 1)    " & vbCrLf
      sSql = sSql & "      SET @PartType3 = 3 " & vbCrLf
      sSql = sSql & "   Else                   " & vbCrLf
      sSql = sSql & "      SET @PartType3 = 0 " & vbCrLf
      sSql = sSql & "                          " & vbCrLf
      sSql = sSql & "   IF (@PartType4 = 1)    " & vbCrLf
      sSql = sSql & "      SET @PartType4 = 4 " & vbCrLf
      sSql = sSql & "   Else                   " & vbCrLf
      sSql = sSql & "      SET @PartType4 = 0 " & vbCrLf
      sSql = sSql & "    " & vbCrLf
      sSql = sSql & "   --DROP TABLE #tempRunReqDate" & vbCrLf
      sSql = sSql & "   --delete from #tempRunReqDate" & vbCrLf
      sSql = sSql & "   CREATE TABLE #tempRunReqDate(     " & vbCrLf
      sSql = sSql & "   [RUNREF] [char](30) NOT NULL," & vbCrLf
      sSql = sSql & "   [RUNNO] [int] NOT NULL," & vbCrLf
      sSql = sSql & "   [RUNSCHED] [smalldatetime] NULL," & vbCrLf
      sSql = sSql & "   [RUNCOMPLETE] [smalldatetime] NULL," & vbCrLf
      sSql = sSql & "   [RUNSTATUS] [char](2) NULL," & vbCrLf
      sSql = sSql & "   [RUNQTY] [decimal](12, 4) NULL," & vbCrLf
      sSql = sSql & "   [RUNCOST] [decimal](12, 4) NULL," & vbCrLf
      sSql = sSql & "   [MRP_TYPE] [tinyint] NULL," & vbCrLf
      sSql = sSql & "   [MRP_CATAGORY] [varchar](24) NULL," & vbCrLf
      sSql = sSql & "   [MRP_PARTDATERQD] [smalldatetime] NULL," & vbCrLf
      sSql = sSql & "   [MRP_COMMENT] [varchar](80) NULL," & vbCrLf
      sSql = sSql & "   [EARLYLATE_DAYS] [int] NULL" & vbCrLf
      sSql = sSql & "   )                               " & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   INSERT INTO #tempRunReqDate (RUNREF, RUNNO, RUNSTATUS, RUNSCHED, RUNCOMPLETE,RUNQTY,  " & vbCrLf
      sSql = sSql & "     RUNCOST)  " & vbCrLf
      sSql = sSql & "   SELECT RunsTable.RUNREF, RunsTable.RUNNO, RunsTable.RUNSTATUS, RunsTable.RUNSCHED, " & vbCrLf
      sSql = sSql & "      RunsTable.RUNCOMPLETE,RunsTable.RUNQTY, RunsTable.RUNCOST " & vbCrLf
      sSql = sSql & "   FROM RunsTable, PartTable where RunsTable.RUNREF = PartTable.PARTREF AND RUNSTATUS NOT IN ('CL', 'CA', 'CO')" & vbCrLf
      sSql = sSql & "         --AND RunsTable.RUNSCHED between @StartDate and @EndDate " & vbCrLf
      sSql = sSql & "          AND PALEVEL IN (@PartType1, @PartType2, @PartType3, @PartType4)" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   --// Update the dates for the ones with the SO allocations." & vbCrLf
      sSql = sSql & "   UPDATE a set a.MRP_TYPE = b.MRP_TYPE , a.MRP_CATAGORY = b.MRP_CATAGORY, " & vbCrLf
      sSql = sSql & "      a.MRP_PARTDATERQD = b.MRP_PARTDATERQD,a.MRP_COMMENT = b.MRP_COMMENT" & vbCrLf
      sSql = sSql & "      FROM #tempRunReqDate a,    MrplTable b, vw_RunAllocTable c" & vbCrLf
      sSql = sSql & "   WHERE b.MRP_PARTREF = c.RUNREF AND b.MRP_SONUM = c.RASO AND b.MRP_SOITEM = c.RASOITEM" & vbCrLf
      sSql = sSql & "      --AND b.MRP_PARTREF = '115A278011' " & vbCrLf
      sSql = sSql & "      AND b.MRP_TYPE = 11" & vbCrLf
      sSql = sSql & "      AND c.RUNSTATUS NOT IN ('CL', 'CA', 'CO')" & vbCrLf
      sSql = sSql & "      and a.runref = c.RUNREF AND a.runno = c.runno" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   DECLARE curMOPick CURSOR               " & vbCrLf
      sSql = sSql & "   LOCAL                               " & vbCrLf
      sSql = sSql & "   Scroll                              " & vbCrLf
      sSql = sSql & "   FOR                                     " & vbCrLf
      sSql = sSql & "      SELECT MrplTable.MRP_PARTDATERQD, MrplTable.MRP_MOREF, MrplTable.MRP_MORUNNO" & vbCrLf
      sSql = sSql & "      FROM MrplTable, #tempRunReqDate  WHERE MrplTable.MRP_TYPE IN (4,3) " & vbCrLf
      sSql = sSql & "         AND Mrp_MOREF = Runref and MRP_MORUNNO = RUNNO AND #tempRunReqDate.MRP_PARTDATERQD IS NULL" & vbCrLf
      sSql = sSql & "         --AND mrp_partref = '007F2416302IMA1'" & vbCrLf
      sSql = sSql & "   OPEN curMOPick" & vbCrLf
      sSql = sSql & "   FETCH NEXT FROM curMOPick INTO @mrpMOPickDt, @mrpMORef, @mrpMORun" & vbCrLf
      sSql = sSql & "   WHILE (@@FETCH_STATUS <> -1)                            " & vbCrLf
      sSql = sSql & "   BEGIN                                                   " & vbCrLf
      sSql = sSql & "   IF (@@FETCH_STATUS <> -2)                           " & vbCrLf
      sSql = sSql & "   BEGIN                                               " & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "      SELECT TOP (1) @mrpComment = MRP_COMMENT, @mrpDateRqd = MRP_PARTDATERQD," & vbCrLf
      sSql = sSql & "         @mrpCat = MRP_CATAGORY, @mrpType = MRP_TYPE" & vbCrLf
      sSql = sSql & "      FROM MrplTable WHERE MRP_TYPE = 14 " & vbCrLf
      sSql = sSql & "         AND MRP_PartDateRQD >= @mrpMOPickDt AND mrp_partref = @mrpMORef" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "      UPDATE a set a.MRP_TYPE = @mrpType, a.MRP_CATAGORY = @mrpCat, " & vbCrLf
      sSql = sSql & "         a.MRP_PARTDATERQD = @mrpDateRqd,a.MRP_COMMENT = @mrpComment" & vbCrLf
      sSql = sSql & "         FROM #tempRunReqDate a" & vbCrLf
      sSql = sSql & "      WHERE a.runref = @mrpMORef AND a.runno = @mrpMORun    " & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "      SET @mrpComment = NULL" & vbCrLf
      sSql = sSql & "      SET @mrpDateRqd = NULL" & vbCrLf
      sSql = sSql & "      SET @mrpCat = NULL" & vbCrLf
      sSql = sSql & "      SET @mrpType = NULL" & vbCrLf
      sSql = sSql & "      " & vbCrLf
      sSql = sSql & "      End                                                                     " & vbCrLf
      sSql = sSql & "   FETCH NEXT FROM curMOPick INTO @mrpMOPickDt, @mrpMORef, @mrpMORun" & vbCrLf
      sSql = sSql & "   End                                                                         " & vbCrLf
      sSql = sSql & "   CLOSE curMOPick  --// close the cursor                                        " & vbCrLf
      sSql = sSql & "   DEALLOCATE curMOPick                                                            " & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   UPDATE #tempRunReqDate SET EARLYLATE_DAYS = DATEDIFF(day, RUNSCHED, MRP_PARTDATERQD)" & vbCrLf
      sSql = sSql & "      WHERE MRP_PARTDATERQD IS NOT NULL" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   SELECT RUNREF, RUNNO, RUNSTATUS, RUNSCHED, RUNCOMPLETE,EARLYLATE_DAYS, RUNQTY,  " & vbCrLf
      sSql = sSql & "      RUNCOST, MRP_TYPE, MRP_CATAGORY, MRP_PARTDATERQD, MRP_COMMENT,PartTable.PARTNUM, " & vbCrLf
      sSql = sSql & "     PartTable.PADESC, PartTable.PAEXTDESC, PartTable.PALEVEL,PartTable.PAPRODCODE, " & vbCrLf
      sSql = sSql & "      PartTable.PACLASS, PartTable.PASTDCOST, PartTable.PAMAKEBUY" & vbCrLf
      sSql = sSql & "    FROM #tempRunReqDate, PartTable WHERE RUNREF = PartRef" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   Drop table #tempRunReqDate" & vbCrLf
      sSql = sSql & "  " & vbCrLf
      sSql = sSql & "END  "
      
      ExecuteScript False, sSql
      
      
      If Not ColumnExists("RunsTable", "RUNPREPKMOREF") Then
         sSql = "ALTER TABLE dbo.RunsTable ADD RUNPREPKMOREF varchar(30) NULL, RUNPREPKNO int NULL"
         ExecuteScript False, sSql
      End If
      
      If (TableExists("viewRptInventoryAdjustments")) Then
         ExecuteScript False, "drop view viewRptInventoryAdjustments"
      End If
      
      sSql = "CREATE VIEW [dbo].[viewRptInventoryAdjustments]" & vbCrLf
      sSql = sSql & "AS" & vbCrLf
      sSql = sSql & "SELECT dbo.InvaTable.INTYPE, dbo.InvaTable.INPART, dbo.InvaTable.INADATE, dbo.InvaTable.INREF1," & vbCrLf
      sSql = sSql & "  dbo.InvaTable.INAQTY , dbo.InvaTable.INAMT, dbo.InvaTable.INTOTMATL, dbo.InvaTable.INTOTLABOR, " & vbCrLf
      sSql = sSql & "  dbo.InvaTable.INTOTEXP , dbo.InvaTable.INTOTOH, dbo.InvaTable.INCREDITACCT, " & vbCrLf
      sSql = sSql & "  dbo.InvaTable.INDEBITACCT , dbo.LohdTable.LOTUNITCOST, dbo.LohdTable.LOTTOTMATL, " & vbCrLf
      sSql = sSql & "  dbo.LohdTable.LOTTOTLABOR , dbo.LohdTable.LOTTOTEXP, " & vbCrLf
      sSql = sSql & "  dbo.LohdTable.LOTTOTOH , dbo.LohdTable.lotNumber, dbo.LohdTable.LOTUSERLOTID, dbo.InvaTable.INNO, " & vbCrLf
      sSql = sSql & "  dbo.LohdTable.LOTORIGINALQTY " & vbCrLf
      sSql = sSql & "FROM dbo.LoitTable INNER JOIN" & vbCrLf
      sSql = sSql & "  dbo.LohdTable ON dbo.LoitTable.LOINUMBER = dbo.LohdTable.LOTNUMBER RIGHT OUTER JOIN" & vbCrLf
      sSql = sSql & "  dbo.InvaTable ON dbo.LoitTable.LOIPARTREF = dbo.InvaTable.INPART AND dbo.LoitTable.LOIACTIVITY = dbo.InvaTable.INNUMBER" & vbCrLf
      sSql = sSql & "Where (dbo.InvaTable.INTYPE = 19) Or " & vbCrLf
      sSql = sSql & "   (dbo.InvaTable.INTYPE = 30)"
      
      ExecuteScript False, sSql
      
      If StoreProcedureExists("RptInventoryAdjustments") Then
         sSql = "DROP PROCEDURE RptInventoryAdjustments"
         ExecuteScript False, sSql
      End If
      
      sSql = "CREATE PROCEDURE [dbo].[RptInventoryAdjustments] " & vbCrLf
      sSql = sSql & "@StartDate as varchar(16), @EndDate as Varchar(16), @PartClass as Varchar(16),@PartCode as varchar(8)" & vbCrLf
      sSql = sSql & "AS " & vbCrLf
      sSql = sSql & "BEGIN " & vbCrLf
      sSql = sSql & "   declare @partRef as varchar(30) " & vbCrLf
      sSql = sSql & "   declare @partNum as varchar(30) " & vbCrLf
      sSql = sSql & "   declare @partDesc as varchar(30) " & vbCrLf
      sSql = sSql & "   declare @partExDesc as varchar(3072) " & vbCrLf
      sSql = sSql & "   declare @lotNum as varchar(15) " & vbCrLf
      sSql = sSql & "   declare @lotUserID as varchar(40) " & vbCrLf
      sSql = sSql & "   declare @Inno as Int " & vbCrLf
      sSql = sSql & "   declare @actualDt as varchar(30) " & vbCrLf
      sSql = sSql & "   declare @qty as decimal(12, 4)" & vbCrLf
      sSql = sSql & "   declare @Orgqty as decimal(12, 4)" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   declare @invAmt as decimal(12,4) " & vbCrLf
      sSql = sSql & "   declare @invTotMatl decimal(12,4) " & vbCrLf
      sSql = sSql & "   declare @invTotLabor decimal(12,4) " & vbCrLf
      sSql = sSql & "   declare @invTotExp decimal(12,4) " & vbCrLf
      sSql = sSql & "   declare @invTotOH decimal(12,4) " & vbCrLf
      sSql = sSql & "   declare @creditAcc varchar(12)" & vbCrLf
      sSql = sSql & "   declare @debitAcc varchar(12)" & vbCrLf
      sSql = sSql & "   declare @lotTotMatl decimal(12,4) " & vbCrLf
      sSql = sSql & "   declare @lotTotLabor decimal(12,4) " & vbCrLf
      sSql = sSql & "   declare @lotTotExp decimal(12,4) " & vbCrLf
      sSql = sSql & "   declare @lotTotOH decimal(12,4) " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   declare @totMatlCost decimal(12,4) " & vbCrLf
      sSql = sSql & "   declare @totLaborCost decimal(12,4) " & vbCrLf
      sSql = sSql & "   declare @totExpCost decimal(12,4) " & vbCrLf
      sSql = sSql & "   declare @totOHCost decimal(12,4) " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   declare @fInvMatl int " & vbCrLf
      sSql = sSql & "   declare @fInvLabor int " & vbCrLf
      sSql = sSql & "   declare @fInvExp int " & vbCrLf
      sSql = sSql & "   declare @fInvOH int " & vbCrLf
      sSql = sSql & "   declare @invType int" & vbCrLf
      sSql = sSql & "                      " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "    IF (@PartClass = 'ALL') " & vbCrLf
      sSql = sSql & "    BEGIN " & vbCrLf
      sSql = sSql & "      SET @PartClass = '' " & vbCrLf
      sSql = sSql & "    End " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "    IF (@PartCode = 'ALL') " & vbCrLf
      sSql = sSql & "    BEGIN " & vbCrLf
      sSql = sSql & "      SET @PartCode = '' " & vbCrLf
      sSql = sSql & "    End " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   -- DELETE FROM #tempINVReport " & vbCrLf
      sSql = sSql & "   --ALTER TABLE #tempINVReport  Add INTYPE int null" & vbCrLf
      sSql = sSql & "   --ALTER TABLE #tempINVReport  Add LOTORIGINALQTY decimal(12,4) null" & vbCrLf
      sSql = sSql & "   CREATE TABLE #tempINVReport " & vbCrLf
      sSql = sSql & "   ( " & vbCrLf
      sSql = sSql & "      PARTNUM Varchar(30) NULL, " & vbCrLf
      sSql = sSql & "      PADESC varchar(30) NULL , " & vbCrLf
      sSql = sSql & "      PAEXTDESC varchar(3072) NULL , " & vbCrLf
      sSql = sSql & "     LOTNUMBER varchar(15) NULL, " & vbCrLf
      sSql = sSql & "     LOTUSERLOTID varchar(40) NULL, " & vbCrLf
      sSql = sSql & "     LOTORIGINALQTY decimal(12,4) null," & vbCrLf
      sSql = sSql & "    INTYPE int null," & vbCrLf
      sSql = sSql & "     INNO int NULL, " & vbCrLf
      sSql = sSql & "      INADATE varchar(30) NULL, " & vbCrLf
      sSql = sSql & "      INAQTY decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      INAMT decimal (12,4) NULL, " & vbCrLf
      sSql = sSql & "       TOTMATL decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "       TOTLABOR decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "       TOTEXP decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "       TOTOH decimal(12,4) NULL, " & vbCrLf
      sSql = sSql & "      CREDITACCT varchar(12) NULL, " & vbCrLf
      sSql = sSql & "      DEBITACCT varchar(12) NULL, " & vbCrLf
      sSql = sSql & "      flgMatl int NULL, " & vbCrLf
      sSql = sSql & "      flgLabor int NULL, " & vbCrLf
      sSql = sSql & "      flgExp int NULL, " & vbCrLf
      sSql = sSql & "      flgOH int NULL " & vbCrLf
      sSql = sSql & "   ) " & vbCrLf
      sSql = sSql & "    " & vbCrLf
      sSql = sSql & "   DECLARE curInvRpt CURSOR   FOR " & vbCrLf
      sSql = sSql & "      SELECT INTYPE, INPART, LOTNUMBER, LOTUSERLOTID, INNO, INADATE, " & vbCrLf
      sSql = sSql & "         INAQTY, LOTORIGINALQTY, INAMT, INTOTMATL, " & vbCrLf
      sSql = sSql & "         INTOTLABOR, INTOTEXP, INTOTOH, " & vbCrLf
      sSql = sSql & "         INCREDITACCT, INDEBITACCT, LOTTOTMATL, " & vbCrLf
      sSql = sSql & "         LOTTOTLABOR, LOTTOTEXP, LOTTOTOH, " & vbCrLf
      sSql = sSql & "         PartNum , PADESC, PAEXTDESC " & vbCrLf
      sSql = sSql & "      From viewRptInventoryAdjustments, PartTable " & vbCrLf
      sSql = sSql & "      Where viewRptInventoryAdjustments.INPART = PartTable.PartRef " & vbCrLf
      sSql = sSql & "         AND viewRptInventoryAdjustments.INADATE BETWEEN @StartDate AND @EndDate" & vbCrLf
      sSql = sSql & "         AND PartTable.PACLASS LIKE '%' + @PartClass + '%' " & vbCrLf
      sSql = sSql & "         AND PartTable.PAPRODCODE LIKE '%' + @PartCode + '%' " & vbCrLf
      sSql = sSql & "--         AND INPART = '65B801038' " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   OPEN curInvRpt " & vbCrLf
      sSql = sSql & "   FETCH NEXT FROM curInvRpt INTO @invType, @partRef, @lotNum, @lotUserID, @Inno, @actualDt, @qty, @Orgqty, " & vbCrLf
      sSql = sSql & "                  @invAmt, @invTotMatl, @invTotLabor, " & vbCrLf
      sSql = sSql & "                  @invTotExp,@invTotOH, @creditAcc, @debitAcc, " & vbCrLf
      sSql = sSql & "                  @lotTotMatl, @lotTotLabor, @lotTotExp, @lotTotOH, " & vbCrLf
      sSql = sSql & "                  @partNum, @partDesc, @partExDesc " & vbCrLf
      sSql = sSql & "   WHILE (@@FETCH_STATUS <> -1) " & vbCrLf
      sSql = sSql & "   BEGIN " & vbCrLf
      sSql = sSql & "      IF (@@FETCH_STATUS <> -2) " & vbCrLf
      sSql = sSql & "      BEGIN " & vbCrLf
      sSql = sSql & "          " & vbCrLf
      sSql = sSql & "         -- Get the costed values from Lothd table " & vbCrLf
      sSql = sSql & "         -- if the Inv table does not have the cost for " & vbCrLf
      sSql = sSql & "         -- material, expenses, OH and Labour. " & vbCrLf
      sSql = sSql & "         SET @totMatlCost = @invTotMatl " & vbCrLf
      sSql = sSql & "         SET @fInvMatl = 1 " & vbCrLf
      sSql = sSql & "         IF (@invTotMatl = 0.0000) " & vbCrLf
      sSql = sSql & "         BEGIN " & vbCrLf
      sSql = sSql & "            IF (@lotTotMatl IS NOT NULL) AND (@Orgqty <> 0.0000)" & vbCrLf
      sSql = sSql & "            BEGIN " & vbCrLf
      sSql = sSql & "             " & vbCrLf
      sSql = sSql & "               SET @totMatlCost = (@qty * @lotTotMatl ) / @Orgqty" & vbCrLf
      sSql = sSql & "               SET @fInvMatl = 0 " & vbCrLf
      sSql = sSql & "            End " & vbCrLf
      sSql = sSql & "         End " & vbCrLf
      sSql = sSql & "         -- Labour " & vbCrLf
      sSql = sSql & "         SET @totLaborCost = @invTotLabor " & vbCrLf
      sSql = sSql & "         SET @fInvLabor = 1 " & vbCrLf
      sSql = sSql & "         IF (@invTotLabor = 0.0000) " & vbCrLf
      sSql = sSql & "         BEGIN " & vbCrLf
      sSql = sSql & "            IF (@lotTotLabor IS NOT NULL) " & vbCrLf
      sSql = sSql & "            BEGIN " & vbCrLf
      sSql = sSql & "               SET @totLaborCost = (@qty * @lotTotLabor) / @Orgqty " & vbCrLf
      sSql = sSql & "               SET @fInvLabor = 0 " & vbCrLf
      sSql = sSql & "            End " & vbCrLf
      sSql = sSql & "         End " & vbCrLf
      sSql = sSql & "         -- Exp " & vbCrLf
      sSql = sSql & "         SET @totExpCost = @invTotExp " & vbCrLf
      sSql = sSql & "         SET @fInvExp = 1 " & vbCrLf
      sSql = sSql & "         IF (@invTotExp = 0.0000) " & vbCrLf
      sSql = sSql & "         BEGIN " & vbCrLf
      sSql = sSql & "            IF (@lotTotExp IS NOT NULL) " & vbCrLf
      sSql = sSql & "            BEGIN " & vbCrLf
      sSql = sSql & "               SET @totExpCost = (@qty * @lotTotExp ) / @Orgqty" & vbCrLf
      sSql = sSql & "               SET @fInvExp = 0 " & vbCrLf
      sSql = sSql & "            End " & vbCrLf
      sSql = sSql & "         End " & vbCrLf
      sSql = sSql & "         -- OH " & vbCrLf
      sSql = sSql & "         SET @totOHCost = @invTotOH " & vbCrLf
      sSql = sSql & "         SET @fInvOH = 1 " & vbCrLf
      sSql = sSql & "         IF (@invTotOH = 0.0000) " & vbCrLf
      sSql = sSql & "         BEGIN " & vbCrLf
      sSql = sSql & "            IF (@lotTotOH IS NOT NULL) " & vbCrLf
      sSql = sSql & "            BEGIN " & vbCrLf
      sSql = sSql & "               SET @totOHCost = (@qty * @lotTotOH ) / @Orgqty" & vbCrLf
      sSql = sSql & "               SET @fInvOH = 0 " & vbCrLf
      sSql = sSql & "            End " & vbCrLf
      sSql = sSql & "         End " & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "         -- Insert to the temp table " & vbCrLf
      sSql = sSql & "         INSERT INTO #tempINVReport (PARTNUM, LOTNUMBER, LOTUSERLOTID, " & vbCrLf
      sSql = sSql & "            INNO, PADESC, PAEXTDESC, INADATE, " & vbCrLf
      sSql = sSql & "               INAQTY, LOTORIGINALQTY, INAMT, TOTMATL,TOTLABOR,TOTEXP,TOTOH, CREDITACCT, DEBITACCT, " & vbCrLf
      sSql = sSql & "               flgMatl, flgLabor, flgExp, flgOH, INTYPE) " & vbCrLf
      sSql = sSql & "         VALUES (@partNum, @lotNum, @lotUserID, @Inno, @partDesc, @partExDesc, @actualDt,@qty, @Orgqty, " & vbCrLf
      sSql = sSql & "               @invAmt,@totMatlCost,@totLaborCost,@totExpCost,@totOHCost, " & vbCrLf
      sSql = sSql & "               @creditAcc,@debitAcc,@fInvMatl,@fInvLabor,@fInvExp,@fInvOH, @invType) " & vbCrLf
      sSql = sSql & "     End " & vbCrLf
      sSql = sSql & "       " & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM curInvRpt INTO @invType, @partRef, @lotNum, @lotUserID, @Inno, " & vbCrLf
      sSql = sSql & "      @actualDt, @qty, @Orgqty, @invAmt, @invTotMatl, @invTotLabor, " & vbCrLf
      sSql = sSql & "      @invTotExp,@invTotOH, @creditAcc, @debitAcc, @lotTotMatl, @lotTotLabor, @lotTotExp, @lotTotOH, " & vbCrLf
      sSql = sSql & "        @partNum, @partDesc, @partExDesc " & vbCrLf
      sSql = sSql & "   End " & vbCrLf
      sSql = sSql & "          " & vbCrLf
      sSql = sSql & "   CLOSE curInvRpt   --// close the cursor " & vbCrLf
      sSql = sSql & "   DEALLOCATE curInvRpt " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   -- select data for the report " & vbCrLf
      sSql = sSql & "   SELECT a.PARTNUM as PARTNUM, LOTNUMBER, LOTUSERLOTID, INNO, " & vbCrLf
      sSql = sSql & "      a.PADESC as PADESC, a.PAEXTDESC as PAEXTDESC, PALEVEL, INADATE, " & vbCrLf
      sSql = sSql & "         INAQTY,INAMT, TOTMATL,TOTLABOR,TOTEXP,TOTOH,INTYPE,  " & vbCrLf
      sSql = sSql & "         CREDITACCT, DEBITACCT,flgMatl, flgLabor, " & vbCrLf
      sSql = sSql & "         flgExp , flgOH " & vbCrLf
      sSql = sSql & "      FROM #tempINVReport a, PartTable " & vbCrLf
      sSql = sSql & "     WHERE PartTable.PARTNUM = a.PARTNUM" & vbCrLf
      sSql = sSql & "       " & vbCrLf
      sSql = sSql & "-- drop the temp table " & vbCrLf
      sSql = sSql & "   DROP table #tempINVReport " & vbCrLf
      sSql = sSql & "End"
      
      ExecuteScript False, sSql
      
      
      If StoreProcedureExists("RptChartOfAccount") Then
         sSql = "DROP PROCEDURE RptChartOfAccount"
         ExecuteScript False, sSql
      End If
      
      sSql = "CREATE PROCEDURE [dbo].[RptChartOfAccount]  " & vbCrLf
      sSql = sSql & "    @InclIncAcct as varchar(1)" & vbCrLf
      sSql = sSql & "AS " & vbCrLf
      sSql = sSql & "BEGIN " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   declare @glAcctRef as varchar(10) " & vbCrLf
      sSql = sSql & "   declare @glMsAcct as varchar(10) " & vbCrLf
      sSql = sSql & "   declare @TopLevelDesc as varchar(30)" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   declare @level as varchar(12)" & vbCrLf
      sSql = sSql & "   declare @InclInAcct as Integer" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   if (@InclIncAcct = '1')" & vbCrLf
      sSql = sSql & "      SET @InclInAcct = ''" & vbCrLf
      sSql = sSql & "   else" & vbCrLf
      sSql = sSql & "      SET @InclInAcct = '0'" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   CREATE TABLE #tempChartOfAcct(   " & vbCrLf
      sSql = sSql & "   [TOPLEVEL] [varchar](12) NULL,  " & vbCrLf
      sSql = sSql & "   [TOPLEVELDESC] [varchar](30) NULL, " & vbCrLf
      sSql = sSql & "   [GLACCTREF] [varchar](112) NULL,         " & vbCrLf
      sSql = sSql & "   [GLDESCR] [varchar](120) NULL,  " & vbCrLf
      sSql = sSql & "   [GLMASTER] [varchar](12) NULL,   " & vbCrLf
      sSql = sSql & "   [GLFSLEVEL] [INT] NULL," & vbCrLf
      sSql = sSql & "   [GLINACTIVE] [int] NULL," & vbCrLf
      sSql = sSql & "   [SORTKEYLEVEL] [int] NULL,           " & vbCrLf
      sSql = sSql & "   [GLACCSORTKEY] [varchar](512) NULL           " & vbCrLf
      sSql = sSql & ")                             " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   DECLARE balAcctStruc CURSOR  FOR " & vbCrLf
      sSql = sSql & "      SELECT COASSTACCT, COASSTDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      UNION ALL" & vbCrLf
      sSql = sSql & "      SELECT COLIABACCT, COLIABDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      UNION ALL" & vbCrLf
      sSql = sSql & "      SELECT COINCMACCT, COINCMDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      UNION ALL " & vbCrLf
      sSql = sSql & "      SELECT COEQTYACCT, COEQTYDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      UNION ALL" & vbCrLf
      sSql = sSql & "      SELECT COCOGSACCT, COCOGSDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      UNION ALL" & vbCrLf
      sSql = sSql & "      SELECT COEXPNACCT, COEXPNDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      UNION ALL" & vbCrLf
      sSql = sSql & "      SELECT COOINCACCT, COOINCDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      UNION ALL" & vbCrLf
      sSql = sSql & "      SELECT COFDTXACCT, COFDTXDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      UNION ALL" & vbCrLf
      sSql = sSql & "     SELECT COOEXPACCT, COOEXPDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      --UNION ALL" & vbCrLf
      sSql = sSql & "      --SELECT COFDTXACCT, COFDTXDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   OPEN balAcctStruc" & vbCrLf
      sSql = sSql & "   FETCH NEXT FROM balAcctStruc INTO @level, @TopLevelDesc" & vbCrLf
      sSql = sSql & "   WHILE (@@FETCH_STATUS <> -1) " & vbCrLf
      sSql = sSql & "   BEGIN " & vbCrLf
      sSql = sSql & "      IF (@@FETCH_STATUS <> -2) " & vbCrLf
      sSql = sSql & "      BEGIN " & vbCrLf
      sSql = sSql & "         " & vbCrLf
      sSql = sSql & "         INSERT INTO #tempChartOfAcct(TOPLEVEL, TOPLEVELDESC, GLACCTREF, GLDESCR, GLMASTER, GLFSLEVEL,GLINACTIVE, SORTKEYLEVEL,GLACCSORTKEY)" & vbCrLf
      sSql = sSql & "         select @level as TopLevel, @TopLevelDesc as TopLevelDesc, @level as GLACCTREF, " & vbCrLf
      sSql = sSql & "            @TopLevelDesc as GLDESCR, '' as GLMASTER, 0 as GLFSLEVEL, 0,0 as level, @level as SortKey" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "         with cte" & vbCrLf
      sSql = sSql & "         as" & vbCrLf
      sSql = sSql & "         (select GLACCTREF, GLDESCR, GLMASTER, GLFSLEVEL, GLINACTIVE, 0 as level," & vbCrLf
      sSql = sSql & "            cast(cast(@level as varchar(12))+ char(36)+ GLACCTREF as varchar(max)) as SortKey" & vbCrLf
      sSql = sSql & "         from GlacTable" & vbCrLf
      sSql = sSql & "         where GLMASTER = cast(@level as varchar(12)) AND GLINACTIVE LIKE @InclInAcct" & vbCrLf
      sSql = sSql & "         union all" & vbCrLf
      sSql = sSql & "         select a.GLACCTREF, a.GLDESCR, a.GLMASTER, a.GLFSLEVEL, a.GLINACTIVE, level + 1," & vbCrLf
      sSql = sSql & "          cast(COALESCE(SortKey,'') + char(36) + COALESCE(a.GLACCTREF,'') as varchar(max))as SortKey" & vbCrLf
      sSql = sSql & "         from cte" & vbCrLf
      sSql = sSql & "            inner join GlacTable a" & vbCrLf
      sSql = sSql & "               on cte.GLACCTREF = a.GLMASTER" & vbCrLf
      sSql = sSql & "            WHERE a.GLINACTIVE LIKE @InclInAcct" & vbCrLf
      sSql = sSql & "         )" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "         INSERT INTO #tempChartOfAcct(TOPLEVEL, TOPLEVELDESC, GLACCTREF, GLDESCR, GLMASTER, GLFSLEVEL,GLINACTIVE, SORTKEYLEVEL,GLACCSORTKEY)" & vbCrLf
      sSql = sSql & "         select @level as TopLevel, @TopLevelDesc as TopLevelDesc, " & vbCrLf
      sSql = sSql & "               Replicate('  ', level) + GLACCTREF as GLACCTREF, " & vbCrLf
      sSql = sSql & "               Replicate('  ', level) + GLDESCR as GLDESCR, GLMASTER, " & vbCrLf
      sSql = sSql & "               GLFSLEVEL, GLINACTIVE,level, SortKey" & vbCrLf
      sSql = sSql & "         from cte order by SortKey" & vbCrLf
      sSql = sSql & "         " & vbCrLf
      sSql = sSql & "      END" & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM balAcctStruc INTO @level, @TopLevelDesc" & vbCrLf
      sSql = sSql & "   END         " & vbCrLf
      sSql = sSql & "   CLOSE balAcctStruc" & vbCrLf
      sSql = sSql & "   DEALLOCATE balAcctStruc" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   SELECT TOPLEVEL, TOPLEVELDESC, GLACCTREF, GLDESCR, GLMASTER, " & vbCrLf
      sSql = sSql & "      GLFSLEVEL,GLINACTIVE, SORTKEYLEVEL,GLACCSORTKEY " & vbCrLf
      sSql = sSql & "   FROM #tempChartOfAcct ORDER BY GLACCSORTKEY" & vbCrLf
      sSql = sSql & "                                           " & vbCrLf
      sSql = sSql & "   DROP table #tempChartOfAcct            " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "End" & vbCrLf
      
      ExecuteScript False, sSql
      
      If (TableExists("ViewLohdPartTable")) Then
         ExecuteScript False, "drop view ViewLohdPartTable"
      End If
      
      sSql = "CREATE VIEW [dbo].[ViewLohdPartTable]" & vbCrLf
      sSql = sSql & "AS " & vbCrLf
      sSql = sSql & "SELECT dbo.LohdTable.LOTNUMBER, dbo.PartTable.PARTREF, dbo.PartTable.PADESC, dbo.PartTable.PAEXTDESC, " & vbCrLf
      sSql = sSql & "   dbo.LohdTable.LOTUSERLOTID, dbo.LohdTable.LOTADATE, dbo.LohdTable.LOTORIGINALQTY, dbo.LohdTable.LOTREMAININGQTY, " & vbCrLf
      sSql = sSql & "   dbo.LohdTable.LOTUNITCOST, dbo.LohdTable.LOTDATECOSTED, dbo.PartTable.PACLASS, dbo.PartTable.PAPRODCODE, " & vbCrLf
      sSql = sSql & "   dbo.PartTable.PASTDCOST, dbo.LohdTable.LOTTOTMATL, dbo.LohdTable.LOTTOTLABOR, dbo.LohdTable.LOTTOTEXP, " & vbCrLf
      sSql = sSql & "   dbo.LohdTable.LOTTOTOH, dbo.PartTable.PAUSEACTUALCOST, dbo.PartTable.PALOTTRACK, dbo.PartTable.PATOTOH, " & vbCrLf
      sSql = sSql & "   dbo.PartTable.PALABOR, dbo.PartTable.PATOTEXP, dbo.PartTable.PATOTMATL, dbo.PartTable.PALEVEL, " & vbCrLf
      sSql = sSql & "   dbo.PartTable.PARTNUM, dbo.PartTable.PAOBSOLETE, dbo.PartTable.PAINACTIVE" & vbCrLf
      sSql = sSql & "FROM dbo.LohdTable LEFT OUTER JOIN" & vbCrLf
      sSql = sSql & "   dbo.PartTable ON dbo.LohdTable.LOTPARTREF = dbo.PartTable.PARTREF" & vbCrLf
      sSql = sSql & "WHERE (dbo.PartTable.PALEVEL <= 4)"
      
      ExecuteScript False, sSql
      
      
      If StoreProcedureExists("RptRMFGoods") Then
         sSql = "DROP PROCEDURE RptRMFGoods"
         ExecuteScript False, sSql
      End If
      
      sSql = "CREATE PROCEDURE [dbo].[RptRMFGoods]   " & vbCrLf
      sSql = sSql & "       @ReportDate as varchar(16), @PartClass as Varchar(16),   " & vbCrLf
      sSql = sSql & "       @PartCode as varchar(8), @lotHDOnly as int, @PartType1 as Integer,   " & vbCrLf
      sSql = sSql & "       @PartType2 as Integer, @PartType3 as Integer, @PartType4 as Integer,  " & vbCrLf
      sSql = sSql & "       @ExInactive as Integer  " & vbCrLf
      sSql = sSql & "AS          " & vbCrLf
      sSql = sSql & "BEGIN        " & vbCrLf
      sSql = sSql & "         declare @partRef as varchar(30)     " & vbCrLf
      sSql = sSql & "         declare @partType as int             " & vbCrLf
      sSql = sSql & "         declare @partDesc as varchar(30)       " & vbCrLf
      sSql = sSql & "         declare @partExDesc as varchar(3072)      " & vbCrLf
      sSql = sSql & "         declare @rptRemQty as decimal(12,4)    " & vbCrLf
      sSql = sSql & "         declare @deltaQty as decimal(12,4)     " & vbCrLf
      sSql = sSql & "         declare @lotRemQty as decimal(12,4)    " & vbCrLf
      sSql = sSql & "         declare @lotOrgQty as decimal(12,4)    " & vbCrLf
      sSql = sSql & "         declare @tmpInvQty as decimal(12,4)    " & vbCrLf
      sSql = sSql & "         declare @tmpLastInvQty as decimal(12,4)      " & vbCrLf
      sSql = sSql & "         declare @rptInvcost decimal(12,4)      " & vbCrLf
      sSql = sSql & "         declare @lastInvcost decimal(12,4)     " & vbCrLf
      sSql = sSql & "         declare @orgInvcost decimal(12,4)      " & vbCrLf
      sSql = sSql & "         declare @tmpInvCost decimal(12,4)      " & vbCrLf
      sSql = sSql & "         declare @tmpLastInvCost decimal(12,4)     " & vbCrLf
      sSql = sSql & "         declare @lastQty as decimal(12,4)      " & vbCrLf
      sSql = sSql & "         declare @SumQty as decimal(12,4)  " & vbCrLf
      sSql = sSql & "         declare @PSNum as varchar(12)  " & vbCrLf
      sSql = sSql & "        " & vbCrLf
      sSql = sSql & "         declare @orgQty as decimal(12,4)    " & vbCrLf
      sSql = sSql & "         declare @rptQty as decimal(12,4)    " & vbCrLf
      sSql = sSql & "         declare @rptCreditACC varchar(12)      " & vbCrLf
      sSql = sSql & "       declare @rptDebitACC varchar(12)  " & vbCrLf
      sSql = sSql & "       declare @rptACC varchar(12)     " & vbCrLf
      sSql = sSql & "       declare @CurACC varchar(12)     " & vbCrLf
      sSql = sSql & "       declare @tmpCreditAcc varchar(12)     " & vbCrLf
      sSql = sSql & "       declare @tmpDebitAcc varchar(12)   " & vbCrLf
      sSql = sSql & "       declare @tmplastCreditAcc varchar(12)    " & vbCrLf
      sSql = sSql & "       declare @tmpLastDebitAcc varchar(12)     " & vbCrLf
      sSql = sSql & "       declare @lastCreditACC varchar(12)    " & vbCrLf
      sSql = sSql & "       declare @lastDebitACC varchar(12)     " & vbCrLf
      sSql = sSql & "       declare @lastACC varchar(12)    " & vbCrLf
      sSql = sSql & "       declare @orgCreditACC varchar(12)  " & vbCrLf
      sSql = sSql & "       declare @orgDebitACC varchar(12)   " & vbCrLf
      sSql = sSql & "       declare @orgACC varchar(12)     " & vbCrLf
      sSql = sSql & "       declare @OrgInvNum as int    " & vbCrLf
      sSql = sSql & "       declare @rptInvNum as int    " & vbCrLf
      sSql = sSql & "       declare @LastInvNum as int   " & vbCrLf
      sSql = sSql & "       declare @tmpInvNum as int    " & vbCrLf
      sSql = sSql & "       declare @tmpLastInvNum as int   " & vbCrLf
      sSql = sSql & "       declare @LotNumber varchar(51)     " & vbCrLf
      sSql = sSql & "       declare @LotNum varchar(51)     " & vbCrLf
      sSql = sSql & "         " & vbCrLf
      sSql = sSql & "       declare @LotUserID varchar(51)     " & vbCrLf
      sSql = sSql & "       declare @lotAcualDate as smalldatetime   " & vbCrLf
      sSql = sSql & "       declare @lotCostedDate as smalldatetime     " & vbCrLf
      sSql = sSql & "       declare @curDate as smalldatetime     " & vbCrLf
      sSql = sSql & "       declare @AcualDate as smalldatetime   " & vbCrLf
      sSql = sSql & "       declare @CostedDate as smalldatetime     " & vbCrLf
      sSql = sSql & "       declare @tmpINVAdate  as smalldatetime     " & vbCrLf
      sSql = sSql & "       declare @tmpLastINVAdate  as smalldatetime     " & vbCrLf
      sSql = sSql & "       declare @unitcost as decimal(12,4)    " & vbCrLf
      sSql = sSql & "       declare @partStdCost as decimal(12,4)    " & vbCrLf
      sSql = sSql & "       declare @LotUnitCost as decimal(12,4)    " & vbCrLf
      sSql = sSql & "       declare @lotTotMatl as decimal(12,4)     " & vbCrLf
      sSql = sSql & "       declare @lotTotLabor as decimal(12,4)    " & vbCrLf
      sSql = sSql & "       declare @lotTotExp as decimal(12,4)   " & vbCrLf
      sSql = sSql & "       declare @lotTotOH as decimal(12,4)    " & vbCrLf
      sSql = sSql & "       declare @partActCost as int     " & vbCrLf
      sSql = sSql & "       declare @partLotTrack as int    " & vbCrLf
      sSql = sSql & "       declare @flgStdCost as int   " & vbCrLf
      sSql = sSql & "       declare @flgLdCost as int    " & vbCrLf
      sSql = sSql & "       declare @flgInvCost as int   " & vbCrLf
      sSql = sSql & "       declare @flgLdRQErr as int   " & vbCrLf
      sSql = sSql & "       declare @flgOrgAcc as int    " & vbCrLf
      sSql = sSql & "       declare @flgRptAcc as int    " & vbCrLf
      sSql = sSql & "       declare @flgLastAcc as int   " & vbCrLf
      sSql = sSql & "        " & vbCrLf
      sSql = sSql & "        " & vbCrLf
      sSql = sSql & "         IF (@PartClass = 'ALL')  " & vbCrLf
      sSql = sSql & "         BEGIN   " & vbCrLf
      sSql = sSql & "            SET @PartClass = ''    " & vbCrLf
      sSql = sSql & "         End              " & vbCrLf
      sSql = sSql & "         IF (@PartCode = 'ALL')    " & vbCrLf
      sSql = sSql & "         BEGIN   " & vbCrLf
      sSql = sSql & "            SET @PartCode = ''        " & vbCrLf
      sSql = sSql & "       End                       " & vbCrLf
      sSql = sSql & "          IF (@PartType1 = 1)       " & vbCrLf
      sSql = sSql & "            SET @PartType1 = 1      " & vbCrLf
      sSql = sSql & "         Else                      " & vbCrLf
      sSql = sSql & "           SET @PartType1 = 0      " & vbCrLf
      sSql = sSql & "         IF (@PartType2 = 1)       " & vbCrLf
      sSql = sSql & "           SET @PartType2 = 2      " & vbCrLf
      sSql = sSql & "         Else                      " & vbCrLf
      sSql = sSql & "           SET @PartType2 = 0      " & vbCrLf
      sSql = sSql & "          IF (@PartType3 = 1)      " & vbCrLf
      sSql = sSql & "              SET @PartType3 = 3   " & vbCrLf
      sSql = sSql & "          Else                     " & vbCrLf
      sSql = sSql & "              SET @PartType3 = 0   " & vbCrLf
      sSql = sSql & "                                   " & vbCrLf
      sSql = sSql & "          IF (@PartType4 = 1)      " & vbCrLf
      sSql = sSql & "              SET @PartType4 = 4   " & vbCrLf
      sSql = sSql & "          Else                     " & vbCrLf
      sSql = sSql & "              SET @PartType4 = 0   " & vbCrLf
      sSql = sSql & "              " & vbCrLf
      sSql = sSql & "      -- DELETE FROM tempRMFGoods  " & vbCrLf
      sSql = sSql & "        " & vbCrLf
      sSql = sSql & "         CREATE TABLE #tempRMFGoods(     " & vbCrLf
      sSql = sSql & "         [LOTNUMBER] [varchar](15) NULL,    " & vbCrLf
      sSql = sSql & "         [PARTNUM] [varchar](30) NULL,   " & vbCrLf
      sSql = sSql & "         [PALEVEL] [int] NULL,           " & vbCrLf
      sSql = sSql & "         [PADESC] [varchar](30) NULL,    " & vbCrLf
      sSql = sSql & "         [PAEXTDESC] [varchar](3072) NULL,     " & vbCrLf
      sSql = sSql & "         [LOTUSERLOTID] [char](40) NULL,       " & vbCrLf
      sSql = sSql & "         [ORGINNUMBER] [int] NULL,             " & vbCrLf
      sSql = sSql & "         [RPTINNUMBER] [int] NULL,             " & vbCrLf
      sSql = sSql & "         [CURINNUMBER] [int] NULL,             " & vbCrLf
      sSql = sSql & "         [ACTUALDATE] [smalldatetime] NULL,    " & vbCrLf
      sSql = sSql & "         [RPTDATEQTY] [decimal](12, 4) NULL,   " & vbCrLf
      sSql = sSql & "         [UNITCOST] [decimal](12, 4) NULL,     " & vbCrLf
      sSql = sSql & "         [PASTDCOST] [decimal](12, 4) NULL,    " & vbCrLf
      sSql = sSql & "         [LOTUNITCOST] [decimal](12, 4) NULL,     " & vbCrLf
      sSql = sSql & "         [INAMT] [decimal](12, 4) NULL,           " & vbCrLf
      sSql = sSql & "         [ORGCOST] [decimal](12, 4) NULL,         " & vbCrLf
      sSql = sSql & "         [STDCOST] [decimal](12, 4) NULL,         " & vbCrLf
      sSql = sSql & "         [LSTACOST] [decimal](12, 4) NULL,        " & vbCrLf
      sSql = sSql & "         [RPTCOST] [decimal](12, 4) NULL,         " & vbCrLf
      sSql = sSql & "         [CURCOST] [decimal](12, 4) NULL,         " & vbCrLf
      sSql = sSql & "         [COSTEDDATE] [smalldatetime] NULL,       " & vbCrLf
      sSql = sSql & "         [RPTACCOUNT] [char](12) NULL,            " & vbCrLf
      sSql = sSql & "         [ORIGINALACC] [char](12) NULL,           " & vbCrLf
      sSql = sSql & "         [LASTACTVITYACC] [char](12) NULL,        " & vbCrLf
      sSql = sSql & "         [CURRENTACC] [char](12) NULL,   " & vbCrLf
      sSql = sSql & "         [PACLASS] [char](4) NULL,    " & vbCrLf
      sSql = sSql & "         [PAPRODCODE] [char](6) NULL,    " & vbCrLf
      sSql = sSql & "         [flgStdCost] [int] NULL,     " & vbCrLf
      sSql = sSql & "         [flgLdCost] [int] NULL,      " & vbCrLf
      sSql = sSql & "         [flgInvCost] [int] NULL,     " & vbCrLf
      sSql = sSql & "         [flgLdRQErr] [int] NULL,     " & vbCrLf
      sSql = sSql & "         [flgRptAcc] [int] NULL,      " & vbCrLf
      sSql = sSql & "         [flgOrgAcc] [int] NULL,      " & vbCrLf
      sSql = sSql & "         [flgLastAcc] [int] NULL      " & vbCrLf
      sSql = sSql & "      )                               " & vbCrLf
      sSql = sSql & "                                      " & vbCrLf
      sSql = sSql & "       if (@ExInactive = 1)  " & vbCrLf
      sSql = sSql & "       BEGIN  " & vbCrLf
      sSql = sSql & "         DECLARE curLotHd CURSOR LOCAL   " & vbCrLf
      sSql = sSql & "         FOR  " & vbCrLf
      sSql = sSql & "         " & vbCrLf
      sSql = sSql & "         SELECT LOTNUMBER, LOTUSERLOTID, PARTREF, PADESC, PAEXTDESC,   " & vbCrLf
      sSql = sSql & "           LOTADATE,LOTORIGINALQTY, LOTREMAININGQTY, LOTUNITCOST, LOTDATECOSTED,     " & vbCrLf
      sSql = sSql & "           PACLASS , PAPRODCODE, PASTDCOST, PAUSEACTUALCOST, PALOTTRACK, PALEVEL     " & vbCrLf
      sSql = sSql & "         From ViewLohdPartTable    " & vbCrLf
      sSql = sSql & "         WHERE ViewLohdPartTable.LOTADATE  < DATEADD(dd, 1 , @ReportDate)    " & vbCrLf
      sSql = sSql & "           AND ViewLohdPartTable.PACLASS LIKE '%' + @PartClass + '%'        " & vbCrLf
      sSql = sSql & "           AND ViewLohdPartTable.PAPRODCODE LIKE '%' + @PartCode + '%'      " & vbCrLf
      sSql = sSql & "           AND ViewLohdPartTable.PALEVEL IN (@PartType1, @PartType2, @PartType3, @PartType4)     " & vbCrLf
      sSql = sSql & "           AND NOT (PAOBSOLETE = 1 OR PAINACTIVE = 1)  " & vbCrLf
      sSql = sSql & "      END  " & vbCrLf
      sSql = sSql & "      ELSE  " & vbCrLf
      sSql = sSql & "      BEGIN  " & vbCrLf
      sSql = sSql & "         DECLARE curLotHd CURSOR LOCAL   " & vbCrLf
      sSql = sSql & "         FOR  " & vbCrLf
      sSql = sSql & "         " & vbCrLf
      sSql = sSql & "         SELECT LOTNUMBER, LOTUSERLOTID, PARTREF, PADESC, PAEXTDESC,   " & vbCrLf
      sSql = sSql & "           LOTADATE,LOTORIGINALQTY, LOTREMAININGQTY, LOTUNITCOST, LOTDATECOSTED,     " & vbCrLf
      sSql = sSql & "           PACLASS , PAPRODCODE, PASTDCOST, PAUSEACTUALCOST, PALOTTRACK, PALEVEL     " & vbCrLf
      sSql = sSql & "         From ViewLohdPartTable    " & vbCrLf
      sSql = sSql & "         WHERE ViewLohdPartTable.LOTADATE  < DATEADD(dd, 1 , @ReportDate)    " & vbCrLf
      sSql = sSql & "           AND ViewLohdPartTable.PACLASS LIKE '%' + @PartClass + '%'        " & vbCrLf
      sSql = sSql & "           AND ViewLohdPartTable.PAPRODCODE LIKE '%' + @PartCode + '%'      " & vbCrLf
      sSql = sSql & "           AND ViewLohdPartTable.PALEVEL IN (@PartType1, @PartType2, @PartType3, @PartType4)     " & vbCrLf
      sSql = sSql & "           --AND PARTREF IN ('NAS1578V3T9','BACB28AP06P018','BACB30NT3K22')   " & vbCrLf
      sSql = sSql & "      END  " & vbCrLf
      sSql = sSql & "              " & vbCrLf
      sSql = sSql & "       OPEN curLotHd                                                       " & vbCrLf
      sSql = sSql & "       FETCH NEXT FROM curLotHd INTO @LotNumber, @LotUserID, @partRef,     " & vbCrLf
      sSql = sSql & "          @partDesc, @partExDesc, @lotAcualDate, @lotOrgQty,               " & vbCrLf
      sSql = sSql & "          @lotRemQty,@LotUnitCost, @lotCostedDate,                         " & vbCrLf
      sSql = sSql & "          @PartClass, @PartCode, @partStdCost, @partActCost, @partLotTrack, @partType     " & vbCrLf
      sSql = sSql & "                                                                        " & vbCrLf
      sSql = sSql & "       WHILE (@@FETCH_STATUS <> -1)                                     " & vbCrLf
      sSql = sSql & "       BEGIN                                                            " & vbCrLf
      sSql = sSql & "       IF (@@FETCH_STATUS <> -2)       " & vbCrLf
      sSql = sSql & "       BEGIN                           " & vbCrLf
      sSql = sSql & "          SET @flgLdRQErr = 0          " & vbCrLf
      sSql = sSql & "       IF (@lotRemQty < 0.0000)        " & vbCrLf
      sSql = sSql & "       BEGIN                           " & vbCrLf
      sSql = sSql & "          SET @lotRemQty = 0.0000      " & vbCrLf
      sSql = sSql & "          SET @flgLdRQErr  = 1         " & vbCrLf
      sSql = sSql & "       End                             " & vbCrLf
      sSql = sSql & "       SET @curDate = GETDATE()        " & vbCrLf
      sSql = sSql & "                                       " & vbCrLf
      sSql = sSql & "       SELECT @deltaQty = ISNULL(SUM(LOIQUANTITY), 0.0000)     " & vbCrLf
      sSql = sSql & "       From LoitTable                                          " & vbCrLf
      sSql = sSql & "       WHERE LOIADATE BETWEEN DATEADD(dd, 1 ,@ReportDate) AND DATEADD(dd, 1 ,@curDate)    " & vbCrLf
      sSql = sSql & "          AND LOIPARTREF = @partRef                      " & vbCrLf
      sSql = sSql & "          AND LOINUMBER = @LotNumber                     " & vbCrLf
      sSql = sSql & "       SET @rptRemQty = @lotRemQty + (@deltaQty * -1)    " & vbCrLf
      sSql = sSql & "       IF @rptRemQty < 0.0000             " & vbCrLf
      sSql = sSql & "       SET @rptRemQty = @rptRemQty * -1   " & vbCrLf
      sSql = sSql & "       SET @flgStdCost = 0       " & vbCrLf
      sSql = sSql & "       SET @flgLdCost = 0        " & vbCrLf
      sSql = sSql & "       SET @flgInvCost = 0       " & vbCrLf
      sSql = sSql & "       SET @flgOrgAcc = 0        " & vbCrLf
      sSql = sSql & "       SET @flgRptAcc = 0        " & vbCrLf
      sSql = sSql & "       SET @flgLastAcc = 0       " & vbCrLf
      sSql = sSql & "                                 " & vbCrLf
      sSql = sSql & "       DECLARE curInv CURSOR     " & vbCrLf
      sSql = sSql & "       LOCAL                     " & vbCrLf
      sSql = sSql & "       Scroll                    " & vbCrLf
      sSql = sSql & "       FOR                       " & vbCrLf
      sSql = sSql & "       SELECT INNUMBER, INAMT, INAQTY, ISNULL(INCREDITACCT,0), ISNULL(INDEBITACCT, 0), INADATE     " & vbCrLf
      sSql = sSql & "           From InvaTable, LoitTable                            " & vbCrLf
      sSql = sSql & "       WHERE InvaTable.INPART = @partRef                    " & vbCrLf
      sSql = sSql & "          AND LoitTable.LOINUMBER = @LotNumber              " & vbCrLf
      sSql = sSql & "          AND InvaTable.INPART = LoitTable.LOIPARTREF       " & vbCrLf
      sSql = sSql & "          AND InvaTable.INNUMBER = LoitTable.LOIACTIVITY    " & vbCrLf
      sSql = sSql & "       ORDER BY INADATE ASC            " & vbCrLf
      sSql = sSql & "                                       " & vbCrLf
      sSql = sSql & "       OPEN curInv                     " & vbCrLf
      sSql = sSql & "       FETCH FIRST FROM curInv INTO @tmpInvNum, @tmpInvCost, @tmpInvQty,   " & vbCrLf
      sSql = sSql & "       @tmpCreditAcc, @tmpDebitAcc, @tmpINVAdate   " & vbCrLf
      sSql = sSql & "       IF (@@FETCH_STATUS <> -1)    " & vbCrLf
      sSql = sSql & "       BEGIN                        " & vbCrLf
      sSql = sSql & "       IF (@@FETCH_STATUS <> -2)    " & vbCrLf
      sSql = sSql & "       BEGIN                        " & vbCrLf
      sSql = sSql & "          SET @orgInvcost = @tmpInvCost   " & vbCrLf
      sSql = sSql & "          SET @orgQty = @tmpInvQty        " & vbCrLf
      sSql = sSql & "          SET @orgCreditACC = @tmpCreditAcc     " & vbCrLf
      sSql = sSql & "          SET @orgDebitACC = @tmpDebitAcc    " & vbCrLf
      sSql = sSql & "          SET @OrgInvNum = @tmpInvNum        " & vbCrLf
      sSql = sSql & "       End                                   " & vbCrLf
      sSql = sSql & "       FETCH LAST FROM curInv INTO @tmpLastInvNum, @tmpLastInvCost, @tmpLastInvQty,    " & vbCrLf
      sSql = sSql & "       @tmplastCreditAcc, @tmpLastDebitAcc, @tmpLastINVAdate   " & vbCrLf
      sSql = sSql & "       IF (@@FETCH_STATUS <> -2)    " & vbCrLf
      sSql = sSql & "       BEGIN                        " & vbCrLf
      sSql = sSql & "       SET @lastInvcost = @tmpLastInvCost    " & vbCrLf
      sSql = sSql & "       SET @lastQty = @tmpLastInvQty      " & vbCrLf
      sSql = sSql & "       SET @lastCreditACC = @tmplastCreditAcc   " & vbCrLf
      sSql = sSql & "       SET @lastDebitACC = @tmpLastDebitAcc     " & vbCrLf
      sSql = sSql & "       SET @LastInvNum = @tmpLastInvNum         " & vbCrLf
      sSql = sSql & "       IF @tmpLastINVAdate > DATEADD(dd, 1, @ReportDate)    " & vbCrLf
      sSql = sSql & "       BEGIN                                                " & vbCrLf
      sSql = sSql & "         SELECT TOP 1 @rptInvNum = INNUMBER, @rptInvcost = INAMT,   " & vbCrLf
      sSql = sSql & "            @rptQty = INAQTY, @rptCreditACC = ISNULL(INCREDITACCT, 0),    " & vbCrLf
      sSql = sSql & "            @rptDebitACC = ISNULL(INDEBITACCT, 0)       " & vbCrLf
      sSql = sSql & "         From InvaTable, LoitTable                   " & vbCrLf
      sSql = sSql & "            WHERE INADATE < DATEADD(dd, 1, @ReportDate)    " & vbCrLf
      sSql = sSql & "               AND InvaTable.INPART = @partRef                " & vbCrLf
      sSql = sSql & "               AND LoitTable.LOINUMBER = @LotNumber           " & vbCrLf
      sSql = sSql & "               AND InvaTable.INPART = LoitTable.LOIPARTREF    " & vbCrLf
      sSql = sSql & "               AND InvaTable.INNUMBER = LoitTable.LOIACTIVITY    " & vbCrLf
      sSql = sSql & "               ORDER BY INADATE DESC                             " & vbCrLf
      sSql = sSql & "        End                                            " & vbCrLf
      sSql = sSql & "        Else                                           " & vbCrLf
      sSql = sSql & "        BEGIN                                          " & vbCrLf
      sSql = sSql & "        SET @rptInvNum = @tmpLastInvNum                " & vbCrLf
      sSql = sSql & "                                          " & vbCrLf
      sSql = sSql & "                                             " & vbCrLf
      sSql = sSql & "       SET @rptInvcost = @tmpLastInvCost     " & vbCrLf
      sSql = sSql & "       SET @rptQty = @tmpLastInvQty          " & vbCrLf
      sSql = sSql & "       SET @rptCreditACC = @tmplastCreditAcc    " & vbCrLf
      sSql = sSql & "       SET @rptDebitACC = @tmpLastDebitAcc      " & vbCrLf
      sSql = sSql & "       End                                   " & vbCrLf
      sSql = sSql & "       End                                   " & vbCrLf
      sSql = sSql & "       End                                   " & vbCrLf
      sSql = sSql & "       CLOSE curInv   --// close the cursor     " & vbCrLf
      sSql = sSql & "       DEALLOCATE curInv            " & vbCrLf
      sSql = sSql & "       IF (@partActCost = 0)        " & vbCrLf
      sSql = sSql & "       BEGIN                        " & vbCrLf
      sSql = sSql & "       SET @unitcost = @partStdCost    " & vbCrLf
      sSql = sSql & "       SET @flgStdCost = 1          " & vbCrLf
      sSql = sSql & "       End                          " & vbCrLf
      sSql = sSql & "       Else                         " & vbCrLf
      sSql = sSql & "       BEGIN                        " & vbCrLf
      sSql = sSql & "       IF @lotHDOnly = 1            " & vbCrLf
      sSql = sSql & "       BEGIN                        " & vbCrLf
      sSql = sSql & "       SET @unitcost = @LotUnitCost    " & vbCrLf
      sSql = sSql & "       SET @flgLdCost = 1              " & vbCrLf
      sSql = sSql & "       End                             " & vbCrLf
      sSql = sSql & "       Else                            " & vbCrLf
      sSql = sSql & "       BEGIN                           " & vbCrLf
      sSql = sSql & "       IF @lotCostedDate < DATEADD(dd, 1, @ReportDate)   " & vbCrLf
      sSql = sSql & "          BEGIN                              " & vbCrLf
      sSql = sSql & "          SET @unitcost = @LotUnitCost       " & vbCrLf
      sSql = sSql & "          SET @flgLdCost = 1     " & vbCrLf
      sSql = sSql & "          End                    " & vbCrLf
      sSql = sSql & "          Else                   " & vbCrLf
      sSql = sSql & "          BEGIN                  " & vbCrLf
      sSql = sSql & "          SET @unitcost = @rptInvcost     " & vbCrLf
      sSql = sSql & "          SET @flgInvCost = 1             " & vbCrLf
      sSql = sSql & "          End                          " & vbCrLf
      sSql = sSql & "          END --LotHD only             " & vbCrLf
      sSql = sSql & "          END --Part Cost              " & vbCrLf
      sSql = sSql & "          SELECT @CurACC = dbo.fnGetPartInvAccount(@partRef)   " & vbCrLf
      sSql = sSql & "          -- Lastest < report account#          " & vbCrLf
      sSql = sSql & "          IF @rptQty >= 0.0000                  " & vbCrLf
      sSql = sSql & "          SET @rptACC = @rptDebitACC            " & vbCrLf
      sSql = sSql & "          Else                                  " & vbCrLf
      sSql = sSql & "          SET @rptACC = @rptCreditACC           " & vbCrLf
      sSql = sSql & "          IF ((@rptACC = '') OR (@rptACC = NULL))        " & vbCrLf
      sSql = sSql & "          BEGIN                     " & vbCrLf
      sSql = sSql & "          SET @rptACC = @CurACC     " & vbCrLf
      sSql = sSql & "          SET @flgRptAcc = 1        " & vbCrLf
      sSql = sSql & "          End                       " & vbCrLf
      sSql = sSql & "          -- last record            " & vbCrLf
      sSql = sSql & "          IF @lastQty >= 0.0000        " & vbCrLf
      sSql = sSql & "          SET @lastACC = @lastDebitACC    " & vbCrLf
      sSql = sSql & "          Else                            " & vbCrLf
      sSql = sSql & "          SET @lastACC = @lastCreditACC   " & vbCrLf
      sSql = sSql & "          IF ((@lastACC = '') OR (@lastACC = NULL))   " & vbCrLf
      sSql = sSql & "          BEGIN                     " & vbCrLf
      sSql = sSql & "          SET @lastACC = @CurACC    " & vbCrLf
      sSql = sSql & "          SET @flgLastAcc = 1       " & vbCrLf
      sSql = sSql & "          End                       " & vbCrLf
      sSql = sSql & "          -- Lastest < report account#    " & vbCrLf
      sSql = sSql & "          IF @orgQty >= 0.0000            " & vbCrLf
      sSql = sSql & "          SET @orgACC = @orgDebitACC      " & vbCrLf
      sSql = sSql & "          Else                            " & vbCrLf
      sSql = sSql & "          SET @orgACC = @orgCreditACC        " & vbCrLf
      sSql = sSql & "          IF ((@orgACC = '') OR (@orgACC = NULL))     " & vbCrLf
      sSql = sSql & "          BEGIN                      " & vbCrLf
      sSql = sSql & "          SET @orgACC = @CurACC        " & vbCrLf
      sSql = sSql & "          SET @flgOrgAcc = 1        " & vbCrLf
      sSql = sSql & "          End                       " & vbCrLf
      sSql = sSql & "          -- Insert to the temp table     " & vbCrLf
      sSql = sSql & "          INSERT INTO #tempRMFGoods       " & vbCrLf
      sSql = sSql & "          (PARTNUM, PALEVEL, PADESC, PAEXTDESC, LOTNUMBER, LOTUSERLOTID,   " & vbCrLf
      sSql = sSql & "          ORGINNUMBER, RPTINNUMBER, CURINNUMBER, ACTUALDATE,RPTDATEQTY, COSTEDDATE,    " & vbCrLf
      sSql = sSql & "          UNITCOST,PASTDCOST, LOTUNITCOST, ORGCOST, STDCOST,   " & vbCrLf
      sSql = sSql & "          LSTACOST, RPTCOST, CURCOST, RPTACCOUNT,ORIGINALACC,     " & vbCrLf
      sSql = sSql & "          LASTACTVITYACC, CURRENTACC, PACLASS,PAPRODCODE,      " & vbCrLf
      sSql = sSql & "          flgStdCost, flgLdCost, flgInvCost, flgLdRQErr,    " & vbCrLf
      sSql = sSql & "          flgRptAcc, flgOrgAcc, flgLastAcc)        " & vbCrLf
      sSql = sSql & "          VALUES (@partRef, @partType, @partDesc, @partExDesc, @LotNumber,@LotUserID, @OrgInvNum,     " & vbCrLf
      sSql = sSql & "          @rptInvNum, @LastInvNum, @lotAcualDate,@rptRemQty,@lotCostedDate,   " & vbCrLf
      sSql = sSql & "          @unitcost,@partStdCost, @LotUnitCost, @orgInvcost, @partStdCost,    " & vbCrLf
      sSql = sSql & "          @lastInvcost,@rptInvcost, @LotUnitCost, @rptACC, @orgACC, @lastACC,    " & vbCrLf
      sSql = sSql & "          @CurACC, @PartClass,@PartCode,@flgStdCost, @flgLdCost, @flgInvCost,    " & vbCrLf
      sSql = sSql & "          @flgLdRQErr, @flgRptAcc, @flgOrgAcc, @flgLastAcc)                      " & vbCrLf
      sSql = sSql & "          SET @rptRemQty = NULL     " & vbCrLf
      sSql = sSql & "          SET @deltaQty = NULL      " & vbCrLf
      sSql = sSql & "          SET @lotRemQty = NULL     " & vbCrLf
      sSql = sSql & "          SET @lotOrgQty = NULL     " & vbCrLf
      sSql = sSql & "          SET @tmpInvQty = NULL     " & vbCrLf
      sSql = sSql & "          SET @tmpLastInvQty  = NULL   " & vbCrLf
      sSql = sSql & "          SET @rptInvcost = NULL    " & vbCrLf
      sSql = sSql & "          SET @lastInvcost = NULL   " & vbCrLf
      sSql = sSql & "          SET @orgInvcost = NULL    " & vbCrLf
      sSql = sSql & "          SET @tmpInvCost = NULL    " & vbCrLf
      sSql = sSql & "          SET @unitcost = NULL      " & vbCrLf
      sSql = sSql & "          SET @tmpLastInvCost = NULL   " & vbCrLf
      sSql = sSql & "          SET @lastQty = NULL    " & vbCrLf
      sSql = sSql & "          SET @orgQty = NULL     " & vbCrLf
      sSql = sSql & "          SET @rptQty  = NULL    " & vbCrLf
      sSql = sSql & "          SET @rptCreditACC = NULL     " & vbCrLf
      sSql = sSql & "          SET @rptDebitACC  = NULL     " & vbCrLf
      sSql = sSql & "         SET @rptACC  = NULL       " & vbCrLf
      sSql = sSql & "         SET @tmpCreditAcc  = NULL    " & vbCrLf
      sSql = sSql & "         SET @tmpDebitAcc = NULL      " & vbCrLf
      sSql = sSql & "         SET @tmplastCreditAcc = NULL    " & vbCrLf
      sSql = sSql & "         SET @tmpLastDebitAcc = NULL     " & vbCrLf
      sSql = sSql & "         SET @lastCreditACC = NULL       " & vbCrLf
      sSql = sSql & "         SET @lastDebitACC = NULL        " & vbCrLf
      sSql = sSql & "         SET @lastACC  = NULL            " & vbCrLf
      sSql = sSql & "         SET @orgCreditACC  = NULL       " & vbCrLf
      sSql = sSql & "         SET @orgDebitACC  = NULL        " & vbCrLf
      sSql = sSql & "         SET @orgACC  = NULL             " & vbCrLf
      sSql = sSql & "         SET @OrgInvNum = NULL           " & vbCrLf
      sSql = sSql & "         SET @rptInvNum = NULL           " & vbCrLf
      sSql = sSql & "         SET @LastInvNum = NULL          " & vbCrLf
      sSql = sSql & "         End                       " & vbCrLf
      sSql = sSql & "         FETCH NEXT FROM curLotHd INTO @LotNumber, @LotUserID, @partRef,     " & vbCrLf
      sSql = sSql & "         @partDesc, @partExDesc, @lotAcualDate, @lotOrgQty,                  " & vbCrLf
      sSql = sSql & "         @lotRemQty,@LotUnitCost, @lotCostedDate,                            " & vbCrLf
      sSql = sSql & "         @PartClass, @PartCode, @partStdCost, @partActCost, @partLotTrack, @partType     " & vbCrLf
      sSql = sSql & "         End                                      " & vbCrLf
      sSql = sSql & "         CLOSE curLotHd   --// close the cursor   " & vbCrLf
      sSql = sSql & "         DEALLOCATE curLotHd                      " & vbCrLf
      sSql = sSql & "                                                   " & vbCrLf
      sSql = sSql & "           " & vbCrLf
      sSql = sSql & "         DECLARE curLotNumPS CURSOR  FOR  " & vbCrLf
      sSql = sSql & "            SELECT LOIPSNUMBER,LOINUMBER, (SUM(LOIQUANTITY) * -1) SumQty FROM loitTable,pshdTable   " & vbCrLf
      sSql = sSql & "               WHERE LOIPSNUMBER = psnumber AND PSPRINTED IS NOT NULL AND psshipped = 0   " & vbCrLf
      sSql = sSql & "            GROUP BY LOIPSNUMBER,LOINUMBER  " & vbCrLf
      sSql = sSql & "            HAVING SUM(LOIQUANTITY) < 0  " & vbCrLf
      sSql = sSql & "        " & vbCrLf
      sSql = sSql & "         OPEN curLotNumPS  " & vbCrLf
      sSql = sSql & "         FETCH NEXT FROM curLotNumPS INTO @PSNum, @LotNum, @SumQty  " & vbCrLf
      sSql = sSql & "         WHILE (@@FETCH_STATUS <> -1)  " & vbCrLf
      sSql = sSql & "         BEGIN  " & vbCrLf
      sSql = sSql & "            IF (@@FETCH_STATUS <> -2)  " & vbCrLf
      sSql = sSql & "            BEGIN  " & vbCrLf
      sSql = sSql & "                 " & vbCrLf
      sSql = sSql & "               --print 'Lot:' + @LotNum + 'Qty:' + Convert(varchar(20), @SumQty)  " & vbCrLf
      sSql = sSql & "               UPDATE #tempRMFGoods SET RPTDATEQTY = RPTDATEQTY + @SumQty WHERE LOTNUMBER = @LotNum  " & vbCrLf
      sSql = sSql & "                 " & vbCrLf
      sSql = sSql & "            End  " & vbCrLf
      sSql = sSql & "            FETCH NEXT FROM curLotNumPS INTO @PSNum, @LotNum, @SumQty  " & vbCrLf
      sSql = sSql & "         End  " & vbCrLf
      sSql = sSql & "           " & vbCrLf
      sSql = sSql & "         Close curLotNumPS  " & vbCrLf
      sSql = sSql & "         DEALLOCATE curLotNumPS  " & vbCrLf
      sSql = sSql & "           " & vbCrLf
      sSql = sSql & "         SELECT * FROM #tempRMFGoods              " & vbCrLf
      sSql = sSql & "           " & vbCrLf
      sSql = sSql & "         DROP table #tempRMFGoods              " & vbCrLf
      sSql = sSql & "                    " & vbCrLf
      sSql = sSql & "End "
      
      ExecuteScript False, sSql
      
      If StoreProcedureExists("InvMRPExcessReport") Then
         sSql = "DROP PROCEDURE InvMRPExcessReport"
         ExecuteScript False, sSql
      End If
      
      sSql = "CREATE PROCEDURE [dbo].[InvMRPExcessReport]" & vbCrLf
      sSql = sSql & " @PartClass as Varchar(16), @PartCode as varchar(8), @PartType1 as Integer, " & vbCrLf
      sSql = sSql & "  @PartType2 as Integer, @PartType3 as Integer, @PartType4 as Integer " & vbCrLf
      sSql = sSql & " AS  " & vbCrLf
      sSql = sSql & "  BEGIN " & vbCrLf
      sSql = sSql & "    declare @mrpPartRef as varchar(30) " & vbCrLf
      sSql = sSql & "    declare @QtyRem as integer " & vbCrLf
      sSql = sSql & "   declare @mrp_active as integer" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "    IF (@PartClass = 'ALL') " & vbCrLf
      sSql = sSql & "     BEGIN                   " & vbCrLf
      sSql = sSql & "         SET @PartClass = '' " & vbCrLf
      sSql = sSql & "     End                     " & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "     IF (@PartCode = 'ALL')  " & vbCrLf
      sSql = sSql & "     BEGIN                   " & vbCrLf
      sSql = sSql & "         SET @PartCode = ''  " & vbCrLf
      sSql = sSql & "     End                     " & vbCrLf
      sSql = sSql & "     IF (@PartType1 = 1)     " & vbCrLf
      sSql = sSql & "         SET @PartType1 = 1  " & vbCrLf
      sSql = sSql & "     Else                    " & vbCrLf
      sSql = sSql & "         SET @PartType1 = 0  " & vbCrLf
      sSql = sSql & "     IF (@PartType2 = 1)     " & vbCrLf
      sSql = sSql & "         SET @PartType2 = 2  " & vbCrLf
      sSql = sSql & "     Else                    " & vbCrLf
      sSql = sSql & "         SET @PartType2 = 0  " & vbCrLf
      sSql = sSql & "     IF (@PartType3 = 1)     " & vbCrLf
      sSql = sSql & "         SET @PartType3 = 3  " & vbCrLf
      sSql = sSql & "    Else                    " & vbCrLf
      sSql = sSql & "         SET @PartType3 = 0  " & vbCrLf
      sSql = sSql & "     IF (@PartType4 = 1)     " & vbCrLf
      sSql = sSql & "         SET @PartType4 = 4  " & vbCrLf
      sSql = sSql & "     Else                    " & vbCrLf
      sSql = sSql & "         SET @PartType4 = 0  " & vbCrLf
      sSql = sSql & "     CREATE TABLE #tempMrpExRpt          " & vbCrLf
      sSql = sSql & "     (                                   " & vbCrLf
      sSql = sSql & "         PACLASS varchar(4) NULL ,       " & vbCrLf
      sSql = sSql & "         PAPRODCODE varchar(6) NULL ,    " & vbCrLf
      sSql = sSql & "         PALEVEL tinyint NULL ,          " & vbCrLf
      sSql = sSql & "         PARTREF varchar(30) NULL ,      " & vbCrLf
      sSql = sSql & "         PARTNUM varchar(30) NULL ,      " & vbCrLf
      sSql = sSql & "         PADESC varchar(30) NULL ,       " & vbCrLf
      sSql = sSql & "         PAEXTDESC varchar(3072) NULL ,  " & vbCrLf
      sSql = sSql & "         LOTNUMBER varchar(15) NULL,     " & vbCrLf
      sSql = sSql & "         LOTUSERLOTID varchar(40) NULL,  " & vbCrLf
      sSql = sSql & "         MRP_QTYREM int NULL,            " & vbCrLf
      sSql = sSql & "         LOTUNITCOST decimal(12,4) NULL , " & vbCrLf
      sSql = sSql & "         PASTDCOST decimal(12,4) NULL ,  " & vbCrLf
      sSql = sSql & "         PAUSEACTUALCOST tinyint NULL ,  " & vbCrLf
      sSql = sSql & "         PALOTTRACK tinyint NULL," & vbCrLf
      sSql = sSql & "         MRP_ACTIVITY tinyint NULL" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "     )                                   " & vbCrLf
      sSql = sSql & "     DECLARE curInv CURSOR               " & vbCrLf
      sSql = sSql & "     LOCAL                               " & vbCrLf
      sSql = sSql & "     Scroll                              " & vbCrLf
      sSql = sSql & "    FOR                                     " & vbCrLf
      sSql = sSql & "        SELECT mrp_partref, SUM(mrp_partqtyrqd) as rem from " & vbCrLf
      sSql = sSql & "            MrplTable                                       " & vbCrLf
      sSql = sSql & "        --WHERE mrp_partref LIKE 'BNPL%'                    " & vbCrLf
      sSql = sSql & "        GROUP BY mrp_partref                                " & vbCrLf
      sSql = sSql & "            Having Sum(mrp_partqtyrqd) >= 1                 " & vbCrLf
      sSql = sSql & "    OPEN curInv                                             " & vbCrLf
      sSql = sSql & "    FETCH NEXT FROM curInv INTO @mrpPartRef, @QtyRem        " & vbCrLf
      sSql = sSql & "    WHILE (@@FETCH_STATUS <> -1)                            " & vbCrLf
      sSql = sSql & "    BEGIN                                                   " & vbCrLf
      sSql = sSql & "        IF (@@FETCH_STATUS <> -2)                           " & vbCrLf
      sSql = sSql & "        BEGIN" & vbCrLf
      sSql = sSql & "      --/ find if there is any activity" & vbCrLf
      sSql = sSql & "      SELECT @mrp_active = case when count(*) > 0 then 1 else 0 end " & vbCrLf
      sSql = sSql & "             FROM MrplTable WHERE mrp_partref = @mrpPartRef" & vbCrLf
      sSql = sSql & "         and mrp_type NOT IN ('1','17')" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "        INSERT INTO #tempMrpExRpt (PACLASS, PAPRODCODE, PALEVEL,                " & vbCrLf
      sSql = sSql & "            PARTREF, PARTNUM, PADESC, PAEXTDESC, LOTNUMBER, LOTUSERLOTID,       " & vbCrLf
      sSql = sSql & "            MRP_QTYREM, LOTUNITCOST, PASTDCOST, PAUSEACTUALCOST, PALOTTRACK, MRP_ACTIVITY)    " & vbCrLf
      sSql = sSql & "            SELECT top(1) PACLASS, PAPRODCODE, PALEVEL, PARTREF, PARTNUM, PADESC, " & vbCrLf
      sSql = sSql & "                PAEXTDESC, LOTNUMBER, LOTUSERLOTID, @QtyRem,LOTUNITCOST,        " & vbCrLf
      sSql = sSql & "                PASTDCOST , PAUSEACTUALCOST, PALOTTRACK, @mrp_active                         " & vbCrLf
      sSql = sSql & "            From ViewLohdPartTable                                              " & vbCrLf
      sSql = sSql & "                WHERE partRef = @mrpPartRef                                     " & vbCrLf
      sSql = sSql & "                AND PACLASS LIKE '%' + @PartClass + '%'                         " & vbCrLf
      sSql = sSql & "                AND PAPRODCODE LIKE '%' + @PartCode + '%'                       " & vbCrLf
      sSql = sSql & "                AND PALEVEL IN (@PartType1, @PartType2, @PartType3, @PartType4) " & vbCrLf
      sSql = sSql & "        End                                                                     " & vbCrLf
      sSql = sSql & "        FETCH NEXT FROM curInv INTO @mrpPartRef, @QtyRem                     " & vbCrLf
      sSql = sSql & "    End                                                                         " & vbCrLf
      sSql = sSql & "    CLOSE curInv   --// close the cursor                                        " & vbCrLf
      sSql = sSql & "    DEALLOCATE curInv                                                           " & vbCrLf
      sSql = sSql & "    SELECT PACLASS, PAPRODCODE, PALEVEL,                                        " & vbCrLf
      sSql = sSql & "            PARTREF, PARTNUM, PADESC, PAEXTDESC, LOTNUMBER, LOTUSERLOTID,       " & vbCrLf
      sSql = sSql & "            MRP_QTYREM , LOTUNITCOST, PASTDCOST, PAUSEACTUALCOST, PALOTTRACK,MRP_ACTIVITY" & vbCrLf
      sSql = sSql & "    FROM #tempMrpExRpt                                                          " & vbCrLf
      sSql = sSql & "    DROP table #tempMrpExRpt                                                    " & vbCrLf
      sSql = sSql & " End "
      
      ExecuteScript False, sSql
      
      sSql = "ALTER PROCEDURE [dbo].[Qry_FillParts] AS" & vbCrLf
      sSql = sSql & "   SELECT PARTREF,PARTNUM,PADESC" & vbCrLf
      sSql = sSql & "   FROM PartTable  WHERE PAINACTIVE = 0 AND PAOBSOLETE = 0" & vbCrLf
      sSql = sSql & "   ORDER BY PARTREF"
      
      ExecuteScript False, sSql
      
      sSql = "ALTER PROCEDURE [dbo].[Qry_SortedPartTypesBelow4]" & vbCrLf
      sSql = sSql & "   AS" & vbCrLf
      sSql = sSql & "   SELECT PARTREF,PARTNUM,PALEVEL" & vbCrLf
      sSql = sSql & "   From PartTable" & vbCrLf
      sSql = sSql & "   WHERE (PALEVEL<4 AND PAPRODCODE<>'BID' AND PAINACTIVE = 0 AND PAOBSOLETE = 0)" & vbCrLf
      sSql = sSql & "   ORDER BY PARTREF"
      
      ExecuteScript False, sSql

      sSql = "ALTER PROCEDURE [dbo].[Qry_FillSortedParts] AS" & vbCrLf
      sSql = sSql & "   SELECT PARTREF,PARTNUM,PADESC" & vbCrLf
      sSql = sSql & "   From PartTable" & vbCrLf
      sSql = sSql & "   WHERE PAPRODCODE<>'BID' AND PAINACTIVE = 0 AND PAOBSOLETE = 0" & vbCrLf
      sSql = sSql & "   ORDER BY PARTREF"
      
      ExecuteScript False, sSql
      
      sSql = "ALTER PROCEDURE [dbo].[Qry_FillPartRoutings] AS" & vbCrLf
      sSql = sSql & "   SELECT PARTREF,PARTNUM,PALEVEL,PAROUTING" & vbCrLf
      sSql = sSql & "   From PartTable" & vbCrLf
      sSql = sSql & "   Where (PALEVEL < 7 Or PALEVEL = 8) And PAINACTIVE = 0 And PAOBSOLETE = 0" & vbCrLf
      sSql = sSql & "   ORDER BY PAROUTING"
      
      ExecuteScript False, sSql
      
      
      sSql = "ALTER PROCEDURE [dbo].[Qry_PartTypesBelow4] AS" & vbCrLf
      sSql = sSql & "   SELECT PARTREF,PARTNUM" & vbCrLf
      sSql = sSql & "   From PartTable" & vbCrLf
      sSql = sSql & "   WHERE (PALEVEL<4 AND PAPRODCODE<>'BID' AND PAINACTIVE = 0 And PAOBSOLETE = 0)" & vbCrLf
      sSql = sSql & "   ORDER BY PARTREF"
      
      ExecuteScript False, sSql
      
      sSql = "ALTER PROCEDURE [dbo].[Qry_GetPartRouting]" & vbCrLf
      sSql = sSql & " (@routpart char(30))" & vbCrLf
      sSql = sSql & " as" & vbCrLf
      sSql = sSql & " SELECT PARTREF,PARTNUM,PADESC,PALEVEL,PAROUTING FROM PartTable" & vbCrLf
      sSql = sSql & " WHERE PARTREF=@routpart AND PAINACTIVE = 0 And PAOBSOLETE = 0"

      ExecuteScript False, sSql

      sSql = "ALTER TABLE ComnTable ADD CODISAUTOSCAN int NULL"
      ExecuteScript False, sSql

      ' update the version
      ExecuteScript False, "Update Version Set Version = " & newver
   
   End If
End Function

Private Function UpdateDatabase64()

   newver = 138
   If ver < newver Then

      clsADOCon.ADOErrNum = 0

      If Not ColumnExists("ComnTable", "COPSOVERSHIP") Then
         sSql = "ALTER TABLE ComnTable ADD COPSOVERSHIP int NULL"
         ExecuteScript False, sSql
      End If
      
      If Not ColumnExists("custtable", "CUSTBLDG") Then
         sSql = "ALTER TABLE custtable ADD CUSTBLDG varchar(12) null CONSTRAINT DF_CustTable_CUSTBLDG DEFAULT ''," & vbCrLf
         sSql = sSql & " CUSTDOOR varchar(12) null CONSTRAINT DF_CustTable_CUSTDOOR DEFAULT ''"
         ExecuteScript False, sSql
      End If
      
      If ColumnExists("RunsTable", "RUNRTAPPDATE") Then
         
         Dim sConstraintName As String
         sConstraintName = GetConstrinNameforColumn("RunsTable", "RUNRTAPPDATE")
         If sConstraintName <> "" Then ExecuteScript False, "alter table RunsTable drop CONSTRAINT " & sConstraintName
      
         sSql = "alter table RunsTable alter column RUNRTAPPDATE varchar(10)"
         ExecuteScript False, sSql
         
         sSql = "ALTER TABLE RunsTable ADD CONSTRAINT DF_RunsTable_RUNRTAPPDATE DEFAULT ('') FOR RUNRTAPPDATE"
         ExecuteScript False, sSql
      End If

      If Not ColumnExists("cihdtable", "INVCNT") Then
         sSql = "ALTER TABLE cihdtable  ADD INVCNT int NULL CONSTRAINT DF_cihdtable_INVCNT DEFAULT 0"
         ExecuteScript False, sSql
      End If
      
      If Not ColumnExists("cihdtable", "INVUSR") Then
         sSql = "ALTER TABLE cihdtable ADD INVUSR varchar(4) NULL CONSTRAINT DF_cihdtable_INVUSR DEFAULT ('')"
         ExecuteScript False, sSql
      End If
      
      ' update the version
      ExecuteScript False, "Update Version Set Version = " & newver
   
   End If
End Function

Private Function UpdateDatabase65()

   newver = 139
   If ver < newver Then

      clsADOCon.ADOErrNum = 0

      If Not ColumnExists("PARTTABLE", "CustomFld1") Then
         sSql = "ALTER TABLE PARTTABLE ADD CustomFld1 varchar(30) NULL default('')"
         ExecuteScript False, sSql
      End If

      If Not ColumnExists("ComnTable", "PARTSEARCHOP") Then
         sSql = "ALTER TABLE [ComnTable] ADD PARTSEARCHOP int null default 0"
         ExecuteScript False, sSql
      End If
      
      If Not ColumnExists("ChHdrTable", "ChkLfAdd") Then
         sSql = "ALTER TABLE ChHdrTable ADD ChkLfAdd varchar(160) null"
         ExecuteScript False, sSql
      End If

      sSql = "ALTER  PROCEDURE [dbo].[RptMORunOptDetail]" & vbCrLf
      sSql = sSql & " @MOPart as varchar(30),@cutoffDt as varchar(10)" & vbCrLf
      sSql = sSql & " AS" & vbCrLf
      sSql = sSql & " BEGIN " & vbCrLf
      sSql = sSql & "    CREATE TABLE #tempRunOpDet" & vbCrLf
      sSql = sSql & "    (" & vbCrLf
      sSql = sSql & "       RUNREF Varchar(30) NULL," & vbCrLf
      sSql = sSql & "       RUNNO int Null," & vbCrLf
      sSql = sSql & "       NextOPNO smallint NULL," & vbCrLf
      sSql = sSql & "       NextOPSHOP varchar(12) NULL," & vbCrLf
      sSql = sSql & "       NextOPCENTER varchar(12) NULL," & vbCrLf
      sSql = sSql & "       PONUMBER int NULL" & vbCrLf
      sSql = sSql & "    )" & vbCrLf
      sSql = sSql & "    INSERT INTO #tempRunOpDet(RUNREF, RUNNO, NextOPNO, NextOPSHOP, NextOPCENTER)" & vbCrLf
      sSql = sSql & "    select runstable.Runref, runstable.runno, f.NextOPNO, f.NextOPSHOP, f.NextOPCENTER" & vbCrLf
      sSql = sSql & "       from runstable,RnopTable," & vbCrLf
      sSql = sSql & "       (select a.runref, a.runno, b.OPNO NextOPNO, OPSHOP NextOPSHOP, OPCENTER NextOPCENTER," & vbCrLf
      sSql = sSql & "             ROW_NUMBER() OVER (PARTITION BY opref, oprun" & vbCrLf
      sSql = sSql & "                           ORDER BY opref DESC, oprun) as rn" & vbCrLf
      sSql = sSql & "          from runstable a,rnopTable b" & vbCrLf
      sSql = sSql & "          where a.runref = b.opref and" & vbCrLf
      sSql = sSql & "             a.RunNO = b.oprun And b.opno > a.runopcur" & vbCrLf
      sSql = sSql & "       ) as f" & vbCrLf
      sSql = sSql & "    where RunsTable.RUNSCHED <= @cutoffDt AND" & vbCrLf
      sSql = sSql & "       RunsTable.RUNSTATUS NOT IN ('CA','CL','CO') and RunsTable.runref =  @MOPart" & vbCrLf
      sSql = sSql & "       and RunsTable.runref =  f.runref AND RunsTable.runno = f.runno" & vbCrLf
      sSql = sSql & "       and f.rn = 1" & vbCrLf
      sSql = sSql & "    " & vbCrLf
      sSql = sSql & "    UPDATE a SET a.PONUMBER = poitTable.PINUMBER" & vbCrLf
      sSql = sSql & "    from #tempRunOpDet a, ShopTable, poitTable WHERE SHPREF = nextOPSHOP" & vbCrLf
      sSql = sSql & "       AND SHPSERVICE = 1 AND PIRUNPART = RUNREF AND PIRUNNO = RUNNO" & vbCrLf
      sSql = sSql & "    " & vbCrLf
      sSql = sSql & "    SELECT DISTINCT a.NextOPNO, a.NextOPSHOP, a.NextOPCENTER, a.PONUMBER, RnopTable.OPSHOP as CurOPShop," & vbCrLf
      sSql = sSql & "       RnopTable.OPCENTER as CurOPCenter, RunsTable.*" & vbCrLf
      sSql = sSql & "       FROM runstable, RnopTable, #tempRunOpDet a" & vbCrLf
      sSql = sSql & "       Where a.Runref = RunsTable.Runref And a.RunNO = RunsTable.RunNO" & vbCrLf
      sSql = sSql & "          AND RnopTable.OPREF = RunsTable.runref" & vbCrLf
      sSql = sSql & "          AND RnopTable.OPRUN = RunsTable.runno" & vbCrLf
      sSql = sSql & "          and RunsTable.runopcur = RnopTable.OPNO" & vbCrLf
      sSql = sSql & "          AND a.RunRef = RnopTable.OPREF AND a.RunNo = RnopTable.OPRUN" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "    DROP table #tempRunOpDet" & vbCrLf
      sSql = sSql & " End"
      
      ExecuteScript False, sSql
      
      
      ' update the version
      ExecuteScript False, "Update Version Set Version = " & newver
   
   End If
End Function

Private Function UpdateDatabase66()

    newver = 140
    If ver < newver Then
        
        clsADOCon.ADOErrNum = 0
        
        If Not ColumnExists("ComnTable", "CODISAUTOSCAN") Then
        sSql = "ALTER TABLE ComnTable ADD CODISAUTOSCAN int NULL default 0"
        ExecuteScript False, sSql
        End If
        
        If (Not TableExists("EsReportLots01t")) Then
        
            sSql = "CREATE TABLE [dbo].[EsReportLots01t](" & vbCrLf
            sSql = sSql & " [LOTREC] [int] NULL," & vbCrLf
            sSql = sSql & " [LOTID] [char](15) NULL" & vbCrLf
            sSql = sSql & ") ON [PRIMARY]"
            
            ExecuteScript False, sSql
            
            sSql = "ALTER TABLE [dbo].[EsReportLots01t] ADD  DEFAULT ((0)) FOR [LOTREC]"
            ExecuteScript False, sSql
            
            sSql = "ALTER TABLE [dbo].[EsReportLots01t] ADD  DEFAULT ('') FOR [LOTID]"
            ExecuteScript False, sSql
        
        End If
        
        If Not ColumnExists("EsReportWIP", "WIPRUNQTY") Then
            sSql = "ALTER TABLE EsReportWIP ADD WIPRUNQTY decimal(12,4) default(0), WIPRUNPARTIALQTY decimal(12,4) default(0)"
            ExecuteScript False, sSql
        End If
        
        
        If StoreProcedureExists("RptMORunOptDetail") Then
            sSql = "DROP PROCEDURE RptMORunOptDetail"
            ExecuteScript False, sSql
        End If
        
        sSql = "CREATE PROCEDURE [dbo].[RptMORunOptDetail]" & vbCrLf
        sSql = sSql & "      @MOPart as varchar(30),@cutoffDt as varchar(10)" & vbCrLf
        sSql = sSql & "AS " & vbCrLf
        sSql = sSql & "BEGIN" & vbCrLf
        sSql = sSql & " CREATE TABLE #tempRunOpDet" & vbCrLf
        sSql = sSql & " ( " & vbCrLf
        sSql = sSql & "     RUNREF Varchar(30) NULL, " & vbCrLf
        sSql = sSql & "     RUNNO int Null, " & vbCrLf
        sSql = sSql & "     NextOPNO smallint NULL," & vbCrLf
        sSql = sSql & "     NextOPSHOP varchar(12) NULL," & vbCrLf
        sSql = sSql & "     NextOPCENTER varchar(12) NULL," & vbCrLf
        sSql = sSql & "     PONUMBER int NULL     " & vbCrLf
        sSql = sSql & " ) " & vbCrLf
        sSql = sSql & " INSERT INTO #tempRunOpDet(RUNREF, RUNNO, NextOPNO, NextOPSHOP, NextOPCENTER)" & vbCrLf
        sSql = sSql & " select distinct runstable.Runref, runstable.runno, f.NextOPNO, f.NextOPSHOP, f.NextOPCENTER " & vbCrLf
        sSql = sSql & "     from runstable,RnopTable," & vbCrLf
        sSql = sSql & "     (select a.runref, a.runno, b.OPNO NextOPNO, OPSHOP NextOPSHOP, OPCENTER NextOPCENTER," & vbCrLf
        sSql = sSql & "ROW_NUMBER() OVER (PARTITION BY opref, oprun" & vbCrLf
        sSql = sSql & "                               ORDER BY opref DESC, oprun) as rn" & vbCrLf
        sSql = sSql & "         from runstable a,rnopTable b" & vbCrLf
        sSql = sSql & "         where a.runref = b.opref and " & vbCrLf
        sSql = sSql & "a.runno = b.oprun and b.opcompdate is null and b.opno <> a.runopcur" & vbCrLf
        sSql = sSql & "             --and b.opno > a.runopcur" & vbCrLf
        sSql = sSql & "     ) as f" & vbCrLf
        sSql = sSql & " where RunsTable.RUNSCHED <= @cutoffDt AND " & vbCrLf
        sSql = sSql & "     RunsTable.RUNSTATUS NOT IN ('CA','CL','CO') and RunsTable.runref =  @MOPart" & vbCrLf
        sSql = sSql & "     and RunsTable.runref =  f.runref AND RunsTable.runno = f.runno" & vbCrLf
        sSql = sSql & "     and f.rn = 1 " & vbCrLf
        sSql = sSql & " " & vbCrLf
        sSql = sSql & " UPDATE a SET a.PONUMBER = poitTable.PINUMBER" & vbCrLf
        sSql = sSql & " from #tempRunOpDet a, ShopTable, poitTable WHERE SHPREF = nextOPSHOP " & vbCrLf
        sSql = sSql & "     AND SHPSERVICE = 1 AND PIRUNPART = RUNREF AND PIRUNNO = RUNNO" & vbCrLf
        sSql = sSql & " " & vbCrLf
        sSql = sSql & " SELECT DISTINCT a.NextOPNO, a.NextOPSHOP, a.NextOPCENTER, a.PONUMBER, RnopTable.OPSHOP as CurOPShop, " & vbCrLf
        sSql = sSql & "     RnopTable.OPCENTER as CurOPCenter, RunsTable.* " & vbCrLf
        sSql = sSql & "     FROM runstable, RnopTable, #tempRunOpDet a" & vbCrLf
        sSql = sSql & "     WHERE a.RunRef = runstable.Runref AND a.RunNo = runstable.RunNO" & vbCrLf
        sSql = sSql & "         AND RnopTable.OPREF = RunsTable.runref " & vbCrLf
        sSql = sSql & "         AND RnopTable.OPRUN = RunsTable.runno" & vbCrLf
        sSql = sSql & "         and RunsTable.runopcur = RnopTable.OPNO" & vbCrLf
        sSql = sSql & "         AND a.RunRef = RnopTable.OPREF AND a.RunNo = RnopTable.OPRUN" & vbCrLf
        sSql = sSql & "     " & vbCrLf
        sSql = sSql & " DROP table #tempRunOpDet " & vbCrLf
        sSql = sSql & "END"
        
        ExecuteScript False, sSql
        
        If StoreProcedureExists("RptWCQListStats") Then
            sSql = "DROP PROCEDURE RptWCQListStats"
            ExecuteScript False, sSql
        End If
        
        sSql = "CREATE PROCEDURE [dbo].[RptWCQListStats]" & vbCrLf
        sSql = sSql & " @BeginDate  as varchar(30),@EdnDate as varchar(10)," & vbCrLf
        sSql = sSql & " @OpShop as varchar(12), @OpCenter as varchar(12)  " & vbCrLf
        sSql = sSql & " AS" & vbCrLf
        sSql = sSql & " BEGIN " & vbCrLf
        sSql = sSql & " IF (@OpShop = '')  " & vbCrLf
        sSql = sSql & " BEGIN   " & vbCrLf
        sSql = sSql & "     SET @OpShop = '%'    " & vbCrLf
        sSql = sSql & " End " & vbCrLf
        sSql = sSql & "              " & vbCrLf
        sSql = sSql & " IF (@OpCenter = '')    " & vbCrLf
        sSql = sSql & " BEGIN   " & vbCrLf
        sSql = sSql & "     SET @OpCenter = '%'        " & vbCrLf
        sSql = sSql & " End                       " & vbCrLf
        sSql = sSql & "    " & vbCrLf
        sSql = sSql & " select distinct runstable.Runref, runstable.runno, OPCENTER, RUNSTATUS, RUNQTY," & vbCrLf
        sSql = sSql & "     runopcur,RnopTable.OPQDATE,  RnopTable.OPSCHEDDATE," & vbCrLf
        sSql = sSql & "     f.PrevOPNO, f.OPQDATE PREVQDATE, f.OPSCHEDDATE PREVSCHEDDATE," & vbCrLf
        sSql = sSql & "     DATEDIFF(day,f.OPSCHEDDATE, RnopTable.OPQDATE) DtDiffQue," & vbCrLf
        sSql = sSql & "     DATEDIFF(day, f.OPSCHEDDATE, GETDATE()) DtDiffNow" & vbCrLf
        sSql = sSql & "    from runstable,RnopTable," & vbCrLf
        sSql = sSql & "    (select a.runref, a.runno, b.OPNO PrevOPNO, OPQDATE, OPSCHEDDATE," & vbCrLf
        sSql = sSql & "          ROW_NUMBER() OVER (PARTITION BY opref, oprun" & vbCrLf
        sSql = sSql & "                        ORDER BY opref DESC, oprun DESC, OPNO desc) as rn" & vbCrLf
        sSql = sSql & "       from runstable a,rnopTable b" & vbCrLf
        sSql = sSql & "       where a.runref = b.opref and" & vbCrLf
        sSql = sSql & "          a.RunNO = b.oprun And b.opno < a.runopcur" & vbCrLf
        sSql = sSql & "    ) as f" & vbCrLf
        sSql = sSql & " where RunsTable.RunSched between @BeginDate and @EdnDate" & vbCrLf
        sSql = sSql & "    and RunsTable.runref =  f.runref AND RunsTable.runno = f.runno" & vbCrLf
        sSql = sSql & "    and RnopTable.opref = RunsTable.runref AND RunsTable.runno = RnopTable.OPRUN" & vbCrLf
        sSql = sSql & "    and RunsTable.runopcur = RnopTable.Opno" & vbCrLf
        sSql = sSql & "    and RnopTable.OPSHOP LIKE @OpShop AND RnopTable.OPCENTER LIKE @OpCenter" & vbCrLf
        sSql = sSql & "    and f.rn = 1" & vbCrLf
        sSql = sSql & " End"
        
        ExecuteScript False, sSql
      
        ' update the version
        ExecuteScript False, "Update Version Set Version = " & newver
   
   End If
End Function


Private Function UpdateDatabase67()

    newver = 141
    If ver < newver Then
        
        clsADOCon.ADOErrNum = 0
        
        If Not ColumnExists("ComnTable", "COALLOWSCPOM") Then
            sSql = "ALTER table dbo.ComnTable add COALLOWSCPOM tinyint NULL CONSTRAINT DF_ComnTable_COALLOWSCPOM DEFAULT 0"
            ExecuteScript False, sSql
        End If
        
        If Not ColumnExists("RnopTable", "OPWCSTATUS") Then
            sSql = "ALTER table dbo.RnopTable add OPWCSTATUS tinyint NULL CONSTRAINT OPWCSTATUS_con DEFAULT 0"
            ExecuteScript False, sSql
        End If
        
        If Not ColumnExists("RnopTable", "STATUS_REF") Then
            sSql = "ALTER table dbo.RnopTable add STATUS_REF varchar(4) NULL CONSTRAINT [DF_RnopTable_STATUS_REF]  DEFAULT ('')"
            ExecuteScript False, sSql
        End If
        
        
        If Not ColumnExists("bmplTable", "BMPICKAT") Then
            sSql = "ALTER table bmplTable add BMPICKAT int null CONSTRAINT [DF_bmplTable_BMPICKAT]  DEFAULT (1)"
            ExecuteScript False, sSql
            
            sSql = "UPDATE bmplTable set BMPICKAT = 1"
            ExecuteScript False, sSql
        End If
        
        If ColumnExists("CcitTable", "CIPADESC") Then
            
            Dim sOldNme As String
            
            sOldNme = GetConstrinNameforColumn("CcitTable", "CIPADESC")
    
            'ExecuteScript True, "exec sp_rename '" & sOldNme & "','" & sNewObjName & "',OBJECT"

            sSql = "ALTER Table CcitTable DROP CONSTRAINT " & sOldNme
            ExecuteScript False, sSql
            
            sSql = "ALTER TABLE dbo.CcitTable ALTER COLUMN CIPADESC VARCHAR(64) null"
            ExecuteScript False, sSql
            
            sSql = "ALTER TABLE CcitTable ADD CONSTRAINT DF_CcitTable_CIPADESC DEFAULT ('') FOR CIPADESC"
            ExecuteScript False, sSql
            
        End If
        
        If Not ColumnExists("ComnTable", "COALLOWMOCOMT") Then
            sSql = "ALTER table dbo.ComnTable add COALLOWMOCOMT tinyint NULL CONSTRAINT DF_ComnTable_COALLOWMOCOMT DEFAULT 0"
            ExecuteScript False, sSql
        End If
        
        If ColumnExists("EsReportLots01d", "LoiActivity") Then
            sSql = "ALTER Table dbo.EsReportLots01d ALTER COLUMN LoiActivity varchar(64) null"
            ExecuteScript False, sSql
        End If
        
        If ColumnExists("LohdTable", "LOTCOMMENTS") Then
            sSql = "ALTER TABLE dbo.LohdTable ALTER COLUMN LOTCOMMENTS VARCHAR(2048) null"
            ExecuteScript False, sSql
        End If
        
        ' update the version
        ExecuteScript False, "Update Version Set Version = " & newver
   
   End If
End Function

Private Function UpdateDatabase68()

    newver = 142
    If ver < newver Then
        
        clsADOCon.ADOErrNum = 0

        If StoreProcedureExists("RptMRPMOQtyShortage") Then
         sSql = "DROP PROCEDURE RptMRPMOQtyShortage"
         ExecuteScript False, sSql
        End If
        
        sSql = "CREATE PROCEDURE [dbo].[RptMRPMOQtyShortage]" & vbCrLf
        sSql = sSql & "      @InMOPart as varchar(30), @StartDate as datetime, @EndDate as datetime" & vbCrLf
        sSql = sSql & "AS " & vbCrLf
        sSql = sSql & "BEGIN" & vbCrLf
        sSql = sSql & "" & vbCrLf
        sSql = sSql & "   declare @ChildKey as varchar(1024)" & vbCrLf
        sSql = sSql & "   declare @GLSortKey as varchar(1024)" & vbCrLf
        sSql = sSql & "   declare @SortKey as varchar(1024)" & vbCrLf
        sSql = sSql & "" & vbCrLf
        sSql = sSql & "   declare @MOPart as varchar(30)" & vbCrLf
        sSql = sSql & "   declare @MORun as Integer" & vbCrLf
        sSql = sSql & "   declare @MOQtyRqd as decimal(12,4)" & vbCrLf
        sSql = sSql & "   declare @MOPartRqDt as datetime " & vbCrLf
        sSql = sSql & "" & vbCrLf
        sSql = sSql & "   declare @Part as varchar(30)" & vbCrLf
        sSql = sSql & "   declare @PAQOH as decimal(12,4)" & vbCrLf
        sSql = sSql & "   declare @RunTot as decimal(12,4)" & vbCrLf
        sSql = sSql & "   declare @AssyPart as varchar(30)" & vbCrLf
        sSql = sSql & "   declare @BMQtyReq as decimal(12,4)" & vbCrLf
        sSql = sSql & "   declare @RunQtyReq as decimal (12, 4)" & vbCrLf
        sSql = sSql & "   declare @PartDateQrd as datetime" & vbCrLf
        sSql = sSql & "   " & vbCrLf
        sSql = sSql & "   --DROP TABLE #tempMOPartsDetail " & vbCrLf
        sSql = sSql & "   DELETE FROM tempMrplPartShort" & vbCrLf
        sSql = sSql & "   " & vbCrLf
        sSql = sSql & "  BEGIN" & vbCrLf
        sSql = sSql & "   IF (@InMOPart = '')" & vbCrLf
        sSql = sSql & "      SET @InMOPart = @InMOPart + '%'" & vbCrLf
        sSql = sSql & "  " & vbCrLf
        sSql = sSql & "  DECLARE curMrpExp CURSOR  FOR" & vbCrLf
        sSql = sSql & "   SELECT MRP_PARTREF,0 as RUNNO, MRP_PARTQTYRQD, MRP_ACTIONDATE" & vbCrLf
        sSql = sSql & "   FROM MrplTable, PartTable   " & vbCrLf
        sSql = sSql & "   WHERE MRP_PARTREF = PartRef   " & vbCrLf
        sSql = sSql & "      AND MrplTable.MRP_PARTREF LIKE @InMOPart" & vbCrLf
        sSql = sSql & "      AND MrplTable.MRP_PARTPRODCODE LIKE '%'  " & vbCrLf
        sSql = sSql & "      AND MrplTable.MRP_PARTCLASS LIKE '%'  " & vbCrLf
        sSql = sSql & "      AND MrplTable.MRP_POBUYER LIKE '%'  " & vbCrLf
        sSql = sSql & "      AND MrplTable.MRP_PARTDATERQD BETWEEN @StartDate AND @EndDate" & vbCrLf
        sSql = sSql & "      AND MrplTable.MRP_TYPE IN (6, 5)   " & vbCrLf
        sSql = sSql & "      AND PartTable.PAMAKEBUY ='M'" & vbCrLf
        sSql = sSql & "   UNION" & vbCrLf
        sSql = sSql & "      SELECT DISTINCT RUNREF, RUNNO, RUNQTY,RUNSCHED  as MRP_ACTIONDATE FROM RunsTable WHERE " & vbCrLf
        sSql = sSql & "         RUNREF LIKE @InMOPart AND RUNSTATUS = 'SC'" & vbCrLf
        sSql = sSql & "         AND RUNPKSTART BETWEEN @StartDate  AND @EndDate order by MRP_ACTIONDATE" & vbCrLf
        sSql = sSql & "" & vbCrLf
        sSql = sSql & "  OPEN curMrpExp" & vbCrLf
        sSql = sSql & "  FETCH NEXT FROM curMrpExp INTO @MOPart, @MORun, @MOQtyRqd, @MOPartRqDt" & vbCrLf
        sSql = sSql & "  WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
        sSql = sSql & "  BEGIN" & vbCrLf
        sSql = sSql & "     IF (@@FETCH_STATUS <> -2)" & vbCrLf
        sSql = sSql & "     BEGIN" & vbCrLf
        sSql = sSql & "      with cte" & vbCrLf
        sSql = sSql & "      as (select BMASSYPART,BMPARTREF,BMPARTREV, BMQTYREQD , RTrim(BMUNITS) BMUNITS, " & vbCrLf
        sSql = sSql & "            BMCONVERSION, BMSEQUENCE, 0 as level," & vbCrLf
        sSql = sSql & "            cast(LTRIM(RTrim(BMASSYPART)) + char(36)+ COALESCE(cast(BMSEQUENCE as varchar(4)), '') + LTRIM(RTrim(BMPARTREF)) as varchar(max)) as SortKey" & vbCrLf
        sSql = sSql & "         from BmplTable" & vbCrLf
        sSql = sSql & "         where BMASSYPART = @MOPart" & vbCrLf
        sSql = sSql & "         union all" & vbCrLf
        sSql = sSql & "         select a.BMASSYPART,a.BMPARTREF,a.BMPARTREV, a.BMQTYREQD , RTrim(a.BMUNITS) BMUNITS, " & vbCrLf
        sSql = sSql & "            a.BMCONVERSION, a.BMSEQUENCE, level + 1," & vbCrLf
        sSql = sSql & "            cast(COALESCE(SortKey,'') + char(36) + COALESCE(cast(a.BMSEQUENCE as varchar(4)), '') + COALESCE(LTRIM(RTrim(a.BMPARTREF)) ,'') as varchar(max))as SortKey" & vbCrLf
        sSql = sSql & "         from cte" & vbCrLf
        sSql = sSql & "            inner join BmplTable a" & vbCrLf
                       sSql = sSql & "on cte.BMPARTREF = a.BMASSYPART" & vbCrLf
        sSql = sSql & "      ) " & vbCrLf
        sSql = sSql & "     INSERT INTO tempMrplPartShort(BMASSYPART,BMPARTREF,BMQTYREQD," & vbCrLf
        sSql = sSql & "      SORTKEYLEVEL,BMSEQUENCE, SortKey, PAQOH, RUNNO,MRP_PARTQTYRQD, MRP_ACTIONDATE)" & vbCrLf
        sSql = sSql & "     select BMASSYPART, BMPARTREF,BMQTYREQD,level,BMSEQUENCE, SortKey, PAQOH, @MORun, @MOQtyRqd, @MOPartRqDt" & vbCrLf
        sSql = sSql & "       from cte, PartTable WHERE PARTREF = BMPARTREF  AND BMPARTREF <> 'NULL' order by SortKey,BMSEQUENCE" & vbCrLf
        sSql = sSql & "        " & vbCrLf
        sSql = sSql & "   End" & vbCrLf
        sSql = sSql & "   FETCH NEXT FROM curMrpExp INTO @MOPart, @MORun, @MOQtyRqd, @MOPartRqDt" & vbCrLf
        sSql = sSql & "  End" & vbCrLf
        sSql = sSql & "  Close curMrpExp" & vbCrLf
        sSql = sSql & "  DEALLOCATE curMrpExp" & vbCrLf
        sSql = sSql & "" & vbCrLf
        sSql = sSql & "  DECLARE curRunTot CURSOR  FOR" & vbCrLf
        sSql = sSql & "  select DISTINCT BMPARTREF, PAQOH from tempMrplPartShort order by BMPARTREF" & vbCrLf
        sSql = sSql & "  OPEN curRunTot" & vbCrLf
        sSql = sSql & "  FETCH NEXT FROM curRunTot INTO @Part, @PAQOH" & vbCrLf
        sSql = sSql & "  WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
        sSql = sSql & "  BEGIN" & vbCrLf
        sSql = sSql & "     IF (@@FETCH_STATUS <> -2)" & vbCrLf
        sSql = sSql & "     BEGIN" & vbCrLf
        sSql = sSql & "        SET @RunTot = 0.0000" & vbCrLf
        sSql = sSql & "        SET @RunTot = @PAQOH" & vbCrLf
        sSql = sSql & "        DECLARE curRunTot1 CURSOR  FOR" & vbCrLf
        sSql = sSql & "         select DISTINCT BMASSYPART, BMQTYREQD, MRP_PARTQTYRQD, MRP_ACTIONDATE from tempMrplPartShort " & vbCrLf
        sSql = sSql & "            WHERE BMPARTREF = @Part" & vbCrLf
        sSql = sSql & "         order by BMASSYPART, MRP_ACTIONDATE " & vbCrLf
        sSql = sSql & "        OPEN curRunTot1" & vbCrLf
        sSql = sSql & "        FETCH NEXT FROM curRunTot1 INTO @AssyPart, @BMQtyReq, @RunQtyReq, @PartDateQrd" & vbCrLf
        sSql = sSql & "        WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
        sSql = sSql & "        BEGIN" & vbCrLf
        sSql = sSql & "          IF (@@FETCH_STATUS <> -2)" & vbCrLf
        sSql = sSql & "          BEGIN" & vbCrLf
        sSql = sSql & "            --Set @RunTot = ROUND(@RunTot,4)" & vbCrLf
        sSql = sSql & "            Set @RunTot = @RunTot -  ( @BMQtyReq * @RunQtyReq)" & vbCrLf
        sSql = sSql & "            UPDATE tempMrplPartShort SET PAQRUNTOT = @RunTot WHERE " & vbCrLf
        sSql = sSql & "BMASSYPART = @AssyPart AND BMPARTREF = @Part AND MRP_ACTIONDATE = @PartDateQrd" & vbCrLf
        sSql = sSql & "          END" & vbCrLf
        sSql = sSql & "          FETCH NEXT FROM curRunTot1 INTO @AssyPart, @BMQtyReq, @RunQtyReq,@PartDateQrd" & vbCrLf
        sSql = sSql & "        End" & vbCrLf
        sSql = sSql & "        Close curRunTot1" & vbCrLf
        sSql = sSql & "        DEALLOCATE curRunTot1" & vbCrLf
        sSql = sSql & "    END" & vbCrLf
        sSql = sSql & "    FETCH NEXT FROM curRunTot INTO @Part, @PAQOH" & vbCrLf
        sSql = sSql & "  End" & vbCrLf
        sSql = sSql & "  Close curRunTot" & vbCrLf
        sSql = sSql & "  DEALLOCATE curRunTot" & vbCrLf
        sSql = sSql & " END" & vbCrLf
        sSql = sSql & "END"
        
        ExecuteScript False, sSql
        
        
        If StoreProcedureExists("InvMRPExcessReport") Then
         sSql = "DROP PROCEDURE InvMRPExcessReport"
         ExecuteScript False, sSql
        End If
        
        sSql = "CREATE PROCEDURE [dbo].[InvMRPExcessReport]" & vbCrLf
        sSql = sSql & "  @PartClass as Varchar(16), @PartCode as varchar(8), @PartType1 as Integer, " & vbCrLf
        sSql = sSql & "   @PartType2 as Integer, @PartType3 as Integer, @PartType4 as Integer " & vbCrLf
        sSql = sSql & "  AS  " & vbCrLf
        sSql = sSql & "   BEGIN " & vbCrLf
        sSql = sSql & "     declare @mrpPartRef as varchar(30) " & vbCrLf
        sSql = sSql & "     declare @QtyRem as integer " & vbCrLf
        sSql = sSql & "    declare @mrp_active as integer" & vbCrLf
        sSql = sSql & " " & vbCrLf
        sSql = sSql & "     IF (@PartClass = 'ALL') " & vbCrLf
        sSql = sSql & "      BEGIN                   " & vbCrLf
        sSql = sSql & "          SET @PartClass = '' " & vbCrLf
        sSql = sSql & "      End                     " & vbCrLf
        sSql = sSql & " " & vbCrLf
        sSql = sSql & "      IF (@PartCode = 'ALL')  " & vbCrLf
        sSql = sSql & "      BEGIN                   " & vbCrLf
        sSql = sSql & "          SET @PartCode = ''  " & vbCrLf
        sSql = sSql & "      End                     " & vbCrLf
        sSql = sSql & "      IF (@PartType1 = 1)     " & vbCrLf
        sSql = sSql & "          SET @PartType1 = 1  " & vbCrLf
        sSql = sSql & "      Else                    " & vbCrLf
        sSql = sSql & "          SET @PartType1 = 0  " & vbCrLf
        sSql = sSql & "      IF (@PartType2 = 1)     " & vbCrLf
        sSql = sSql & "          SET @PartType2 = 2  " & vbCrLf
        sSql = sSql & "      Else                    " & vbCrLf
        sSql = sSql & "          SET @PartType2 = 0  " & vbCrLf
        sSql = sSql & "      IF (@PartType3 = 1)     " & vbCrLf
        sSql = sSql & "          SET @PartType3 = 3  " & vbCrLf
        sSql = sSql & "     Else                    " & vbCrLf
        sSql = sSql & "          SET @PartType3 = 0  " & vbCrLf
        sSql = sSql & "      IF (@PartType4 = 1)     " & vbCrLf
        sSql = sSql & "          SET @PartType4 = 4  " & vbCrLf
        sSql = sSql & "      Else                    " & vbCrLf
        sSql = sSql & "          SET @PartType4 = 0  " & vbCrLf
        sSql = sSql & "      CREATE TABLE #tempMrpExRpt          " & vbCrLf
        sSql = sSql & "      (                                   " & vbCrLf
        sSql = sSql & "          PACLASS varchar(4) NULL ,       " & vbCrLf
        sSql = sSql & "          PAPRODCODE varchar(6) NULL ,    " & vbCrLf
        sSql = sSql & "          PALEVEL tinyint NULL ,          " & vbCrLf
        sSql = sSql & "          PARTREF varchar(30) NULL ,      " & vbCrLf
        sSql = sSql & "          PARTNUM varchar(30) NULL ,      " & vbCrLf
        sSql = sSql & "          PADESC varchar(30) NULL ,       " & vbCrLf
        sSql = sSql & "          PAEXTDESC varchar(3072) NULL ,  " & vbCrLf
        sSql = sSql & "          LOTNUMBER varchar(15) NULL,     " & vbCrLf
        sSql = sSql & "          LOTUSERLOTID varchar(40) NULL,  " & vbCrLf
        sSql = sSql & "          MRP_QTYREM int NULL,            " & vbCrLf
        sSql = sSql & "          LOTUNITCOST decimal(12,4) NULL , " & vbCrLf
        sSql = sSql & "          PASTDCOST decimal(12,4) NULL ,  " & vbCrLf
        sSql = sSql & "          PAUSEACTUALCOST tinyint NULL ,  " & vbCrLf
        sSql = sSql & "          PALOTTRACK tinyint NULL," & vbCrLf
        sSql = sSql & "          MRP_ACTIVITY tinyint NULL" & vbCrLf
        sSql = sSql & " " & vbCrLf
        sSql = sSql & "      )                                   " & vbCrLf
        sSql = sSql & "      DECLARE curInv CURSOR               " & vbCrLf
        sSql = sSql & "      LOCAL                               " & vbCrLf
        sSql = sSql & "      Scroll                              " & vbCrLf
        sSql = sSql & "     FOR                                     " & vbCrLf
        sSql = sSql & "         SELECT mrp_partref, SUM(mrp_partqtyrqd) as rem from " & vbCrLf
        sSql = sSql & "             MrplTable       " & vbCrLf
        sSql = sSql & "           WHERE mrp_type NOT IN ('5', '7')                                " & vbCrLf
        sSql = sSql & "         --WHERE mrp_partref LIKE 'BNPL%'                    " & vbCrLf
        sSql = sSql & "         GROUP BY mrp_partref                                " & vbCrLf
        sSql = sSql & "             Having Sum(mrp_partqtyrqd) >= 1                 " & vbCrLf
        sSql = sSql & "     OPEN curInv                                             " & vbCrLf
        sSql = sSql & "     FETCH NEXT FROM curInv INTO @mrpPartRef, @QtyRem        " & vbCrLf
        sSql = sSql & "     WHILE (@@FETCH_STATUS <> -1)                            " & vbCrLf
        sSql = sSql & "     BEGIN                                                   " & vbCrLf
        sSql = sSql & "         IF (@@FETCH_STATUS <> -2)                           " & vbCrLf
        sSql = sSql & "         BEGIN" & vbCrLf
        sSql = sSql & "       --/ find if there is any activity" & vbCrLf
        sSql = sSql & "       SELECT @mrp_active = case when count(*) > 0 then 1 else 0 end " & vbCrLf
        sSql = sSql & "              FROM MrplTable WHERE mrp_partref = @mrpPartRef" & vbCrLf
        sSql = sSql & "          and mrp_type NOT IN ('1','17', '5', '6')" & vbCrLf
        sSql = sSql & " " & vbCrLf
        sSql = sSql & "         INSERT INTO #tempMrpExRpt (PACLASS, PAPRODCODE, PALEVEL,                " & vbCrLf
        sSql = sSql & "             PARTREF, PARTNUM, PADESC, PAEXTDESC, LOTNUMBER, LOTUSERLOTID,       " & vbCrLf
        sSql = sSql & "             MRP_QTYREM, LOTUNITCOST, PASTDCOST, PAUSEACTUALCOST, PALOTTRACK, MRP_ACTIVITY)    " & vbCrLf
        sSql = sSql & "             SELECT top(1) PACLASS, PAPRODCODE, PALEVEL, PARTREF, PARTNUM, PADESC, " & vbCrLf
        sSql = sSql & " PAEXTDESC, LOTNUMBER, LOTUSERLOTID, @QtyRem,LOTUNITCOST,        " & vbCrLf
        sSql = sSql & "                 PASTDCOST , PAUSEACTUALCOST, PALOTTRACK, @mrp_active                         " & vbCrLf
        sSql = sSql & "             From ViewLohdPartTable                                              " & vbCrLf
        sSql = sSql & " WHERE partRef = @mrpPartRef                                     " & vbCrLf
        sSql = sSql & "                 AND PACLASS LIKE '%' + @PartClass + '%'                         " & vbCrLf
        sSql = sSql & " AND PAPRODCODE LIKE '%' + @PartCode + '%'                       " & vbCrLf
        sSql = sSql & "                 AND PALEVEL IN (@PartType1, @PartType2, @PartType3, @PartType4) " & vbCrLf
        sSql = sSql & "         End                                                                     " & vbCrLf
        sSql = sSql & "         FETCH NEXT FROM curInv INTO @mrpPartRef, @QtyRem                     " & vbCrLf
        sSql = sSql & "     End                                                                         " & vbCrLf
        sSql = sSql & "     CLOSE curInv   --// close the cursor                                        " & vbCrLf
        sSql = sSql & "     DEALLOCATE curInv                                                           " & vbCrLf
        sSql = sSql & "     SELECT PACLASS, PAPRODCODE, PALEVEL,                                        " & vbCrLf
        sSql = sSql & "             PARTREF, PARTNUM, PADESC, PAEXTDESC, LOTNUMBER, LOTUSERLOTID,       " & vbCrLf
        sSql = sSql & "             MRP_QTYREM , LOTUNITCOST, PASTDCOST, PAUSEACTUALCOST, PALOTTRACK,MRP_ACTIVITY" & vbCrLf
        sSql = sSql & "     FROM #tempMrpExRpt                                                          " & vbCrLf
        sSql = sSql & "     DROP table #tempMrpExRpt                                                    " & vbCrLf
        sSql = sSql & "  End "

        ExecuteScript False, sSql
        
        ' update the version
        ExecuteScript False, "Update Version Set Version = " & newver
   
   End If
End Function


Private Function UpdateDatabase69()

   newver = 143
   If ver < newver Then
   
      clsADOCon.ADOErrNum = 0
      
      If (Not TableExists("LtTrkTable")) Then
      
         sSql = "CREATE TABLE [dbo].[LtTrkTable](" & vbCrLf
         sSql = sSql & "   [LOTNUMBER] [varchar](15) NULL," & vbCrLf
         sSql = sSql & "   [LOTUSERLOTID] [varchar](40) NULL" & vbCrLf
         sSql = sSql & ") ON [PRIMARY]"
         
         ExecuteScript False, sSql
         
      End If
      
      If Not ColumnExists("RnopTable", "LOTUSERLOTID") Then
         sSql = "ALTER TABLE dbo.RnopTable ADD  [LOTUSERLOTID] [varchar](40) NULL"
         ExecuteScript False, sSql
      End If
      
      If Not ColumnExists("ComnTable", "COLOTATPOM") Then
         sSql = "ALTER TABLE dbo.ComnTable ADD  COLOTATPOM smallint NULL"
         ExecuteScript False, sSql
      End If
      
      
      If StoreProcedureExists("RptHistoryWCQListStats") Then
         sSql = "DROP PROCEDURE RptHistoryWCQListStats"
         ExecuteScript False, sSql
      End If
      
      sSql = "CREATE PROCEDURE [dbo].[RptHistoryWCQListStats]" & vbCrLf
      sSql = sSql & " @BeginDate  as varchar(30),@EdnDate as varchar(10)," & vbCrLf
      sSql = sSql & " @OpShop as varchar(12), @OpCenter as varchar(12)  " & vbCrLf
      sSql = sSql & " AS" & vbCrLf
      sSql = sSql & " BEGIN " & vbCrLf
      sSql = sSql & "   IF (@OpShop = '')  " & vbCrLf
      sSql = sSql & "   BEGIN   " & vbCrLf
      sSql = sSql & "      SET @OpShop = '%'    " & vbCrLf
      sSql = sSql & "   End " & vbCrLf
      sSql = sSql & "                " & vbCrLf
      sSql = sSql & "   IF (@OpCenter = '')    " & vbCrLf
      sSql = sSql & "   BEGIN   " & vbCrLf
      sSql = sSql & "      SET @OpCenter = '%'        " & vbCrLf
      sSql = sSql & "   End                       " & vbCrLf
      sSql = sSql & "    " & vbCrLf
      sSql = sSql & "   select distinct runstable.Runref, runstable.runno, OPCENTER, RUNSTATUS, RUNQTY," & vbCrLf
      sSql = sSql & "      runopcur,RnopTable.OPQDATE,  RnopTable.OPSCHEDDATE," & vbCrLf
      sSql = sSql & "      f.PrevOPNO, f.OPQDATE PREVQDATE, f.OPCOMPDATE PREVCOMPDATE," & vbCrLf
      sSql = sSql & "      DATEDIFF(day,f.OPCOMPDATE, RnopTable.OPQDATE) DtDiffQue," & vbCrLf
      sSql = sSql & "      DATEDIFF(day, f.OPCOMPDATE, GETDATE()) DtDiffNow" & vbCrLf
      sSql = sSql & "      from runstable,RnopTable," & vbCrLf
      sSql = sSql & "      (select a.runref, a.runno, b.OPNO PrevOPNO, OPQDATE, OPCOMPDATE," & vbCrLf
      sSql = sSql & "          ROW_NUMBER() OVER (PARTITION BY opref, oprun" & vbCrLf
      sSql = sSql & "                     ORDER BY opref DESC, oprun DESC, OPNO desc) as rn" & vbCrLf
      sSql = sSql & "        from runstable a,rnopTable b" & vbCrLf
      sSql = sSql & "        where a.runref = b.opref and" & vbCrLf
      sSql = sSql & "          a.RunNO = b.oprun And b.opno < a.runopcur" & vbCrLf
      sSql = sSql & "      ) as f" & vbCrLf
      sSql = sSql & "   where RnopTable.OPSCHEDDATE between @BeginDate and @EdnDate" & vbCrLf
      sSql = sSql & "      and RunsTable.runref =  f.runref AND RunsTable.runno = f.runno" & vbCrLf
      sSql = sSql & "      and RnopTable.opref = RunsTable.runref AND RunsTable.runno = RnopTable.OPRUN" & vbCrLf
      sSql = sSql & "      and RunsTable.runopcur = RnopTable.Opno" & vbCrLf
      sSql = sSql & "      and RnopTable.OPSHOP LIKE @OpShop AND RnopTable.OPCENTER LIKE @OpCenter" & vbCrLf
      sSql = sSql & "       --AND RnopTable.OPCOMPLETE = 0" & vbCrLf
      sSql = sSql & "      --and f.rn = 1" & vbCrLf
      sSql = sSql & " End"
      
      ExecuteScript False, sSql
      
      ' update the version
      ExecuteScript False, "Update Version Set Version = " & newver
   
   End If
End Function

Private Function UpdateDatabase70()

   newver = 144
   If ver < newver Then
   
      clsADOCon.ADOErrNum = 0
      
      If Not ColumnExists("CcitTable", "CILOTLOCATION") Then
       
         sSql = "ALTER TABLE CcitTable ADD  [CILOTLOCATION] [char](4) NULL"
         ExecuteScript False, sSql
      End If
      
      
      ' update the version
      ExecuteScript False, "Update Version Set Version = " & newver
   
   End If
End Function

Private Function UpdateDatabase71()

   newver = 145
   If ver < newver Then
   
      clsADOCon.ADOErrNum = 0
      
      If (Not TableExists("tempPOReqDate")) Then
      
         sSql = "CREATE TABLE tempPOReqDate(  " & vbCrLf
         sSql = sSql & "   [MRP_PARTREF] [char](30) NOT NULL," & vbCrLf
         sSql = sSql & "   [MRP_PARTNUM] [char](30) NOT NULL," & vbCrLf
         sSql = sSql & "   [MRP_TYPE] [tinyint] NULL," & vbCrLf
         sSql = sSql & "   [MRP_PONUM] [int] NULL," & vbCrLf
         sSql = sSql & "   [MRP_POITEM] [tinyint] NULL," & vbCrLf
         sSql = sSql & "   [MRP_PARTLEVEL] [tinyint] NOT NULL," & vbCrLf
         sSql = sSql & "   [MRP_HGHPRTDTRQD] [smalldatetime] NULL," & vbCrLf
         sSql = sSql & "   [MRP_PARTDATERQD] [smalldatetime] NULL," & vbCrLf
         sSql = sSql & "   [MRP_PARTQTYRQD] [decimal](12, 4) NULL," & vbCrLf
         sSql = sSql & "   [MRP_CATAGORY] [varchar](24) NULL," & vbCrLf
         sSql = sSql & "   [MRP_COMMENT] [varchar](80) NULL," & vbCrLf
         sSql = sSql & "   [EARLYLATE_DAYS] [int] NULL" & vbCrLf
         sSql = sSql & ")                               "

         ExecuteScript False, sSql
      End If
      
      If (Not TableExists("tempPOQtyRun")) Then
         sSql = "CREATE TABLE tempPOQtyRun(     " & vbCrLf
         sSql = sSql & "    [MRP_PARTREF] [char](30) NOT NULL," & vbCrLf
         sSql = sSql & "    [MRP_PARTDATERQD] [smalldatetime] NULL," & vbCrLf
         sSql = sSql & "    [MRP_PARTQTYRQD] [decimal](12, 4) NULL," & vbCrLf
         sSql = sSql & "    [MRP_ROW] [int] NULL," & vbCrLf
         sSql = sSql & "    [QtyFlagged] [tinyint] NULL" & vbCrLf
         sSql = sSql & "   )  "
            
         ExecuteScript False, sSql
      End If

      If (Not TableExists("tempMrpType2s")) Then
         sSql = "CREATE TABLE tempMrpType2s(     " & vbCrLf
         sSql = sSql & "    [MRP_PARTREF] [char](30) NOT NULL," & vbCrLf
         sSql = sSql & "    [MRP_PARTQTYRQD] [decimal](12, 4) NULL," & vbCrLf
         sSql = sSql & "    [MRP_PONUM] [int] NULL," & vbCrLf
         sSql = sSql & "    [MRP_POITEM] [tinyint] NULL" & vbCrLf
         sSql = sSql & "   )                               "
         
         ExecuteScript False, sSql
      End If
         
      If (Not TableExists("tempRunReqDate")) Then
         sSql = "CREATE TABLE tempRunReqDate(     " & vbCrLf
         sSql = sSql & " [RUNREF] [char](30) NOT NULL," & vbCrLf
         sSql = sSql & " [RUNNO] [int] NOT NULL," & vbCrLf
         sSql = sSql & " [RUNSCHED] [smalldatetime] NULL," & vbCrLf
         sSql = sSql & " [RUNCOMPLETE] [smalldatetime] NULL," & vbCrLf
         sSql = sSql & " [RUNSTATUS] [char](2) NULL," & vbCrLf
         sSql = sSql & " [RUNQTY] [decimal](12, 4) NULL," & vbCrLf
         sSql = sSql & " [RUNCOST] [decimal](12, 4) NULL," & vbCrLf
         sSql = sSql & " [MRP_TYPE] [tinyint] NULL," & vbCrLf
         sSql = sSql & " [MRP_CATAGORY] [varchar](24) NULL," & vbCrLf
         sSql = sSql & " [MRP_PARTDATERQD] [smalldatetime] NULL," & vbCrLf
         sSql = sSql & " [MRP_COMMENT] [varchar](80) NULL," & vbCrLf
         sSql = sSql & " [EARLYLATE_DAYS] [int] NULL" & vbCrLf
         sSql = sSql & "   )                               "
         ExecuteScript False, sSql
      End If

      If (Not TableExists("tempQtyRun")) Then
         sSql = "CREATE TABLE tempQtyRun(     " & vbCrLf
         sSql = sSql & "    [MRP_PARTREF] [char](30) NOT NULL," & vbCrLf
         sSql = sSql & "    [MRP_PARTDATERQD] [smalldatetime] NULL," & vbCrLf
         sSql = sSql & "    [MRP_PARTQTYRQD] [decimal](12, 4) NULL," & vbCrLf
         sSql = sSql & "    [MRP_MOPARTDATE] [smalldatetime] NULL," & vbCrLf
         sSql = sSql & "    [MRP_PARTRUNNINGQTY] [decimal](12, 4) NULL," & vbCrLf
         sSql = sSql & "    [MRP_ROW] [int] NULL,   " & vbCrLf
         sSql = sSql & "    [QtyFlagged] [tinyint] NULL" & vbCrLf
         sSql = sSql & "   )  "
         ExecuteScript False, sSql
      End If
      
      
      
      If StoreProcedureExists("UpdatePOMrpUsed") Then
         sSql = "DROP PROCEDURE UpdatePOMrpUsed"
         ExecuteScript False, sSql
      End If
      
      sSql = "CREATE PROCEDURE [dbo].[UpdatePOMrpUsed]  " & vbCrLf
      sSql = sSql & " @mrpPOPartRef as varchar(30) " & vbCrLf
      sSql = sSql & " AS  " & vbCrLf
      sSql = sSql & "BEGIN   " & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   declare @mrpDateRqd as datetime " & vbCrLf
      sSql = sSql & "   declare @mrpPOPartref1 as varchar(30) " & vbCrLf
      sSql = sSql & "   declare @mrpPOPartref2 as varchar(30)" & vbCrLf
      sSql = sSql & "   declare @mrpPOITEM  as int " & vbCrLf
      sSql = sSql & "   declare @mrpPONUM as int " & vbCrLf
      sSql = sSql & "   declare @mrpHigherReqDate as datetime" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   declare @mrpHigherReqQty as decimal(15, 2)" & vbCrLf
      sSql = sSql & "   declare @mrPartQty as decimal(15, 2)" & vbCrLf
      sSql = sSql & "   declare @mrpRow as int" & vbCrLf
      sSql = sSql & "   declare @cnt as int" & vbCrLf
      sSql = sSql & "   declare @done as int" & vbCrLf
      sSql = sSql & "   declare @QtyOnHand as decimal(15, 2)" & vbCrLf
      sSql = sSql & "   declare @mrpStockPartDateReq as datetime" & vbCrLf
      sSql = sSql & "   declare @mrpConsumedPartDateReq as datetime" & vbCrLf
      sSql = sSql & "   declare @mrpRunningQty as decimal (15, 2)" & vbCrLf
      sSql = sSql & "   declare @mrpStockQtyReq as decimal (15, 2)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   declare @bBeginLoop as int" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   declare @mrpPOQty as decimal(15,2) " & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   --// get the QOH from the begining balance" & vbCrLf
      sSql = sSql & "   SELECT @mrpRunningQty = ISNULL(SUM(MRP_PARTQTYRQD), 0) FROM MrplTable WHERE MrplTable.MRP_PARTREF = @mrpPOPartRef and mrp_type = 1" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "print 'Qty OH : ' + CONVERT(varchar(10), @mrpRunningQty)" & vbCrLf
      sSql = sSql & "      " & vbCrLf
      sSql = sSql & "   --// init the date required date to the top " & vbCrLf
      sSql = sSql & "   SELECT top 1 @mrpStockPartDateReq = MRP_PARTDATERQD " & vbCrLf
      sSql = sSql & "   FROM MrplTable" & vbCrLf
      sSql = sSql & "   WHERE" & vbCrLf
      sSql = sSql & "      MRP_PARTREF = @mrpPOPartRef AND --@mrpPOPartRef AND --(''BACB30NM3K7',','024116','BACC30BH6K','SHA2024L00.100X36.000X144.00','204574394')" & vbCrLf
      sSql = sSql & "      MrplTable.MRP_TYPE IN (14,3,12,4)" & vbCrLf
      sSql = sSql & "      ORDER BY MRP_PARTDATERQD" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "print 'Stock Date : ' + CONVERT(varchar(10), @mrpStockPartDateReq, 101)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   --SET @mrpRunningQty = 0" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   DECLARE curMrpStockPart CURSOR               " & vbCrLf
      sSql = sSql & "   LOCAL                               " & vbCrLf
      sSql = sSql & "   Scroll                              " & vbCrLf
      sSql = sSql & "   FOR                                     " & vbCrLf
      sSql = sSql & "      SELECT MrplTable.MRP_PARTDATERQD, MrplTable.MRP_PARTQTYRQD * -1" & vbCrLf
      sSql = sSql & "      FROM MrplTable" & vbCrLf
      sSql = sSql & "      WHERE" & vbCrLf
      sSql = sSql & "         MRP_PARTREF = @mrpPOPartRef AND --@mrpPOPartRef AND --(''BACB30NM3K7',','024116','BACC30BH6K','SHA2024L00.100X36.000X144.00','204574394')" & vbCrLf
      sSql = sSql & "         MrplTable.MRP_TYPE IN (14,3,12,4)" & vbCrLf
      sSql = sSql & "         ORDER BY MRP_PARTDATERQD" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   OPEN curMrpStockPart " & vbCrLf
      sSql = sSql & "   FETCH NEXT FROM curMrpStockPart  INTO @mrpStockPartDateReq, @mrpStockQtyReq" & vbCrLf
      sSql = sSql & "   WHILE (@@FETCH_STATUS <> -1)                            " & vbCrLf
      sSql = sSql & "   BEGIN                                                   " & vbCrLf
      sSql = sSql & "      IF (@@FETCH_STATUS <> -2)                           " & vbCrLf
      sSql = sSql & "      BEGIN" & vbCrLf
      sSql = sSql & "         " & vbCrLf
      sSql = sSql & "print 'Running Qty :' + CONVERT(varchar(10), @mrpRunningQty)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "         SET @mrpRunningQty = @mrpRunningQty - @mrpStockQtyReq" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "print 'Running Qty After :' + CONVERT(varchar(10), @mrpRunningQty)" & vbCrLf
      sSql = sSql & "print 'Stock PartReq :' + Convert (varchar (12), @mrpStockPartDateReq, 101)" & vbCrLf
      sSql = sSql & "         IF (@mrpRunningQty < 0)" & vbCrLf
      sSql = sSql & "BREAK" & vbCrLf
      sSql = sSql & "         " & vbCrLf
      sSql = sSql & "      END" & vbCrLf
      sSql = sSql & "   FETCH NEXT FROM curMrpStockPart  INTO @mrpStockPartDateReq, @mrpStockQtyReq" & vbCrLf
      sSql = sSql & "   END         " & vbCrLf
      sSql = sSql & "   CLOSE curMrpStockPart --// close the cursor                                        " & vbCrLf
      sSql = sSql & "   DEALLOCATE curMrpStockPart" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   SET @bBeginLoop = 1" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   SELECT @cnt = COUNT(MRP_PARTREF) FROM tempMrpType2s" & vbCrLf
      sSql = sSql & "               WHERE MRP_PARTREF = @mrpPOPartRef" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   IF @cnt = 1" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "   print 'PartRef Count 1 : ' + @mrpPOPartRef            " & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "      SET @done = 0" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "      IF (@mrpRunningQty > 0)" & vbCrLf
      sSql = sSql & "      BEGIN" & vbCrLf
      sSql = sSql & "         SELECT TOP(1) @mrPartQty =  MrplTable.MRP_PARTQTYRQD * -1" & vbCrLf
      sSql = sSql & "         FROM MrplTable" & vbCrLf
      sSql = sSql & "         WHERE" & vbCrLf
      sSql = sSql & "MRP_PARTREF = @mrpPOPartRef AND --@mrpPOPartRef AND --(''BACB30NM3K7',','024116','BACC30BH6K','SHA2024L00.100X36.000X144.00','204574394')" & vbCrLf
      sSql = sSql & "            MrplTable.MRP_TYPE IN (14,3,12,4)" & vbCrLf
      sSql = sSql & "AND MRP_PARTDATERQD >= @mrpStockPartDateReq" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "         if (@mrpRunningQty > @mrPartQty)" & vbCrLf
      sSql = sSql & "SET @done = 1" & vbCrLf
      sSql = sSql & "         " & vbCrLf
      sSql = sSql & "      END" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "      IF(@done = 0)" & vbCrLf
      sSql = sSql & "      BEGIN" & vbCrLf
      sSql = sSql & "         SELECT TOP(1) @mrpPONUM = MRP_PONUM, @mrpPOITEM = MRP_POITEM " & vbCrLf
      sSql = sSql & "FROM tempMrpType2s WHERE MRP_PARTREF = @mrpPOPartRef" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "         SELECT TOP(1) @mrpHigherReqDate = MrplTable.MRP_PARTDATERQD" & vbCrLf
      sSql = sSql & "         FROM MrplTable" & vbCrLf
      sSql = sSql & "         WHERE" & vbCrLf
      sSql = sSql & "MRP_PARTREF = @mrpPOPartRef AND --@mrpPOPartRef AND --('SHA6013KE00.063X48.000X144.00',','024116','BACC30BH6K','SHA2024L00.100X36.000X144.00','204574394')" & vbCrLf
      sSql = sSql & "            MrplTable.MRP_TYPE IN (14,3,12,4)" & vbCrLf
      sSql = sSql & "AND MRP_PARTDATERQD >= @mrpStockPartDateReq" & vbCrLf
      sSql = sSql & "         ORDER BY MRP_PARTDATERQD" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "         UPDATE tempPOReqDate SET MRP_HGHPRTDTRQD = @mrpHigherReqDate WHERE MRP_PARTREF = @mrpPOPartRef" & vbCrLf
      sSql = sSql & "               AND MRP_PONUM = @mrpPONUM AND MRP_POITEM = @mrpPOITEM" & vbCrLf
      sSql = sSql & "      END" & vbCrLf
      sSql = sSql & "   END" & vbCrLf
      sSql = sSql & "   ELSE" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "print 'After the loop :' + Convert( varchar(12), @mrpStockPartDateReq, 101)      " & vbCrLf
      sSql = sSql & "print 'PartRef' + @mrpPOPartRef           " & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "      INSERT INTO tempPOQtyRun (MRP_PARTREF,MRP_PARTDATERQD,MRP_PARTQTYRQD, MRP_ROW)" & vbCrLf
      sSql = sSql & "      SELECT MrplTable.MRP_PARTREF, MrplTable.MRP_PARTDATERQD, MrplTable.MRP_PARTQTYRQD * -1, MrplTable.MRP_ROW " & vbCrLf
      sSql = sSql & "      FROM MrplTable" & vbCrLf
      sSql = sSql & "      WHERE" & vbCrLf
      sSql = sSql & "         MRP_PARTREF = @mrpPOPartRef AND --@mrpPOPartRef AND --(''BACB30NM3K7',','024116','BACC30BH6K','SHA2024L00.100X36.000X144.00','204574394')" & vbCrLf
      sSql = sSql & "         MrplTable.MRP_TYPE IN (14,3,12,4)" & vbCrLf
      sSql = sSql & "         AND MRP_PARTDATERQD >= @mrpStockPartDateReq" & vbCrLf
      sSql = sSql & "         --ORDER BY MrplTable.MRP_PARTDATERQD" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "      DECLARE curMrpPO CURSOR               " & vbCrLf
      sSql = sSql & "      LOCAL                               " & vbCrLf
      sSql = sSql & "      Scroll                              " & vbCrLf
      sSql = sSql & "      FOR                                     " & vbCrLf
      sSql = sSql & "         SELECT DISTINCT tempMrpType2s.MRP_PARTREF, tempMrpType2s.MRP_PARTQTYRQD, " & vbCrLf
      sSql = sSql & "                  tempMrpType2s.MRP_PONUM, tempMrpType2s.MRP_POITEM, tempPOReqDate.MRP_PARTDATERQD" & vbCrLf
      sSql = sSql & "                  FROM tempMrpType2s, tempPOReqDate" & vbCrLf
      sSql = sSql & "                  WHERE tempMrpType2s.MRP_PARTREF = tempPOReqDate.MRP_PARTREF " & vbCrLf
      sSql = sSql & "                  AND tempMrpType2s.MRP_PONUM = tempPOReqDate.MRP_PONUM " & vbCrLf
      sSql = sSql & "                  AND tempMrpType2s.MRP_POITEM = tempPOReqDate.MRP_POITEM " & vbCrLf
      sSql = sSql & "                  AND tempMrpType2s.MRP_PARTREF = @mrpPOPartRef --" & vbCrLf
      sSql = sSql & "                  ORDER BY tempPOReqDate.MRP_PARTDATERQD" & vbCrLf
      sSql = sSql & "      OPEN curMrpPO" & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM curMrpPO INTO @mrpPOPartref1, @mrpPOQty, @mrpPONUM, @mrpPOITEM, @mrpConsumedPartDateReq" & vbCrLf
      sSql = sSql & "      WHILE (@@FETCH_STATUS <> -1)                            " & vbCrLf
      sSql = sSql & "      BEGIN                                                   " & vbCrLf
      sSql = sSql & "         IF (@@FETCH_STATUS <> -2)                           " & vbCrLf
      sSql = sSql & "         BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "            print 'Part Ref1:' + @mrpPOPartref1" & vbCrLf
      sSql = sSql & "print 'HigherReq Qty:' + Convert(varchar(24), @mrpPOQty)" & vbCrLf
      sSql = sSql & "            print 'PONumber :' + Convert(varchar(24), @mrpPONUM)" & vbCrLf
      sSql = sSql & "print 'PO Item :' + Convert(varchar(24), @mrpPOITEM)" & vbCrLf
      sSql = sSql & "            " & vbCrLf
      sSql = sSql & "                  " & vbCrLf
      sSql = sSql & "DECLARE curMrpPOCovered CURSOR" & vbCrLf
      sSql = sSql & "            LOCAL                               " & vbCrLf
      sSql = sSql & "Scroll                              " & vbCrLf
      sSql = sSql & "            FOR                                     " & vbCrLf
      sSql = sSql & "SELECT MRP_PARTREF,MRP_PARTDATERQD,MRP_PARTQTYRQD, MRP_ROW FROM tempPOQtyRun " & vbCrLf
      sSql = sSql & "                  WHERE QtyFlagged IS NULL ORDER BY MRP_PARTDATERQD" & vbCrLf
      sSql = sSql & "OPEN curMrpPOCovered" & vbCrLf
      sSql = sSql & "            FETCH NEXT FROM curMrpPOCovered INTO @mrpPOPartref2, @mrpHigherReqDate, @mrpHigherReqQty, @mrpRow" & vbCrLf
      sSql = sSql & "WHILE (@@FETCH_STATUS <> -1)                            " & vbCrLf
      sSql = sSql & "            BEGIN                                                   " & vbCrLf
      sSql = sSql & "               IF (@@FETCH_STATUS <> -2)                           " & vbCrLf
      sSql = sSql & "               BEGIN" & vbCrLf
      sSql = sSql & "                  IF (@bBeginLoop = 1)" & vbCrLf
      sSql = sSql & "                  BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   print 'Part Ref2:' + @mrpPOPartref2" & vbCrLf
      sSql = sSql & "   print 'HigherReq Qty:' + Convert(varchar(24), @mrpHigherReqQty)" & vbCrLf
      sSql = sSql & "   print 'Mrp Row:'  + Convert(varchar(24), @mrpRow)" & vbCrLf
      sSql = sSql & "   print 'Inside Mrp Higher Req Date :' + convert(varchar(24), @mrpHigherReqDate, 101)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "                     UPDATE tempPOReqDate SET MRP_HGHPRTDTRQD = @mrpHigherReqDate WHERE MRP_PARTREF = @mrpPOPartref2 " & vbCrLf
      sSql = sSql & "                           AND MRP_PONUM = @mrpPONUM AND MRP_POITEM = @mrpPOITEM" & vbCrLf
      sSql = sSql & "                     SET @bBeginLoop = 0" & vbCrLf
      sSql = sSql & "                  END" & vbCrLf
      sSql = sSql & "                        " & vbCrLf
      sSql = sSql & "                  SET @mrpPOQty = @mrpPOQty - @mrpHigherReqQty" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   print 'MrpPOQty :' + convert(varchar(24), @mrpPOQty)" & vbCrLf
      sSql = sSql & "   print 'Not first Mrp Higher Req Date :' + convert(varchar(24), @mrpHigherReqDate, 101)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "                  " & vbCrLf
      sSql = sSql & "                  IF (@mrpPOQty < 0)" & vbCrLf
      sSql = sSql & "                     BREAK" & vbCrLf
      sSql = sSql & "                  " & vbCrLf
      sSql = sSql & "                  UPDATE tempPOQtyRun SET QtyFlagged = 1 WHERE MRP_ROW = @mrpRow" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "               END" & vbCrLf
      sSql = sSql & "               FETCH NEXT FROM curMrpPOCovered INTO @mrpPOPartref2, @mrpHigherReqDate, @mrpHigherReqQty, @mrpRow" & vbCrLf
      sSql = sSql & "END" & vbCrLf
      sSql = sSql & "                   " & vbCrLf
      sSql = sSql & "CLOSE curMrpPOCovered --// close the cursor                                        " & vbCrLf
      sSql = sSql & "            DEALLOCATE curMrpPOCovered" & vbCrLf
      sSql = sSql & "               " & vbCrLf
      sSql = sSql & "         END" & vbCrLf
      sSql = sSql & "               " & vbCrLf
      sSql = sSql & "         SET @bBeginLoop = 1" & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM curMrpPO INTO @mrpPOPartref1, @mrpPOQty, @mrpPONUM, @mrpPOITEM, @mrpConsumedPartDateReq" & vbCrLf
      sSql = sSql & "      END         " & vbCrLf
      sSql = sSql & "      CLOSE curMrpPO --// close the cursor                                        " & vbCrLf
      sSql = sSql & "      DEALLOCATE curMrpPO" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "      --DELETE FROM tempPOQtyRun" & vbCrLf
      sSql = sSql & "   END" & vbCrLf
      sSql = sSql & "END"
      
      ExecuteScript False, sSql
      
      If StoreProcedureExists("RptEarlyLateDatesPO") Then
         sSql = "DROP PROCEDURE RptEarlyLateDatesPO"
         ExecuteScript False, sSql
      End If
      
      sSql = "CREATE PROCEDURE [dbo].[RptEarlyLateDatesPO]  " & vbCrLf
      sSql = sSql & " @StartDate as varchar(16), @EndDate as Varchar(16) " & vbCrLf
      sSql = sSql & " AS  " & vbCrLf
      sSql = sSql & "BEGIN   " & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   declare @mrpDateRqd as datetime " & vbCrLf
      sSql = sSql & "   declare @mrpPOPartRef as varchar(30) " & vbCrLf
      sSql = sSql & "   declare @mrpPOPartref1 as varchar(30) " & vbCrLf
      sSql = sSql & "   declare @mrpPOPartref2 as varchar(30)" & vbCrLf
      sSql = sSql & "   declare @mrpPOITEM  as int " & vbCrLf
      sSql = sSql & "   declare @mrpPONUM as int " & vbCrLf
      sSql = sSql & "   declare @mrpHigherReqDate as datetime" & vbCrLf
      sSql = sSql & "   declare @mrpHigherReqQty as decimal(15, 2)" & vbCrLf
      sSql = sSql & "   declare @mrpRow as int" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   declare @bBeginLoop as int" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   declare @mrpPOQty as decimal(15,2) " & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "    " & vbCrLf
      sSql = sSql & "   delete from tempPOReqDate" & vbCrLf
      sSql = sSql & "   delete from tempPOQtyRun" & vbCrLf
      sSql = sSql & "   delete from tempMrpType2s      " & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   INSERT INTO tempPOReqDate (MRP_PARTREF, MRP_PARTNUM, MRP_TYPE, MRP_PONUM, MRP_POITEM,MRP_PARTLEVEL,  " & vbCrLf
      sSql = sSql & "MRP_PARTDATERQD,MRP_PARTQTYRQD,MRP_CATAGORY,MRP_COMMENT)  " & vbCrLf
      sSql = sSql & "      SELECT MRP_PARTREF, MRP_PARTNUM, MRP_TYPE, MRP_PONUM, MRP_POITEM,MRP_PARTLEVEL,  " & vbCrLf
      sSql = sSql & "         MRP_PARTDATERQD,MRP_PARTQTYRQD,MRP_CATAGORY,MRP_COMMENT " & vbCrLf
      sSql = sSql & "      FROM  MrplTable WHERE mrp_type = 2 --AND MRP_PARTREF = 'BACC30BH6K'" & vbCrLf
      sSql = sSql & "         and MRP_PARTDATERQD BETWEEN @StartDate AND  @EndDate" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   INSERT INTO tempMrpType2s (MRP_PARTREF, MRP_PARTQTYRQD, MRP_PONUM, MRP_POITEM)" & vbCrLf
      sSql = sSql & "      SELECT DISTINCT MRP_PARTREF, MRP_PARTQTYRQD, MRP_PONUM, MRP_POITEM FROM tempPOReqDate" & vbCrLf
      sSql = sSql & "WHERE mrp_type = 2" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   DECLARE curMrptype2 CURSOR               " & vbCrLf
      sSql = sSql & "   LOCAL                               " & vbCrLf
      sSql = sSql & "   Scroll                              " & vbCrLf
      sSql = sSql & "   FOR                                     " & vbCrLf
      sSql = sSql & "      SELECT DISTINCT MRP_PARTREF FROM tempPOReqDate WHERE mrp_type = 2 AND MRP_PARTDATERQD BETWEEN @StartDate AND  @EndDate" & vbCrLf
      sSql = sSql & "--AND MRP_PARTREF = 'BACB30NM3K7'--'BACC30BH6K'" & vbCrLf
      sSql = sSql & "   OPEN curMrptype2" & vbCrLf
      sSql = sSql & "   FETCH NEXT FROM curMrptype2 INTO @mrpPOPartRef" & vbCrLf
      sSql = sSql & "   WHILE (@@FETCH_STATUS <> -1)                            " & vbCrLf
      sSql = sSql & "   BEGIN                                                   " & vbCrLf
      sSql = sSql & "      IF (@@FETCH_STATUS <> -2)                           " & vbCrLf
      sSql = sSql & "      BEGIN                     " & vbCrLf
      sSql = sSql & "         EXEC [UpdatePOMrpUsed] @mrpPOPartRef" & vbCrLf
      sSql = sSql & "      END" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM curMrptype2 INTO @mrpPOPartRef" & vbCrLf
      sSql = sSql & "   END" & vbCrLf
      sSql = sSql & "   CLOSE curMrptype2 --// close the cursor                                        " & vbCrLf
      sSql = sSql & "   DEALLOCATE curMrptype2" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   UPDATE tempPOReqDate SET EARLYLATE_DAYS = DATEDIFF(day, MRP_PARTDATERQD, MRP_HGHPRTDTRQD)" & vbCrLf
      sSql = sSql & "      WHERE MRP_HGHPRTDTRQD IS NOT NULL" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   SELECT MRP_PARTREF,MRP_PARTNUM, MRP_TYPE, MRP_PONUM, MRP_POITEM, MRP_PARTLEVEL, MRP_HGHPRTDTRQD, " & vbCrLf
      sSql = sSql & "      MRP_PARTDATERQD, MRP_PARTQTYRQD, MRP_CATAGORY, MRP_COMMENT, EARLYLATE_DAYS" & vbCrLf
      sSql = sSql & "    FROM tempPOReqDate " & vbCrLf
      sSql = sSql & "END"

      ExecuteScript False, sSql

      If StoreProcedureExists("UpdateMOPickMrpUsed") Then
         sSql = "DROP PROCEDURE UpdateMOPickMrpUsed"
         ExecuteScript False, sSql
      End If

      sSql = "CREATE PROCEDURE [dbo].[UpdateMOPickMrpUsed]  " & vbCrLf
      sSql = sSql & "  @mrpMORef as varchar(30) " & vbCrLf
      sSql = sSql & "AS  " & vbCrLf
      sSql = sSql & "BEGIN   " & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   declare @mrpMOPickDt as datetime " & vbCrLf
      sSql = sSql & "   declare @mrpDateRqd as datetime " & vbCrLf
      sSql = sSql & "   declare @mrpComment as varchar(80) " & vbCrLf
      sSql = sSql & "   declare @mrpCat as varchar(24) " & vbCrLf
      sSql = sSql & "   declare @mrpType as int " & vbCrLf
      sSql = sSql & "   declare @mrpMORun as int " & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   declare @QtyOnHand as decimal(15, 2)" & vbCrLf
      sSql = sSql & "   declare @mrpPartDateReq as datetime" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   declare @mrpRunningQty as decimal (15, 2)" & vbCrLf
      sSql = sSql & "   declare @mrpStockQtyReq as decimal (15, 2)" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   declare @mrpRow as int" & vbCrLf
      sSql = sSql & "   declare @bFirst as int" & vbCrLf
      sSql = sSql & "   declare @BeginStockQty as decimal (15, 2)" & vbCrLf
      sSql = sSql & "   declare @mrpMOQty as decimal (15, 2)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   delete from tempQtyRun" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "print 'MO Partref :' + @mrpMORef" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   --// set the required part" & vbCrLf
      sSql = sSql & "   INSERT INTO tempQtyRun (MRP_PARTREF,MRP_PARTDATERQD,MRP_PARTQTYRQD, MRP_PARTRUNNINGQTY, MRP_ROW, QtyFlagged)" & vbCrLf
      sSql = sSql & "   SELECT MrplTable.MRP_PARTREF, MrplTable.MRP_PARTDATERQD, MrplTable.MRP_PARTQTYRQD * -1, " & vbCrLf
      sSql = sSql & "         MrplTable.MRP_PARTQTYRQD * -1 , MRP_ROW, 0" & vbCrLf
      sSql = sSql & "   FROM MrplTable" & vbCrLf
      sSql = sSql & "   WHERE" & vbCrLf
      sSql = sSql & "      MRP_PARTREF = @mrpMORef AND --(''BACB30NM3K7',','024116','BACC30BH6K','SHA2024L00.100X36.000X144.00','204574394')" & vbCrLf
      sSql = sSql & "      MrplTable.MRP_TYPE IN (14, 13, 12,11)" & vbCrLf
      sSql = sSql & "      " & vbCrLf
      sSql = sSql & "   --// get the QOH from the begining balance" & vbCrLf
      sSql = sSql & "   SELECT @BeginStockQty = ISNULL(SUM(MRP_PARTQTYRQD), 0) FROM MrplTable " & vbCrLf
      sSql = sSql & "         WHERE MrplTable.MRP_PARTREF = @mrpMORef and mrp_type = 1" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   IF (@@ROWCOUNT = 0)" & vbCrLf
      sSql = sSql & "      SET @BeginStockQty = 0" & vbCrLf
      sSql = sSql & "      " & vbCrLf
      sSql = sSql & "print 'MO Partref Begin Balance:' + Convert(varchar(10), @BeginStockQty)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   --// take care of the begining balance " & vbCrLf
      sSql = sSql & "   DECLARE curMrpBeginQty CURSOR               " & vbCrLf
      sSql = sSql & "   LOCAL                               " & vbCrLf
      sSql = sSql & "   Scroll                              " & vbCrLf
      sSql = sSql & "   FOR                                     " & vbCrLf
      sSql = sSql & "      SELECT MRP_PARTDATERQD, MRP_PARTRUNNINGQTY, MRP_ROW" & vbCrLf
      sSql = sSql & "      FROM tempQtyRun" & vbCrLf
      sSql = sSql & "      WHERE MRP_PARTRUNNINGQTY > 0" & vbCrLf
      sSql = sSql & "         ORDER BY MRP_PARTDATERQD" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   OPEN curMrpBeginQty " & vbCrLf
      sSql = sSql & "   FETCH NEXT FROM curMrpBeginQty  INTO @mrpPartDateReq, @mrpStockQtyReq, @mrpRow" & vbCrLf
      sSql = sSql & "   WHILE (@@FETCH_STATUS <> -1)                            " & vbCrLf
      sSql = sSql & "   BEGIN                                                   " & vbCrLf
      sSql = sSql & "      IF (@@FETCH_STATUS <> -2)                           " & vbCrLf
      sSql = sSql & "      BEGIN" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "print 'IN loop RowNum:' + Convert(varchar(10), @mrpRow)" & vbCrLf
      sSql = sSql & "print 'IN loop Date:' + Convert(varchar(10), @mrpPartDateReq, 101)" & vbCrLf
      sSql = sSql & "print 'IN loop StockQty:' + Convert(varchar(10), @mrpStockQtyReq)" & vbCrLf
      sSql = sSql & "         " & vbCrLf
      sSql = sSql & "         IF (@mrpStockQtyReq >= @BeginStockQty)" & vbCrLf
      sSql = sSql & "         BEGIN" & vbCrLf
      sSql = sSql & "SET @mrpStockQtyReq = @mrpStockQtyReq - @BeginStockQty" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "print 'Updating Begin Stock:' + Convert(varchar(10), @mrpStockQtyReq)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "UPDATE tempQtyRun SET MRP_PARTRUNNINGQTY = MRP_PARTRUNNINGQTY - @BeginStockQty" & vbCrLf
      sSql = sSql & "               WHERE MRP_ROW = @mrpRow" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "            SET @BeginStockQty = 0" & vbCrLf
      sSql = sSql & "         END" & vbCrLf
      sSql = sSql & "         ELSE" & vbCrLf
      sSql = sSql & "         BEGIN" & vbCrLf
      sSql = sSql & "SET @BeginStockQty = @BeginStockQty - @mrpStockQtyReq" & vbCrLf
      sSql = sSql & "            " & vbCrLf
      sSql = sSql & "UPDATE tempQtyRun SET MRP_PARTRUNNINGQTY = 0, QtyFlagged = 1" & vbCrLf
      sSql = sSql & "               WHERE MRP_PARTDATERQD = @mrpPartDateReq AND MRP_ROW = @mrpRow" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "         END" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "         IF (@BeginStockQty = 0.0)" & vbCrLf
      sSql = sSql & "BREAK" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "      END" & vbCrLf
      sSql = sSql & "   FETCH NEXT FROM curMrpBeginQty  INTO @mrpPartDateReq, @mrpStockQtyReq, @mrpRow" & vbCrLf
      sSql = sSql & "   END         " & vbCrLf
      sSql = sSql & "   CLOSE curMrpBeginQty --// close the cursor                                        " & vbCrLf
      sSql = sSql & "   DEALLOCATE curMrpBeginQty" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   DECLARE curMO CURSOR               " & vbCrLf
      sSql = sSql & "   LOCAL                               " & vbCrLf
      sSql = sSql & "   Scroll                              " & vbCrLf
      sSql = sSql & "   FOR                                     " & vbCrLf
      sSql = sSql & "     SELECT MrplTable.MRP_PARTDATERQD, MrplTable.MRP_MOREF, MrplTable.MRP_MORUNNO, MRP_PARTQTYRQD" & vbCrLf
      sSql = sSql & "     FROM MrplTable, tempRunReqDate  WHERE MrplTable.MRP_TYPE IN (4,3) " & vbCrLf
      sSql = sSql & "       AND Mrp_MOREF = Runref and MRP_MORUNNO = RUNNO AND tempRunReqDate.MRP_PARTDATERQD IS NULL" & vbCrLf
      sSql = sSql & "       AND mrp_partref = @mrpMORef" & vbCrLf
      sSql = sSql & "      ORDER BY MrplTable.MRP_MOREF, MrplTable.MRP_PARTDATERQD, MrplTable.MRP_MORUNNO" & vbCrLf
      sSql = sSql & "   OPEN curMO" & vbCrLf
      sSql = sSql & "   FETCH NEXT FROM curMO INTO @mrpMOPickDt, @mrpMORef, @mrpMORun, @mrpMOQty" & vbCrLf
      sSql = sSql & "   WHILE (@@FETCH_STATUS <> -1)                            " & vbCrLf
      sSql = sSql & "   BEGIN                                                   " & vbCrLf
      sSql = sSql & "   IF (@@FETCH_STATUS <> -2)                           " & vbCrLf
      sSql = sSql & "   BEGIN                                               " & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "print 'MO Ref :' + @mrpMORef" & vbCrLf
      sSql = sSql & "print 'MO Run#:' + Convert(varchar(10), @mrpMORun)" & vbCrLf
      sSql = sSql & "      SET @bFirst = 1" & vbCrLf
      sSql = sSql & "print 'First Time:' + Convert(varchar(10), @bFirst)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "      DECLARE curMOPickQty CURSOR               " & vbCrLf
      sSql = sSql & "      LOCAL                               " & vbCrLf
      sSql = sSql & "      Scroll                              " & vbCrLf
      sSql = sSql & "      FOR                                     " & vbCrLf
      sSql = sSql & "         SELECT MRP_PARTDATERQD, MRP_PARTRUNNINGQTY, MRP_ROW" & vbCrLf
      sSql = sSql & "         FROM tempQtyRun" & vbCrLf
      sSql = sSql & "         WHERE MRP_PARTRUNNINGQTY > 0" & vbCrLf
      sSql = sSql & "ORDER BY MRP_PARTDATERQD" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "      OPEN curMOPickQty " & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM curMOPickQty INTO @mrpPartDateReq, @mrpRunningQty, @mrpRow" & vbCrLf
      sSql = sSql & "      WHILE (@@FETCH_STATUS <> -1)                            " & vbCrLf
      sSql = sSql & "      BEGIN                                                   " & vbCrLf
      sSql = sSql & "         IF (@@FETCH_STATUS <> -2)                           " & vbCrLf
      sSql = sSql & "         BEGIN" & vbCrLf
      sSql = sSql & "         " & vbCrLf
      sSql = sSql & "print 'Inside tempQtyRun:' + Convert(varchar(24), @mrpRow)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "print 'MO picks Qty :' + Convert(varchar(24), @mrpRunningQty)" & vbCrLf
      sSql = sSql & "print 'MO Pick Date:' + Convert(varchar(10), @mrpPartDateReq, 101)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "print 'MO Qty:' + Convert(varchar(10), @mrpMOQty)" & vbCrLf
      sSql = sSql & "print 'MO Pick Qty:' + Convert(varchar(10), @mrpRunningQty)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "IF(@bFirst = 1)" & vbCrLf
      sSql = sSql & "            BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "               SELECT TOP (1) @mrpComment = MRP_COMMENT, @mrpDateRqd = MRP_PARTDATERQD," & vbCrLf
      sSql = sSql & "                     @mrpCat = MRP_CATAGORY, @mrpType = MRP_TYPE" & vbCrLf
      sSql = sSql & "               FROM MrplTable " & vbCrLf
      sSql = sSql & "               WHERE mrp_partref = @mrpMORef" & vbCrLf
      sSql = sSql & "                   AND MRP_PartDateRQD = @mrpPartDateReq AND MRP_ROW = @mrpRow" & vbCrLf
      sSql = sSql & "                   order by MRP_PartDateRQD" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "               UPDATE a set a.MRP_TYPE = @mrpType, a.MRP_CATAGORY = @mrpCat, " & vbCrLf
      sSql = sSql & "                   a.MRP_PARTDATERQD = @mrpPartDateReq,a.MRP_COMMENT = @mrpComment" & vbCrLf
      sSql = sSql & "               FROM tempRunReqDate a" & vbCrLf
      sSql = sSql & "               WHERE a.runref = @mrpMORef AND a.runno = @mrpMORun    " & vbCrLf
      sSql = sSql & "               " & vbCrLf
      sSql = sSql & "               SET @bFirst = 0" & vbCrLf
      sSql = sSql & "END" & vbCrLf
      sSql = sSql & "            " & vbCrLf
      sSql = sSql & "IF (@mrpMOQty >= @mrpRunningQty)" & vbCrLf
      sSql = sSql & "            BEGIN" & vbCrLf
      sSql = sSql & "               SET @mrpMOQty = @mrpMOQty - @mrpRunningQty" & vbCrLf
      sSql = sSql & "               " & vbCrLf
      sSql = sSql & "               UPDATE tempQtyRun SET MRP_PARTRUNNINGQTY = 0, QtyFlagged = 1" & vbCrLf
      sSql = sSql & "                  WHERE MRP_PARTDATERQD = @mrpPartDateReq AND MRP_ROW = @mrpRow" & vbCrLf
      sSql = sSql & "               " & vbCrLf
      sSql = sSql & "END" & vbCrLf
      sSql = sSql & "            ELSE" & vbCrLf
      sSql = sSql & "BEGIN" & vbCrLf
      sSql = sSql & "               SET @mrpRunningQty = @mrpRunningQty - @mrpMOQty" & vbCrLf
      sSql = sSql & "               " & vbCrLf
      sSql = sSql & "               UPDATE tempQtyRun SET MRP_PARTRUNNINGQTY = MRP_PARTRUNNINGQTY - @mrpMOQty" & vbCrLf
      sSql = sSql & "                  WHERE MRP_PARTDATERQD = @mrpPartDateReq AND MRP_ROW = @mrpRow" & vbCrLf
      sSql = sSql & "               SET @mrpMOQty = 0 " & vbCrLf
      sSql = sSql & "END" & vbCrLf
      sSql = sSql & "            " & vbCrLf
      sSql = sSql & "IF (@mrpMOQty = 0)" & vbCrLf
      sSql = sSql & "               BREAK" & vbCrLf
      sSql = sSql & "         " & vbCrLf
      sSql = sSql & "         END" & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM curMOPickQty INTO @mrpPartDateReq, @mrpRunningQty, @mrpRow" & vbCrLf
      sSql = sSql & "      END         " & vbCrLf
      sSql = sSql & "      CLOSE curMOPickQty --// close the cursor                                        " & vbCrLf
      sSql = sSql & "      DEALLOCATE curMOPickQty" & vbCrLf
      sSql = sSql & "      " & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "      SET @mrpComment = NULL" & vbCrLf
      sSql = sSql & "      SET @mrpDateRqd = NULL" & vbCrLf
      sSql = sSql & "      SET @mrpCat = NULL" & vbCrLf
      sSql = sSql & "      SET @mrpType = NULL" & vbCrLf
      sSql = sSql & "      " & vbCrLf
      sSql = sSql & "      End                                                                     " & vbCrLf
      sSql = sSql & "   FETCH NEXT FROM curMO INTO @mrpMOPickDt, @mrpMORef, @mrpMORun, @mrpMOQty" & vbCrLf
      sSql = sSql & "   End                                                                         " & vbCrLf
      sSql = sSql & "   CLOSE curMO --// close the cursor                                        " & vbCrLf
      sSql = sSql & "   DEALLOCATE curMO" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   --Drop table #tempRunReqDate" & vbCrLf
      sSql = sSql & "END"

      ExecuteScript False, sSql

      If StoreProcedureExists("RptEarlyLateDates") Then
         sSql = "DROP PROCEDURE RptEarlyLateDates"
         ExecuteScript False, sSql
      End If

      sSql = "CREATE PROCEDURE [dbo].[RptEarlyLateDates]  " & vbCrLf
      sSql = sSql & " @StartDate as varchar(16), @EndDate as Varchar(16), " & vbCrLf
      sSql = sSql & " @PartType1 as Integer, @PartType2 as Integer, @PartType3 as Integer, " & vbCrLf
      sSql = sSql & " @PartType4 as Integer " & vbCrLf
      sSql = sSql & "AS  " & vbCrLf
      sSql = sSql & "BEGIN   " & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   declare @mrpMORef as varchar(30) " & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   IF (@PartType1 = 1)     " & vbCrLf
      sSql = sSql & "      SET @PartType1 = 1    " & vbCrLf
      sSql = sSql & "   Else                    " & vbCrLf
      sSql = sSql & "      SET @PartType1 = 0    " & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   IF (@PartType2 = 1)     " & vbCrLf
      sSql = sSql & "      SET @PartType2 = 2    " & vbCrLf
      sSql = sSql & "   Else                    " & vbCrLf
      sSql = sSql & "      SET @PartType2 = 0    " & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   IF (@PartType3 = 1)    " & vbCrLf
      sSql = sSql & "      SET @PartType3 = 3 " & vbCrLf
      sSql = sSql & "   Else                   " & vbCrLf
      sSql = sSql & "      SET @PartType3 = 0 " & vbCrLf
      sSql = sSql & "                          " & vbCrLf
      sSql = sSql & "    " & vbCrLf
      sSql = sSql & "   delete from tempRunReqDate" & vbCrLf
      sSql = sSql & "   delete from tempQtyRun" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   INSERT INTO tempRunReqDate (RUNREF, RUNNO, RUNSTATUS, RUNSCHED, RUNCOMPLETE,RUNQTY,  " & vbCrLf
      sSql = sSql & "                           RUNCOST)  " & vbCrLf
      sSql = sSql & "      SELECT RunsTable.RUNREF, RunsTable.RUNNO, RunsTable.RUNSTATUS, RunsTable.RUNSCHED, " & vbCrLf
      sSql = sSql & "        RunsTable.RUNCOMPLETE,RunsTable.RUNQTY, RunsTable.RUNCOST " & vbCrLf
      sSql = sSql & "      FROM RunsTable, PartTable where RunsTable.RUNREF = PartTable.PARTREF AND RUNSTATUS NOT IN ('CL', 'CA', 'CO')" & vbCrLf
      sSql = sSql & "      --AND RUNREF IN( '116U6270996') --,'113T196038'" & vbCrLf
      sSql = sSql & "          --AND RunsTable.RUNSCHED between @StartDate and @EndDate " & vbCrLf
      sSql = sSql & "           AND PALEVEL IN (@PartType1, @PartType2, @PartType3)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   --// take care of the begining balance " & vbCrLf
      sSql = sSql & "   DECLARE curMOs CURSOR               " & vbCrLf
      sSql = sSql & "   LOCAL                               " & vbCrLf
      sSql = sSql & "   Scroll                              " & vbCrLf
      sSql = sSql & "   FOR                                     " & vbCrLf
      sSql = sSql & "      SELECT DISTINCT RUNREF" & vbCrLf
      sSql = sSql & "      FROM tempRunReqDate" & vbCrLf
      sSql = sSql & "      WHERE RUNQTY > 0" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   OPEN curMOs " & vbCrLf
      sSql = sSql & "   FETCH NEXT FROM curMOs  INTO @mrpMORef" & vbCrLf
      sSql = sSql & "   WHILE (@@FETCH_STATUS <> -1)                            " & vbCrLf
      sSql = sSql & "   BEGIN                                                   " & vbCrLf
      sSql = sSql & "      IF (@@FETCH_STATUS <> -2)                           " & vbCrLf
      sSql = sSql & "      BEGIN" & vbCrLf
      sSql = sSql & "      " & vbCrLf
      sSql = sSql & "         EXEC [UpdateMOPickMrpUsed] @mrpMORef" & vbCrLf
      sSql = sSql & "      END" & vbCrLf
      sSql = sSql & "   FETCH NEXT FROM curMOs  INTO @mrpMORef" & vbCrLf
      sSql = sSql & "   END         " & vbCrLf
      sSql = sSql & "   CLOSE curMOs --// close the cursor                                        " & vbCrLf
      sSql = sSql & "   DEALLOCATE curMOs" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   UPDATE tempRunReqDate SET EARLYLATE_DAYS = DATEDIFF(day, RUNSCHED, MRP_PARTDATERQD)" & vbCrLf
      sSql = sSql & "      WHERE MRP_PARTDATERQD IS NOT NULL" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   SELECT RUNREF, RUNNO, RUNSTATUS, RUNSCHED, RUNCOMPLETE,EARLYLATE_DAYS, RUNQTY,  " & vbCrLf
      sSql = sSql & "      RUNCOST, MRP_TYPE, MRP_CATAGORY, MRP_PARTDATERQD, MRP_COMMENT,PartTable.PARTNUM, " & vbCrLf
      sSql = sSql & "     PartTable.PADESC, PartTable.PAEXTDESC, PartTable.PALEVEL,PartTable.PAPRODCODE, " & vbCrLf
      sSql = sSql & "      PartTable.PACLASS, PartTable.PASTDCOST, PartTable.PAMAKEBUY" & vbCrLf
      sSql = sSql & "    FROM tempRunReqDate, PartTable WHERE RUNREF = PartRef" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   --Drop table #tempRunReqDate" & vbCrLf
      sSql = sSql & "  " & vbCrLf
      sSql = sSql & "END"

      ExecuteScript False, sSql

      If StoreProcedureExists("RptMRPMOQtyShortage") Then
         sSql = "DROP PROCEDURE RptMRPMOQtyShortage"
         ExecuteScript False, sSql
      End If

      sSql = "CREATE PROCEDURE [dbo].[RptMRPMOQtyShortage]" & vbCrLf
      sSql = sSql & "      @InMOPart as varchar(30), @StartDate as datetime, @EndDate as datetime" & vbCrLf
      sSql = sSql & "AS " & vbCrLf
      sSql = sSql & "BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   declare @ChildKey as varchar(1024)" & vbCrLf
      sSql = sSql & "   declare @GLSortKey as varchar(1024)" & vbCrLf
      sSql = sSql & "   declare @SortKey as varchar(1024)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   declare @MOPart as varchar(30)" & vbCrLf
      sSql = sSql & "   declare @MORun as Integer" & vbCrLf
      sSql = sSql & "   declare @MOQtyRqd as decimal(12,4)" & vbCrLf
      sSql = sSql & "   declare @MOPartRqDt as datetime " & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   declare @Part as varchar(30)" & vbCrLf
      sSql = sSql & "   declare @PAQOH as decimal(12,4)" & vbCrLf
      sSql = sSql & "   declare @RunTot as decimal(12,4)" & vbCrLf
      sSql = sSql & "   declare @AssyPart as varchar(30)" & vbCrLf
      sSql = sSql & "   declare @BMQtyReq as decimal(12,4)" & vbCrLf
      sSql = sSql & "   declare @RunQtyReq as decimal (12, 4)" & vbCrLf
      sSql = sSql & "   declare @PartDateQrd as datetime" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   --DROP TABLE #tempMOPartsDetail " & vbCrLf
      sSql = sSql & "   DELETE FROM tempMrplPartShort" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "  BEGIN" & vbCrLf
      sSql = sSql & "   IF (@InMOPart = '')" & vbCrLf
      sSql = sSql & "      SET @InMOPart = @InMOPart + '%'" & vbCrLf
      sSql = sSql & "  " & vbCrLf
      sSql = sSql & "  DECLARE curMrpExp CURSOR  FOR" & vbCrLf
      sSql = sSql & "   SELECT MRP_PARTREF,0 as RUNNO, MRP_PARTQTYRQD, MRP_ACTIONDATE" & vbCrLf
      sSql = sSql & "   FROM MrplTable, PartTable   " & vbCrLf
      sSql = sSql & "   WHERE MRP_PARTREF = PartRef   " & vbCrLf
      sSql = sSql & "      AND MrplTable.MRP_PARTREF LIKE @InMOPart" & vbCrLf
      sSql = sSql & "      AND MrplTable.MRP_PARTPRODCODE LIKE '%'  " & vbCrLf
      sSql = sSql & "      AND MrplTable.MRP_PARTCLASS LIKE '%'  " & vbCrLf
      sSql = sSql & "      AND MrplTable.MRP_POBUYER LIKE '%'  " & vbCrLf
      sSql = sSql & "      AND MrplTable.MRP_PARTDATERQD BETWEEN @StartDate AND @EndDate" & vbCrLf
      sSql = sSql & "      AND MrplTable.MRP_TYPE IN (6, 5)   " & vbCrLf
      sSql = sSql & "      AND PartTable.PAMAKEBUY ='M'" & vbCrLf
      sSql = sSql & "   UNION" & vbCrLf
      sSql = sSql & "      SELECT DISTINCT RUNREF, RUNNO, RUNQTY,RUNSCHED  as MRP_ACTIONDATE FROM RunsTable WHERE " & vbCrLf
      sSql = sSql & "         RUNREF LIKE @InMOPart AND RUNSTATUS = 'SC'" & vbCrLf
      sSql = sSql & "         AND RUNPKSTART BETWEEN @StartDate  AND @EndDate order by MRP_ACTIONDATE" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "  OPEN curMrpExp" & vbCrLf
      sSql = sSql & "  FETCH NEXT FROM curMrpExp INTO @MOPart, @MORun, @MOQtyRqd, @MOPartRqDt" & vbCrLf
      sSql = sSql & "  WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "  BEGIN" & vbCrLf
      sSql = sSql & "     IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "     BEGIN" & vbCrLf
      sSql = sSql & "      with cte" & vbCrLf
      sSql = sSql & "      as (select BMASSYPART,BMPARTREF,BMPARTREV, BMQTYREQD , RTrim(BMUNITS) BMUNITS, " & vbCrLf
      sSql = sSql & "            BMCONVERSION, BMSEQUENCE, 0 as level," & vbCrLf
      sSql = sSql & "            cast(LTRIM(RTrim(BMASSYPART)) + char(36)+ COALESCE(cast(BMSEQUENCE as varchar(4)), '') + LTRIM(RTrim(BMPARTREF)) as varchar(max)) as SortKey" & vbCrLf
      sSql = sSql & "         from BmplTable" & vbCrLf
      sSql = sSql & "         where BMASSYPART = @MOPart" & vbCrLf
      sSql = sSql & "         union all" & vbCrLf
      sSql = sSql & "         select a.BMASSYPART,a.BMPARTREF,a.BMPARTREV, a.BMQTYREQD , RTrim(a.BMUNITS) BMUNITS, " & vbCrLf
      sSql = sSql & "            a.BMCONVERSION, a.BMSEQUENCE, level + 1," & vbCrLf
      sSql = sSql & "            cast(COALESCE(SortKey,'') + char(36) + COALESCE(cast(a.BMSEQUENCE as varchar(4)), '') + COALESCE(LTRIM(RTrim(a.BMPARTREF)) ,'') as varchar(max))as SortKey" & vbCrLf
      sSql = sSql & "         from cte" & vbCrLf
      sSql = sSql & "            inner join BmplTable a" & vbCrLf
      sSql = sSql & "on cte.BMPARTREF = a.BMASSYPART" & vbCrLf
      sSql = sSql & "     ) " & vbCrLf
      sSql = sSql & "     INSERT INTO tempMrplPartShort(BMASSYPART,BMPARTREF,BMQTYREQD," & vbCrLf
      sSql = sSql & "      SORTKEYLEVEL,BMSEQUENCE, SortKey, PAQOH, RUNNO,MRP_PARTQTYRQD, MRP_ACTIONDATE)" & vbCrLf
      sSql = sSql & "     select BMASSYPART, BMPARTREF,BMQTYREQD,level,BMSEQUENCE, SortKey, PAQOH, @MORun, @MOQtyRqd, @MOPartRqDt" & vbCrLf
      sSql = sSql & "       from cte, PartTable WHERE PARTREF = BMPARTREF  AND BMPARTREF <> 'NULL' order by SortKey,BMSEQUENCE" & vbCrLf
      sSql = sSql & "        " & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "   FETCH NEXT FROM curMrpExp INTO @MOPart, @MORun, @MOQtyRqd, @MOPartRqDt" & vbCrLf
      sSql = sSql & "  End" & vbCrLf
      sSql = sSql & "  Close curMrpExp" & vbCrLf
      sSql = sSql & "  DEALLOCATE curMrpExp" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "  DECLARE curRunTot CURSOR  FOR" & vbCrLf
      sSql = sSql & "  select DISTINCT BMPARTREF, PAQOH from tempMrplPartShort order by BMPARTREF" & vbCrLf
      sSql = sSql & "  OPEN curRunTot" & vbCrLf
      sSql = sSql & "  FETCH NEXT FROM curRunTot INTO @Part, @PAQOH" & vbCrLf
      sSql = sSql & "  WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "  BEGIN" & vbCrLf
      sSql = sSql & "     IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "     BEGIN" & vbCrLf
      sSql = sSql & "        SET @RunTot = 0.0000" & vbCrLf
      sSql = sSql & "        SET @RunTot = @PAQOH" & vbCrLf
      sSql = sSql & "        DECLARE curRunTot1 CURSOR  FOR" & vbCrLf
      sSql = sSql & "         select DISTINCT BMASSYPART, BMQTYREQD, MRP_PARTQTYRQD, MRP_ACTIONDATE from tempMrplPartShort " & vbCrLf
      sSql = sSql & "            WHERE BMPARTREF = @Part" & vbCrLf
      sSql = sSql & "         order by MRP_ACTIONDATE  -- BMASSYPART, " & vbCrLf
      sSql = sSql & "        OPEN curRunTot1" & vbCrLf
      sSql = sSql & "        FETCH NEXT FROM curRunTot1 INTO @AssyPart, @BMQtyReq, @RunQtyReq, @PartDateQrd" & vbCrLf
      sSql = sSql & "        WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "        BEGIN" & vbCrLf
      sSql = sSql & "          IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "          BEGIN" & vbCrLf
      sSql = sSql & "            --Set @RunTot = ROUND(@RunTot,4)" & vbCrLf
      sSql = sSql & "            Set @RunTot = @RunTot -  ( @BMQtyReq * @RunQtyReq)" & vbCrLf
      sSql = sSql & "            UPDATE tempMrplPartShort SET PAQRUNTOT = @RunTot WHERE " & vbCrLf
      sSql = sSql & "BMASSYPART = @AssyPart AND BMPARTREF = @Part AND MRP_ACTIONDATE = @PartDateQrd" & vbCrLf
      sSql = sSql & "          END" & vbCrLf
      sSql = sSql & "          FETCH NEXT FROM curRunTot1 INTO @AssyPart, @BMQtyReq, @RunQtyReq,@PartDateQrd" & vbCrLf
      sSql = sSql & "        End" & vbCrLf
      sSql = sSql & "        Close curRunTot1" & vbCrLf
      sSql = sSql & "        DEALLOCATE curRunTot1" & vbCrLf
      sSql = sSql & "     END" & vbCrLf
      sSql = sSql & "     FETCH NEXT FROM curRunTot INTO @Part, @PAQOH" & vbCrLf
      sSql = sSql & "  End" & vbCrLf
      sSql = sSql & "  Close curRunTot" & vbCrLf
      sSql = sSql & "  DEALLOCATE curRunTot" & vbCrLf
      sSql = sSql & " END" & vbCrLf
      sSql = sSql & "END" & vbCrLf
      
      ExecuteScript False, sSql
      
      If StoreProcedureExists("YearEndGLPost") Then
         sSql = "DROP PROCEDURE YearEndGLPost"
         ExecuteScript False, sSql
      End If
      
      sSql = "CREATE PROCEDURE [dbo].[YearEndGLPost]" & vbCrLf
      sSql = sSql & "    @StartDate as Varchar(16), @EndDate as varchar(16)," & vbCrLf
      sSql = sSql & "    @StartAcc as Varchar(16), @EndAcc as varchar(16)," & vbCrLf
      sSql = sSql & "   @IncludeInActiveAcc as varchar(2)" & vbCrLf
      sSql = sSql & "AS                              " & vbCrLf
      sSql = sSql & "  BEGIN " & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   SET NOCOUNT ON" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   declare @InvAcct as varchar(2)" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   if (@IncludeInActiveAcc = '1')" & vbCrLf
      sSql = sSql & "      SET @InvAcct = ''" & vbCrLf
      sSql = sSql & "   Else" & vbCrLf
      sSql = sSql & "      SET @InvAcct = '0'" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   CREATE TABLE #tempGLACCTREF" & vbCrLf
      sSql = sSql & "   (                       " & vbCrLf
      sSql = sSql & "      tGLACCTREF varchar(12) NULL " & vbCrLf
      sSql = sSql & "   );" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   With cte as (select GLACCTREF" & vbCrLf
      sSql = sSql & "    From GlacTable where GLMASTER IN" & vbCrLf
      sSql = sSql & "              (SELECT COINCMACCT FROM GlmsTable" & vbCrLf
      sSql = sSql & "               Union All" & vbCrLf
      sSql = sSql & "               SELECT COCOGSACCT FROM GlmsTable" & vbCrLf
      sSql = sSql & "               Union All" & vbCrLf
      sSql = sSql & "               SELECT COEXPNACCT FROM GlmsTable" & vbCrLf
      sSql = sSql & "               Union All" & vbCrLf
      sSql = sSql & "               SELECT COOINCACCT FROM GlmsTable" & vbCrLf
      sSql = sSql & "               Union All" & vbCrLf
      sSql = sSql & "               SELECT COOEXPACCT FROM GlmsTable" & vbCrLf
      sSql = sSql & "               Union All" & vbCrLf
      sSql = sSql & "               SELECT COFDTXACCT FROM GlmsTable) AND GLINACTIVE LIKE @InvAcct" & vbCrLf
      sSql = sSql & "    Union All select a.GLACCTREF" & vbCrLf
      sSql = sSql & "    From cte inner join GlacTable a" & vbCrLf
      sSql = sSql & "         on cte.GLACCTREF = a.GLMASTER" & vbCrLf
      sSql = sSql & "      WHERE GLINACTIVE LIKE @InvAcct" & vbCrLf
      sSql = sSql & "    ) " & vbCrLf
      sSql = sSql & "    INSERT INTO #tempGLACCTREF (tGLACCTREF)" & vbCrLf
      sSql = sSql & "    select GLACCTREF from cte " & vbCrLf
      sSql = sSql & "    " & vbCrLf
      sSql = sSql & "      " & vbCrLf
      sSql = sSql & "   --DELETE FROM tempGLPost1" & vbCrLf
      sSql = sSql & "   CREATE TABLE #tempGLPost1" & vbCrLf
      sSql = sSql & "   (                       " & vbCrLf
      sSql = sSql & "      tGLDESCR varchar(40) NULL ," & vbCrLf
      sSql = sSql & "      tGJPOST varchar(16) NULL ," & vbCrLf
      sSql = sSql & "      tJINAME varchar(12) NULL ," & vbCrLf
      sSql = sSql & "      tJIACCOUNT varchar(12) NULL ," & vbCrLf
      sSql = sSql & "      tAcc_StartBal decimal (13,2) NULL," & vbCrLf
      sSql = sSql & "      tJIDEB decimal(13,2) NULL ," & vbCrLf
      sSql = sSql & "      tJICRD decimal(13,2) NULL ," & vbCrLf
      sSql = sSql & "      tJR_DCDEBIT decimal(13,2) NULL ," & vbCrLf
      sSql = sSql & "      tJR_DCCREDIT decimal(13,2)NULL ," & vbCrLf
      sSql = sSql & "      tJR_TotBal decimal(13,2) NULL ," & vbCrLf
      sSql = sSql & "      tGJ_TotBal decimal(13,2) NULL ," & vbCrLf
      sSql = sSql & "      tMJTYPE varchar(2) NULL ," & vbCrLf
      sSql = sSql & "      tMJDESCRIPTION varchar(30) NULL" & vbCrLf
      sSql = sSql & "   )" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   INSERT INTO #tempGLPost1 (tGLDESCR, tGJPOST, tJINAME, tJIACCOUNT, tAcc_StartBal, " & vbCrLf
      sSql = sSql & "tJIDEB, tJICRD, tJR_DCDEBIT, tJR_DCCREDIT, tJR_TotBal," & vbCrLf
      sSql = sSql & "            tGJ_TotBal, tMJTYPE, tMJDESCRIPTION) " & vbCrLf
      sSql = sSql & "               EXEC TrialBalanceGLPost @StartDate, @EndDate, @StartAcc, @EndAcc, @IncludeInActiveAcc" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   SELECT tGLDESCR as GLDESCR, tJIACCOUNT as JIACCOUNT, tAcc_StartBal as StartingBal, --tJINAME, " & vbCrLf
      sSql = sSql & "      SUM(tJIDEB) AS GLDEBIT, SUM(tJICRD) AS GLCREDIT, " & vbCrLf
      sSql = sSql & "      SUM(tJIDEB) - SUM(tJICRD) AS NetProfit," & vbCrLf
      sSql = sSql & "      (tAcc_StartBal + (SUM(tJIDEB) - SUM(tJICRD))) AS EndingBal" & vbCrLf
      sSql = sSql & "   FROM #tempGLPost1, GlacTable " & vbCrLf
      sSql = sSql & "   WHERE tJIACCOUNT = GLACCTREF AND GLACCTREF IN (SELECT tGLACCTREF FROM #tempGLACCTREF)" & vbCrLf
      sSql = sSql & "   GROUP BY tGLDESCR, tJIACCOUNT, tAcc_StartBal --tJINAME, " & vbCrLf
      sSql = sSql & "   ORDER BY tJIACCOUNT" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "-- SELECT * FROM tempGLPost1                 " & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   DROP TABLE #tempGLPost1" & vbCrLf
      sSql = sSql & "   DROP TABLE #tempGLACCTREF" & vbCrLf
      sSql = sSql & "End"
      
      ExecuteScript False, sSql

      ' update the version
      ExecuteScript False, "Update Version Set Version = " & newver
   
   End If
End Function


Private Function UpdateDatabase72()

   newver = 146
   If ver < newver Then
   
      clsADOCon.ADOErrNum = 0
      
      ExecuteScript False, "drop view view_RunNextOpWC"
      
      sSql = "CREATE VIEW [dbo].[view_RunNextOpWC]" & vbCrLf
      sSql = sSql & "AS " & vbCrLf
      sSql = sSql & "   select distinct runstable.Runref, runstable.runno, runstable.RUNOPCUR, f.NextOPNO, f.NextOPSHOP, f.NextOPCENTER" & vbCrLf
      sSql = sSql & "      From runstable, RnopTable, " & vbCrLf
      sSql = sSql & "      (select a.runref, a.runno, b.OPNO NextOPNO, OPSHOP NextOPSHOP, OPCENTER NextOPCENTER," & vbCrLf
      sSql = sSql & "            ROW_NUMBER() OVER (PARTITION BY opref, oprun" & vbCrLf
      sSql = sSql & "                          ORDER BY opref DESC, oprun) as rn" & vbCrLf
      sSql = sSql & "         from runstable a,rnopTable b" & vbCrLf
      sSql = sSql & "         where a.runref = b.opref and" & vbCrLf
      sSql = sSql & "            A.Runno = b.oprun And b.opcompdate Is Null And b.opNo <> A.runopcur" & vbCrLf
      sSql = sSql & "            --and b.opno > a.runopcur" & vbCrLf
      sSql = sSql & "      ) as f" & vbCrLf
      sSql = sSql & "   where RunsTable.RUNSTATUS NOT IN ('CA','CL','CO')  and RunsTable.runref =  f.runref AND RunsTable.runno = f.runno" & vbCrLf
      sSql = sSql & "      and f.rn = 1"
      
      ExecuteScript False, sSql
      
      ' update the version
      ExecuteScript False, "Update Version Set Version = " & newver
   
   End If
End Function

Private Function UpdateDatabase73()

   newver = 147
   If ver < newver Then
   
      clsADOCon.ADOErrNum = 0
      
      If (Not TableExists("FusionSOVOI")) Then
         sSql = "CREATE TABLE [dbo].[FusionSOVOI](" & vbCrLf
         sSql = sSql & "   [ITSO] [int] NULL," & vbCrLf
         sSql = sSql & "   [ITNUMBER] [int] NULL," & vbCrLf
         sSql = sSql & "   [ITREV] [char](2) NULL," & vbCrLf
         sSql = sSql & "   [ITPART] [char](30) NULL," & vbCrLf
         sSql = sSql & "   [ITQTY] [decimal](12, 4) NULL," & vbCrLf
         sSql = sSql & "   [ITSCHED] [smalldatetime] NULL," & vbCrLf
         sSql = sSql & "   [WITHDRAWN_QTY] [decimal](12, 4) NULL," & vbCrLf
         sSql = sSql & "   [REMITQTY] [decimal](12, 4) NULL," & vbCrLf
         sSql = sSql & "   [COMPLFLG] [tinyint] NULL," & vbCrLf
         sSql = sSql & "   [PAYMENT_DOC_NO] [varchar](80) NOT NULL," & vbCrLf
         sSql = sSql & "   [PAYMENT_DOC_IT_NO] [int] NOT NULL," & vbCrLf
         sSql = sSql & "   [REMARKPS] [varchar](1024) NULL," & vbCrLf
         sSql = sSql & "   ITPSNUMBER varchar(8) null," & vbCrLf
         sSql = sSql & "   ITPSITEM smallint null," & vbCrLf
         sSql = sSql & "   ITPSSHIPPED smallint null  " & vbCrLf
         sSql = sSql & ") ON [PRIMARY]"
         
         ExecuteScript False, sSql
      End If
   
      If (Not TableExists("FusionSOVOIExport")) Then
         sSql = "CREATE TABLE [dbo].[FusionSOVOIExport](" & vbCrLf
         sSql = sSql & "   [PAYMENT_DOC_NO] [varchar](80) NULL," & vbCrLf
         sSql = sSql & "   [PAYMENT_DOC_IT_NO] [int] NULL" & vbCrLf
         sSql = sSql & ") ON [PRIMARY]"
   
         ExecuteScript False, sSql
      End If
   
      If (Not TableExists("VOIPmtIss")) Then
         sSql = "CREATE TABLE [dbo].[VOIPmtIss](" & vbCrLf
         sSql = sSql & "   [MATL_NO] [char](30) NOT NULL," & vbCrLf
         sSql = sSql & "   [PAYMENT_DOC_NO] [varchar](80) NOT NULL," & vbCrLf
         sSql = sSql & "   [PAYMENT_DOC_IT_NO] [int] NOT NULL," & vbCrLf
         sSql = sSql & "   [YEAR] [int] NULL," & vbCrLf
         sSql = sSql & "   [ISSUE_AMOUNT] [decimal](12, 4) NULL," & vbCrLf
         sSql = sSql & "   [WITHDRAWN_QTY] [decimal](12, 4) NULL," & vbCrLf
         sSql = sSql & "   [ISSUE_DTE] [smalldatetime] NULL," & vbCrLf
         sSql = sSql & "   [CHECK_NO] [varchar](50) NOT NULL," & vbCrLf
         sSql = sSql & "   [CHECK_AMT] [decimal](12, 4) NULL," & vbCrLf
         sSql = sSql & "   [CHECK_DT] [smalldatetime] NULL," & vbCrLf
         sSql = sSql & "   [REMARKS] [varchar](1024) NULL" & vbCrLf
         sSql = sSql & ") ON [PRIMARY]"
   
         ExecuteScript False, sSql
      End If
   
      If (Not TableExists("tmpVOIPmtIss")) Then
         sSql = "CREATE TABLE [dbo].[tmpVOIPmtIss](" & vbCrLf
         sSql = sSql & "   [MATL_NO] [char](30) NOT NULL," & vbCrLf
         sSql = sSql & "   [PAYMENT_DOC_NO] [varchar](80) NOT NULL," & vbCrLf
         sSql = sSql & "   [PAYMENT_DOC_IT_NO] [int] NOT NULL," & vbCrLf
         sSql = sSql & "   [YEAR] [int] NULL," & vbCrLf
         sSql = sSql & "   [ISSUE_AMOUNT] [decimal](12, 4) NULL," & vbCrLf
         sSql = sSql & "   [WITHDRAWN_QTY] [decimal](12, 4) NULL," & vbCrLf
         sSql = sSql & "   [ISSUE_DTE] [smalldatetime] NULL," & vbCrLf
         sSql = sSql & "   [CHECK_NO] [varchar](50) NOT NULL," & vbCrLf
         sSql = sSql & "   [CHECK_AMT] [decimal](12, 4) NULL," & vbCrLf
         sSql = sSql & "   [CHECK_DT] [smalldatetime] NULL," & vbCrLf
         sSql = sSql & "   [REMARKS] [varchar](1024) NULL" & vbCrLf
         sSql = sSql & ") ON [PRIMARY]"
      
   
         ExecuteScript False, sSql
      End If
   
      If (Not TableExists("tempVOIPConsume")) Then
         sSql = "CREATE TABLE [dbo].[tempVOIPConsume](" & vbCrLf
         sSql = sSql & "   [MATL_NO] [char](30) NOT NULL," & vbCrLf
         sSql = sSql & "   [PAYMENT_DOC_NO] [varchar](80) NOT NULL," & vbCrLf
         sSql = sSql & "   [PAYMENT_DOC_IT_NO] [int] NOT NULL," & vbCrLf
         sSql = sSql & "   [WITHDRAWN_QTY] [decimal](12, 4) NULL," & vbCrLf
         sSql = sSql & "   [REMQTY] [decimal](12, 4) NULL," & vbCrLf
         sSql = sSql & "   [ISSUE_DTE] [smalldatetime] NULL" & vbCrLf
         sSql = sSql & ") ON [PRIMARY]"
         
         ExecuteScript False, sSql
      End If
         
      If Not ColumnExists("ComnTable", "COBOMSETQTY") Then
        sSql = "ALTER TABLE ComnTable ADD COBOMSETQTY int null"
        clsADOCon.ExecuteSql sSql 'rdExecDirect
      End If
         
      If Not ColumnExists("ComnTable", "COONLYOPENPO") Then
        sSql = "ALTER TABLE ComnTable ADD COONLYOPENPO int null"
        clsADOCon.ExecuteSql sSql 'rdExecDirect
      End If


      ' update the version
      ExecuteScript False, "Update Version Set Version = " & newver
   
   End If
End Function


Private Function UpdateDatabase74()
   'updates for ROLT by class and product code
   '

   Dim SQL As String
   SQL = ""
   
   newver = 149
   If ver < newver Then
   
      clsADOCon.ADOErrNum = 0
      
' function fnGetWorkWeekHours
SQL = "if object_id('dbo.fnGetWorkWeekHours') is null" & vbCrLf
SQL = SQL & "    exec ('create function dbo.fnGetWorkWeekHours () returns int as begin return 0 end')" & vbCrLf

ExecuteScript False, SQL

SQL = "" & vbCrLf
SQL = SQL & "alter function dbo.fnGetWorkWeekHours" & vbCrLf
SQL = SQL & "(" & vbCrLf
SQL = SQL & ")" & vbCrLf
SQL = SQL & "returns decimal(12,2)" & vbCrLf
SQL = SQL & "as" & vbCrLf
SQL = SQL & "/*" & vbCrLf
SQL = SQL & "created for Reorder Lead Time by class and product code" & vbCrLf
SQL = SQL & "created 7/1/2015 by Terry Lindeman" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & " test" & vbCrLf
SQL = SQL & "select dbo.fnGetWorkWeekHours()" & vbCrLf
SQL = SQL & "*/" & vbCrLf
SQL = SQL & "begin" & vbCrLf
SQL = SQL & "  declare @hours as decimal(12,2)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "  -- get hours from template" & vbCrLf
SQL = SQL & "  select @hours = CALSUNHR1 + CALMONHR1 + CALTUEHR1 + CALWEDHR1 + CALTHUHR1 + CALFRIHR1 + CALSATHR1" & vbCrLf
SQL = SQL & "  from CctmTable" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "  return @hours" & vbCrLf
SQL = SQL & "end" & vbCrLf
SQL = SQL & "" & vbCrLf

ExecuteScript False, SQL

' stored procedure RptReorderLeadTime
SQL = "if object_id('RptReorderLeadTime') is null" & vbCrLf
SQL = SQL & "    exec ('create procedure RptReorderLeadTime as select 1')" & vbCrLf

ExecuteScript False, SQL

SQL = "" & vbCrLf
SQL = SQL & "alter procedure RptReorderLeadTime" & vbCrLf
SQL = SQL & "  @PartPrefix varchar(30)," & vbCrLf
SQL = SQL & "  @ProductCode varchar(6),      -- blank for all" & vbCrLf
SQL = SQL & "  @PartClass varchar(4),        -- blank for all" & vbCrLf
SQL = SQL & "  @ShowDetails bit,          -- = 1 to show subassenbly levels" & vbCrLf
SQL = SQL & "  @ExactMatchOnly bit,          -- = 0 for wildcard match" & vbCrLf
SQL = SQL & "  @ShowType1 bit," & vbCrLf
SQL = SQL & "  @ShowType2 bit," & vbCrLf
SQL = SQL & "  @ShowType3 bit," & vbCrLf
SQL = SQL & "  @ShowType4 bit" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "as" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "/*" & vbCrLf
SQL = SQL & "created for Reorder Lead Time by class and product code" & vbCrLf
SQL = SQL & "created 7/1/2015 by Terry Lindeman" & vbCrLf
SQL = SQL & "revised 7/2/2015 by Terry Lindeman - add type 1,2,3,4 selection parameters" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "test" & vbCrLf
SQL = SQL & "exec RptReorderLeadTime '233A5323-13', '', '',0, 1, 1,1,1,1   " & vbCrLf
SQL = SQL & "exec RptReorderLeadTime '311A2710-9', '', '', 0, 1, 1,1,1,1" & vbCrLf
SQL = SQL & "exec RptReorderLeadTime '3', '', '', 0, 1, 1,1,1,1" & vbCrLf
SQL = SQL & "exec RptReorderLeadTime '3', '', '', 0, 0, 1,0,0,0" & vbCrLf
SQL = SQL & "exec RptReorderLeadTime '3', '', '', 0, 0, 0,1,0,0" & vbCrLf
SQL = SQL & "exec RptReorderLeadTime '3', '', '', 0, 0, 0,0,1,0" & vbCrLf
SQL = SQL & "exec RptReorderLeadTime '', '', '', 0, 0, 0,0,0,1" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "select count(*) from parttable where palevel = 4" & vbCrLf
SQL = SQL & "*/" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "declare @PartPrefixKey varchar(31), @ProductCodeKey varchar(6), @PartClassKey varchar(4)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "set @PartPrefixKey = replace(replace(isnull(@PartPrefix,''), '-', ''), ' ', '')" & vbCrLf
SQL = SQL & "set @ProductCodeKey = replace(replace(isnull(@ProductCode,''), '-', ''), ' ', '')" & vbCrLf
SQL = SQL & "set @PartClassKey = replace(replace(isnull(@PartClass,''), '-', ''), ' ', '')" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- use wildcard match unless exact match requested" & vbCrLf
SQL = SQL & "if @ExactMatchOnly = 0" & vbCrLf
SQL = SQL & "begin" & vbCrLf
SQL = SQL & "  if len(@PartPrefixKey) < 30 " & vbCrLf
SQL = SQL & "     set @PartPrefixKey = @PartPrefixKey + '%'" & vbCrLf
SQL = SQL & "end" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "if len(@ProductCodeKey) < 6 " & vbCrLf
SQL = SQL & "  set @ProductCodeKey = @ProductCodeKey + '%'" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "if len(@PartClassKey) < 4 " & vbCrLf
SQL = SQL & "  set @PartClassKey = @PartClassKey + '%'" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "print @PartPrefixKey" & vbCrLf
SQL = SQL & "print @ProductCodeKey" & vbCrLf
SQL = SQL & "print @ProductCodeKey" & vbCrLf
SQL = SQL & "print cast(@ShowDetails as varchar(10))" & vbCrLf
SQL = SQL & "print cast(@ExactMatchOnly as varchar(10))" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "create table #temp" & vbCrLf
SQL = SQL & "(" & vbCrLf
SQL = SQL & "  PartRef varchar(30)," & vbCrLf
SQL = SQL & "  PartNum varchar(30)," & vbCrLf
SQL = SQL & "  PaDesc varchar(30)," & vbCrLf
SQL = SQL & "  PaProdCode varchar(6)," & vbCrLf
SQL = SQL & "  PartClass varchar(4)," & vbCrLf
SQL = SQL & "  PaLevel tinyint," & vbCrLf
SQL = SQL & "  PaBOMRev varchar(4)," & vbCrLf
SQL = SQL & "  PaMakeBuy varchar(1)," & vbCrLf
SQL = SQL & "  PaFlowTime decimal(12,4), " & vbCrLf
SQL = SQL & "  PaLeadTime decimal(12,4), " & vbCrLf
SQL = SQL & "  PaRRQ int, " & vbCrLf
SQL = SQL & "  PaRouting varchar(30)," & vbCrLf
SQL = SQL & "  RtQueueHrs decimal(9,4), " & vbCrLf
SQL = SQL & "  RtMoveHrs decimal(9,4), " & vbCrLf
SQL = SQL & "  RtSetupHrs decimal(9,4), " & vbCrLf
SQL = SQL & "  RtUnitHrs decimal(9,4)," & vbCrLf
SQL = SQL & "  BomQty decimal(12,4)," & vbCrLf
SQL = SQL & "  ExplodedQty decimal(12,4)," & vbCrLf
SQL = SQL & "  ExplosionLevel int," & vbCrLf
SQL = SQL & "  RunDaysThisLevel int," & vbCrLf
SQL = SQL & "  RtgDaysThisLevel int," & vbCrLf
SQL = SQL & "  ROLTDaysThisLevel int," & vbCrLf
SQL = SQL & "  ROLTDaysTotal int," & vbCrLf
SQL = SQL & "  ParentPartRef varchar(30)" & vbCrLf
SQL = SQL & ")" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "insert #temp ( PartRef, PartNum, PaDesc, PaProdCode, PartClass, PaLevel, PaBOMRev," & vbCrLf
SQL = SQL & "PaMakeBuy, PaFlowTime, PaLeadTime, PaRRQ, PaRouting," & vbCrLf
SQL = SQL & "BomQty, ExplodedQty, ExplosionLevel, RunDaysThisLevel, RtgDaysThisLevel, ROLTDaysThisLevel, ROLTDaysTotal, ParentPartRef )" & vbCrLf
SQL = SQL & "select PARTREF, PARTNUM, PADESC, PAPRODCODE, PACLASS, PALEVEL, PABOMREV," & vbCrLf
SQL = SQL & "PaMakeBuy, PaFlowTime, PaLeadTime, PaRRQ, PaRouting," & vbCrLf
SQL = SQL & "1.0, -- BomQty" & vbCrLf
SQL = SQL & "1.0, -- ExplodedQty" & vbCrLf
SQL = SQL & "0,      -- ExplosionLevel" & vbCrLf
SQL = SQL & "0,      -- RunDaysThisLevel" & vbCrLf
SQL = SQL & "0,      -- RtgDaysThisLevel" & vbCrLf
SQL = SQL & "0,      -- ROLTDaysThisLevel" & vbCrLf
SQL = SQL & "0,      -- ROLTDaysTotal" & vbCrLf
SQL = SQL & "''      -- ParentPartRef" & vbCrLf
SQL = SQL & "from PartTable " & vbCrLf
SQL = SQL & "left join RthdTable on RTREF=PAROUTING " & vbCrLf
SQL = SQL & "where PARTREF like @PartPrefixKey and PAPRODCODE like @ProductCodeKey and PACLASS like @PartClassKey " & vbCrLf
SQL = SQL & "and" & vbCrLf
SQL = SQL & "( " & vbCrLf
SQL = SQL & "  (@ShowType1 = 1 and PALEVEL = 1)" & vbCrLf
SQL = SQL & "  or (@ShowType2 = 1 and PALEVEL = 2)" & vbCrLf
SQL = SQL & "  or (@ShowType3 = 1 and PALEVEL = 3)" & vbCrLf
SQL = SQL & "  or (@ShowType4 = 1 and PALEVEL = 4)" & vbCrLf
SQL = SQL & ")" & vbCrLf
SQL = SQL & "order by PARTREF" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- explode parts to basic level (type 4)" & vbCrLf
SQL = SQL & "declare @count int, @oldcount int, @level int" & vbCrLf
SQL = SQL & "select @count = count(*) from #temp" & vbCrLf
SQL = SQL & "set @oldcount = 0" & vbCrLf
SQL = SQL & "set @level = 0" & vbCrLf
SQL = SQL & "while @oldcount <> @count and @level < 10" & vbCrLf
SQL = SQL & "begin" & vbCrLf
SQL = SQL & "  set @oldcount = @count" & vbCrLf
SQL = SQL & "  insert #temp ( PartRef, PartNum, PaDesc, PaProdCode, PartClass, PaLevel, PaBOMRev, " & vbCrLf
SQL = SQL & "  PaMakeBuy, PaFlowTime, PaLeadTime, PaRRQ, PaRouting," & vbCrLf
SQL = SQL & "  BomQty, ExplodedQty, ExplosionLevel, RunDaysThisLevel, RtgDaysThisLevel, ROLTDaysThisLevel, ROLTDaysTotal, ParentPartRef )" & vbCrLf
SQL = SQL & "  select p.PARTREF, p.PARTNUM, p.PADESC, p.PAPRODCODE, p.PACLASS, p.PALEVEL, p.PABOMREV, " & vbCrLf
SQL = SQL & "  p.PAMAKEBUY, p.PAFLOWTIME, p.PALEADTIME, p.PARRQ, p.PaRouting," & vbCrLf
SQL = SQL & "  BMQTYREQD,              -- BomQty" & vbCrLf
SQL = SQL & "  BMQTYREQD * t.ExplodedQty, -- ExplodedQty" & vbCrLf
SQL = SQL & "  @level + 1,             -- ExplosionLevel" & vbCrLf
SQL = SQL & "  0,                   -- RunDaysThisLevel" & vbCrLf
SQL = SQL & "  0,                   -- RtgDaysThisLevel" & vbCrLf
SQL = SQL & "  0,                   -- ROLTDaysThisLevel" & vbCrLf
SQL = SQL & "  0,                   -- ROLTDaysTotal" & vbCrLf
SQL = SQL & "  BMASSYPART              -- ParentPartRef" & vbCrLf
SQL = SQL & "  from BmplTable b" & vbCrLf
SQL = SQL & "  join #temp t on t.PartRef = b.BMASSYPART and t.ExplosionLevel = @level and t.PaLevel < 4" & vbCrLf
SQL = SQL & "  join PartTable p on p.PARTREF = b.BMPARTREF and p.PABOMREV = b.BMPARTREV" & vbCrLf
SQL = SQL & "  --where BMASSYPART in (select PartRef from #temp where ExplosionLevel = @level) and PaLevel <= 4" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "  set @level = @level + 1" & vbCrLf
SQL = SQL & "  select @count = count(*) from #temp" & vbCrLf
SQL = SQL & "end" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- set routing parameters for parts where there is a routing" & vbCrLf
SQL = SQL & "update t" & vbCrLf
SQL = SQL & "set t.RtQueueHrs = r.RtQueueHrs," & vbCrLf
SQL = SQL & "t.RtMoveHrs = r.RtMoveHrs," & vbCrLf
SQL = SQL & "t.RtSetupHrs = r.RtSetupHrs," & vbCrLf
SQL = SQL & "t.RtUnitHrs = r.RtUnitHrs" & vbCrLf
SQL = SQL & "from #temp t " & vbCrLf
SQL = SQL & "left join RthdTable r on r.RTREF=t.PAROUTING " & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- set individual ROLTs for purchased parts" & vbCrLf
SQL = SQL & "update #temp set RoltDaysThisLevel = PaLeadTime where PaMakeBuy = 'B'" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- set individual ROLTs for manufactured parts" & vbCrLf
SQL = SQL & "declare @hoursPerDay decimal(12,2)" & vbCrLf
SQL = SQL & "set @hoursPerDay = dbo.fnGetWorkWeekHours() / 7.0" & vbCrLf
SQL = SQL & "if isnull(@hoursPerDay,0) = 0 set @hoursPerDay = 40.0 / 7.0" & vbCrLf
SQL = SQL & "update #temp set RtgDaysThisLevel = Round( (RtQueueHrs + RtMoveHrs + RtSetupHrs " & vbCrLf
SQL = SQL & "+ case PaRRQ when null then 1 when 0 then 1 else Parrq end * RtUnitHrs ) / @hoursPerDay, 0)" & vbCrLf
SQL = SQL & "where PaMakeBuy <> 'B'" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- for Valley, set run days to most recent run total time WITH RUN # < 600" & vbCrLf
SQL = SQL & "update t set RunDaysThisLevel = DATEDIFF(d, r.RUNPKSTART, r.RUNSCHED)" & vbCrLf
SQL = SQL & "from #temp t" & vbCrLf
SQL = SQL & "join RunsTable r on r.RUNREF = t.PartRef" & vbCrLf
SQL = SQL & "where r.RUNNO = (select max(RUNNO) from RunsTable r2 where r2.RUNREF = T.PartRef and  r2.RUNNO < 600)" & vbCrLf
SQL = SQL & "and t.PaMakeBuy <> 'B'" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- here we can choose ROLT days from either routing or run" & vbCrLf
SQL = SQL & "-- We will use run ROLT based upon Valley's needs" & vbCrLf
SQL = SQL & "-- update #temp set ROLTDaysThisLevel = RtgDaysThisLevel where PaMakeBuy <> 'B'" & vbCrLf
SQL = SQL & "update #temp set ROLTDaysThisLevel = RunDaysThisLevel where PaMakeBuy <> 'B'" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- set total ROLT so far to ROLT for this level" & vbCrLf
SQL = SQL & "update #temp set ROLTDaysTotal = ROLTDaysThisLevel " & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- roll up ROLT starting from bottom level" & vbCrLf
SQL = SQL & "set @level = @level - 1" & vbCrLf
SQL = SQL & "while @level >= 0" & vbCrLf
SQL = SQL & "begin" & vbCrLf
SQL = SQL & "  print cast(@level as varchar(2))" & vbCrLf
SQL = SQL & "  update #temp" & vbCrLf
SQL = SQL & "  set ROLTDaysTotal = ROLTDaysThisLevel + isnull(( select max(ROLTDaysTotal ) from #temp t " & vbCrLf
SQL = SQL & "  where t.ExplosionLevel = @level + 1 and t.ParentPartRef = #temp.PartRef ), 0)" & vbCrLf
SQL = SQL & "  from #temp" & vbCrLf
SQL = SQL & "  where ExplosionLevel = @level" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "  set @level = @level - 1" & vbCrLf
SQL = SQL & "end" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "select * from #temp" & vbCrLf
SQL = SQL & "where ExplosionLevel = 0 or @ShowDetails = 1" & vbCrLf
SQL = SQL & "order by ExplosionLevel, PartRef " & vbCrLf
SQL = SQL & "" & vbCrLf

ExecuteScript False, SQL


      ' update the version
      ExecuteScript False, "Update Version Set Version = " & newver
   
   End If
End Function


Private Function UpdateDatabase75()

   newver = 150
   If ver < newver Then
   
      clsADOCon.ADOErrNum = 0
      
      If (Not TableExists("VOIPDocNumCutoff")) Then
         sSql = "CREATE TABLE [dbo].[VOIPDocNumCutoff](" & vbCrLf
         sSql = sSql & "   [PAYMENT_DOC_NO] Not [VarChar](80), " & vbCrLf
         sSql = sSql & ") ON [PRIMARY]"
         
         ExecuteScript False, sSql
      End If
         
      If Not ColumnExists("ComnTable", "COLOGOUTONPOUT") Then
        sSql = "ALTER TABLE ComnTable ADD COLOGOUTONPOUT int null"
        clsADOCon.ExecuteSql sSql 'rdExecDirect
      End If
         
      If Not ColumnExists("rtopTable", "OPFILLREF") Then
        sSql = "ALTER TABLE rtopTable ADD OPFILLREF Varchar(30) NULL"
        clsADOCon.ExecuteSql sSql 'rdExecDirect
      End If

      ' update the version
      ExecuteScript False, "Update Version Set Version = " & newver
   
   End If
End Function


Private Function UpdateDatabase76()

   newver = 151
   If ver < newver Then
   
      clsADOCon.ADOErrNum = 0
         
      If (TableExists("FusionSOVOI")) Then
         sSql = "ALTER TABLE FusionSOVOI ADD" & vbCrLf
         sSql = sSql & " [CHECK_NO] [varchar](50) NULL," & vbCrLf
         sSql = sSql & " [CHECK_AMT] [decimal](12, 4) NULL," & vbCrLf
         sSql = sSql & " [CHECK_DT] [smalldatetime] NULL," & vbCrLf
         sSql = sSql & " [INNO] int NULL," & vbCrLf
         sSql = sSql & " [CASHRECEIPT] int NULL"
         
         ExecuteScript False, sSql
      End If
   
      If Not ColumnExists("ComnTable", "COPSPOPUPWARNING") Then
        sSql = "ALTER TABLE ComnTable ADD COPSPOPUPWARNING int null"
        clsADOCon.ExecuteSql sSql 'rdExecDirect
      End If
         
      ' update the version
      ExecuteScript False, "Update Version Set Version = " & newver
   
   End If
End Function
   
   
   
   
Private Function UpdateDatabase77()
   'updates for ROLT by class and product code
   '

   Dim SQL As String
   SQL = ""
   
   newver = 152
   If ver < newver Then
   
      clsADOCon.ADOErrNum = 0
      
' stored procedure RptReorderLeadTime
SQL = "if object_id('RptReorderLeadTime') is null" & vbCrLf
SQL = SQL & "    exec ('create procedure RptReorderLeadTime as select 1')" & vbCrLf

ExecuteScript False, SQL

SQL = "" & vbCrLf
SQL = SQL & "alter procedure RptReorderLeadTime" & vbCrLf
SQL = SQL & "  @PartPrefix varchar(30)," & vbCrLf
SQL = SQL & "  @ProductCode varchar(6),      -- blank for all" & vbCrLf
SQL = SQL & "  @PartClass varchar(4),        -- blank for all" & vbCrLf
SQL = SQL & "  @ShowDetails bit,          -- = 1 to show subassenbly levels" & vbCrLf
SQL = SQL & "  @ExactMatchOnly bit,       -- = 0 for wildcard match" & vbCrLf
SQL = SQL & "  @ShowType1 bit," & vbCrLf
SQL = SQL & "  @ShowType2 bit," & vbCrLf
SQL = SQL & "  @ShowType3 bit," & vbCrLf
SQL = SQL & "  @ShowType4 bit" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "as" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "/*" & vbCrLf
SQL = SQL & "created for Reorder Lead Time by class and product code" & vbCrLf
SQL = SQL & "created 7/1/2015 by Terry Lindeman" & vbCrLf
SQL = SQL & "revised 7/2/2015 by Terry Lindeman - add type 1,2,3,4 selection parameters" & vbCrLf
SQL = SQL & "revised 7/15/2015 by Terry Lindeman - show parts in explosion order when details are selected." & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "test" & vbCrLf
SQL = SQL & "exec RptReorderLeadTime '233A5323-13', '', '',0, 1, 1,1,1,1   " & vbCrLf
SQL = SQL & "exec RptReorderLeadTime '311A2710-9', '', '', 0, 1, 1,1,1,1" & vbCrLf
SQL = SQL & "exec RptReorderLeadTime '3', '', '', 0, 1, 1,1,1,1" & vbCrLf
SQL = SQL & "exec RptReorderLeadTime '3', '', '', 0, 0, 1,0,0,0" & vbCrLf
SQL = SQL & "exec RptReorderLeadTime '', '', '', 0, 0, 0,0,0,1" & vbCrLf
SQL = SQL & "exec RptReorderLeadTime '843Z6', '', '', 1, 0, 1,0,0,0" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "select count(*) from parttable where palevel = 4" & vbCrLf
SQL = SQL & "*/" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "declare @PartPrefixKey varchar(31), @ProductCodeKey varchar(6), @PartClassKey varchar(4)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "set @PartPrefixKey = replace(replace(isnull(@PartPrefix,''), '-', ''), ' ', '')" & vbCrLf
SQL = SQL & "set @ProductCodeKey = replace(replace(isnull(@ProductCode,''), '-', ''), ' ', '')" & vbCrLf
SQL = SQL & "set @PartClassKey = replace(replace(isnull(@PartClass,''), '-', ''), ' ', '')" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- use wildcard match unless exact match requested" & vbCrLf
SQL = SQL & "if @ExactMatchOnly = 0" & vbCrLf
SQL = SQL & "begin" & vbCrLf
SQL = SQL & "  if len(@PartPrefixKey) < 30 " & vbCrLf
SQL = SQL & "     set @PartPrefixKey = @PartPrefixKey + '%'" & vbCrLf
SQL = SQL & "end" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "if len(@ProductCodeKey) < 6 " & vbCrLf
SQL = SQL & "  set @ProductCodeKey = @ProductCodeKey + '%'" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "if len(@PartClassKey) < 4 " & vbCrLf
SQL = SQL & "  set @PartClassKey = @PartClassKey + '%'" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "print @PartPrefixKey" & vbCrLf
SQL = SQL & "print @ProductCodeKey" & vbCrLf
SQL = SQL & "print @ProductCodeKey" & vbCrLf
SQL = SQL & "print cast(@ShowDetails as varchar(10))" & vbCrLf
SQL = SQL & "print cast(@ExactMatchOnly as varchar(10))" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "create table #temp" & vbCrLf
SQL = SQL & "(" & vbCrLf
SQL = SQL & "  ID int identity," & vbCrLf
SQL = SQL & "  PartRef varchar(30)," & vbCrLf
SQL = SQL & "  PartNum varchar(30)," & vbCrLf
SQL = SQL & "  PaDesc varchar(30)," & vbCrLf
SQL = SQL & "  PaProdCode varchar(6)," & vbCrLf
SQL = SQL & "  PartClass varchar(4)," & vbCrLf
SQL = SQL & "  PaLevel tinyint," & vbCrLf
SQL = SQL & "  PaBOMRev varchar(4)," & vbCrLf
SQL = SQL & "  PaMakeBuy varchar(1)," & vbCrLf
SQL = SQL & "  PaFlowTime decimal(12,4), " & vbCrLf
SQL = SQL & "  PaLeadTime decimal(12,4), " & vbCrLf
SQL = SQL & "  PaRRQ int, " & vbCrLf
SQL = SQL & "  PaRouting varchar(30)," & vbCrLf
SQL = SQL & "  RtQueueHrs decimal(9,4), " & vbCrLf
SQL = SQL & "  RtMoveHrs decimal(9,4), " & vbCrLf
SQL = SQL & "  RtSetupHrs decimal(9,4), " & vbCrLf
SQL = SQL & "  RtUnitHrs decimal(9,4)," & vbCrLf
SQL = SQL & "  BomQty decimal(12,4)," & vbCrLf
SQL = SQL & "  ExplodedQty decimal(12,4)," & vbCrLf
SQL = SQL & "  ExplosionLevel int," & vbCrLf
SQL = SQL & "  RunDaysThisLevel int," & vbCrLf
SQL = SQL & "  RtgDaysThisLevel int," & vbCrLf
SQL = SQL & "  ROLTDaysThisLevel int," & vbCrLf
SQL = SQL & "  ROLTDaysTotal int," & vbCrLf
SQL = SQL & "  ParentPartRef varchar(30)," & vbCrLf
SQL = SQL & "  TopPartRef varchar(30)," & vbCrLf
SQL = SQL & "  SortKey varchar(100)" & vbCrLf
SQL = SQL & ")" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "insert #temp ( PartRef, PartNum, PaDesc, PaProdCode, PartClass, PaLevel, PaBOMRev," & vbCrLf
SQL = SQL & "PaMakeBuy, PaFlowTime, PaLeadTime, PaRRQ, PaRouting," & vbCrLf
SQL = SQL & "BomQty, ExplodedQty, ExplosionLevel, RunDaysThisLevel, RtgDaysThisLevel, ROLTDaysThisLevel, ROLTDaysTotal, ParentPartRef, TopPartRef )" & vbCrLf
SQL = SQL & "select PARTREF, PARTNUM, PADESC, PAPRODCODE, PACLASS, PALEVEL, PABOMREV," & vbCrLf
SQL = SQL & "PaMakeBuy, PaFlowTime, PaLeadTime, PaRRQ, PaRouting," & vbCrLf
SQL = SQL & "1.0, -- BomQty" & vbCrLf
SQL = SQL & "1.0, -- ExplodedQty" & vbCrLf
SQL = SQL & "0,      -- ExplosionLevel" & vbCrLf
SQL = SQL & "0,      -- RunDaysThisLevel" & vbCrLf
SQL = SQL & "0,      -- RtgDaysThisLevel" & vbCrLf
SQL = SQL & "0,      -- ROLTDaysThisLevel" & vbCrLf
SQL = SQL & "0,      -- ROLTDaysTotal" & vbCrLf
SQL = SQL & "'',     -- ParentPartRef" & vbCrLf
SQL = SQL & "PartRef -- TopPartRef" & vbCrLf
SQL = SQL & "from PartTable p" & vbCrLf
SQL = SQL & "left join RthdTable on RTREF=PAROUTING " & vbCrLf
SQL = SQL & "where PARTREF like @PartPrefixKey and PAPRODCODE like @ProductCodeKey and PACLASS like @PartClassKey " & vbCrLf
SQL = SQL & "and" & vbCrLf
SQL = SQL & "( " & vbCrLf
SQL = SQL & "  (@ShowType1 = 1 and PALEVEL = 1)" & vbCrLf
SQL = SQL & "  or (@ShowType2 = 1 and PALEVEL = 2)" & vbCrLf
SQL = SQL & "  or (@ShowType3 = 1 and PALEVEL = 3)" & vbCrLf
SQL = SQL & "  or (@ShowType4 = 1 and PALEVEL = 4)" & vbCrLf
SQL = SQL & ")" & vbCrLf
SQL = SQL & "order by p.PARTREF" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "update #temp set SortKey = right( '000000' + cast(ID as varchar(7)), 7)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- explode parts to basic level (type 4)" & vbCrLf
SQL = SQL & "declare @count int, @oldcount int, @level int" & vbCrLf
SQL = SQL & "select @count = count(*) from #temp" & vbCrLf
SQL = SQL & "set @oldcount = 0" & vbCrLf
SQL = SQL & "set @level = 0" & vbCrLf
SQL = SQL & "while @oldcount <> @count and @level < 10" & vbCrLf
SQL = SQL & "begin" & vbCrLf
SQL = SQL & "  set @oldcount = @count" & vbCrLf
SQL = SQL & "  insert #temp ( PartRef, PartNum, PaDesc, PaProdCode, PartClass, PaLevel, PaBOMRev, " & vbCrLf
SQL = SQL & "  PaMakeBuy, PaFlowTime, PaLeadTime, PaRRQ, PaRouting," & vbCrLf
SQL = SQL & "  BomQty, ExplodedQty, ExplosionLevel, RunDaysThisLevel, RtgDaysThisLevel, ROLTDaysThisLevel, " & vbCrLf
SQL = SQL & "  ROLTDaysTotal, ParentPartRef, TopPartRef, SortKey )" & vbCrLf
SQL = SQL & "  select p.PARTREF, p.PARTNUM, p.PADESC, p.PAPRODCODE, p.PACLASS, p.PALEVEL, p.PABOMREV, " & vbCrLf
SQL = SQL & "  p.PAMAKEBUY, p.PAFLOWTIME, p.PALEADTIME, p.PARRQ, p.PaRouting," & vbCrLf
SQL = SQL & "  BMQTYREQD,              -- BomQty" & vbCrLf
SQL = SQL & "  BMQTYREQD * t.ExplodedQty, -- ExplodedQty" & vbCrLf
SQL = SQL & "  @level + 1,             -- ExplosionLevel" & vbCrLf
SQL = SQL & "  0,                   -- RunDaysThisLevel" & vbCrLf
SQL = SQL & "  0,                   -- RtgDaysThisLevel" & vbCrLf
SQL = SQL & "  0,                   -- ROLTDaysThisLevel" & vbCrLf
SQL = SQL & "  0,                   -- ROLTDaysTotal" & vbCrLf
SQL = SQL & "  BMASSYPART,             -- ParentPartRef" & vbCrLf
SQL = SQL & "  t.TopPartRef,           -- TopPartRef" & vbCrLf
SQL = SQL & "  t.SortKey               -- partial SortKey" & vbCrLf
SQL = SQL & "  from BmplTable b" & vbCrLf
SQL = SQL & "  join #temp t on t.PartRef = b.BMASSYPART and t.ExplosionLevel = @level and t.PaLevel < 4" & vbCrLf
SQL = SQL & "  join PartTable p on p.PARTREF = b.BMPARTREF and p.PABOMREV = b.BMPARTREV" & vbCrLf
SQL = SQL & "  --where BMASSYPART in (select PartRef from #temp where ExplosionLevel = @level) and PaLevel <= 4" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "  update #temp set SortKey = SortKey + '.' + right( '000000' + cast(ID as varchar(7)), 7) where ExplosionLevel = @level + 1" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "  set @level = @level + 1" & vbCrLf
SQL = SQL & "  select @count = count(*) from #temp" & vbCrLf
SQL = SQL & "end" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- set routing parameters for parts where there is a routing" & vbCrLf
SQL = SQL & "update t" & vbCrLf
SQL = SQL & "set t.RtQueueHrs = r.RtQueueHrs," & vbCrLf
SQL = SQL & "t.RtMoveHrs = r.RtMoveHrs," & vbCrLf
SQL = SQL & "t.RtSetupHrs = r.RtSetupHrs," & vbCrLf
SQL = SQL & "t.RtUnitHrs = r.RtUnitHrs" & vbCrLf
SQL = SQL & "from #temp t " & vbCrLf
SQL = SQL & "left join RthdTable r on r.RTREF=t.PAROUTING " & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- set individual ROLTs for purchased parts" & vbCrLf
SQL = SQL & "update #temp set RoltDaysThisLevel = PaLeadTime where PaMakeBuy = 'B'" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- set individual ROLTs for manufactured parts" & vbCrLf
SQL = SQL & "declare @hoursPerDay decimal(12,2)" & vbCrLf
SQL = SQL & "set @hoursPerDay = dbo.fnGetWorkWeekHours() / 7.0" & vbCrLf
SQL = SQL & "if isnull(@hoursPerDay,0) = 0 set @hoursPerDay = 40.0 / 7.0" & vbCrLf
SQL = SQL & "update #temp set RtgDaysThisLevel = Round( (RtQueueHrs + RtMoveHrs + RtSetupHrs " & vbCrLf
SQL = SQL & "+ case PaRRQ when null then 1 when 0 then 1 else Parrq end * RtUnitHrs ) / @hoursPerDay, 0)" & vbCrLf
SQL = SQL & "where PaMakeBuy <> 'B'" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- for Valley, set run days to most recent run total time WITH RUN # < 600" & vbCrLf
SQL = SQL & "update t set RunDaysThisLevel = DATEDIFF(d, r.RUNPKSTART, r.RUNSCHED)" & vbCrLf
SQL = SQL & "from #temp t" & vbCrLf
SQL = SQL & "join RunsTable r on r.RUNREF = t.PartRef" & vbCrLf
SQL = SQL & "where r.RUNNO = (select max(RUNNO) from RunsTable r2 where r2.RUNREF = T.PartRef and  r2.RUNNO < 600)" & vbCrLf
SQL = SQL & "and t.PaMakeBuy <> 'B'" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- here we can choose ROLT days from either routing or run" & vbCrLf
SQL = SQL & "-- We will use run ROLT based upon Valley's needs" & vbCrLf
SQL = SQL & "-- update #temp set ROLTDaysThisLevel = RtgDaysThisLevel where PaMakeBuy <> 'B'" & vbCrLf
SQL = SQL & "update #temp set ROLTDaysThisLevel = RunDaysThisLevel where PaMakeBuy <> 'B'" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- set total ROLT so far to ROLT for this level" & vbCrLf
SQL = SQL & "update #temp set ROLTDaysTotal = ROLTDaysThisLevel " & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- roll up ROLT starting from bottom level" & vbCrLf
SQL = SQL & "set @level = @level - 1" & vbCrLf
SQL = SQL & "while @level >= 0" & vbCrLf
SQL = SQL & "begin" & vbCrLf
SQL = SQL & "  print cast(@level as varchar(2))" & vbCrLf
SQL = SQL & "  update #temp" & vbCrLf
SQL = SQL & "  set ROLTDaysTotal = ROLTDaysThisLevel + isnull(( select max(ROLTDaysTotal ) from #temp t " & vbCrLf
SQL = SQL & "  where t.ExplosionLevel = @level + 1 and t.ParentPartRef = #temp.PartRef ), 0)" & vbCrLf
SQL = SQL & "  from #temp" & vbCrLf
SQL = SQL & "  where ExplosionLevel = @level" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "  set @level = @level - 1" & vbCrLf
SQL = SQL & "end" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "select * from #temp" & vbCrLf
SQL = SQL & "where ExplosionLevel = 0 or @ShowDetails = 1" & vbCrLf
SQL = SQL & "order by SortKey " & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "--select ID, TopPartRef, ExplosionLevel, ParentPartRef, PartRef, ExplosionLevel, SortKey, ROLTDaysTotal from #temp" & vbCrLf
SQL = SQL & "--where ExplosionLevel = 0 or @ShowDetails = 1" & vbCrLf
SQL = SQL & "--order by SortKey" & vbCrLf
SQL = SQL & "" & vbCrLf

ExecuteScript False, SQL


ExecuteScript False, SQL


      ' update the version
      ExecuteScript False, "Update Version Set Version = " & newver
   
   End If
End Function

   
Private Function UpdateDatabase78()
   'updates for ROLT by class and product code
   '

   Dim SQL As String
   SQL = ""
   
   newver = 153
   If ver < newver Then
   
      clsADOCon.ADOErrNum = 0
      
      If Not ColumnExists("RthdTable", "RTINACTIVE") Then
        sSql = "ALTER TABLE RthdTable ADD RTINACTIVE tinyint not null default 0"
        clsADOCon.ExecuteSql sSql
      End If
         
      If Not ColumnExists("CihdTable", "INVREASONS") Then
        sSql = "ALTER TABLE CihdTable add INVREASONS varchar(2048) null default('')"
        clsADOCon.ExecuteSql sSql
      End If
      

      SQL = "" & vbCrLf
      SQL = SQL & "ALTER PROCEDURE [dbo].[Qry_FillRoutings]  as" & vbCrLf
      SQL = SQL & "SELECT RTREF,RTNUM From RthdTable WHERE RTINACTIVE = 0  ORDER BY RTREF"
      SQL = SQL & "" & vbCrLf
      
      ExecuteScript False, SQL
 

      If Not ColumnExists("ComnTable", "COWARNSERVICEOPOPEN") Then
          sSql = "ALTER table dbo.ComnTable add COWARNSERVICEOPOPEN tinyint NULL CONSTRAINT DF_ComnTable_COWARNSERVICEOPOPEN DEFAULT 0"
          ExecuteScript False, sSql
      End If

      If Not ColumnExists("CCitTable", "CILOTLOCATION") Then
          sSql = "Alter table CCitTable Add CILOTLOCATION [char](4) NULL"
          ExecuteScript False, sSql
      End If

      If (Not TableExists("LtTrkTable")) Then
         sSql = "CREATE TABLE [dbo].[LtTrkTable](" & vbCrLf
         sSql = sSql & " [LOTNUMBER] [varchar](15) NULL," & vbCrLf
         sSql = sSql & " [LOTUSERLOTID] [varchar](40) NULL" & vbCrLf
         sSql = sSql & " ) ON [PRIMARY]"
         
         ExecuteScript False, sSql
      End If

      If Not ColumnExists("rtopTable", "OPFILLREF") Then
          sSql = "ALTER TABLE rtopTable ADD OPFILLREF Varchar(30) NULL"
          ExecuteScript False, sSql
      End If


 
      sSql = "ALTER PROCEDURE [dbo].[RptInvMovFromWIP] " & vbCrLf
      sSql = sSql & "    @StartDate as varchar(16), @EndDate as Varchar(16),  " & vbCrLf
      sSql = sSql & "    @PartType1 as Integer, @PartType2 as Integer, @PartType3 as Integer, @PartType4 as Integer  " & vbCrLf
      sSql = sSql & "   AS  " & vbCrLf
      sSql = sSql & "   BEGIN " & vbCrLf
      sSql = sSql & "    " & vbCrLf
      sSql = sSql & "      IF (@PartType1 = 1)      " & vbCrLf
      sSql = sSql & "         SET @PartType1 = 1     " & vbCrLf
      sSql = sSql & "      Else                     " & vbCrLf
      sSql = sSql & "         SET @PartType1 = 0     " & vbCrLf
      sSql = sSql & "    " & vbCrLf
      sSql = sSql & "      IF (@PartType2 = 1)      " & vbCrLf
      sSql = sSql & "         SET @PartType2 = 2     " & vbCrLf
      sSql = sSql & "      Else                     " & vbCrLf
      sSql = sSql & "         SET @PartType2 = 0     " & vbCrLf
      sSql = sSql & "       " & vbCrLf
      sSql = sSql & "   IF (@PartType3 = 1)     " & vbCrLf
      sSql = sSql & "      SET @PartType3 = 3  " & vbCrLf
      sSql = sSql & "   Else                    " & vbCrLf
      sSql = sSql & "     SET @PartType3 = 0  " & vbCrLf
      sSql = sSql & "                              " & vbCrLf
      sSql = sSql & "      IF (@PartType4 = 1)     " & vbCrLf
      sSql = sSql & "         SET @PartType4 = 4  " & vbCrLf
      sSql = sSql & "      Else                    " & vbCrLf
      sSql = sSql & "         SET @PartType4 = 0  " & vbCrLf
      sSql = sSql & "    " & vbCrLf
      sSql = sSql & "      SELECT Inadate, InvaTable.INTYPE,InvaTable.INLOTNUMBER,InvaTable.INPART, InvaTable.INREF2,  " & vbCrLf
      sSql = sSql & "         InvaTable.INAQTY, InvaTable.INAMT, LohdTable.LOTORIGINALQTY, LohdTable.LOTTOTMATL, INTOTMATL,  " & vbCrLf
      sSql = sSql & "         LohdTable.LOTTOTLABOR, INTOTLABOR, LohdTable.LOTTOTEXP, INTOTEXP, LohdTable.LOTTOTOH, INTOTOH, " & vbCrLf
      sSql = sSql & "         LOTDATECOSTED, INDEBITACCT, INCREDITACCT " & vbCrLf
      sSql = sSql & "      FROM " & vbCrLf
      sSql = sSql & "         (PartTable PartTable INNER JOIN InvaTable InvaTable ON " & vbCrLf
      sSql = sSql & "            PartTable.PARTREF = InvaTable.INPART) " & vbCrLf
      sSql = sSql & "          LEFT OUTER JOIN LohdTable LohdTable ON " & vbCrLf
      sSql = sSql & "            InvaTable.INLOTNUMBER = LohdTable.LOTNUMBER " & vbCrLf
      sSql = sSql & "      WHERE " & vbCrLf
      sSql = sSql & "         InvaTable.INTYPE IN (6,12) and  " & vbCrLf
      sSql = sSql & "         Convert(DateTime, Inadate, 101) between @StartDate and @EndDate  " & vbCrLf
      sSql = sSql & "            AND PALEVEL IN (@PartType1, @PartType2, @PartType3, @PartType4) " & vbCrLf
      sSql = sSql & "      --    AND INPART = 'MX000075' " & vbCrLf
      sSql = sSql & "         AND INLOTNUMBER NOT IN (SELECT a.INLOTNUMBER  FROM InvaTable a where  " & vbCrLf
      sSql = sSql & "            a.INPART = InvaTable.INPART " & vbCrLf
      sSql = sSql & "            --a.INPART = 'MX000075'  " & vbCrLf
      sSql = sSql & "            AND a.INTYPE IN (6,38,12) AND Convert(DateTime, a.Inadate, 101) between @StartDate and @EndDate " & vbCrLf
      sSql = sSql & "      GROUP BY INLOTNUMBER  " & vbCrLf
      sSql = sSql & "      HAVING COUNT(INLOTNUMBER) > 1) " & vbCrLf
      sSql = sSql & "      ORDER BY " & vbCrLf
      sSql = sSql & "         PartTable.PALEVEL ASC, " & vbCrLf
      sSql = sSql & "         PartTable.PACLASS ASC " & vbCrLf
      sSql = sSql & "    " & vbCrLf
      sSql = sSql & "   END "
      
Debug.Print sSql

      ExecuteScript False, sSql
 
      sSql = "ALTER procedure [dbo].[UpdateTimeCardTotals]" & vbCrLf
      sSql = sSql & " @EmpNo int," & vbCrLf
      sSql = sSql & " @Date datetime" & vbCrLf
      sSql = sSql & "as " & vbCrLf
      sSql = sSql & "/* test" & vbCrLf
      sSql = sSql & "    UpdateTimeCardTotals 52, '9/8/2008'" & vbCrLf
      sSql = sSql & "*/" & vbCrLf
      sSql = sSql & "update TchdTable " & vbCrLf
      sSql = sSql & "set TMSTART = (select top 1 TCSTART From TcitTable " & vbCrLf
      sSql = sSql & " join TchdTable on TCCARD = TMCARD" & vbCrLf
      sSql = sSql & " where TCEMP = @EmpNo and TMDAY = @Date and TCSTOP <> ''" & vbCrLf
      sSql = sSql & " and ISDATE(TCSTART + 'm') = 1 and ISDATE(TCSTOP + 'm') = 1" & vbCrLf
      sSql = sSql & " order by tcstarttime)," & vbCrLf
      sSql = sSql & "TMSTOP = (select top 1 TCSTOP From TcitTable" & vbCrLf
      sSql = sSql & " join TchdTable on TCCARD = TMCARD" & vbCrLf
      sSql = sSql & " where TCEMP = @EmpNo and TMDAY = @Date and TCSTOP <> ''" & vbCrLf
      sSql = sSql & " and ISDATE(TCSTART + 'm') = 1 and ISDATE(TCSTOP + 'm') = 1" & vbCrLf
      sSql = sSql & " order by case when datediff( n, cast(rtrim(TCSTART) + 'm' as datetime)," & vbCrLf
      sSql = sSql & " cast(rtrim(TCSTOP) + 'm' as datetime) ) >= 0  " & vbCrLf
      sSql = sSql & " then cast(rtrim(TCSTOP) + 'm' as datetime) " & vbCrLf
      sSql = sSql & " else dateadd(day, 1, cast(rtrim(TCSTOP) + 'm' as datetime)) end desc)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "where TMEMP = @EmpNo and TMDAY = @Date" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "update TchdTable " & vbCrLf
      sSql = sSql & " set TMREGHRS = (select isnull(sum(hrs), 0.000) from viewTimeCardHours" & vbCrLf
      sSql = sSql & " where EmpNo = @EmpNo" & vbCrLf
      sSql = sSql & " and chgDay = @Date" & vbCrLf
      sSql = sSql & " and type = 'R')," & vbCrLf
      sSql = sSql & " TMOVTHRS = (select isnull(sum(hrs), 0.000) from viewTimeCardHours" & vbCrLf
      sSql = sSql & " where EmpNo = @EmpNo" & vbCrLf
      sSql = sSql & " and chgDay = @Date" & vbCrLf
      sSql = sSql & " and type = 'O')," & vbCrLf
      sSql = sSql & " TMDBLHRS = (select isnull(sum(hrs), 0.000) from viewTimeCardHours" & vbCrLf
      sSql = sSql & " where EmpNo = @EmpNo" & vbCrLf
      sSql = sSql & " and chgDay = @Date" & vbCrLf
      sSql = sSql & " and type = 'D')" & vbCrLf
      sSql = sSql & "where TMEMP = @EmpNo and TMDAY = @Date"
      
      ExecuteScript False, sSql
      
      If (Not TableExists("TlitTableNew")) Then
      
         sSql = "CREATE TABLE [dbo].[TlitTableNew](" & vbCrLf
         sSql = sSql & " [TOOL_NUM] [char](30) NOT NULL CONSTRAINT [DF_TlitTableNew_TOOL_NUM]  DEFAULT ('')," & vbCrLf
         sSql = sSql & " [TOOL_PARTREF] [char](30) NOT NULL CONSTRAINT [DF_TlitTableNew_TOOL_PARTREF]  DEFAULT ('')," & vbCrLf
         sSql = sSql & " [TOOL_CLASS] [char](12) NULL CONSTRAINT [DF_TlitTableNew_TOOL_CLASS]  DEFAULT ('')" & vbCrLf
         sSql = sSql & ") ON [PRIMARY]" & vbCrLf
         
         ExecuteScript False, sSql
      End If

      If (Not TableExists("TlitTableNew")) Then    'WRONG -- corrected in UpdateDatabase84
         sSql = "CREATE TABLE [dbo].[TlnhdTableNew](" & vbCrLf
         sSql = sSql & "   [TOOL_NUM] [char](30) NOT NULL," & vbCrLf
         sSql = sSql & "   [TOOL_DTADDED] [char](12) NULL," & vbCrLf
         sSql = sSql & "   [TOOL_CGPONUM] [char](30) NULL," & vbCrLf
         sSql = sSql & "   [TOOL_CUSTPONUM] [char](30) NULL," & vbCrLf
         sSql = sSql & "   [TOOL_CGSOPONUM] [char](30) NULL," & vbCrLf
         sSql = sSql & "   [TOOL_GOVOWNED] [char](10) NULL," & vbCrLf
         sSql = sSql & "   [TOOL_CLASS] [char](12) NULL," & vbCrLf
         sSql = sSql & "   [TOOL_HOMEBLDG] [char](30) NULL," & vbCrLf
         sSql = sSql & "   [TOOL_HOMEAISLE] [char](30) NULL," & vbCrLf
         sSql = sSql & "   [TOOL_SHELFNUM] [char](30) NULL," & vbCrLf
         sSql = sSql & "   [TOOL_GRID] [char](30) NULL," & vbCrLf
         sSql = sSql & "   [TOOL_LOCNUM] [char](30) NULL," & vbCrLf
         sSql = sSql & "   [TOOL_COMMENTS] [varchar](1020) NULL," & vbCrLf
         sSql = sSql & "   [TOOL_OWNER] [char](20) NULL," & vbCrLf
         sSql = sSql & "   [TOOL_ACCTTO] [char](20) NULL," & vbCrLf
         sSql = sSql & "   [TOOL_SN] [char](20) NULL," & vbCrLf
         sSql = sSql & "   [TOOL_MAKEPN] [char](20) NULL," & vbCrLf
         sSql = sSql & "   [TOOL_CAVNUM] [char](20) NULL," & vbCrLf
         sSql = sSql & "   [TOOL_DIM] [char](20) NULL," & vbCrLf
         sSql = sSql & "   [TOOL_BLANKPONUM] [char](20) NULL," & vbCrLf
         sSql = sSql & "   [TOOL_MONUM] [char](20) NULL," & vbCrLf
         sSql = sSql & "   [TOOL_TOOLMATSTAT] [char](20) NULL," & vbCrLf
         sSql = sSql & "   [TOOL_SRVSTAT] [char](20) NULL," & vbCrLf
         sSql = sSql & "   [TOOL_DISPSTAT] [char](20) NULL," & vbCrLf
         sSql = sSql & "   [TOOL_STORAGESTAT] [char](20) NULL" & vbCrLf
         sSql = sSql & " CONSTRAINT [PK_TlnhdTableNew_TOOL_NUM] PRIMARY KEY CLUSTERED" & vbCrLf
         sSql = sSql & "(" & vbCrLf
         sSql = sSql & "   [TOOL_NUM] Asc" & vbCrLf
         sSql = sSql & ")WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 80) ON [PRIMARY]" & vbCrLf
         sSql = sSql & ") ON [PRIMARY]"

         ExecuteScript False, sSql
         
         sSql = "ALTER TABLE TlnhdTableNew Add TOOL_ITAR int NULL CONSTRAINT DF__TlnhdTabl__TOOL_ITAR default(0)"
         ExecuteScript False, sSql

      End If
      
      If StoreProcedureExists("RptHistoryWCQListStats") Then
         sSql = "DROP PROCEDURE RptHistoryWCQListStats"
         ExecuteScript False, sSql
      End If
      
      
      If StoreProcedureExists("RptWCQListStats") Then
         sSql = "DROP PROCEDURE RptWCQListStats"
         ExecuteScript False, sSql
      End If
      
      sSql = "CREATE PROCEDURE [dbo].[RptHistoryWCQListStats]" & vbCrLf
      sSql = sSql & " @BeginDate  as varchar(30),@EdnDate as varchar(10)," & vbCrLf
      sSql = sSql & " @OpShop as varchar(12), @OpCenter as varchar(12)  " & vbCrLf
      sSql = sSql & " AS" & vbCrLf
      sSql = sSql & " BEGIN " & vbCrLf
      sSql = sSql & "   IF (@OpShop = '')  " & vbCrLf
      sSql = sSql & "   BEGIN   " & vbCrLf
      sSql = sSql & "      SET @OpShop = '%'    " & vbCrLf
      sSql = sSql & "   End " & vbCrLf
      sSql = sSql & "                " & vbCrLf
      sSql = sSql & "   IF (@OpCenter = '')    " & vbCrLf
      sSql = sSql & "   BEGIN   " & vbCrLf
      sSql = sSql & "      SET @OpCenter = '%'        " & vbCrLf
      sSql = sSql & "   End                       " & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   select distinct runstable.Runref, runstable.runno, OPCENTER, RUNSTATUS, RUNQTY," & vbCrLf
      sSql = sSql & "      runopcur,RnopTable.OPQDATE,  RnopTable.OPSCHEDDATE," & vbCrLf
      sSql = sSql & "      f.PrevOPNO, f.OPQDATE PREVQDATE, f.OPCOMPDATE PREVCOMPDATE," & vbCrLf
      sSql = sSql & "      DATEDIFF(day,f.OPCOMPDATE, RnopTable.OPQDATE) DtDiffQue," & vbCrLf
      sSql = sSql & "      DATEDIFF(day, f.OPCOMPDATE, GETDATE()) DtDiffNow" & vbCrLf
      sSql = sSql & "      from runstable,RnopTable," & vbCrLf
      sSql = sSql & "      (select a.runref, a.runno, b.OPNO PrevOPNO, OPQDATE, OPCOMPDATE," & vbCrLf
      sSql = sSql & "          ROW_NUMBER() OVER (PARTITION BY opref, oprun" & vbCrLf
      sSql = sSql & "                     ORDER BY opref DESC, oprun DESC, OPNO desc) as rn" & vbCrLf
      sSql = sSql & "        from runstable a,rnopTable b" & vbCrLf
      sSql = sSql & "        where a.runref = b.opref and" & vbCrLf
      sSql = sSql & "          a.RunNO = b.oprun And b.opno < a.runopcur" & vbCrLf
      sSql = sSql & "      ) as f" & vbCrLf
      sSql = sSql & "   where RnopTable.OPSCHEDDATE between @BeginDate and @EdnDate" & vbCrLf
      sSql = sSql & "      and RunsTable.runref =  f.runref AND RunsTable.runno = f.runno" & vbCrLf
      sSql = sSql & "      and RnopTable.opref = RunsTable.runref AND RunsTable.runno = RnopTable.OPRUN" & vbCrLf
      sSql = sSql & "      and RunsTable.runopcur = RnopTable.Opno" & vbCrLf
      sSql = sSql & "      and RnopTable.OPSHOP LIKE @OpShop AND RnopTable.OPCENTER LIKE @OpCenter" & vbCrLf
      sSql = sSql & "       --AND RnopTable.OPCOMPLETE = 0" & vbCrLf
      sSql = sSql & "      --and f.rn = 1" & vbCrLf
      sSql = sSql & " End"
         
      ExecuteScript False, sSql
      
      
      sSql = "CREATE PROCEDURE [dbo].[RptWCQListStats]" & vbCrLf
      sSql = sSql & " @BeginDate  as varchar(30),@EdnDate as varchar(10)," & vbCrLf
      sSql = sSql & " @OpShop as varchar(12), @OpCenter as varchar(12)  " & vbCrLf
      sSql = sSql & " AS" & vbCrLf
      sSql = sSql & " BEGIN " & vbCrLf
      sSql = sSql & " IF (@OpShop = '')  " & vbCrLf
      sSql = sSql & " BEGIN   " & vbCrLf
      sSql = sSql & "     SET @OpShop = '%'    " & vbCrLf
      sSql = sSql & " End " & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & " IF (@OpCenter = '')    " & vbCrLf
      sSql = sSql & " BEGIN   " & vbCrLf
      sSql = sSql & "     SET @OpCenter = '%'        " & vbCrLf
      sSql = sSql & " End                       " & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & " select distinct runstable.Runref, runstable.runno, OPCENTER, RUNSTATUS, RUNQTY," & vbCrLf
      sSql = sSql & "     runopcur,RnopTable.OPQDATE,  RnopTable.OPSCHEDDATE," & vbCrLf
      sSql = sSql & "     f.PrevOPNO, f.OPQDATE PREVQDATE, f.OPSCHEDDATE PREVSCHEDDATE," & vbCrLf
      sSql = sSql & "     DATEDIFF(day,f.OPSCHEDDATE, RnopTable.OPQDATE) DtDiffQue," & vbCrLf
      sSql = sSql & "     DATEDIFF(day, f.OPSCHEDDATE, GETDATE()) DtDiffNow" & vbCrLf
      sSql = sSql & "    from runstable,RnopTable," & vbCrLf
      sSql = sSql & "    (select a.runref, a.runno, b.OPNO PrevOPNO, OPQDATE, OPSCHEDDATE," & vbCrLf
      sSql = sSql & "          ROW_NUMBER() OVER (PARTITION BY opref, oprun" & vbCrLf
      sSql = sSql & "                        ORDER BY opref DESC, oprun DESC, OPNO desc) as rn" & vbCrLf
      sSql = sSql & "       from runstable a,rnopTable b" & vbCrLf
      sSql = sSql & "       where a.runref = b.opref and" & vbCrLf
      sSql = sSql & "          a.RunNO = b.oprun And b.opno < a.runopcur" & vbCrLf
      sSql = sSql & "    ) as f" & vbCrLf
      sSql = sSql & " where RunsTable.RunSched between @BeginDate and @EdnDate" & vbCrLf
      sSql = sSql & "    and RunsTable.runref =  f.runref AND RunsTable.runno = f.runno" & vbCrLf
      sSql = sSql & "    and RnopTable.opref = RunsTable.runref AND RunsTable.runno = RnopTable.OPRUN" & vbCrLf
      sSql = sSql & "    and RunsTable.runopcur = RnopTable.Opno" & vbCrLf
      sSql = sSql & "    and RnopTable.OPSHOP LIKE @OpShop AND RnopTable.OPCENTER LIKE @OpCenter" & vbCrLf
      sSql = sSql & "    and f.rn = 1" & vbCrLf
      sSql = sSql & " End"
      
      ExecuteScript False, sSql
      
      ' update the version
      ExecuteScript False, "Update Version Set Version = " & newver
   
   End If
End Function
   
   
'''''''''''''''''''''''''''''''''

Private Function UpdateDatabase79()

   Dim SQL As String
   SQL = ""
   
   newver = 154
   If ver < newver Then
   
        clsADOCon.ADOErrNum = 0
        
'''''''''''''''''''''''''''''''''''''''''''''''''''
      
' required for Vendor Statement Report
SQL = "alter table EsReportVendorStmt add Journal varchar(12) NULL" & vbCrLf
ExecuteScript False, SQL

' column does not exist in AWJ database, so just add it in this script
SQL = "alter table ComnTable add COWARNSERVICEOPOPEN int NOT NULL DEFAULT(0)" & vbCrLf
ExecuteScript False, SQL

' add flag to turn on sheete inventory functions
SQL = "alter table ComnTable add COUSESHEETINVENTORY int NOT NULL DEFAULT(0) " & vbCrLf
ExecuteScript False, SQL

' lot header additions
SQL = "alter table LohdTable add LOTRESERVEDBY varchar(4)" & vbCrLf
ExecuteScript False, SQL
SQL = "alter table LohdTable add LOTRESERVEDON DATETIME" & vbCrLf
ExecuteScript False, SQL
SQL = "alter table LohdTable add LOTCERT varchar(40)" & vbCrLf
ExecuteScript False, SQL

' lot item additions
SQL = "alter table LoitTable add LOIHEIGHT decimal(12,4)" & vbCrLf
ExecuteScript False, SQL
SQL = "alter table LoitTable add LOILENGTH decimal(12,4)" & vbCrLf
ExecuteScript False, SQL
SQL = "alter table LoitTable add LOIAREA as cast(isnull(LOIHEIGHT,0) * isnull(LOILENGTH,0) as decimal(12,4))" & vbCrLf
ExecuteScript False, SQL
SQL = "alter table LoitTable add LOIUSER varchar(4)" & vbCrLf
ExecuteScript False, SQL
SQL = "alter table LoitTable add LOIPARENTREC int" & vbCrLf
ExecuteScript False, SQL
SQL = "alter table LoitTable add LOISONUMBER int" & vbCrLf
ExecuteScript False, SQL
SQL = "alter table LoitTable add LOISHEETACTTYPE char(2)        -- PK,RS" & vbCrLf
ExecuteScript False, SQL
SQL = "alter table LoitTable add LOIINACTIVE bit                -- = 1 to exclude from future sheet processes" & vbCrLf
ExecuteScript False, SQL

SQL = "if object_id('SheetPick') IS NOT NULL" & vbCrLf
SQL = SQL & "    drop procedure SheetPick" & vbCrLf
ExecuteScript False, SQL

SQL = "create procedure dbo.SheetPick" & vbCrLf
SQL = SQL & "   @UserLotNo varchar(40),     -- lotuserlotid" & vbCrLf
SQL = SQL & "   @User varchar(4)," & vbCrLf
SQL = SQL & "   @SO int" & vbCrLf
SQL = SQL & "   " & vbCrLf
SQL = SQL & "as" & vbCrLf
SQL = SQL & "/*" & vbCrLf
SQL = SQL & "Pick a sheet" & vbCrLf
SQL = SQL & "exec SheetPick '029373-1-A','MGR',222222" & vbCrLf
SQL = SQL & "*/" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- find all rectangles in lot" & vbCrLf
SQL = SQL & "begin tran" & vbCrLf
SQL = SQL & "create table #rect" & vbCrLf
SQL = SQL & "(" & vbCrLf
SQL = SQL & "   id int identity," & vbCrLf
SQL = SQL & "   ParentRecord int," & vbCrLf
SQL = SQL & "   Height decimal(12,4)," & vbCrLf
SQL = SQL & "   Length decimal(12,4)," & vbCrLf
SQL = SQL & "   NewRecord int," & vbCrLf
SQL = SQL & "   Qty decimal(12,4)" & vbCrLf
SQL = SQL & ")" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "declare @LotNo char(15)" & vbCrLf
SQL = SQL & "select @LotNo = LOTNUMBER from LohdTable where LOTUSERLOTID = @UserLotNo" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "insert #rect (ParentRecord,Height,Length,NewRecord,Qty)" & vbCrLf
SQL = SQL & "select li.LOIRECORD,li.LOIHEIGHT,li.LOILENGTH,0,cast(li.LOIHEIGHT*li.LOILENGTH as decimal(12,4)) from LoitTable li" & vbCrLf
SQL = SQL & "   join LohdTable lh on lh.LOTNUMBER = li.LOINUMBER" & vbCrLf
SQL = SQL & "   where lh.LOTNUMBER = @LotNo and LOIQUANTITY > 0 " & vbCrLf
SQL = SQL & "   --and LOTRESERVEDON is not null" & vbCrLf
SQL = SQL & "   and (li.LOIINACTIVE is null or li.LOIINACTIVE = 0)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- assign new recordnumbers" & vbCrLf
SQL = SQL & "declare @max int" & vbCrLf
SQL = SQL & "select @max = max(LOIRECORD) from LoitTable where LOINUMBER = @LotNo" & vbCrLf
SQL = SQL & "update #rect set NewRecord = @max + id" & vbCrLf
SQL = SQL & "   " & vbCrLf
SQL = SQL & "--select * from #rect  " & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "declare @partRef varchar(30), @currentTime datetime, @uom char(2), @type int" & vbCrLf
SQL = SQL & "declare @unitCost decimal(12,4), @nextINNUMBER int, @totalQty decimal(12,4)" & vbCrLf
SQL = SQL & "select @partRef = LOTPARTREF, @unitCost = LOTUNITCOST, @totalQty = LOTREMAININGQTY from LohdTable where LOTNUMBER = @LotNo" & vbCrLf
SQL = SQL & "select @uom = PAUNITS from PartTable where PARTREF = @partRef" & vbCrLf
SQL = SQL & "set @currentTime = getdate()" & vbCrLf
SQL = SQL & "select @nextINNUMBER = max(INNUMBER) + 1 from InvaTable" & vbCrLf
SQL = SQL & "set @type = 19     -- manual adjustment" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- deactivate rectangles being picked so they won't show up again" & vbCrLf
SQL = SQL & "Update li" & vbCrLf
SQL = SQL & "   set li.LOIINACTIVE = 1" & vbCrLf
SQL = SQL & "from LoitTable li " & vbCrLf
SQL = SQL & "join #rect r on li.LOINUMBER = @LotNo and li.LOIRECORD = r.ParentRecord" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "--select * from LoitTable li " & vbCrLf
SQL = SQL & "--join #rect r on li.LOINUMBER = @LotNo and li.LOIRECORD = r.ParentRecord" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- create new LoitTable record to zero lot quantity" & vbCrLf
SQL = SQL & "INSERT INTO [dbo].[LoitTable]" & vbCrLf
SQL = SQL & "           ([LOINUMBER]" & vbCrLf
SQL = SQL & "           ,[LOIRECORD]" & vbCrLf
SQL = SQL & "           ,[LOITYPE]" & vbCrLf
SQL = SQL & "           ,[LOIPARTREF]" & vbCrLf
SQL = SQL & "           ,[LOIADATE]" & vbCrLf
SQL = SQL & "           ,[LOIPDATE]" & vbCrLf
SQL = SQL & "           ,[LOIQUANTITY]" & vbCrLf
SQL = SQL & "           ,[LOIMOPARTREF]" & vbCrLf
SQL = SQL & "           ,[LOIMORUNNO]" & vbCrLf
SQL = SQL & "           ,[LOIPONUMBER]" & vbCrLf
SQL = SQL & "           ,[LOIPOITEM]" & vbCrLf
SQL = SQL & "           ,[LOIPOREV]" & vbCrLf
SQL = SQL & "           ,[LOIPSNUMBER]" & vbCrLf
SQL = SQL & "           ,[LOIPSITEM]" & vbCrLf
SQL = SQL & "           ,[LOICUSTINVNO]" & vbCrLf
SQL = SQL & "           ,[LOICUST]" & vbCrLf
SQL = SQL & "           ,[LOIVENDINVNO]" & vbCrLf
SQL = SQL & "           ,[LOIVENDOR]" & vbCrLf
SQL = SQL & "           ,[LOIACTIVITY]" & vbCrLf
SQL = SQL & "           ,[LOICOMMENT]" & vbCrLf
SQL = SQL & "           ,[LOIUNITS]" & vbCrLf
SQL = SQL & "           ,[LOIMOPKCANCEL]" & vbCrLf
SQL = SQL & "           ,[LOIHEIGHT]" & vbCrLf
SQL = SQL & "           ,[LOILENGTH]" & vbCrLf
SQL = SQL & "           ,[LOIUSER]" & vbCrLf
SQL = SQL & "          ,LOIPARENTREC" & vbCrLf
SQL = SQL & "           ,[LOISONUMBER]" & vbCrLf
SQL = SQL & "          ,LOISHEETACTTYPE" & vbCrLf
SQL = SQL & "          )" & vbCrLf
SQL = SQL & "     SELECT" & vbCrLf
SQL = SQL & "           @LotNo" & vbCrLf
SQL = SQL & "           ,r.NewRecord" & vbCrLf
SQL = SQL & "           ,@type              -- manual adjustment" & vbCrLf
SQL = SQL & "           ,@partRef" & vbCrLf
SQL = SQL & "           ,@currentTime" & vbCrLf
SQL = SQL & "           ,@currentTime" & vbCrLf
SQL = SQL & "           ,-r.Qty" & vbCrLf
SQL = SQL & "           ,null   --LOIMOPARTREF, char(30),>" & vbCrLf
SQL = SQL & "           ,null   --<LOIMORUNNO, int,>" & vbCrLf
SQL = SQL & "           ,null   --<LOIPONUMBER, int,>" & vbCrLf
SQL = SQL & "           ,null   --<LOIPOITEM, smallint,>" & vbCrLf
SQL = SQL & "           ,null   --<LOIPOREV, char(2),>" & vbCrLf
SQL = SQL & "           ,null   --<LOIPSNUMBER, char(8),>" & vbCrLf
SQL = SQL & "           ,null   --<LOIPSITEM, smallint,>" & vbCrLf
SQL = SQL & "           ,null   --<LOICUSTINVNO, int,>" & vbCrLf
SQL = SQL & "           ,null   --<LOICUST, char(10),>" & vbCrLf
SQL = SQL & "           ,null   --<LOIVENDINVNO, char(20),>" & vbCrLf
SQL = SQL & "           ,null   --<LOIVENDOR, char(10),>" & vbCrLf
SQL = SQL & "           ,null   --<LOIACTIVITY, int,> points to InvaTable.INNO when IA is created" & vbCrLf
SQL = SQL & "           ,'sheet pick'   --<LOICOMMENT, varchar(40),>" & vbCrLf
SQL = SQL & "           ,@uom   --<LOIUNITS, char(2),>" & vbCrLf
SQL = SQL & "           ,null   --<LOIMOPKCANCEL, smallint,>" & vbCrLf
SQL = SQL & "           ,r.HEIGHT   --<LOIHEIGHT, decimal(12,4),>" & vbCrLf
SQL = SQL & "           ,r.LENGTH   --<LOILENGTH, decimal(12,4),>" & vbCrLf
SQL = SQL & "           ,@User          --<LOIUSER, varchar(4),>" & vbCrLf
SQL = SQL & "          ,r.ParentRecord  --LOIPARENTREC" & vbCrLf
SQL = SQL & "           ,@SO                --<LOISONUMBER, int,>" & vbCrLf
SQL = SQL & "          ,'PK'            --LOISHEETACTTYPE" & vbCrLf
SQL = SQL & "       from #rect r" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "--select * from LoitTable li " & vbCrLf
SQL = SQL & "--join #rect r on li.LOINUMBER = @LotNo" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- set lot quantity = 0" & vbCrLf
SQL = SQL & "update LohdTable set LOTREMAININGQTY = 0 where LOTNUMBER = @LotNo" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- create new IA record to reduce part quantity" & vbCrLf
SQL = SQL & "INSERT INTO [dbo].[InvaTable]" & vbCrLf
SQL = SQL & "           ([INTYPE]" & vbCrLf
SQL = SQL & "           ,[INPART]" & vbCrLf
SQL = SQL & "           ,[INREF1]" & vbCrLf
SQL = SQL & "           ,[INREF2]" & vbCrLf
SQL = SQL & "           ,[INPDATE]" & vbCrLf
SQL = SQL & "           ,[INADATE]" & vbCrLf
SQL = SQL & "           ,[INPQTY]" & vbCrLf
SQL = SQL & "           ,[INAQTY]" & vbCrLf
SQL = SQL & "           ,[INAMT]" & vbCrLf
SQL = SQL & "           ,[INTOTMATL]" & vbCrLf
SQL = SQL & "           ,[INTOTLABOR]" & vbCrLf
SQL = SQL & "           ,[INTOTEXP]" & vbCrLf
SQL = SQL & "           ,[INTOTOH]" & vbCrLf
SQL = SQL & "           ,[INTOTHRS]" & vbCrLf
SQL = SQL & "           ,[INCREDITACCT]" & vbCrLf
SQL = SQL & "           ,[INDEBITACCT]" & vbCrLf
SQL = SQL & "           ,[INGLJOURNAL]" & vbCrLf
SQL = SQL & "           ,[INGLPOSTED]" & vbCrLf
SQL = SQL & "           ,[INGLDATE]" & vbCrLf
SQL = SQL & "           ,[INMOPART]" & vbCrLf
SQL = SQL & "           ,[INMORUN]" & vbCrLf
SQL = SQL & "           ,[INSONUMBER]" & vbCrLf
SQL = SQL & "           ,[INSOITEM]" & vbCrLf
SQL = SQL & "           ,[INSOREV]" & vbCrLf
SQL = SQL & "           ,[INPONUMBER]" & vbCrLf
SQL = SQL & "           ,[INPORELEASE]" & vbCrLf
SQL = SQL & "           ,[INPOITEM]" & vbCrLf
SQL = SQL & "           ,[INPOREV]" & vbCrLf
SQL = SQL & "           ,[INPSNUMBER]" & vbCrLf
SQL = SQL & "           ,[INPSITEM]" & vbCrLf
SQL = SQL & "           ,[INWIPLABACCT]" & vbCrLf
SQL = SQL & "           ,[INWIPMATACCT]" & vbCrLf
SQL = SQL & "           ,[INWIPOHDACCT]" & vbCrLf
SQL = SQL & "           ,[INWIPEXPACCT]" & vbCrLf
SQL = SQL & "           ,[INNUMBER]" & vbCrLf
SQL = SQL & "           ,[INLOTNUMBER]" & vbCrLf
SQL = SQL & "           ,[INUSER]" & vbCrLf
SQL = SQL & "           ,[INUNITS]" & vbCrLf
SQL = SQL & "           ,[INDRLABACCT]" & vbCrLf
SQL = SQL & "           ,[INDRMATACCT]" & vbCrLf
SQL = SQL & "           ,[INDREXPACCT]" & vbCrLf
SQL = SQL & "           ,[INDROHDACCT]" & vbCrLf
SQL = SQL & "           ,[INCRLABACCT]" & vbCrLf
SQL = SQL & "           ,[INCRMATACCT]" & vbCrLf
SQL = SQL & "           ,[INCREXPACCT]" & vbCrLf
SQL = SQL & "           ,[INCROHDACCT]" & vbCrLf
SQL = SQL & "           ,[INLOTTRACK]" & vbCrLf
SQL = SQL & "           ,[INUSEACTUALCOST]" & vbCrLf
SQL = SQL & "           ,[INCOSTEDBY]" & vbCrLf
SQL = SQL & "           ,[INMAINTCOSTED])" & vbCrLf
SQL = SQL & "     select" & vbCrLf
SQL = SQL & "           @type               --<INTYPE, int,>" & vbCrLf
SQL = SQL & "           ,@partRef           --char(30),>" & vbCrLf
SQL = SQL & "           ,'Manual Adjustment'    --<INREF1, char(20),>" & vbCrLf
SQL = SQL & "           ,'Sheet Inventory'  --<INREF2, char(40),>" & vbCrLf
SQL = SQL & "           ,@currentTime       --<INPDATE, smalldatetime,>" & vbCrLf
SQL = SQL & "           ,@currentTime       --<INADATE, smalldatetime,>" & vbCrLf
SQL = SQL & "           ,-r.Qty         --<INPQTY, decimal(12,4),>" & vbCrLf
SQL = SQL & "           ,-r.Qty         --<INAQTY, decimal(12,4),>" & vbCrLf
SQL = SQL & "           ,@unitCost          -- <INAMT, decimal(12,4),>" & vbCrLf
SQL = SQL & "           ,0.0                    --<INTOTMATL, decimal(12,4),>" & vbCrLf
SQL = SQL & "           ,0.0                    --<INTOTLABOR, decimal(12,4),>" & vbCrLf
SQL = SQL & "           ,0.0                    --<INTOTEXP, decimal(12,4),>" & vbCrLf
SQL = SQL & "           ,0.0                    --<INTOTOH, decimal(12,4),>" & vbCrLf
SQL = SQL & "           ,0.0                    --<INTOTHRS, decimal(12,4),>" & vbCrLf
SQL = SQL & "           ,''                 --<INCREDITACCT, char(12),>" & vbCrLf
SQL = SQL & "           ,''                 --<INDEBITACCT, char(12),>" & vbCrLf
SQL = SQL & "           ,''                 --<INGLJOURNAL, char(12),>" & vbCrLf
SQL = SQL & "           ,0                  --<INGLPOSTED, tinyint,>" & vbCrLf
SQL = SQL & "           ,null               --<INGLDATE, smalldatetime,>" & vbCrLf
SQL = SQL & "           ,''                 --<INMOPART, char(30),>" & vbCrLf
SQL = SQL & "           ,0                  --<INMORUN, int,>" & vbCrLf
SQL = SQL & "           ,0                  --<INSONUMBER, int,>" & vbCrLf
SQL = SQL & "           ,0                  --<INSOITEM, int,>" & vbCrLf
SQL = SQL & "           ,''                 --<INSOREV, char(2),>" & vbCrLf
SQL = SQL & "           ,0                  --<INPONUMBER, int,>" & vbCrLf
SQL = SQL & "           ,0                  --<INPORELEASE, smallint,>" & vbCrLf
SQL = SQL & "           ,0                  --<INPOITEM, smallint,>" & vbCrLf
SQL = SQL & "           ,''                 --<INPOREV, char(2),>" & vbCrLf
SQL = SQL & "           ,''                 --<INPSNUMBER, char(8),>" & vbCrLf
SQL = SQL & "           ,0                  --<INPSITEM, smallint,>" & vbCrLf
SQL = SQL & "           ,''                 --<INWIPLABACCT, char(12),>" & vbCrLf
SQL = SQL & "           ,''                 --<INWIPMATACCT, char(12),>" & vbCrLf
SQL = SQL & "           ,''                 --<INWIPOHDACCT, char(12),>" & vbCrLf
SQL = SQL & "           ,''                 --<INWIPEXPACCT, char(12),>" & vbCrLf
SQL = SQL & "           ,@nextINNUMBER      --<INNUMBER, int,>" & vbCrLf
SQL = SQL & "           ,@LotNo             --<INLOTNUMBER, char(15),>" & vbCrLf
SQL = SQL & "           ,@User              --<INUSER, char(4),>" & vbCrLf
SQL = SQL & "           ,@uom               --<INUNITS, char(2),>" & vbCrLf
SQL = SQL & "           ,''                 --<INDRLABACCT, char(12),>" & vbCrLf
SQL = SQL & "           ,''                 --<INDRMATACCT, char(12),>" & vbCrLf
SQL = SQL & "           ,''                 --<INDREXPACCT, char(12),>" & vbCrLf
SQL = SQL & "           ,''                 --<INDROHDACCT, char(12),>" & vbCrLf
SQL = SQL & "           ,''                 --<INCRLABACCT, char(12),>" & vbCrLf
SQL = SQL & "           ,''                 --<INCRMATACCT, char(12),>" & vbCrLf
SQL = SQL & "           ,''                 --<INCREXPACCT, char(12),>" & vbCrLf
SQL = SQL & "           ,''                 --<INCROHDACCT, char(12),>" & vbCrLf
SQL = SQL & "           ,null               --<INLOTTRACK, bit,>" & vbCrLf
SQL = SQL & "           ,null               --<INUSEACTUALCOST, bit,>" & vbCrLf
SQL = SQL & "           ,null               --<INCOSTEDBY, char(4),>" & vbCrLf
SQL = SQL & "           ,0                  --<INMAINTCOSTED, int,>)" & vbCrLf
SQL = SQL & "       from #rect r" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- now update part QOH" & vbCrLf
SQL = SQL & "update PartTable set PAQOH = PAQOH - @totalQty where PARTREF = @partRef" & vbCrLf
SQL = SQL & "commit tran" & vbCrLf
SQL = SQL & "" & vbCrLf
ExecuteScript False, SQL

SQL = "if object_id('SheetRestock') IS NOT NULL" & vbCrLf
SQL = SQL & "    drop procedure SheetRestock" & vbCrLf
ExecuteScript False, SQL

SQL = "create procedure dbo.SheetRestock" & vbCrLf
SQL = SQL & "   @UserLotNo varchar(40)," & vbCrLf
SQL = SQL & "   @User varchar(4)," & vbCrLf
SQL = SQL & "   @Comments varchar(2048)," & vbCrLf
SQL = SQL & "   @Location varchar(4)," & vbCrLf
SQL = SQL & "   @Params varchar(2000)   -- LOIRECORD,NEWHT,NEWLEN,... repeat (include comma at end)" & vbCrLf
SQL = SQL & "as" & vbCrLf
SQL = SQL & "/*" & vbCrLf
SQL = SQL & "restock sheet LOI records" & vbCrLf
SQL = SQL & "exec SheetRestock '029373-1-A', 'MGR', '2,36,96,0,12,72,'" & vbCrLf
SQL = SQL & "*/" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "begin tran" & vbCrLf
SQL = SQL & "create table #rect" & vbCrLf
SQL = SQL & "(" & vbCrLf
SQL = SQL & "   ParentRecord int," & vbCrLf
SQL = SQL & "   NewHeight decimal(12,4)," & vbCrLf
SQL = SQL & "   NewLength decimal(12,4)," & vbCrLf
SQL = SQL & "   NewRecord int," & vbCrLf
SQL = SQL & "   Qty decimal(12,4)," & vbCrLf
SQL = SQL & "   NewIANumber int" & vbCrLf
SQL = SQL & ")" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "declare @nextRecord int, @nextIANumber int" & vbCrLf
SQL = SQL & "declare @LotNo char(15), @id int, @SO int" & vbCrLf
SQL = SQL & "select @LotNo = LOTNUMBER from LohdTable where LOTUSERLOTID = @UserLotNo" & vbCrLf
SQL = SQL & "select @nextRecord = max(LOIRECORD) + 1 , @SO = max(LOISONUMBER) from LoitTable where LOINUMBER = @LotNo" & vbCrLf
SQL = SQL & "select @nextIANumber = max(INNUMBER) + 1 from InvaTable" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- first update the lot header" & vbCrLf
SQL = SQL & "update LohdTable set LOTCOMMENTS = @Comments, LOTLOCATION = @Location where LOTNUMBER = @LotNo" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- extract parameters" & vbCrLf
SQL = SQL & "DECLARE @start INT, @end INT" & vbCrLf
SQL = SQL & "declare @stringId varchar(10), @stringHt varchar(10), @stringLen varchar(10)" & vbCrLf
SQL = SQL & "SELECT @start = 1, @end = CHARINDEX(',', @Params) " & vbCrLf
SQL = SQL & "WHILE @start < LEN(@Params) + 1 BEGIN " & vbCrLf
SQL = SQL & "    IF @end = 0 break" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "    set @stringId = SUBSTRING(@Params, @start, @end - @start)" & vbCrLf
SQL = SQL & "    SET @start = @end + 1 " & vbCrLf
SQL = SQL & "    SET @end = CHARINDEX(',', @Params, @start)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "    IF @end = 0 break" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "    set @stringHt = SUBSTRING(@Params, @start, @end - @start)" & vbCrLf
SQL = SQL & "    SET @start = @end + 1 " & vbCrLf
SQL = SQL & "    SET @end = CHARINDEX(',', @Params, @start)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "    IF @end = 0 break" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "    set @stringLen = SUBSTRING(@Params, @start, @end - @start)" & vbCrLf
SQL = SQL & "    SET @start = @end + 1 " & vbCrLf
SQL = SQL & "    SET @end = CHARINDEX(',', @Params, @start)" & vbCrLf
SQL = SQL & "   " & vbCrLf
SQL = SQL & "   declare @ht decimal(12,4), @len decimal(12,4)" & vbCrLf
SQL = SQL & "   set @ht = cast(@stringHt as decimal(12,4))" & vbCrLf
SQL = SQL & "   set @len = cast(@stringLen as decimal(12,4))" & vbCrLf
SQL = SQL & "   insert into #rect (ParentRecord, NewHeight, NewLength, NewRecord, NewIANumber)" & vbCrLf
SQL = SQL & "   values (cast(@stringId as int), @ht, @len," & vbCrLf
SQL = SQL & "       case when @ht*@len = 0 then 0 else @nextRecord end," & vbCrLf
SQL = SQL & "       case when @ht*@len = 0 then 0 else @nextIANumber end)" & vbCrLf
SQL = SQL & "   if (@ht*@len) <> 0 " & vbCrLf
SQL = SQL & "   begin" & vbCrLf
SQL = SQL & "       set @nextRecord = @nextRecord + 1" & vbCrLf
SQL = SQL & "       set @nextIANumber = @nextIANumber + 1" & vbCrLf
SQL = SQL & "   end" & vbCrLf
SQL = SQL & "END " & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "update #rect set Qty = NewHeight * NewLength" & vbCrLf
SQL = SQL & "update #rect set ParentRecord = isnull((select top 1 ParentRecord from #rect where ParentRecord <> 0 ),0)" & vbCrLf
SQL = SQL & "where ParentRecord = 0" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "--select * from #rect" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "declare @partRef varchar(30), @currentTime datetime, @uom char(2), @type int" & vbCrLf
SQL = SQL & "declare @unitCost decimal(12,4), @nextINNUMBER int, @totalQty decimal(12,4)" & vbCrLf
SQL = SQL & "select @partRef = LOTPARTREF, @unitCost = LOTUNITCOST, @totalQty = LOTREMAININGQTY from LohdTable where LOTNUMBER = @LotNo" & vbCrLf
SQL = SQL & "select @uom = PAUNITS from PartTable where PARTREF = @partRef" & vbCrLf
SQL = SQL & "set @currentTime = getdate()" & vbCrLf
SQL = SQL & "select @nextINNUMBER = max(INNUMBER) + 1 from InvaTable" & vbCrLf
SQL = SQL & "set @type = 19     -- manual adjustment" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- update existing lot items" & vbCrLf
SQL = SQL & "Update li" & vbCrLf
SQL = SQL & "   set LOIINACTIVE = 1" & vbCrLf
SQL = SQL & "from LoitTable li " & vbCrLf
SQL = SQL & "join #rect r on li.LOINUMBER = @LotNo and li.LOIRECORD = r.ParentRecord" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "--select distinct li.* from LoitTable li " & vbCrLf
SQL = SQL & "--join #rect r on li.LOINUMBER = @LotNo and li.LOIRECORD = r.ParentRecord" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- remove rectangles with no quantity remaining.  These items will not be restocked." & vbCrLf
SQL = SQL & "delete from #rect where Qty = 0" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- create new lot items" & vbCrLf
SQL = SQL & "INSERT INTO [dbo].[LoitTable]" & vbCrLf
SQL = SQL & "           ([LOINUMBER]" & vbCrLf
SQL = SQL & "           ,[LOIRECORD]" & vbCrLf
SQL = SQL & "           ,[LOITYPE]" & vbCrLf
SQL = SQL & "           ,[LOIPARTREF]" & vbCrLf
SQL = SQL & "           ,[LOIADATE]" & vbCrLf
SQL = SQL & "           ,[LOIPDATE]" & vbCrLf
SQL = SQL & "           ,[LOIQUANTITY]" & vbCrLf
SQL = SQL & "           ,[LOIMOPARTREF]" & vbCrLf
SQL = SQL & "           ,[LOIMORUNNO]" & vbCrLf
SQL = SQL & "           ,[LOIPONUMBER]" & vbCrLf
SQL = SQL & "           ,[LOIPOITEM]" & vbCrLf
SQL = SQL & "           ,[LOIPOREV]" & vbCrLf
SQL = SQL & "           ,[LOIPSNUMBER]" & vbCrLf
SQL = SQL & "           ,[LOIPSITEM]" & vbCrLf
SQL = SQL & "           ,[LOICUSTINVNO]" & vbCrLf
SQL = SQL & "           ,[LOICUST]" & vbCrLf
SQL = SQL & "           ,[LOIVENDINVNO]" & vbCrLf
SQL = SQL & "           ,[LOIVENDOR]" & vbCrLf
SQL = SQL & "           ,[LOIACTIVITY]" & vbCrLf
SQL = SQL & "           ,[LOICOMMENT]" & vbCrLf
SQL = SQL & "           ,[LOIUNITS]" & vbCrLf
SQL = SQL & "           ,[LOIMOPKCANCEL]" & vbCrLf
SQL = SQL & "           ,[LOIHEIGHT]" & vbCrLf
SQL = SQL & "           ,[LOILENGTH]" & vbCrLf
SQL = SQL & "           ,[LOIUSER]" & vbCrLf
SQL = SQL & "          ,LOIPARENTREC" & vbCrLf
SQL = SQL & "           ,[LOISONUMBER]" & vbCrLf
SQL = SQL & "          ,LOISHEETACTTYPE" & vbCrLf
SQL = SQL & "          )" & vbCrLf
SQL = SQL & "     SELECT" & vbCrLf
SQL = SQL & "           @LotNo" & vbCrLf
SQL = SQL & "           ,r.NewRecord" & vbCrLf
SQL = SQL & "           ,@type              -- manual adjustment" & vbCrLf
SQL = SQL & "           ,@partRef" & vbCrLf
SQL = SQL & "           ,@currentTime" & vbCrLf
SQL = SQL & "           ,@currentTime" & vbCrLf
SQL = SQL & "           ,r.Qty" & vbCrLf
SQL = SQL & "           ,null   --LOIMOPARTREF, char(30),>" & vbCrLf
SQL = SQL & "           ,null   --<LOIMORUNNO, int,>" & vbCrLf
SQL = SQL & "           ,null   --<LOIPONUMBER, int,>" & vbCrLf
SQL = SQL & "           ,null   --<LOIPOITEM, smallint,>" & vbCrLf
SQL = SQL & "           ,null   --<LOIPOREV, char(2),>" & vbCrLf
SQL = SQL & "           ,null   --<LOIPSNUMBER, char(8),>" & vbCrLf
SQL = SQL & "           ,null   --<LOIPSITEM, smallint,>" & vbCrLf
SQL = SQL & "           ,null   --<LOICUSTINVNO, int,>" & vbCrLf
SQL = SQL & "           ,null   --<LOICUST, char(10),>" & vbCrLf
SQL = SQL & "           ,null   --<LOIVENDINVNO, char(20),>" & vbCrLf
SQL = SQL & "           ,null   --<LOIVENDOR, char(10),>" & vbCrLf
SQL = SQL & "           ,null   --<LOIACTIVITY, int,> points to InvaTable.INNO when IA is created" & vbCrLf
SQL = SQL & "           ,'sheet restock'    --<LOICOMMENT, varchar(40),>" & vbCrLf
SQL = SQL & "           ,@uom   --<LOIUNITS, char(2),>" & vbCrLf
SQL = SQL & "           ,null   --<LOIMOPKCANCEL, smallint,>" & vbCrLf
SQL = SQL & "           ,r.NewHeight    --<LOIHEIGHT, decimal(12,4),>" & vbCrLf
SQL = SQL & "           ,r.NewLength    --<LOILENGTH, decimal(12,4),>" & vbCrLf
SQL = SQL & "           ,@User      --<LOIUSER, varchar(4),>" & vbCrLf
SQL = SQL & "          ,r.ParentRecord  --LOIPICKEDFROMREC" & vbCrLf
SQL = SQL & "           ,@SO        --<LOISONUMBER, int,>" & vbCrLf
SQL = SQL & "          ,'RS'    --LOISHEETACTTYPE" & vbCrLf
SQL = SQL & "       from #rect r" & vbCrLf
SQL = SQL & "       where r.Qty <> 0" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "--select distinct li.* from LoitTable li " & vbCrLf
SQL = SQL & "--join #rect r on li.LOINUMBER = @LotNo and li.LOIRECORD > 1" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- set LOTREMAININGQTY and remove reservation" & vbCrLf
SQL = SQL & "declare @sum decimal(12,4)" & vbCrLf
SQL = SQL & "select @sum = sum(Qty) from #rect" & vbCrLf
SQL = SQL & "update LohdTable " & vbCrLf
SQL = SQL & "   set LOTREMAININGQTY = LOTREMAININGQTY + @sum," & vbCrLf
SQL = SQL & "   LOTRESERVEDBY = NULL," & vbCrLf
SQL = SQL & "   LOTRESERVEDON = NULL" & vbCrLf
SQL = SQL & "   where LOTNUMBER = @LotNo" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- create new ia items" & vbCrLf
SQL = SQL & "INSERT INTO [dbo].[InvaTable]" & vbCrLf
SQL = SQL & "           ([INTYPE]" & vbCrLf
SQL = SQL & "           ,[INPART]" & vbCrLf
SQL = SQL & "           ,[INREF1]" & vbCrLf
SQL = SQL & "           ,[INREF2]" & vbCrLf
SQL = SQL & "           ,[INPDATE]" & vbCrLf
SQL = SQL & "           ,[INADATE]" & vbCrLf
SQL = SQL & "           ,[INPQTY]" & vbCrLf
SQL = SQL & "           ,[INAQTY]" & vbCrLf
SQL = SQL & "           ,[INAMT]" & vbCrLf
SQL = SQL & "           ,[INTOTMATL]" & vbCrLf
SQL = SQL & "           ,[INTOTLABOR]" & vbCrLf
SQL = SQL & "           ,[INTOTEXP]" & vbCrLf
SQL = SQL & "           ,[INTOTOH]" & vbCrLf
SQL = SQL & "           ,[INTOTHRS]" & vbCrLf
SQL = SQL & "           ,[INCREDITACCT]" & vbCrLf
SQL = SQL & "           ,[INDEBITACCT]" & vbCrLf
SQL = SQL & "           ,[INGLJOURNAL]" & vbCrLf
SQL = SQL & "           ,[INGLPOSTED]" & vbCrLf
SQL = SQL & "           ,[INGLDATE]" & vbCrLf
SQL = SQL & "           ,[INMOPART]" & vbCrLf
SQL = SQL & "           ,[INMORUN]" & vbCrLf
SQL = SQL & "           ,[INSONUMBER]" & vbCrLf
SQL = SQL & "           ,[INSOITEM]" & vbCrLf
SQL = SQL & "           ,[INSOREV]" & vbCrLf
SQL = SQL & "           ,[INPONUMBER]" & vbCrLf
SQL = SQL & "           ,[INPORELEASE]" & vbCrLf
SQL = SQL & "           ,[INPOITEM]" & vbCrLf
SQL = SQL & "           ,[INPOREV]" & vbCrLf
SQL = SQL & "           ,[INPSNUMBER]" & vbCrLf
SQL = SQL & "           ,[INPSITEM]" & vbCrLf
SQL = SQL & "           ,[INWIPLABACCT]" & vbCrLf
SQL = SQL & "           ,[INWIPMATACCT]" & vbCrLf
SQL = SQL & "           ,[INWIPOHDACCT]" & vbCrLf
SQL = SQL & "           ,[INWIPEXPACCT]" & vbCrLf
SQL = SQL & "           ,[INNUMBER]" & vbCrLf
SQL = SQL & "           ,[INLOTNUMBER]" & vbCrLf
SQL = SQL & "           ,[INUSER]" & vbCrLf
SQL = SQL & "           ,[INUNITS]" & vbCrLf
SQL = SQL & "           ,[INDRLABACCT]" & vbCrLf
SQL = SQL & "           ,[INDRMATACCT]" & vbCrLf
SQL = SQL & "           ,[INDREXPACCT]" & vbCrLf
SQL = SQL & "           ,[INDROHDACCT]" & vbCrLf
SQL = SQL & "           ,[INCRLABACCT]" & vbCrLf
SQL = SQL & "           ,[INCRMATACCT]" & vbCrLf
SQL = SQL & "           ,[INCREXPACCT]" & vbCrLf
SQL = SQL & "           ,[INCROHDACCT]" & vbCrLf
SQL = SQL & "           ,[INLOTTRACK]" & vbCrLf
SQL = SQL & "           ,[INUSEACTUALCOST]" & vbCrLf
SQL = SQL & "           ,[INCOSTEDBY]" & vbCrLf
SQL = SQL & "           ,[INMAINTCOSTED])" & vbCrLf
SQL = SQL & "     select" & vbCrLf
SQL = SQL & "           @type               --<INTYPE, int,>" & vbCrLf
SQL = SQL & "           ,@partRef           --char(30),>" & vbCrLf
SQL = SQL & "           ,'Manual Adjustment'    --<INREF1, char(20),>" & vbCrLf
SQL = SQL & "           ,'Sheet Inventory'  --<INREF2, char(40),>" & vbCrLf
SQL = SQL & "           ,@currentTime       --<INPDATE, smalldatetime,>" & vbCrLf
SQL = SQL & "           ,@currentTime       --<INADATE, smalldatetime,>" & vbCrLf
SQL = SQL & "           ,r.Qty          --<INPQTY, decimal(12,4),>" & vbCrLf
SQL = SQL & "           ,r.Qty          --<INAQTY, decimal(12,4),>" & vbCrLf
SQL = SQL & "           ,@unitCost          -- <INAMT, decimal(12,4),>" & vbCrLf
SQL = SQL & "           ,0.0                    --<INTOTMATL, decimal(12,4),>" & vbCrLf
SQL = SQL & "           ,0.0                    --<INTOTLABOR, decimal(12,4),>" & vbCrLf
SQL = SQL & "           ,0.0                    --<INTOTEXP, decimal(12,4),>" & vbCrLf
SQL = SQL & "           ,0.0                    --<INTOTOH, decimal(12,4),>" & vbCrLf
SQL = SQL & "           ,0.0                    --<INTOTHRS, decimal(12,4),>" & vbCrLf
SQL = SQL & "           ,''                 --<INCREDITACCT, char(12),>" & vbCrLf
SQL = SQL & "           ,''                 --<INDEBITACCT, char(12),>" & vbCrLf
SQL = SQL & "           ,''                 --<INGLJOURNAL, char(12),>" & vbCrLf
SQL = SQL & "           ,0                  --<INGLPOSTED, tinyint,>" & vbCrLf
SQL = SQL & "           ,null               --<INGLDATE, smalldatetime,>" & vbCrLf
SQL = SQL & "           ,''                 --<INMOPART, char(30),>" & vbCrLf
SQL = SQL & "           ,0                  --<INMORUN, int,>" & vbCrLf
SQL = SQL & "           ,0                  --<INSONUMBER, int,>" & vbCrLf
SQL = SQL & "           ,0                  --<INSOITEM, int,>" & vbCrLf
SQL = SQL & "           ,''                 --<INSOREV, char(2),>" & vbCrLf
SQL = SQL & "           ,0                  --<INPONUMBER, int,>" & vbCrLf
SQL = SQL & "           ,0                  --<INPORELEASE, smallint,>" & vbCrLf
SQL = SQL & "           ,0                  --<INPOITEM, smallint,>" & vbCrLf
SQL = SQL & "           ,''                 --<INPOREV, char(2),>" & vbCrLf
SQL = SQL & "           ,''                 --<INPSNUMBER, char(8),>" & vbCrLf
SQL = SQL & "           ,0                  --<INPSITEM, smallint,>" & vbCrLf
SQL = SQL & "           ,''                 --<INWIPLABACCT, char(12),>" & vbCrLf
SQL = SQL & "           ,''                 --<INWIPMATACCT, char(12),>" & vbCrLf
SQL = SQL & "           ,''                 --<INWIPOHDACCT, char(12),>" & vbCrLf
SQL = SQL & "           ,''                 --<INWIPEXPACCT, char(12),>" & vbCrLf
SQL = SQL & "           ,r.NewIANumber      --<INNUMBER, int,>" & vbCrLf
SQL = SQL & "           ,@LotNo             --<INLOTNUMBER, char(15),>" & vbCrLf
SQL = SQL & "           ,@User              --<INUSER, char(4),>" & vbCrLf
SQL = SQL & "           ,@uom               --<INUNITS, char(2),>" & vbCrLf
SQL = SQL & "           ,''                 --<INDRLABACCT, char(12),>" & vbCrLf
SQL = SQL & "           ,''                 --<INDRMATACCT, char(12),>" & vbCrLf
SQL = SQL & "           ,''                 --<INDREXPACCT, char(12),>" & vbCrLf
SQL = SQL & "           ,''                 --<INDROHDACCT, char(12),>" & vbCrLf
SQL = SQL & "           ,''                 --<INCRLABACCT, char(12),>" & vbCrLf
SQL = SQL & "           ,''                 --<INCRMATACCT, char(12),>" & vbCrLf
SQL = SQL & "           ,''                 --<INCREXPACCT, char(12),>" & vbCrLf
SQL = SQL & "           ,''                 --<INCROHDACCT, char(12),>" & vbCrLf
SQL = SQL & "           ,null               --<INLOTTRACK, bit,>" & vbCrLf
SQL = SQL & "           ,null               --<INUSEACTUALCOST, bit,>" & vbCrLf
SQL = SQL & "           ,null               --<INCOSTEDBY, char(4),>" & vbCrLf
SQL = SQL & "           ,0                  --<INMAINTCOSTED, int,>)" & vbCrLf
SQL = SQL & "       from #rect r" & vbCrLf
SQL = SQL & "       where r.Qty <> 0" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- now update part QOH" & vbCrLf
SQL = SQL & "update PartTable set PAQOH = PAQOH - @totalQty where PARTREF = @partRef" & vbCrLf
SQL = SQL & "commit tran" & vbCrLf
SQL = SQL & "" & vbCrLf
Clipboard.Clear
Clipboard.SetText SQL
ExecuteScript False, SQL

SQL = "if object_id('SheetUnitConversion') IS NOT NULL" & vbCrLf
SQL = SQL & "    drop procedure SheetUnitConversion" & vbCrLf
ExecuteScript False, SQL

SQL = "create procedure dbo.SheetUnitConversion" & vbCrLf
SQL = SQL & "   @LotNo as char(15)" & vbCrLf
SQL = SQL & "as" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "/* convert lot from purchasing units to inventory units" & vbCrLf
SQL = SQL & "test:" & vbCrLf
SQL = SQL & "exec SheetUnitConversion '42701-729201-79'" & vbCrLf
SQL = SQL & "*/" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- get purchase item unit cost, lot dimensions, and units" & vbCrLf
SQL = SQL & "declare @purchaseUnitCost decimal(12,4), @height decimal(12,4), @length decimal(12,4), " & vbCrLf
SQL = SQL & "   @purchUnit char(2), @invUnit char(2), @lotQtyAfter decimal(12,4), @unitCost decimal(12,4), " & vbCrLf
SQL = SQL & "   @purchQty decimal(12,4), @partRef varchar(30), @lotQtyBefore decimal(12,4)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "select @purchaseUnitCost = poi.PIAMT, @height = loh.LOTMATHEIGHT, @length = loh.LOTMATLENGTH," & vbCrLf
SQL = SQL & "   @purchUnit = pt.PAPUNITS, @invUnit = pt.PAUNITS, @purchQty = poi.PIAQTY," & vbCrLf
SQL = SQL & "   @lotQtyAfter = loh.LOTMATHEIGHT * loh.LOTMATLENGTH * ROUND((loh.LOTTOTMATL + .1) / POI.PIAMT,0)," & vbCrLf
SQL = SQL & "   @partRef = pt.PARTREF, @lotQtyBefore = loh.LOTORIGINALQTY " & vbCrLf
SQL = SQL & "from PoitTable poi" & vbCrLf
SQL = SQL & "join PohdTable poh on poh.PONUMBER = poi.PINUMBER" & vbCrLf
SQL = SQL & "join LohdTable loh on loh.LOTPO = poi.PINUMBER and loh.LOTPOITEM = poi.PIITEM and loh.LOTPOITEMREV = poi.PIREV" & vbCrLf
SQL = SQL & "join PartTable pt on pt.PARTREF = loh.LOTPARTREF" & vbCrLf
SQL = SQL & "where loh.LOTNUMBER = @LotNo and  pt.PAPUNITS = 'SH' and pt.PAUNITS <> pt.PAPUNITS and loh.LOTMATHEIGHT > 1 and loh.LOTMATLENGTH > 1 " & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "--print 'before = ' + cast(@lotQtyBefore as varchar(18))" & vbCrLf
SQL = SQL & "--print 'after  = ' + cast(@lotQtyAfter as varchar(18))" & vbCrLf
SQL = SQL & "--print cast(@purchaseUnitCost as varchar(12))" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- if data missing or lot alreadhy converted, do not do it again" & vbCrLf
SQL = SQL & "if @purchaseUnitCost is null or @lotQtyBefore = @lotQtyAfter or isnull(@lotQtyAfter, 0) = 0" & vbCrLf
SQL = SQL & "   return" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "set @unitCost = (@purchaseUnitCost * @lotQtyBefore) / @lotQtyAfter" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "--print cast(@height as varchar(12))" & vbCrLf
SQL = SQL & "--print cast(@length as varchar(12))" & vbCrLf
SQL = SQL & "--print cast(@purchUnit as varchar(12))" & vbCrLf
SQL = SQL & "--print cast(@invUnit as varchar(12))" & vbCrLf
SQL = SQL & "--print cast(@unitCost as varchar(12))" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "begin tran" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- update lot header record" & vbCrLf
SQL = SQL & "update LohdTable set LOTORIGINALQTY = @lotQtyAfter, LOTREMAININGQTY = @lotQtyAfter, LOTUNITCOST = @unitCost" & vbCrLf
SQL = SQL & "where LOTNUMBER = @LotNo " & vbCrLf
SQL = SQL & "--select * from LohdTable where LOTNUMBER = @LotNo" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- update first lot item (receipt)" & vbCrLf
SQL = SQL & "update LoitTable set LOIQUANTITY = @lotQtyAfter, LOIUNITS = @invUnit, LOIHEIGHT = @height, LOILENGTH = @length" & vbCrLf
SQL = SQL & "where LOINUMBER = @LotNo and LOIRECORD = 1" & vbCrLf
SQL = SQL & "--select * from LoitTable where LOINUMBER = @LotNo and LOIRECORD = 1" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- update inventory activity for PO receipt" & vbCrLf
SQL = SQL & "update invatable set INPQTY = @lotQtyAfter, INAQTY = @lotQtyAfter, INAMT = @unitCost, INUNITS = @invUnit" & vbCrLf
SQL = SQL & "where INLOTNUMBER = @LotNo and INTYPE = 15" & vbCrLf
SQL = SQL & "--select * from InvaTable where INLOTNUMBER = @LotNo and INTYPE = 15" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- update part QOH" & vbCrLf
SQL = SQL & "select PAQOH from PartTable where PARTREF = @partRef" & vbCrLf
SQL = SQL & "update PartTable set PAQOH = PAQOH + @lotQtyAfter - @lotQtyBefore where PARTREF = @partRef" & vbCrLf
SQL = SQL & "--select PAQOH from PartTable where PARTREF = @partRef" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "commit tran" & vbCrLf
SQL = SQL & "" & vbCrLf
ExecuteScript False, SQL

SQL = "create table dbo.SSRSInfo" & vbCrLf
SQL = SQL & "(" & vbCrLf
SQL = SQL & "   SSRSID int IDENTITY(1,1) NOT NULL," & vbCrLf
SQL = SQL & "   SSRSFolderUrl varchar(255) NULL" & vbCrLf
SQL = SQL & ")" & vbCrLf
ExecuteScript False, SQL

      
''''''''''''''''''''''''''''''''''''''''''''''''''
        ' update the version
        ExecuteScript False, "Update Version Set Version = " & newver
   
   End If
End Function
   

   
'''''''''''''''''''''''''''''''''

Private Function UpdateDatabase80()

   Dim SQL As String
   SQL = ""
   
   newver = 155
   If ver < newver Then
   
        clsADOCon.ADOErrNum = 0
        
'''''''''''''''''''''''''''''''''''''''''''''''''''
      
        ' separate column for sql causing errors
        SQL = "ALTER TABLE SystemEvents ADD Event_SQL VARCHAR(MAX) NULL"
        ExecuteScript False, SQL

        SQL = "ALTER TABLE SystemEvents ADD CONSTRAINT DF_Event_Date DEFAULT getdate() FOR Event_Date"
        ExecuteScript False, SQL
        
        
        'from UpdateDatabase32 with syntax error fixed (set Set @RowCount = 1)
      If StoreProcedureExists("RptIncomeStatement") Then
         sSql = "DROP PROCEDURE RptIncomeStatement"
         ExecuteScript False, sSql
      End If
      
      
      sSql = "CREATE PROCEDURE [dbo].[RptIncomeStatement]" & vbCrLf
      sSql = sSql & "   @StartDate as varchar(12),@EndDate as varchar(12)," & vbCrLf
      sSql = sSql & "   @YearBeginDate as varchar(12), @InclIncAcct as varchar(1)" & vbCrLf
      sSql = sSql & "AS " & vbCrLf
      sSql = sSql & "BEGIN" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   declare @glAcctRef as varchar(10)" & vbCrLf
      sSql = sSql & "   declare @glMsAcct as varchar(10)" & vbCrLf
      sSql = sSql & "   declare @SumCurBal decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @SumYTD decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @SumPrevBal as decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @level as integer" & vbCrLf
      sSql = sSql & "   declare @TopLevelDesc as varchar(30)" & vbCrLf
      sSql = sSql & "   declare @InclInAcct as Integer" & vbCrLf
      sSql = sSql & "   declare @TopLevAcct as varchar(20)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   declare @PrevMaster as varchar(10)" & vbCrLf
      sSql = sSql & "   declare @RowCount as integer" & vbCrLf
      sSql = sSql & "   declare @GlMasterAcc as varchar(10)" & vbCrLf
      sSql = sSql & "   declare @GlChildAcct as varchar(10)" & vbCrLf
      sSql = sSql & "   declare @ChildKey as varchar(1024)" & vbCrLf
      sSql = sSql & "   declare @GLSortKey as varchar(1024)" & vbCrLf
      sSql = sSql & "   declare @SortKey as varchar(1024)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   DELETE FROM EsReportIncStatement" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   if (@InclIncAcct = '1')" & vbCrLf
      sSql = sSql & "      SET @InclInAcct = ''" & vbCrLf
      sSql = sSql & "   Else" & vbCrLf
      sSql = sSql & "      SET @InclInAcct = '0'" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   DECLARE balAcctStruc CURSOR  FOR" & vbCrLf
      sSql = sSql & "      SELECT '4', COINCMACCT, COINCMDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      Union All" & vbCrLf
      sSql = sSql & "      SELECT '5', COCOGSACCT, COCOGSDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      Union All" & vbCrLf
      sSql = sSql & "      SELECT '6', COEXPNACCT, COEXPNDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      Union All" & vbCrLf
      sSql = sSql & "      SELECT '7', COOINCACCT, COOINCDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      Union All" & vbCrLf
      sSql = sSql & "      SELECT '8', COOEXPACCT, COOEXPDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      Union All" & vbCrLf
      sSql = sSql & "      SELECT '9', COFDTXACCT, COFDTXDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   OPEN balAcctStruc" & vbCrLf
      sSql = sSql & "   FETCH NEXT FROM balAcctStruc INTO @level,@TopLevAcct, @TopLevelDesc" & vbCrLf
      sSql = sSql & "   WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "      IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "      BEGIN" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "        With cte" & vbCrLf
      sSql = sSql & "        as " & vbCrLf
      sSql = sSql & "        (select GLACCTREF, GLDESCR, GLMASTER, GLFSLEVEL, 1 as level," & vbCrLf
      sSql = sSql & "          cast(cast(@level as varchar(4))+ char(36)+ GLACCTREF as varchar(max)) as SortKey" & vbCrLf
      sSql = sSql & "        From GlacTable" & vbCrLf
      sSql = sSql & "        where GLMASTER = cast(@TopLevAcct as varchar(20)) AND GLINACTIVE LIKE @InclInAcct" & vbCrLf
      sSql = sSql & "        Union All" & vbCrLf
      sSql = sSql & "        select a.GLACCTREF, a.GLDESCR, a.GLMASTER, a.GLFSLEVEL, level + 1," & vbCrLf
      sSql = sSql & "         cast(COALESCE(SortKey,'') + char(36) + COALESCE(a.GLACCTREF,'') as varchar(max))as SortKey" & vbCrLf
      sSql = sSql & "        From cte" & vbCrLf
      sSql = sSql & "          inner join GlacTable a" & vbCrLf
      sSql = sSql & "            on cte.GLACCTREF = a.GLMASTER" & vbCrLf
      sSql = sSql & "          WHERE GLINACTIVE LIKE @InclInAcct" & vbCrLf
      sSql = sSql & "        )" & vbCrLf
      sSql = sSql & "        INSERT INTO EsReportIncStatement(GLTOPMaster, GLTOPMASTERDESC, GLACCTREF, GLDESCR, GLMASTER, GLFSLEVEL,SORTKEYLEVEL,GLACCSORTKEY)" & vbCrLf
      sSql = sSql & "        select @level, @TopLevelDesc, GLACCTREF, GLDESCR, GLMASTER, GLFSLEVEL, level, SortKey" & vbCrLf
      sSql = sSql & "        from cte order by SortKey" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "      End" & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM balAcctStruc INTO @level,@TopLevAcct, @TopLevelDesc" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "   Close balAcctStruc" & vbCrLf
      sSql = sSql & "   DEALLOCATE balAcctStruc" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   UPDATE EsReportIncStatement SET CurrentBal = foo.Balance--, SUMCURBAL = foo.Balance" & vbCrLf
      sSql = sSql & "   From" & vbCrLf
      sSql = sSql & "       (SELECT SUM(GjitTable.JICRD) - SUM(GjitTable.JIDEB) as Balance, JIACCOUNT" & vbCrLf
      sSql = sSql & "         FROM GjhdTable INNER JOIN GjitTable ON GJNAME = JINAME" & vbCrLf
      sSql = sSql & "      WHERE GJPOST BETWEEN @StartDate AND @EndDate" & vbCrLf
      sSql = sSql & "         AND GjhdTable.GJPOSTED = 1" & vbCrLf
      sSql = sSql & "      GROUP BY JIACCOUNT) as foo" & vbCrLf
      sSql = sSql & "   Where foo.JIACCOUNT = GLACCTREF" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   UPDATE EsReportIncStatement SET YTD = foo.Balance--, SUMYTD = foo.Balance" & vbCrLf
      sSql = sSql & "   From" & vbCrLf
      sSql = sSql & "      (SELECT JIACCOUNT,SUM(GjitTable.JICRD) - SUM(GjitTable.JIDEB) AS Balance" & vbCrLf
      sSql = sSql & "         FROM GjhdTable INNER JOIN GjitTable ON GJNAME = JINAME" & vbCrLf
      sSql = sSql & "      WHERE (GJPOST BETWEEN @YearBeginDate AND @EndDate)" & vbCrLf
      sSql = sSql & "         AND GjhdTable.GJPOSTED = 1" & vbCrLf
      sSql = sSql & "      GROUP BY JIACCOUNT) as foo" & vbCrLf
      sSql = sSql & "   Where foo.JIACCOUNT = GLACCTREF" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   UPDATE EsReportIncStatement SET PreviousBal = foo.Balance--, SUMPREVBAL = foo.Balance" & vbCrLf
      sSql = sSql & "   From" & vbCrLf
      sSql = sSql & "      (SELECT JIACCOUNT,SUM(GjitTable.JICRD) - SUM(GjitTable.JIDEB) AS Balance" & vbCrLf
      sSql = sSql & "         FROM GjhdTable INNER JOIN GjitTable ON GJNAME = JINAME" & vbCrLf
      sSql = sSql & "      WHERE (GJPOST BETWEEN DATEADD(year, -1, @YearBeginDate) AND DATEADD(year, -1, @EndDate))" & vbCrLf
      sSql = sSql & "         AND GjhdTable.GJPOSTED = 1" & vbCrLf
      sSql = sSql & "      GROUP BY JIACCOUNT) as foo" & vbCrLf
      sSql = sSql & "   Where foo.JIACCOUNT = GLACCTREF" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   SELECT @level =  MAX(SORTKEYLEVEL) FROM EsReportIncStatement" & vbCrLf
      sSql = sSql & "   --set @level = 9" & vbCrLf
      sSql = sSql & "   WHILE (@level >= 1 )" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "      DECLARE curAcctStruc CURSOR  FOR" & vbCrLf
      sSql = sSql & "      SELECT GLMASTER, SUM(ISNULL(SUMCURBAL,0) + (ISNULL(CurrentBal,0))) ," & vbCrLf
      sSql = sSql & "         Sum (IsNull(SUMYTD, 0) + (IsNull(YTD, 0))), Sum(IsNull(SUMPREVBAL, 0) + (IsNull(PreviousBal, 0)))" & vbCrLf
      sSql = sSql & "      From" & vbCrLf
      sSql = sSql & "         (SELECT DISTINCT GLACCTREF, GLDESCR, GLMASTER," & vbCrLf
      sSql = sSql & "         CurrentBal , YTD, PreviousBal, SUMCURBAL, SUMYTD, SUMPREVBAL" & vbCrLf
      sSql = sSql & "         FROM EsReportIncStatement WHERE SORTKEYLEVEL = @level) as foo" & vbCrLf
      sSql = sSql & "      group by GLMASTER" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "      OPEN curAcctStruc" & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM curAcctStruc INTO @glMsAcct, @SumCurBal, @SumYTD, @SumPrevBal" & vbCrLf
      sSql = sSql & "      WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "      BEGIN" & vbCrLf
      sSql = sSql & "         IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "         BEGIN" & vbCrLf
      sSql = sSql & "            UPDATE EsReportIncStatement SET SUMCURBAL = @SumCurBal, SUMYTD = @SumYTD," & vbCrLf
      sSql = sSql & "               SUMPREVBAL = @SumPrevBal, GLDESCR = 'TOTAL ' + LTRIM(GLDESCR)," & vbCrLf
      sSql = sSql & "            HASCHILD = 1" & vbCrLf
      sSql = sSql & "            WHERE GLACCTREF = @glMsAcct" & vbCrLf
      sSql = sSql & "         End" & vbCrLf
      sSql = sSql & "         FETCH NEXT FROM curAcctStruc INTO @glMsAcct, @SumCurBal, @SumYTD, @SumPrevBal" & vbCrLf
      sSql = sSql & "      End" & vbCrLf
      sSql = sSql & "      Close curAcctStruc" & vbCrLf
      sSql = sSql & "      DEALLOCATE curAcctStruc" & vbCrLf
      sSql = sSql & "      SET @level = @level - 1" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   UPDATE EsReportIncStatement SET SUMCURBAL = CurrentBal WHERE SUMCURBAL IS NULL" & vbCrLf
      sSql = sSql & "   UPDATE EsReportIncStatement SET SUMPREVBAL = PreviousBal WHERE SUMPREVBAL IS NULL" & vbCrLf
      sSql = sSql & "   UPDATE EsReportIncStatement SET SUMYTD = YTD  WHERE SUMYTD IS NULL" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   set @level = 0 " & vbCrLf
      sSql = sSql & "   set @RowCount = 1" & vbCrLf
      sSql = sSql & "   SET @PrevMaster = ''" & vbCrLf
      sSql = sSql & "   DECLARE curAcctStruc CURSOR  FOR" & vbCrLf
      sSql = sSql & "      SELECT GLMASTER, GLACCSORTKEY" & vbCrLf
      sSql = sSql & "      FROM EsReportIncStatement " & vbCrLf
      sSql = sSql & "         WHERE HASCHILD IS NULL --GLFSLEVEL = 8 --AND GLMASTER ='AA10'--GLTOPMaster = 1 AND " & vbCrLf
      sSql = sSql & "      ORDER BY GLACCSORTKEY" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   OPEN curAcctStruc" & vbCrLf
      sSql = sSql & "   FETCH NEXT FROM curAcctStruc INTO @GlMasterAcc, @GLSortKey" & vbCrLf
      sSql = sSql & "   WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "    IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "    BEGIN" & vbCrLf
      sSql = sSql & "      if (@PrevMaster <> @GlMasterAcc)" & vbCrLf
      sSql = sSql & "      BEGIN" & vbCrLf
      sSql = sSql & "         UPDATE EsReportIncStatement SET " & vbCrLf
      sSql = sSql & "            SortKeyRev = RIGHT ('0000'+ Cast(@RowCount as varchar), 4) + char(36)+ @GlMasterAcc" & vbCrLf
      sSql = sSql & "         WHERE GLMASTER = @GlMasterAcc AND HASCHILD IS NULL --GLFSLEVEL = 8 --AND GLTOPMaster = 1 " & vbCrLf
      sSql = sSql & "         SET @RowCount = @RowCount + 1" & vbCrLf
      sSql = sSql & "         SET @PrevMaster = @GlMasterAcc" & vbCrLf
      sSql = sSql & "      END" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "    End" & vbCrLf
      sSql = sSql & "    FETCH NEXT FROM curAcctStruc INTO @GlMasterAcc, @GLSortKey" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "       " & vbCrLf
      sSql = sSql & "   Close curAcctStruc" & vbCrLf
      sSql = sSql & "   DEALLOCATE curAcctStruc" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "    SELECT @level = MAX(SORTKEYLEVEL) FROM EsReportIncStatement" & vbCrLf
      sSql = sSql & "   --set @level = 7" & vbCrLf
      sSql = sSql & "   WHILE (@level >= 1 )" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "      SET @PrevMaster = ''" & vbCrLf
      sSql = sSql & "        DECLARE curAcctStruc1 CURSOR  FOR" & vbCrLf
      sSql = sSql & "         SELECT DISTINCT GLACCTREF, GLMASTER, GLACCSORTKEY" & vbCrLf
      sSql = sSql & "         FROM EsReportIncStatement " & vbCrLf
      sSql = sSql & "            WHERE SORTKEYLEVEL = @level AND HASCHILD IS NOT NULL--GLTOPMaster = 1 AND " & vbCrLf
      sSql = sSql & "         order by GLACCSORTKEY" & vbCrLf
      sSql = sSql & "    " & vbCrLf
      sSql = sSql & "        OPEN curAcctStruc1" & vbCrLf
      sSql = sSql & "        FETCH NEXT FROM curAcctStruc1 INTO @GlChildAcct, @GlMasterAcc, @GLSortKey" & vbCrLf
      sSql = sSql & "        WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "        BEGIN" & vbCrLf
      sSql = sSql & "          IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "          BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "            if (@PrevMaster <> @GlChildAcct)" & vbCrLf
      sSql = sSql & "            BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   print 'Record' + @GlChildAcct + ':' + @GlMasterAcc" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "               SELECT TOP 1 @ChildKey = SortKeyRev,@SortKey = GLACCSORTKEY" & vbCrLf
      sSql = sSql & "               FROM EsReportIncStatement " & vbCrLf
      sSql = sSql & "                  WHERE SORTKEYLEVEL > @level AND GLMASTER = @GlChildAcct --GLTOPMaster = 1 AND " & vbCrLf
      sSql = sSql & "               order by GLACCSORTKEY desc" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "               UPDATE EsReportIncStatement SET " & vbCrLf
      sSql = sSql & "                  SortKeyRev = Cast(@ChildKey as varchar(512)) + char(36)+ @GlMasterAcc" & vbCrLf
      sSql = sSql & "               WHERE GLACCTREF = @GlChildAcct AND GLMASTER = @GlMasterAcc " & vbCrLf
      sSql = sSql & "                  AND SORTKEYLEVEL = @level --GLTOPMaster = 1 AND " & vbCrLf
      sSql = sSql & "               SET @PrevMaster = @GlChildAcct" & vbCrLf
      sSql = sSql & "            END" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "          End" & vbCrLf
      sSql = sSql & "          FETCH NEXT FROM curAcctStruc1 INTO @GlChildAcct, @GlMasterAcc, @GLSortKey" & vbCrLf
      sSql = sSql & "        End" & vbCrLf
      sSql = sSql & "               " & vbCrLf
      sSql = sSql & "        Close curAcctStruc1" & vbCrLf
      sSql = sSql & "        DEALLOCATE curAcctStruc1" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "        SET @level = @level - 1" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "  SELECT GLTOPMaster, GLTOPMASTERDESC, GLACCTREF, GLACCTNO, GLDESCR, GLMASTER, GLTYPE,GLINACTIVE, GLFSLEVEL," & vbCrLf
      sSql = sSql & "      SUMCURBAL , CurrentBal, SUMYTD, YTD, SUMPREVBAL, PreviousBal, SORTKEYLEVEL, GLACCSORTKEY" & vbCrLf
      sSql = sSql & "   FROM EsReportIncStatement ORDER BY SortKeyRev --GLTOPMASTER, GLACCSORTKEY desc, SortKeyLevel" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "End"
      
      ExecuteScript False, sSql
      
      sSql = "ALTER procedure [dbo].[UpdateTimeCardTotals]" & vbCrLf
      sSql = sSql & " @EmpNo int," & vbCrLf
      sSql = sSql & " @Date datetime" & vbCrLf
      sSql = sSql & "as " & vbCrLf
      sSql = sSql & "/* test" & vbCrLf
      sSql = sSql & "    UpdateTimeCardTotals 52, '9/8/2008'" & vbCrLf
      sSql = sSql & "*/" & vbCrLf
      sSql = sSql & "update TchdTable " & vbCrLf
      sSql = sSql & "set TMSTART = (select top 1 TCSTART From TcitTable " & vbCrLf
      sSql = sSql & "join TchdTable on TCCARD = TMCARD" & vbCrLf
      sSql = sSql & "where TCEMP = @EmpNo and TMDAY = @Date and TCSTOP <> ''" & vbCrLf
      sSql = sSql & "and ISDATE(TCSTART + 'm') = 1 and ISDATE(TCSTOP + 'm') = 1" & vbCrLf
      sSql = sSql & "order by tcstarttime)," & vbCrLf
      sSql = sSql & "TMSTOP = (select top 1 TCSTOP From TcitTable" & vbCrLf
      sSql = sSql & "join TchdTable on TCCARD = TMCARD" & vbCrLf
      sSql = sSql & "where TCEMP = @EmpNo and TMDAY = @Date and TCSTOP <> ''" & vbCrLf
      sSql = sSql & "and ISDATE(TCSTART + 'm') = 1 and ISDATE(TCSTOP + 'm') = 1" & vbCrLf
      sSql = sSql & "order by TCSTOPTIME desc)" & vbCrLf
      sSql = sSql & "where TMEMP = @EmpNo and TMDAY = @Date" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "update TchdTable " & vbCrLf
      sSql = sSql & "set TMREGHRS = (select isnull(sum(hrs), 0.000) from viewTimeCardHours" & vbCrLf
      sSql = sSql & "where EmpNo = @EmpNo" & vbCrLf
      sSql = sSql & "and chgDay = @Date" & vbCrLf
      sSql = sSql & "and type = 'R')," & vbCrLf
      sSql = sSql & "TMOVTHRS = (select isnull(sum(hrs), 0.000) from viewTimeCardHours" & vbCrLf
      sSql = sSql & "where EmpNo = @EmpNo" & vbCrLf
      sSql = sSql & "and chgDay = @Date" & vbCrLf
      sSql = sSql & "and type = 'O')," & vbCrLf
      sSql = sSql & "TMDBLHRS = (select isnull(sum(hrs), 0.000) from viewTimeCardHours" & vbCrLf
      sSql = sSql & "where EmpNo = @EmpNo" & vbCrLf
      sSql = sSql & "and chgDay = @Date" & vbCrLf
      sSql = sSql & "and type = 'D')" & vbCrLf
      sSql = sSql & "where TMEMP = @EmpNo and TMDAY = @Date"
      
      ExecuteScript False, sSql
      
     
''''''''''''''''''''''''''''''''''''''''''''''''''
        ' update the version
        ExecuteScript False, "Update Version Set Version = " & newver
   
   End If
End Function
   
Private Function UpdateDatabase81()

   Dim SQL As String
   SQL = ""

   newver = 156
   If ver < newver Then

        clsADOCon.ADOErrNum = 0

''''''''''''''''''''''''''''''''''''''''''''''''''

'SQL = "alter table ComnTable add COBACKGROUNDCOLORRGB char(6) null"
'ExecuteScript False, SQL

SQL = "IF EXISTS (SELECT * FROM sys.objects WHERE type = 'P' AND name = 'CompleteAllOps')" & vbCrLf
SQL = SQL & "DROP PROCEDURE CompleteAllOps" & vbCrLf
ExecuteScript False, SQL

SQL = "create procedure dbo.CompleteAllOps" & vbCrLf
SQL = SQL & "   @PartRef varchar(30)," & vbCrLf
SQL = SQL & "   @RunNo int," & vbCrLf
SQL = SQL & "   @NeedJournal int OUTPUT" & vbCrLf
SQL = SQL & "as" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "/*" & vbCrLf
SQL = SQL & "close all operations for an MO" & vbCrLf
SQL = SQL & "NeedJournal  = 0 if successful" & vbCrLf
SQL = SQL & "            = 1 if TJ Journal needs to be created" & vbCrLf
SQL = SQL & "test" & vbCrLf
SQL = SQL & "   declare @NeedJournal int" & vbCrLf
SQL = SQL & "   exec CompleteAllOps '111A340113', 236, @NeedJournal OUT" & vbCrLf
SQL = SQL & "   print @NeedJournal" & vbCrLf
SQL = SQL & "*/" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- create a table of all open time charges" & vbCrLf
SQL = SQL & "Set @NeedJournal = 0" & vbCrLf
SQL = SQL & "set nocount on" & vbCrLf
SQL = SQL & "begin tran" & vbCrLf
SQL = SQL & "select " & vbCrLf
SQL = SQL & "   cast(null as varchar(11)) as TCCARD," & vbCrLf
SQL = SQL & "   ISEMPLOYEE as TCEMP," & vbCrLf
SQL = SQL & "   cast(null as varchar(20)) as TCSTART," & vbCrLf
SQL = SQL & "   cast(null as varchar(20)) as TCSTOP," & vbCrLf
SQL = SQL & "   ISMOSTART as TCSTARTTIME," & vbCrLf
SQL = SQL & "   DATEADD(minute, DATEDIFF(minute, 0, getdate()), 0) as TCSTOPTIME," & vbCrLf
SQL = SQL & "   cast(null as REAL) AS TCHOURS," & vbCrLf
SQL = SQL & "   cast(null as smalldatetime) as TCTIME," & vbCrLf
SQL = SQL & "   'RG' as TCCODE," & vbCrLf
SQL = SQL & "   cast(null as real) as TCRATE," & vbCrLf
SQL = SQL & "   cast(null as real) as TCOHRATE," & vbCrLf
SQL = SQL & "   cast(1 as smallint) as TCRATENO," & vbCrLf
SQL = SQL & "   cast('' as varchar(12)) as TCACCT," & vbCrLf
SQL = SQL & "   cast('' as varchar(12)) as TCACCOUNT," & vbCrLf
SQL = SQL & "   op.OPSHOP as TCSHOP," & vbCrLf
SQL = SQL & "   op.OPCENTER as TCWC," & vbCrLf
SQL = SQL & "   cast (0 as tinyint) as TCPAYTYPE," & vbCrLf
SQL = SQL & "   isnull(ISSURUN,'R') as TCSURUN," & vbCrLf
SQL = SQL & "   cast(0 as real) as TCYIELD," & vbCrLf
SQL = SQL & "   OPREF AS TCPARTREF," & vbCrLf
SQL = SQL & "   OPRUN AS TCRUNNO," & vbCrLf
SQL = SQL & "    OPNO AS TCOPNO," & vbCrLf
SQL = SQL & "   0 TCSORT," & vbCrLf
SQL = SQL & "   cast(0 as real) as TCOHFIXED," & vbCrLf
SQL = SQL & "   dbo.fnGetOpenJournalID('TJ', ISMOSTART) as TCGLJOURNAL," & vbCrLf
SQL = SQL & "   --cast(null as varchar(12)) as TCGLJOURNAL," & vbCrLf
SQL = SQL & "   0 as TCGLREF," & vbCrLf
SQL = SQL & "   'MOCLS' AS TCSOURCE," & vbCrLf
SQL = SQL & "   0 as TCMULTIJOB," & vbCrLf
SQL = SQL & "   0 as TCACCEPT," & vbCrLf
SQL = SQL & "   0 as TCREJECT," & vbCrLf
SQL = SQL & "   0 as TCSCRAP," & vbCrLf
SQL = SQL & "   'Closure forced from Close All Ops' as TCCOMMENTS," & vbCrLf
SQL = SQL & "   cast(null as varchar(6)) as _ShiftRef," & vbCrLf
SQL = SQL & "   cast(null as datetime) as _ShiftStartDate" & vbCrLf  ' 7/19/17 - was cast as Date.  failed in sql 2005
SQL = SQL & "into #temp" & vbCrLf
SQL = SQL & "from IstcTable istc" & vbCrLf
SQL = SQL & "join RnopTable op on op.OPREF = istc.ISMO and op.OPRUN = istc.ISRUN and op.OPNO = istc.ISOP" & vbCrLf
SQL = SQL & "where ISMO = @PartRef and ISRUN = @RunNo" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- return if no TJ journal found for these start dates" & vbCrLf
SQL = SQL & "if exists (select * from #temp where isnull(TCGLJOURNAL, '') = '')" & vbCrLf
SQL = SQL & "begin" & vbCrLf
SQL = SQL & "   rollback tran" & vbCrLf
SQL = SQL & "   set @NeedJournal = 1" & vbCrLf
SQL = SQL & "   return" & vbCrLf
SQL = SQL & "end" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- do not allow charge over 16 hours" & vbCrLf
SQL = SQL & "update #temp set TCSTOPTIME = dateadd(MINUTE,16*60,TCSTARTTIME) where datediff(MINUTE,TCSTARTTIME,TCSTOPTIME) > 16 * 60" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- construct hh:mma/p version of times" & vbCrLf
SQL = SQL & "update #temp set TCSTART = REPLACE(SUBSTRING(CONVERT(VARCHAR(20),TCSTARTTIME,0),13,6),' ','0')" & vbCrLf
SQL = SQL & "update #temp set TCSTOP = REPLACE(SUBSTRING(CONVERT(VARCHAR(20),TCSTOPTIME,0),13,6),' ','0')" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- calculate hours" & vbCrLf
SQL = SQL & "update #temp set tchours = datediff(MINUTE,TCSTARTTIME, TCSTOPTIME) / 60." & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- calculate # minutes" & vbCrLf
SQL = SQL & "update #temp set TCTIME = dateadd(minute,datediff(MINUTE,TCSTARTTIME, TCSTOPTIME),'1/1/1900')" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- determine shift code and shift start date" & vbCrLf
SQL = SQL & "select a.SFREF, A.PREMNUMBER, cast(SFSTHR + 'm' as time) as _START, cast(SFENHR + 'm' as time) as _END, cast(null as int) as _MINUTES" & vbCrLf
SQL = SQL & "into #shifts" & vbCrLf
SQL = SQL & "FROM dbo.sfempTable a" & vbCrLf
SQL = SQL & "join sfcdTable b on a.SFREF = b.SFREF" & vbCrLf
SQL = SQL & "where premnumber in (select tcemp from #temp)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "update #shifts set _MINUTES = DATEDIFF(MINUTE,_START,_END)" & vbCrLf
SQL = SQL & "update #shifts set _MINUTES = _MINUTES + 1440 where _MINUTES < 0" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- case 1: charge starts up to 1 hour before shift start to end of shift, same day" & vbCrLf
SQL = SQL & "update t set _ShiftRef = s.SFREF," & vbCrLf
SQL = SQL & "   _ShiftStartDate = cast(TCSTARTTIME as date)" & vbCrLf
SQL = SQL & "FROM #shifts s join #temp t on t.TCEMP = s.PREMNUMBER" & vbCrLf
SQL = SQL & "where (DATEDIFF(minute, _START, cast(t.TCSTART + 'm' as time)) BETWEEN -60 AND _MINUTES)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- case 2: time charge starts after midnight -- use prior day as shift start day" & vbCrLf
SQL = SQL & "update t set _ShiftRef = s.SFREF," & vbCrLf
SQL = SQL & "   _ShiftStartDate = dateadd(day,-1,cast(TCSTARTTIME as date))" & vbCrLf
SQL = SQL & "FROM #shifts s join #temp t on t.TCEMP = s.PREMNUMBER" & vbCrLf
SQL = SQL & "where (DATEDIFF(minute, _START, cast(t.TCSTART + 'm' as time))  + 1440 BETWEEN -30 AND _MINUTES)" & vbCrLf
SQL = SQL & "and _ShiftStartDate is null" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- case 3: outside of shift hours.  Use shift code (if one assigned) and time charge start date as shift start date" & vbCrLf
SQL = SQL & "update t set _ShiftRef = s.SFREF,      -- null if no shift defined for employee" & vbCrLf
SQL = SQL & "   _ShiftStartDate = cast(TCSTARTTIME as date)" & vbCrLf
SQL = SQL & "FROM #temp t  " & vbCrLf
SQL = SQL & "left join #shifts s on t.TCEMP = s.PREMNUMBER" & vbCrLf
SQL = SQL & "where _ShiftStartDate is null" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- get time card references where they exist" & vbCrLf
SQL = SQL & "update t" & vbCrLf
SQL = SQL & "set TCCARD = TMCARD" & vbCrLf
SQL = SQL & "from #temp t join TchdTable h on h.TMEMP = t.TCEMP AND h.TMDAY = t._ShiftStartDate" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- for charges where there is no current time card, create them" & vbCrLf
SQL = SQL & "-- first create base parameters to construct timecard ID" & vbCrLf
SQL = SQL & "declare @now as datetime, @nowDays int, @nowMs int" & vbCrLf
SQL = SQL & "set @now = getdate()" & vbCrLf
SQL = SQL & "set @nowDays = DATEDIFF(DAY,'1/1/1900',cast(@now as date))" & vbCrLf
SQL = SQL & "set @nowMs = 1000000.0 *cast(DATEDIFF(MILLISECOND,'1/1/1900',cast(@now as time)) as float)/(3600.0*24*1000)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "INSERT INTO TchdTable (TMCARD,TMEMP,TMDAY) " & vbCrLf
SQL = SQL & "select cast(@nowDays as varchar(5)) + cast(@nowMs + ROW_NUMBER() over( order by TCEMP, TCSTARTTIME) - 1 as varchar(6)), " & vbCrLf
SQL = SQL & "   TCEMP, _ShiftStartDate" & vbCrLf
SQL = SQL & "FROM #temp where TCCARD is null" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- add new timecards where needed" & vbCrLf
SQL = SQL & "update t" & vbCrLf
SQL = SQL & "set t.TCCARD = TMCARD" & vbCrLf
SQL = SQL & "from #temp t join TchdTable h on h.TMEMP = t.TCEMP AND h.TMDAY = t._ShiftStartDate" & vbCrLf
SQL = SQL & "where t.TCCARD is null" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- find a regular timecode" & vbCrLf
SQL = SQL & "update #temp set TCCODE = isnull((select top 1 TYPECODE from TmcdTable where TYPETYPE = 'R' ORDER BY TYPESEQ),'RT')" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- get rates and accounts" & vbCrLf
SQL = SQL & "update t " & vbCrLf
SQL = SQL & "set TCACCT = RTRIM(COALESCE(NULLIF(w.WCNACCT,''), NULLIF(s.SHPACCT,''), c.WIPLABACCT))," & vbCrLf
SQL = SQL & "   TCRATE = case when e.PREMPAYRATE <> 0 then e.PREMPAYRATE" & vbCrLf
SQL = SQL & "       when w.WCNSTDRATE <> 0 then w.WCNSTDRATE" & vbCrLf
SQL = SQL & "       else s.SHPRATE end," & vbCrLf
SQL = SQL & "   TCOHRATE = case when w.WCNOHPCT <> 0 then w.WCNOHPCT " & vbCrLf
SQL = SQL & "       else s.SHPOHRATE end," & vbCrLf
SQL = SQL & "   TCOHFIXED = case when w.WCNOHFIXED <> 0 then w.WCNOHFIXED" & vbCrLf
SQL = SQL & "       else s.SHPOHTOTAL end" & vbCrLf
SQL = SQL & "       from RnopTable r" & vbCrLf
SQL = SQL & "join PartTable p on r.OPREF = p.PARTREF" & vbCrLf
SQL = SQL & "join WcntTable w on r.OPCENTER = w.WCNREF" & vbCrLf
SQL = SQL & "join ShopTable s on r.OPSHOP = s.SHPREF" & vbCrLf
SQL = SQL & "join #temp t on t.TCPARTREF = r.OPREF and t.TCRUNNO = r.OPRUN and t.TCOPNO = r.OPNO" & vbCrLf
SQL = SQL & "join ComnTable c on 1 = 1" & vbCrLf
SQL = SQL & "join EmplTable e on E.PREMNUMBER = T.TCEMP" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "update #temp " & vbCrLf
SQL = SQL & "set TCOHRATE = TCRATE * TCOHRATE / 100" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- create time charge in TcitTable" & vbCrLf
SQL = SQL & "INSERT INTO TcitTable (TCCARD,TCEMP,TCSTART,TCSTOP,TCSTARTTIME,TCSTOPTIME," & vbCrLf
SQL = SQL & "      TCHOURS,TCTIME,TCCODE,TCRATE,TCOHRATE,TCRATENO,TCACCT,TCACCOUNT," & vbCrLf
SQL = SQL & "      TCSHOP,TCWC,TCPAYTYPE,TCSURUN,TCYIELD,TCPARTREF,TCRUNNO," & vbCrLf
SQL = SQL & "      TCOPNO,TCSORT,TCOHFIXED,TCGLJOURNAL,TCGLREF,TCSOURCE," & vbCrLf
SQL = SQL & "      TCMULTIJOB,TCACCEPT,TCREJECT,TCSCRAP,TCCOMMENTS)" & vbCrLf
SQL = SQL & "select TCCARD,TCEMP,TCSTART,TCSTOP,TCSTARTTIME,TCSTOPTIME," & vbCrLf
SQL = SQL & "      TCHOURS,TCTIME,TCCODE,TCRATE,TCOHRATE,TCRATENO,TCACCT,TCACCOUNT," & vbCrLf
SQL = SQL & "      TCSHOP,TCWC,TCPAYTYPE,TCSURUN,TCYIELD,TCPARTREF,TCRUNNO," & vbCrLf
SQL = SQL & "      TCOPNO,TCSORT,TCOHFIXED,TCGLJOURNAL,TCGLREF,TCSOURCE," & vbCrLf
SQL = SQL & "      TCMULTIJOB,TCACCEPT,TCREJECT,TCSCRAP,TCCOMMENTS" & vbCrLf
SQL = SQL & "from #temp" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- set min and max times for charges in affected in timecards" & vbCrLf
SQL = SQL & "update TchdTable set TMSTART = (select top 1 TCSTART From TcitTable " & vbCrLf
SQL = SQL & "where TCCARD = TMCARD and TCSTOP <> ''" & vbCrLf
SQL = SQL & "and ISDATE(TCSTART + 'm') = 1 and ISDATE(TCSTOP + 'm') = 1" & vbCrLf
SQL = SQL & "order by tcstarttime)," & vbCrLf
SQL = SQL & "TMSTOP = (select top 1 TCSTOP From TcitTable" & vbCrLf
SQL = SQL & "where TCCARD = TMCARD and TCSTOP <> ''" & vbCrLf
SQL = SQL & "and ISDATE(TCSTART + 'm') = 1 and ISDATE(TCSTOP + 'm') = 1" & vbCrLf
SQL = SQL & "order by TCSTOPTIME desc)" & vbCrLf
SQL = SQL & "where TMCARD in (select distinct TCCARD FROM #temp)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- total regular, overhead and doubletime hours" & vbCrLf
SQL = SQL & "select TCCARD, TYPETYPE, ISNULL(SUM(TCHOURS),0.0) as HRS" & vbCrLf
SQL = SQL & "into #totals" & vbCrLf
SQL = SQL & "from TcitTable ti" & vbCrLf
SQL = SQL & "JOIN TmcdTable tc ON ti.TCCODE = tc.TYPECODE" & vbCrLf
SQL = SQL & "where TCCARD in (select TCCARD FROM #temp)" & vbCrLf
SQL = SQL & "group by TCCARD, TYPETYPE" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "update tc set TMREGHRS = isnull(HRS,0.0)" & vbCrLf
SQL = SQL & "from tchdtable tc" & vbCrLf
SQL = SQL & "join #totals tot on tot.TCCARD = tc.TMCARD and tot.TYPETYPE = 'R'" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "update tc set TMOVTHRS = isnull(HRS,0.0)" & vbCrLf
SQL = SQL & "from tchdtable tc" & vbCrLf
SQL = SQL & "join #totals tot on tot.TCCARD = tc.TMCARD and tot.TYPETYPE = 'O'" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "update tc set TMDBLHRS = isnull(HRS,0.0)" & vbCrLf
SQL = SQL & "from tchdtable tc" & vbCrLf
SQL = SQL & "join #totals tot on tot.TCCARD = tc.TMCARD and tot.TYPETYPE = 'D'" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "--select * from TcitTable tc" & vbCrLf
SQL = SQL & "--join #temp tmp on tc.TCPARTREF = tmp.TCPARTREF and tc.TCRUNNO = tmp.TCRUNNO and tc.TCOPNO = tmp.TCOPNO " & vbCrLf
SQL = SQL & "-- and tc.TCEMP = tmp.TCEMP and tc.TCSTARTTIME = tmp.TCSTARTTIME" & vbCrLf
SQL = SQL & "--select * from TchdTable where TMCARD in (select tccard from #temp)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "delete istc" & vbCrLf
SQL = SQL & "from IstcTable istc join #temp t on t.TCPARTREF = istc.ISMO and t.TCRUNNO = istc.ISRUN" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "drop table #temp" & vbCrLf
SQL = SQL & "drop table #shifts" & vbCrLf
SQL = SQL & "drop table #totals" & vbCrLf
SQL = SQL & "commit tran" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "return" & vbCrLf
SQL = SQL & "" & vbCrLf
ExecuteScript False, SQL


''''''''''''''''''''''''''''''''''''''''''''''''''

        ' update the version
        ExecuteScript False, "Update Version Set Version = " & newver

    End If
End Function


''''''''''''''''''''''''''''''''''''''''''''''''

Private Function UpdateDatabase82()

'update database version template
'set version at top of this file
'add call to this function
'set version below
'add SQL updates


   Dim SQL As String
   SQL = ""

   newver = 157
   If ver < newver Then

        clsADOCon.ADOErrNum = 0

''''''''''''''''''''''''''''''''''''''''''''''''''

SQL = "IF EXISTS (SELECT * FROM sys.objects WHERE type = 'P' AND name = 'RptWCQListStats')" & vbCrLf
SQL = SQL & "DROP PROCEDURE RptWCQListStats" & vbCrLf
ExecuteScript False, SQL

SQL = "create procedure dbo.RptWCQListStats" & vbCrLf
SQL = SQL & " @BeginDate  as varchar(30),@EdnDate as varchar(10)," & vbCrLf
SQL = SQL & " @OpShop as varchar(12), @OpCenter as varchar(12)  " & vbCrLf
SQL = SQL & " AS" & vbCrLf
SQL = SQL & " BEGIN " & vbCrLf
SQL = SQL & "   IF (@OpShop = '')  " & vbCrLf
SQL = SQL & "   BEGIN   " & vbCrLf
SQL = SQL & "       SET @OpShop = '%'    " & vbCrLf
SQL = SQL & "   End " & vbCrLf
SQL = SQL & "                " & vbCrLf
SQL = SQL & "   IF (@OpCenter = '')    " & vbCrLf
SQL = SQL & "   BEGIN   " & vbCrLf
SQL = SQL & "       SET @OpCenter = '%'        " & vbCrLf
SQL = SQL & "   End                       " & vbCrLf
SQL = SQL & "    " & vbCrLf
SQL = SQL & "   select distinct runstable.Runref, runstable.runno, OPCENTER, RUNSTATUS, RUNQTY," & vbCrLf
SQL = SQL & "       runopcur,RnopTable.OPQDATE,  RnopTable.OPSCHEDDATE,RunsTable.RUNPRIORITY," & vbCrLf
SQL = SQL & "       f.PrevOPNO, f.OPQDATE PREVQDATE, f.OPCOMPDATE PREVCOMPDATE," & vbCrLf
SQL = SQL & "       DATEDIFF(day,f.OPCOMPDATE, RnopTable.OPQDATE) DtDiffQue," & vbCrLf
SQL = SQL & "       DATEDIFF(day, f.OPCOMPDATE, GETDATE()) DtDiffNow" & vbCrLf
SQL = SQL & "      from runstable,RnopTable," & vbCrLf
SQL = SQL & "      (select a.runref, a.runno, b.OPNO PrevOPNO, OPQDATE, OPCOMPDATE," & vbCrLf
SQL = SQL & "            ROW_NUMBER() OVER (PARTITION BY opref, oprun" & vbCrLf
SQL = SQL & "                          ORDER BY opref DESC, oprun DESC, OPNO desc) as rn" & vbCrLf
SQL = SQL & "         from runstable a,rnopTable b" & vbCrLf
SQL = SQL & "         where a.runref = b.opref and" & vbCrLf
SQL = SQL & "            a.RunNO = b.oprun And b.opno < a.runopcur" & vbCrLf
SQL = SQL & "      ) as f" & vbCrLf
SQL = SQL & "   where RnopTable.OPSCHEDDATE between @BeginDate and @EdnDate" & vbCrLf
SQL = SQL & "      and RunsTable.runref =  f.runref AND RunsTable.runno = f.runno" & vbCrLf
SQL = SQL & "      and RnopTable.opref = RunsTable.runref AND RunsTable.runno = RnopTable.OPRUN" & vbCrLf
SQL = SQL & "      and RunsTable.runopcur = RnopTable.Opno" & vbCrLf
SQL = SQL & "      and RnopTable.OPSHOP LIKE @OpShop AND RnopTable.OPCENTER LIKE @OpCenter" & vbCrLf
SQL = SQL & "       AND RnopTable.OPCOMPLETE = 0" & vbCrLf
SQL = SQL & "      and f.rn = 1" & vbCrLf
SQL = SQL & "   ORDER BY RunsTable.RUNPRIORITY, RnopTable.OPSCHEDDATE" & vbCrLf
SQL = SQL & "    " & vbCrLf
SQL = SQL & " End" & vbCrLf
SQL = SQL & "" & vbCrLf
ExecuteScript False, SQL

'''''''''''''''''''''''''''''''''''

SQL = "IF EXISTS (SELECT * FROM sys.objects WHERE type = 'P' AND name = 'RptHistoryWCQListStats')" & vbCrLf
SQL = SQL & "DROP PROCEDURE RptHistoryWCQListStats" & vbCrLf
ExecuteScript False, SQL

SQL = "CREATE PROCEDURE dbo.RptHistoryWCQListStats" & vbCrLf
SQL = SQL & " @BeginDate  as varchar(30),@EdnDate as varchar(10)," & vbCrLf
SQL = SQL & " @OpShop as varchar(12), @OpCenter as varchar(12)  " & vbCrLf
SQL = SQL & " AS" & vbCrLf
SQL = SQL & " BEGIN " & vbCrLf
SQL = SQL & "   IF (@OpShop = '')  " & vbCrLf
SQL = SQL & "   BEGIN   " & vbCrLf
SQL = SQL & "      SET @OpShop = '%'    " & vbCrLf
SQL = SQL & "   End;" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "   WITH CTE as " & vbCrLf
SQL = SQL & "   (select b.opref, b.oprun, b.OPNO , OPQDATE, " & vbCrLf
SQL = SQL & "       OPCOMPDATE, OPCOMPLETE," & vbCrLf
SQL = SQL & "       OPSHOP,OPCENTER,OPSCHEDDATE, " & vbCrLf
SQL = SQL & "       ROW_NUMBER() OVER (PARTITION BY opref, oprun" & vbCrLf
SQL = SQL & "                   ORDER BY opref , oprun , OPNO) as rn" & vbCrLf
SQL = SQL & "   from rnopTable b" & vbCrLf
SQL = SQL & "   where b.opcomplete = 1" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "   )" & vbCrLf
SQL = SQL & "   SELECT DISTINCT CTE.opref AS Runref, CTE.oprun AS runno, CTE.OPCENTER, " & vbCrLf
SQL = SQL & "       RunsTable.RUNSTATUS, RunsTable.RUNQTY,RunsTable.runopcur,RunsTable.RUNPRIORITY," & vbCrLf
SQL = SQL & "       CTE.OPQDATE, CTE.OPSCHEDDATE, CTE.OPNO, CTE.OPCOMPDATE, " & vbCrLf
SQL = SQL & "       prev.OPCOMPDATE as PrevCOMDATE, " & vbCrLf
SQL = SQL & "       DATEDIFF(day,prev.OPCOMPDATE, CTE.OPCOMPDATE) DtDiffQue," & vbCrLf
SQL = SQL & "       DATEDIFF(day, prev.OPCOMPDATE, GETDATE()) DtDiffNow" & vbCrLf
SQL = SQL & "   FROM CTE" & vbCrLf
SQL = SQL & "   LEFT JOIN CTE prev ON  CTE.OPREF = prev.OPREF" & vbCrLf
SQL = SQL & "       AND CTE.OPRUN = prev.OPRUN" & vbCrLf
SQL = SQL & "       AND prev.rn = CTE.rn - 1" & vbCrLf
SQL = SQL & "   JOIN RunsTable ON RunsTable.runref =  CTE.opref " & vbCrLf
SQL = SQL & "       AND RunsTable.runno = CTE.oprun" & vbCrLf
SQL = SQL & "   WHERE CTE.OPSHOP LIKE @OpShop AND CTE.OPCENTER LIKE (@OpCenter + '%')" & vbCrLf
SQL = SQL & "   AND CTE.OPCOMPDATE >= @BeginDate " & vbCrLf
SQL = SQL & "   AND CTE.OPCOMPDATE < DATEADD(d, 1, @EdnDate)" & vbCrLf
SQL = SQL & "   ORDER BY RunsTable.RUNPRIORITY,CTE.OPSCHEDDATE" & vbCrLf
SQL = SQL & " End" & vbCrLf
ExecuteScript False, SQL


''''''''''''''''''''''''''''''''''''''''''''''''''

        ' update the version
        ExecuteScript False, "Update Version Set Version = " & newver

    End If
End Function

''''''''''''''''''''''''''''''''''''''''''''''''''

Private Function UpdateDatabase83()

'update database version template
'set version at top of this file
'set version below
'add SQL updates


   Dim SQL As String
   SQL = ""

   newver = 158     ' set actual version
   If ver < newver Then

        clsADOCon.ADOErrNum = 0

''''''''''''''''''''''''''''''''''''''''''''''''''

'not all customers got this column addition in 2011
If Not ColumnExists("EsReportVendorStmt", "CHKACCT") Then ExecuteScript False, "ALTER TABLE EsReportVendorStmt ADD CHKACCT Char(12)"

'some customers did not get this update, which added a second parameter
If StoreProcedureExists("UpdatePackingSlipCosts") Then
    sSql = "DROP PROCEDURE UpdatePackingSlipCosts"
    ExecuteScript False, sSql
End If
      
SQL = "create procedure dbo.UpdatePackingSlipCosts" & vbCrLf
SQL = SQL & "(" & vbCrLf
SQL = SQL & " @PackingSlip varchar(8)," & vbCrLf
SQL = SQL & " @UpdateIaEvenIfJournalClosed bit    -- = 1 to update items for closed journals" & vbCrLf
SQL = SQL & ")" & vbCrLf
SQL = SQL & "as" & vbCrLf
SQL = SQL & "update InvaTable" & vbCrLf
SQL = SQL & "set INAMT = LOTUNITCOST," & vbCrLf
SQL = SQL & "INTOTMATL = cast ( abs( INAQTY ) * LOTTOTMATL / LOTORIGINALQTY as decimal(12,4))," & vbCrLf
SQL = SQL & "INTOTLABOR = cast ( abs( INAQTY ) * LOTTOTLABOR / LOTORIGINALQTY as decimal(12,4))," & vbCrLf
SQL = SQL & "INTOTEXP = cast ( abs( INAQTY ) * LOTTOTEXP / LOTORIGINALQTY as decimal(12,4)), " & vbCrLf
SQL = SQL & "INTOTOH = cast ( abs( INAQTY ) * LOTTOTOH / LOTORIGINALQTY as decimal(12,4))," & vbCrLf
SQL = SQL & "INTOTHRS = cast ( abs( INAQTY ) * LOTTOTHRS / LOTORIGINALQTY as decimal(12,4))" & vbCrLf
SQL = SQL & "from LoitTable " & vbCrLf
SQL = SQL & "join LohdTable ON LOINUMBER = LOTNUMBER" & vbCrLf
SQL = SQL & "join InvaTable ia2 ON INNUMBER = LOIACTIVITY" & vbCrLf
SQL = SQL & "where ia2.INPSNUMBER = @PackingSlip" & vbCrLf
SQL = SQL & "and LOTORIGINALQTY <> 0" & vbCrLf
SQL = SQL & "and (@UpdateIaEvenIfJournalClosed = 1 or ia2.INGLPOSTED = 0)" & vbCrLf
ExecuteScript False, SQL


''''''''''''''''''''''''''''''''''''''''''''''''''''

' this should have happened in UpdateDatabase27, but that did not happen for all users.
If StoreProcedureExists("RptChartOfAccount") Then
   sSql = "DROP PROCEDURE RptChartOfAccount"
   ExecuteScript False, sSql
End If

SQL = "CREATE  PROCEDURE [dbo].[RptChartOfAccount]  " & vbCrLf
SQL = SQL & "    @InclIncAcct as varchar(1)" & vbCrLf
SQL = SQL & "AS " & vbCrLf
SQL = SQL & "/*" & vbCrLf
SQL = SQL & "test" & vbCrLf
SQL = SQL & "  exec RptChartOfAccount 0" & vbCrLf
SQL = SQL & "*/" & vbCrLf
SQL = SQL & "BEGIN " & vbCrLf
SQL = SQL & " " & vbCrLf
SQL = SQL & "   declare @glAcctRef as varchar(10) " & vbCrLf
SQL = SQL & "   declare @glMsAcct as varchar(10) " & vbCrLf
SQL = SQL & "   declare @TopLevelDesc as varchar(30)" & vbCrLf
SQL = SQL & " " & vbCrLf
SQL = SQL & "   declare @level as varchar(12)" & vbCrLf
SQL = SQL & "   declare @InclInAcct as Integer" & vbCrLf
SQL = SQL & " " & vbCrLf
SQL = SQL & "   if (@InclIncAcct = '1')" & vbCrLf
SQL = SQL & "      SET @InclInAcct = ''" & vbCrLf
SQL = SQL & "   else" & vbCrLf
SQL = SQL & "      SET @InclInAcct = '0'" & vbCrLf
SQL = SQL & " " & vbCrLf
SQL = SQL & "   CREATE TABLE #tempChartOfAcct(   " & vbCrLf
SQL = SQL & "   [TOPLEVEL] [varchar](12) NULL,  " & vbCrLf
SQL = SQL & "   [TOPLEVELDESC] [varchar](30) NULL, " & vbCrLf
SQL = SQL & "   [GLACCTREF] [varchar](112) NULL,         " & vbCrLf
SQL = SQL & "   [GLDESCR] [varchar](120) NULL,  " & vbCrLf
SQL = SQL & "   [GLMASTER] [varchar](12) NULL,   " & vbCrLf
SQL = SQL & "   [GLFSLEVEL] [INT] NULL," & vbCrLf
SQL = SQL & "   [GLINACTIVE] [int] NULL," & vbCrLf
SQL = SQL & "   [SORTKEYLEVEL] [int] NULL,           " & vbCrLf
SQL = SQL & "   [GLACCSORTKEY] [varchar](512) NULL           " & vbCrLf
SQL = SQL & ")                             " & vbCrLf
SQL = SQL & " " & vbCrLf
SQL = SQL & " " & vbCrLf
SQL = SQL & "   DECLARE balAcctStruc CURSOR  FOR " & vbCrLf
SQL = SQL & "      SELECT COASSTACCT, COASSTDESC FROM GlmsTable" & vbCrLf
SQL = SQL & "      UNION ALL" & vbCrLf
SQL = SQL & "      SELECT COLIABACCT, COLIABDESC FROM GlmsTable" & vbCrLf
SQL = SQL & "      UNION ALL" & vbCrLf
SQL = SQL & "      SELECT COINCMACCT, COINCMDESC FROM GlmsTable" & vbCrLf
SQL = SQL & "      UNION ALL " & vbCrLf
SQL = SQL & "      SELECT COEQTYACCT, COEQTYDESC FROM GlmsTable" & vbCrLf
SQL = SQL & "      UNION ALL" & vbCrLf
SQL = SQL & "      SELECT COCOGSACCT, COCOGSDESC FROM GlmsTable" & vbCrLf
SQL = SQL & "      UNION ALL" & vbCrLf
SQL = SQL & "      SELECT COEXPNACCT, COEXPNDESC FROM GlmsTable" & vbCrLf
SQL = SQL & "      UNION ALL" & vbCrLf
SQL = SQL & "      SELECT COOINCACCT, COOINCDESC FROM GlmsTable" & vbCrLf
SQL = SQL & "      UNION ALL" & vbCrLf
SQL = SQL & "      SELECT COFDTXACCT, COFDTXDESC FROM GlmsTable" & vbCrLf
SQL = SQL & "      UNION ALL" & vbCrLf
SQL = SQL & "     SELECT COOEXPACCT, COOEXPDESC FROM GlmsTable" & vbCrLf
SQL = SQL & "      --UNION ALL" & vbCrLf
SQL = SQL & "      --SELECT COFDTXACCT, COFDTXDESC FROM GlmsTable" & vbCrLf
SQL = SQL & " " & vbCrLf
SQL = SQL & "   OPEN balAcctStruc" & vbCrLf
SQL = SQL & "   FETCH NEXT FROM balAcctStruc INTO @level, @TopLevelDesc" & vbCrLf
SQL = SQL & "   WHILE (@@FETCH_STATUS <> -1) " & vbCrLf
SQL = SQL & "   BEGIN " & vbCrLf
SQL = SQL & "      IF (@@FETCH_STATUS <> -2) " & vbCrLf
SQL = SQL & "      BEGIN " & vbCrLf
SQL = SQL & "         " & vbCrLf
SQL = SQL & "         INSERT INTO #tempChartOfAcct(TOPLEVEL, TOPLEVELDESC, GLACCTREF, GLDESCR, GLMASTER, GLFSLEVEL,GLINACTIVE, SORTKEYLEVEL,GLACCSORTKEY)" & vbCrLf
SQL = SQL & "         select @level as TopLevel, @TopLevelDesc as TopLevelDesc, @level as GLACCTREF, " & vbCrLf
SQL = SQL & "            @TopLevelDesc as GLDESCR, '' as GLMASTER, 0 as GLFSLEVEL, 0,0 as level, @level as SortKey;" & vbCrLf
SQL = SQL & " " & vbCrLf
SQL = SQL & "         with cte" & vbCrLf
SQL = SQL & "         as" & vbCrLf
SQL = SQL & "         (select GLACCTREF, GLDESCR, GLMASTER, GLFSLEVEL, GLINACTIVE, 0 as level," & vbCrLf
SQL = SQL & "            cast(cast(@level as varchar(12))+ char(36)+ GLACCTREF as varchar(max)) as SortKey" & vbCrLf
SQL = SQL & "         from GlacTable" & vbCrLf
SQL = SQL & "         where GLMASTER = cast(@level as varchar(12)) AND GLINACTIVE LIKE @InclInAcct" & vbCrLf
SQL = SQL & "         union all" & vbCrLf
SQL = SQL & "         select a.GLACCTREF, a.GLDESCR, a.GLMASTER, a.GLFSLEVEL, a.GLINACTIVE, level + 1," & vbCrLf
SQL = SQL & "          cast(COALESCE(SortKey,'') + char(36) + COALESCE(a.GLACCTREF,'') as varchar(max))as SortKey" & vbCrLf
SQL = SQL & "         from cte" & vbCrLf
SQL = SQL & "            inner join GlacTable a" & vbCrLf
SQL = SQL & "               on cte.GLACCTREF = a.GLMASTER" & vbCrLf
SQL = SQL & "            WHERE a.GLINACTIVE LIKE @InclInAcct" & vbCrLf
SQL = SQL & "         )" & vbCrLf
SQL = SQL & " " & vbCrLf
SQL = SQL & "         INSERT INTO #tempChartOfAcct(TOPLEVEL, TOPLEVELDESC, GLACCTREF, GLDESCR, GLMASTER, GLFSLEVEL,GLINACTIVE, SORTKEYLEVEL,GLACCSORTKEY)" & vbCrLf
SQL = SQL & "         select @level as TopLevel, @TopLevelDesc as TopLevelDesc, " & vbCrLf
SQL = SQL & "               Replicate('  ', level) + GLACCTREF as GLACCTREF, " & vbCrLf
SQL = SQL & "               Replicate('  ', level) + GLDESCR as GLDESCR, GLMASTER, " & vbCrLf
SQL = SQL & "               GLFSLEVEL, GLINACTIVE,level, SortKey" & vbCrLf
SQL = SQL & "         from cte order by SortKey" & vbCrLf
SQL = SQL & "         " & vbCrLf
SQL = SQL & "      END" & vbCrLf
SQL = SQL & "      FETCH NEXT FROM balAcctStruc INTO @level, @TopLevelDesc" & vbCrLf
SQL = SQL & "   END         " & vbCrLf
SQL = SQL & "   CLOSE balAcctStruc" & vbCrLf
SQL = SQL & "   DEALLOCATE balAcctStruc" & vbCrLf
SQL = SQL & " " & vbCrLf
SQL = SQL & "   SELECT TOPLEVEL, TOPLEVELDESC, GLACCTREF, GLDESCR, GLMASTER, " & vbCrLf
SQL = SQL & "      GLFSLEVEL,GLINACTIVE, SORTKEYLEVEL,GLACCSORTKEY " & vbCrLf
SQL = SQL & "   FROM #tempChartOfAcct ORDER BY GLACCSORTKEY" & vbCrLf
SQL = SQL & "                                           " & vbCrLf
SQL = SQL & "   DROP table #tempChartOfAcct            " & vbCrLf
SQL = SQL & " " & vbCrLf
SQL = SQL & "End" & vbCrLf
SQL = SQL & "" & vbCrLf
ExecuteScript False, SQL

''''''''''''''''''''''''''''''''''''''''''''''''''

        ' update the version
        ExecuteScript False, "Update Version Set Version = " & newver

    End If
End Function

Private Function UpdateDatabase84()

'update database version template
'set version at top of this file
'set version below
'add SQL updates


   Dim SQL As String
   SQL = ""

   newver = 159     ' set actual version
   If ver < newver Then

        clsADOCon.ADOErrNum = 0

''''''''''''''''''''''''''''''''''''''''''''''''''

      If (Not TableExists("TlitTableNew")) Then
      
         sSql = "CREATE TABLE [dbo].[TlitTableNew](" & vbCrLf
         sSql = sSql & " [TOOL_NUM] [char](30) NOT NULL CONSTRAINT [DF_TlitTableNew_TOOL_NUM]  DEFAULT ('')," & vbCrLf
         sSql = sSql & " [TOOL_PARTREF] [char](30) NOT NULL CONSTRAINT [DF_TlitTableNew_TOOL_PARTREF]  DEFAULT ('')," & vbCrLf
         sSql = sSql & " [TOOL_CLASS] [char](12) NULL CONSTRAINT [DF_TlitTableNew_TOOL_CLASS]  DEFAULT ('')" & vbCrLf
         sSql = sSql & ") ON [PRIMARY]" & vbCrLf
         
         ExecuteScript False, sSql
      End If
      
      'this code did not execute in previous update
      If (Not TableExists("TlnhdTableNew")) Then
         sSql = "CREATE TABLE [dbo].[TlnhdTableNew](" & vbCrLf
         sSql = sSql & "   [TOOL_NUM] [char](30) NOT NULL," & vbCrLf
         sSql = sSql & "   [TOOL_DTADDED] [char](12) NULL," & vbCrLf
         sSql = sSql & "   [TOOL_CGPONUM] [char](30) NULL," & vbCrLf
         sSql = sSql & "   [TOOL_CUSTPONUM] [char](30) NULL," & vbCrLf
         sSql = sSql & "   [TOOL_CGSOPONUM] [char](30) NULL," & vbCrLf
         sSql = sSql & "   [TOOL_GOVOWNED] [char](10) NULL," & vbCrLf
         sSql = sSql & "   [TOOL_CLASS] [char](12) NULL," & vbCrLf
         sSql = sSql & "   [TOOL_HOMEBLDG] [char](30) NULL," & vbCrLf
         sSql = sSql & "   [TOOL_HOMEAISLE] [char](30) NULL," & vbCrLf
         sSql = sSql & "   [TOOL_SHELFNUM] [char](30) NULL," & vbCrLf
         sSql = sSql & "   [TOOL_GRID] [char](30) NULL," & vbCrLf
         sSql = sSql & "   [TOOL_LOCNUM] [char](30) NULL," & vbCrLf
         sSql = sSql & "   [TOOL_COMMENTS] [varchar](1020) NULL," & vbCrLf
         sSql = sSql & "   [TOOL_OWNER] [char](20) NULL," & vbCrLf
         sSql = sSql & "   [TOOL_ACCTTO] [char](20) NULL," & vbCrLf
         sSql = sSql & "   [TOOL_SN] [char](20) NULL," & vbCrLf
         sSql = sSql & "   [TOOL_MAKEPN] [char](20) NULL," & vbCrLf
         sSql = sSql & "   [TOOL_CAVNUM] [char](20) NULL," & vbCrLf
         sSql = sSql & "   [TOOL_DIM] [char](20) NULL," & vbCrLf
         sSql = sSql & "   [TOOL_BLANKPONUM] [char](20) NULL," & vbCrLf
         sSql = sSql & "   [TOOL_MONUM] [char](20) NULL," & vbCrLf
         sSql = sSql & "   [TOOL_TOOLMATSTAT] [char](20) NULL," & vbCrLf
         sSql = sSql & "   [TOOL_SRVSTAT] [char](20) NULL," & vbCrLf
         sSql = sSql & "   [TOOL_DISPSTAT] [char](20) NULL," & vbCrLf
         sSql = sSql & "   [TOOL_STORAGESTAT] [char](20) NULL" & vbCrLf
         sSql = sSql & " CONSTRAINT [PK_TlnhdTableNew_TOOL_NUM] PRIMARY KEY CLUSTERED" & vbCrLf
         sSql = sSql & "(" & vbCrLf
         sSql = sSql & "   [TOOL_NUM] Asc" & vbCrLf
         sSql = sSql & ")WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 80) ON [PRIMARY]" & vbCrLf
         sSql = sSql & ") ON [PRIMARY]"

         ExecuteScript False, sSql
      End If
      
'      sSql = "ALTER TABLE TlnhdTableNew Add TOOL_ITAR int NULL CONSTRAINT DF__TlnhdTabl__TOOL_ITAR default(0)"
'      ExecuteScript False, sSql
      
If Not ColumnExists("TlnhdTableNew", "TOOL_ITAR") Then
   ExecuteScript False, "ALTER TABLE TlnhdTableNew Add TOOL_ITAR int NULL CONSTRAINT DF__TlnhdTabl__TOOL_ITAR default(0)"
End If
      


'      sSql = "ALTER TABLE TlnhdTableNew DROP COLUMN TOOL_MONUM"
'      ExecuteScript False, sSql
'
      sSql = "ALTER TABLE TlnhdTableNew Add TOOL_WEIGHT VARCHAR(20) NULL CONSTRAINT DF__TlnhdTabl__TOOL_WEIGHT default('')"
      ExecuteScript False, sSql

SQL = "IF object_id('fnCompress') IS NOT NULL" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "    DROP FUNCTION [dbo].fnCompress" & vbCrLf
SQL = SQL & "END" & vbCrLf
ExecuteScript False, SQL

SQL = "create function dbo.fnCompress( @in varchar(30))" & vbCrLf
SQL = SQL & "returns varchar(30)" & vbCrLf
SQL = SQL & "-- remove tabs, crs, lfs, blanks, commas, single-quotes and dashes to create a key field" & vbCrLf
SQL = SQL & "as" & vbCrLf
SQL = SQL & "begin" & vbCrLf
SQL = SQL & "  return REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(@in,CHAR(9),''),CHAR(10),''),CHAR(13),''),' ',''),'''',''),'-','')" & vbCrLf
SQL = SQL & "end" & vbCrLf
ExecuteScript False, SQL

SQL = "ALTER TABLE [dbo].[TlnhdTableNew] DROP CONSTRAINT [PK_TlnhdTableNew_TOOL_NUM]" & vbCrLf
ExecuteScript False, SQL

SQL = "ALTER TABLE [TlnhdTableNew] ADD TOOL_NUMREF varchar(30) NULL" & vbCrLf
ExecuteScript False, SQL

SQL = "UPDATE TlnhdTableNew SET TOOL_NUMREF = dbo.fnCompress(TOOL_NUM)," & vbCrLf
SQL = SQL & "  TOOL_WEIGHT = ''" & vbCrLf
ExecuteScript False, SQL

SQL = "ALTER TABLE [TlnhdTableNew] ALTER COLUMN TOOL_weight varchar(20) NOT NULL" & vbCrLf
ExecuteScript False, SQL

SQL = "ALTER TABLE [TlnhdTableNew] ALTER COLUMN TOOL_NUMREF varchar(30) NOT NULL" & vbCrLf
ExecuteScript False, SQL

SQL = "ALTER TABLE [dbo].[TlnhdTableNew] ADD  CONSTRAINT [PK_TlnhdTableNew_TOOL_NUMREF] PRIMARY KEY CLUSTERED " & vbCrLf
SQL = SQL & "(" & vbCrLf
SQL = SQL & "  [TOOL_NUMREF] ASC" & vbCrLf
SQL = SQL & ")" & vbCrLf
ExecuteScript False, SQL

SQL = "EXEC sp_rename 'TlitTableNew.TOOL_NUM', 'TOOL_NUMREF'" & vbCrLf
ExecuteScript False, SQL




''''''''''''''''''''''''''''''''''''''''''''''''''

        ' update the version
        ExecuteScript False, "Update Version Set Version = " & newver

    End If
End Function

Private Function UpdateDatabase85()

'update database version template
'set version at top of this file
'set version below
'add SQL updates


   Dim SQL As String
   SQL = ""

   newver = 160     ' set actual version
   If ver < newver Then

        clsADOCon.ADOErrNum = 0

''''''''''''''''''''''''''''''''''''''''''''''''''

      If StoreProcedureExists("BackLogByPartNumber") Then
         sSql = "DROP PROCEDURE BackLogByPartNumber"
         ExecuteScript False, sSql
      End If

SQL = "create procedure dbo.BackLogByPartNumber" & vbCrLf
SQL = SQL & "  @BegDate as varchar(16), " & vbCrLf
SQL = SQL & "  @EndDate as varchar(16), " & vbCrLf
SQL = SQL & "  @PartNumber as Varchar(30)," & vbCrLf
SQL = SQL & "  @Customer as varchar(10)," & vbCrLf
SQL = SQL & "  @PartClass as Varchar(16)," & vbCrLf
SQL = SQL & "  @PartCode as varchar(8)" & vbCrLf
SQL = SQL & " AS" & vbCrLf
SQL = SQL & "/*" & vbCrLf
SQL = SQL & " test" & vbCrLf
SQL = SQL & " BackLogByPartNumber '4/1/2017', '4/30/2017', '1', 'K', 'ALL', 'ALL'" & vbCrLf
SQL = SQL & "*/    " & vbCrLf
SQL = SQL & " declare @SoType as varchar(1)   " & vbCrLf
SQL = SQL & " declare @SoText as varchar(6)   " & vbCrLf
SQL = SQL & " declare @ItSo as int            " & vbCrLf
SQL = SQL & " declare @ItRev as char(2)       " & vbCrLf
SQL = SQL & " declare @ItNum as int           " & vbCrLf
SQL = SQL & " declare @ItQty as decimal(12,4) " & vbCrLf
SQL = SQL & " declare @PaLotRemQty as decimal(12,4)   " & vbCrLf
SQL = SQL & " declare @PartRem as decimal(12,4)       " & vbCrLf
SQL = SQL & " declare @RunningTot as decimal(12,4)    " & vbCrLf
SQL = SQL & " declare @ItDollars as decimal(12,4)     " & vbCrLf
SQL = SQL & " declare @ItSched as smalldatetime       " & vbCrLf
SQL = SQL & " declare @CusName as varchar(10)         " & vbCrLf
SQL = SQL & " declare @PartNum as varchar(30)         " & vbCrLf
SQL = SQL & " declare @CurPartNum as varchar(30)      " & vbCrLf
SQL = SQL & " declare @PartDesc as varchar(30)        " & vbCrLf
SQL = SQL & " declare @PartLoc as varchar(4)          " & vbCrLf
SQL = SQL & " declare @PartExDesc as varchar(3072)    " & vbCrLf
SQL = SQL & " declare @ItCanceled as tinyint          " & vbCrLf
SQL = SQL & " declare @ItPSNum as varchar(8)          " & vbCrLf
SQL = SQL & " declare @ItInvoice as int declare @ItPSShipped as tinyint   " & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & " IF (@PartNumber = 'ALL')                      " & vbCrLf
SQL = SQL & "   SET @PartNumber = '%'                      " & vbCrLf
SQL = SQL & " IF (@Customer = 'ALL')                      " & vbCrLf
SQL = SQL & "   SET @Customer = ''                      " & vbCrLf
SQL = SQL & " IF (@PartClass = 'ALL')                     " & vbCrLf
SQL = SQL & "     SET @PartClass = ''                     " & vbCrLf
SQL = SQL & " IF (@PartCode = 'ALL')                      " & vbCrLf
SQL = SQL & "    SET @PartCode = ''                      " & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "CREATE TABLE #tempBackLogInfo               " & vbCrLf
SQL = SQL & "    (SOTYPE varchar(1) NULL,        " & vbCrLf
SQL = SQL & "    SOTEXT varchar(6) NULL,         " & vbCrLf
SQL = SQL & "    ITSO Int NULL,                  " & vbCrLf
SQL = SQL & "    ITREV char(2) NULL,              " & vbCrLf
SQL = SQL & "    ITNUMBER int NULL,              " & vbCrLf
SQL = SQL & "    ITQTY decimal(12,4) NULL,       " & vbCrLf
SQL = SQL & "    PALOTQTYREMAINING decimal(12,4) NULL,   " & vbCrLf
SQL = SQL & "    RUNQTYTOT decimal(12,4) NULL,   " & vbCrLf
SQL = SQL & "    ITDOLLARS decimal(12,4) NULL,   " & vbCrLf
SQL = SQL & "    ITSCHED smalldatetime NULL,     " & vbCrLf
SQL = SQL & "    CUNICKNAME varchar(10) NULL,    " & vbCrLf
SQL = SQL & "    PARTNUM varchar(30) NULL,       " & vbCrLf
SQL = SQL & "    PADESC varchar(30) NULL,     " & vbCrLf
SQL = SQL & "    PAEXTDESC varchar(3072) NULL,   " & vbCrLf
SQL = SQL & "    PALOCATION varchar(4) NULL,     " & vbCrLf
SQL = SQL & "    ITCANCELED tinyint NULL,        " & vbCrLf
SQL = SQL & "    ITPSNUMBER varchar(8) NULL, ITINVOICE int NULL, " & vbCrLf
SQL = SQL & "    ITPSSHIPPED tinyint NULL)       " & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & " " & vbCrLf
SQL = SQL & "      DECLARE curbackLog CURSOR   FOR                             " & vbCrLf
SQL = SQL & "       SELECT SohdTable.SOTYPE, SohdTable.SOTEXT,                  " & vbCrLf
SQL = SQL & "          SoitTable.ITSO, SoitTable.ITREV, SoitTable.ITNUMBER,    " & vbCrLf
SQL = SQL & "          SoitTable.ITQTY, PartTable.PALOTQTYREMAINING,           " & vbCrLf
SQL = SQL & "          SoitTable.ITDOLLARS,SoitTable.ITSCHED, CustTable.CUNICKNAME,    " & vbCrLf
SQL = SQL & "          PartTable.PARTNUM, PartTable.PADESC, PartTable.PAEXTDESC,       " & vbCrLf
SQL = SQL & "          PartTable.PALOCATION, SoitTable.ITCANCELED,                     " & vbCrLf
SQL = SQL & "          SoitTable.ITPSNUMBER , SoitTable.ITINVOICE, SoitTable.ITPSSHIPPED   " & vbCrLf
SQL = SQL & "       From SohdTable, SoitTable, CustTable, PartTable             " & vbCrLf
SQL = SQL & "       WHERE SohdTable.SOCUST = CustTable.CUREF AND                " & vbCrLf
SQL = SQL & "          SohdTable.SONUMBER =SoitTable.ITSO AND                  " & vbCrLf
SQL = SQL & "          SoitTable.ITPART=PartTable.PARTREF AND                  " & vbCrLf
SQL = SQL & "          SoitTable.ITCANCELED=0 AND SoitTable.ITPSNUMBER=''      " & vbCrLf
SQL = SQL & "          AND SoitTable.ITINVOICE=0 AND SoitTable.ITPSSHIPPED=0" & vbCrLf
SQL = SQL & "          AND SoitTable.ITPART LIKE @PartNumber + '%'" & vbCrLf
SQL = SQL & "          AND CUREF LIKE '%' + @Customer + '%'                    " & vbCrLf
SQL = SQL & "          AND SoitTable.ITSCHED BETWEEN @BegDate AND @EndDate     " & vbCrLf
SQL = SQL & "          AND PartTable.PACLASS LIKE '%' + @PartClass + '%'       " & vbCrLf
SQL = SQL & "          AND PartTable.PAPRODCODE LIKE '%' + @PartCode + '%'     " & vbCrLf
SQL = SQL & "       ORDER BY partnum, ITSCHED                                   " & vbCrLf
SQL = SQL & "    " & vbCrLf
SQL = SQL & "    OPEN curbackLog                                                " & vbCrLf
SQL = SQL & "    FETCH NEXT FROM curbackLog INTO @SoType, @SoText, @ItSo,  @ItRev, @ItNum, @ItQty, @PaLotRemQty, " & vbCrLf
SQL = SQL & "                     @ItDollars,@ItSched, @CusName, @PartNum,        " & vbCrLf
SQL = SQL & "                     @PartDesc, @PartExDesc, @PartLoc, @ItCanceled,  " & vbCrLf
SQL = SQL & "                     @ItPSNum, @ItInvoice, @ItPSShipped              " & vbCrLf
SQL = SQL & "     SET @CurPartNum = @PartNum                                      " & vbCrLf
SQL = SQL & "     SET @RunningTot = 0                                             " & vbCrLf
SQL = SQL & "     WHILE (@@FETCH_STATUS <> -1)                                    " & vbCrLf
SQL = SQL & "     BEGIN                                                           " & vbCrLf
SQL = SQL & "         IF (@@FETCH_STATUS <> -2)                                   " & vbCrLf
SQL = SQL & "         BEGIN                                                       " & vbCrLf
SQL = SQL & "             IF  @CurPartNum <> @PartNum                             " & vbCrLf
SQL = SQL & "            BEGIN                                                    " & vbCrLf
SQL = SQL & "                 SET @RunningTot = @ItQty                            " & vbCrLf
SQL = SQL & "                 set @CurPartNum = @PartNum                          " & vbCrLf
SQL = SQL & "             End                                                     " & vbCrLf
SQL = SQL & "             Else                                                    " & vbCrLf
SQL = SQL & "             BEGIN                                                   " & vbCrLf
SQL = SQL & "                 SET @RunningTot = @RunningTot + @ItQty              " & vbCrLf
SQL = SQL & "             End                                                     " & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "             SET @PartRem = @PaLotRemQty - @RunningTot                       " & vbCrLf
SQL = SQL & "             INSERT INTO #tempBackLogInfo (SOTYPE, SOTEXT, ITSO, ITREV,      " & vbCrLf
SQL = SQL & "                 ITNUMBER,ITQTY, PALOTQTYREMAINING,RUNQTYTOT, ITDOLLARS,     " & vbCrLf
SQL = SQL & "                 ITSCHED,CUNICKNAME, PARTNUM, PADESC,PAEXTDESC,PALOCATION,   " & vbCrLf
SQL = SQL & "                      ITCANCELED, ITPSNUMBER, ITINVOICE, ITPSSHIPPED)             " & vbCrLf
SQL = SQL & "             VALUES (@SoType, @SoText, @ItSo, @ItRev,@ItNum, @ItQty,@PaLotRemQty,@PartRem, @ItDollars,@ItSched,@CusName, " & vbCrLf
SQL = SQL & "                 @PartNum,@PartDesc,@PartExDesc,@PartLoc, @ItCanceled,@ItPSNum,@ItInvoice,@ItPSShipped)  " & vbCrLf
SQL = SQL & "         End                                                                 " & vbCrLf
SQL = SQL & "         FETCH NEXT FROM curbackLog INTO @SoType, @SoText, @ItSo,            " & vbCrLf
SQL = SQL & "             @ItRev, @ItNum, @ItQty, @PaLotRemQty,                           " & vbCrLf
SQL = SQL & "             @ItDollars,@ItSched, @CusName, @PartNum,                        " & vbCrLf
SQL = SQL & "             @PartDesc, @PartExDesc, @PartLoc, @ItCanceled,                  " & vbCrLf
SQL = SQL & "             @ItPSNum, @ItInvoice, @ItPSShipped                              " & vbCrLf
SQL = SQL & "     End                                                                     " & vbCrLf
SQL = SQL & "     CLOSE curbackLog   --// close the cursor                                " & vbCrLf
SQL = SQL & "     DEALLOCATE curbackLog                                                   " & vbCrLf
SQL = SQL & "     -- select data for the report                                           " & vbCrLf
SQL = SQL & "     SELECT SOTYPE, SOTEXT, ITSO, ITREV,                                     " & vbCrLf
SQL = SQL & "         ITNUMBER,ITQTY, PALOTQTYREMAINING,RUNQTYTOT, ITDOLLARS,             " & vbCrLf
SQL = SQL & "         ITSCHED,CUNICKNAME, PARTNUM, PADESC,PAEXTDESC, PALOCATION,          " & vbCrLf
SQL = SQL & "         ITCANCELED , ITPSNUMBER, ITINVOICE, ITPSSHIPPED                     " & vbCrLf
SQL = SQL & "     FROM #tempBackLogInfo                                                   " & vbCrLf
SQL = SQL & "     ORDER BY ITSCHED                                                        " & vbCrLf
SQL = SQL & "     -- drop the temp table                                                  " & vbCrLf
SQL = SQL & "     DROP table #tempBackLogInfo                                             " & vbCrLf
ExecuteScript False, SQL

''''''''''''''''''''''''''''''''''''''''''''''''''

        ' update the version
        ExecuteScript False, "Update Version Set Version = " & newver

    End If
End Function



Private Function UpdateDatabase86()

   Dim SQL As String
   SQL = ""

   newver = 161     ' set actual version
   If ver < newver Then

        clsADOCon.ADOErrNum = 0

''''''''''''''''''''''''''''''''''''''''''''''''''

SQL = "if object_id('SheetUnitConversion') IS NOT NULL" & vbCrLf
SQL = SQL & "    drop procedure SheetUnitConversion" & vbCrLf
ExecuteScript False, SQL

SQL = "create procedure dbo.SheetUnitConversion" & vbCrLf
SQL = SQL & "   @LotNo as char(15)" & vbCrLf
SQL = SQL & "as" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "/* convert lot from purchasing units to inventory units" & vbCrLf
SQL = SQL & "test:" & vbCrLf
SQL = SQL & "exec SheetUnitConversion '42701-729201-79'" & vbCrLf
SQL = SQL & "*/" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- get purchase item unit cost, lot dimensions, and units" & vbCrLf
SQL = SQL & "declare @purchaseUnitCost decimal(12,4), @height decimal(12,4), @length decimal(12,4), " & vbCrLf
SQL = SQL & "   @purchUnit char(2), @invUnit char(2), @lotQtyAfter decimal(12,4), @unitCost decimal(12,4), " & vbCrLf
SQL = SQL & "   @purchQty decimal(12,4), @partRef varchar(30), @lotQtyBefore decimal(12,4)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "select @purchaseUnitCost = poi.PIAMT, @height = loh.LOTMATHEIGHT, @length = loh.LOTMATLENGTH," & vbCrLf
SQL = SQL & "   @purchUnit = pt.PAPUNITS, @invUnit = pt.PAUNITS, @purchQty = poi.PIAQTY," & vbCrLf
SQL = SQL & "   @lotQtyAfter = loh.LOTMATHEIGHT * loh.LOTMATLENGTH * ROUND((loh.LOTTOTMATL + .1) / POI.PIAMT,0)," & vbCrLf
SQL = SQL & "   @partRef = pt.PARTREF, @lotQtyBefore = loh.LOTORIGINALQTY " & vbCrLf
SQL = SQL & "from PoitTable poi" & vbCrLf
SQL = SQL & "join PohdTable poh on poh.PONUMBER = poi.PINUMBER" & vbCrLf
SQL = SQL & "join LohdTable loh on loh.LOTPO = poi.PINUMBER and loh.LOTPOITEM = poi.PIITEM and loh.LOTPOITEMREV = poi.PIREV" & vbCrLf
SQL = SQL & "join PartTable pt on pt.PARTREF = loh.LOTPARTREF" & vbCrLf
SQL = SQL & "where loh.LOTNUMBER = @LotNo and  pt.PAPUNITS = 'SH' and pt.PAUNITS <> pt.PAPUNITS and loh.LOTMATHEIGHT > 1 and loh.LOTMATLENGTH > 1 " & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "--print 'before = ' + cast(@lotQtyBefore as varchar(18))" & vbCrLf
SQL = SQL & "--print 'after  = ' + cast(@lotQtyAfter as varchar(18))" & vbCrLf
SQL = SQL & "--print cast(@purchaseUnitCost as varchar(12))" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- if data missing or lot alreadhy converted, do not do it again" & vbCrLf
SQL = SQL & "if @purchaseUnitCost is null or @lotQtyBefore = @lotQtyAfter or isnull(@lotQtyAfter, 0) = 0" & vbCrLf
SQL = SQL & "   return" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "set @unitCost = (@purchaseUnitCost * @lotQtyBefore) / @lotQtyAfter" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "--print cast(@height as varchar(12))" & vbCrLf
SQL = SQL & "--print cast(@length as varchar(12))" & vbCrLf
SQL = SQL & "--print cast(@purchUnit as varchar(12))" & vbCrLf
SQL = SQL & "--print cast(@invUnit as varchar(12))" & vbCrLf
SQL = SQL & "--print cast(@unitCost as varchar(12))" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "begin tran" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- update lot header record" & vbCrLf
SQL = SQL & "update LohdTable set LOTORIGINALQTY = @lotQtyAfter, LOTREMAININGQTY = @lotQtyAfter, LOTUNITCOST = @unitCost," & vbCrLf
SQL = SQL & "   LOTTOTMATL = @lotQtyAfter * @unitCost" & vbCrLf
SQL = SQL & "where LOTNUMBER = @LotNo " & vbCrLf
SQL = SQL & "--select * from LohdTable where LOTNUMBER = @LotNo" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- update first lot item (receipt)" & vbCrLf
SQL = SQL & "update LoitTable set LOIQUANTITY = @lotQtyAfter, LOIUNITS = @invUnit, LOIHEIGHT = @height, LOILENGTH = @length" & vbCrLf
SQL = SQL & "where LOINUMBER = @LotNo and LOIRECORD = 1" & vbCrLf
SQL = SQL & "--select * from LoitTable where LOINUMBER = @LotNo and LOIRECORD = 1" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- update inventory activity for PO receipt" & vbCrLf
SQL = SQL & "update invatable set INPQTY = @lotQtyAfter, INAQTY = @lotQtyAfter, INAMT = @unitCost, INUNITS = @invUnit" & vbCrLf
SQL = SQL & "where INLOTNUMBER = @LotNo and INTYPE = 15" & vbCrLf
SQL = SQL & "--select * from InvaTable where INLOTNUMBER = @LotNo and INTYPE = 15" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- update part QOH" & vbCrLf
SQL = SQL & "select PAQOH from PartTable where PARTREF = @partRef" & vbCrLf
SQL = SQL & "update PartTable set PAQOH = PAQOH + @lotQtyAfter - @lotQtyBefore where PARTREF = @partRef" & vbCrLf
SQL = SQL & "--select PAQOH from PartTable where PARTREF = @partRef" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "commit tran" & vbCrLf
SQL = SQL & "" & vbCrLf
ExecuteScript False, SQL


' fix sheet inventory rounding errors
SQL = "update lh" & vbCrLf
SQL = SQL & "set LOTTOTMATL = LOTORIGINALQTY * LOTUNITCOST" & vbCrLf
SQL = SQL & "from LohdTable lh" & vbCrLf
SQL = SQL & "join PartTable pt on pt.PARTREF = lh.LOTPARTREF" & vbCrLf
SQL = SQL & "join ComnTable com on COUSESHEETINVENTORY = 1" & vbCrLf
SQL = SQL & "where PAPUNITS = 'SH' and PAUNITS <> PAPUNITS" & vbCrLf
SQL = SQL & "and LOTTOTMATL <> LOTORIGINALQTY * LOTUNITCOST" & vbCrLf
ExecuteScript False, SQL

SQL = "if object_id('SheetRestock') IS NOT NULL" & vbCrLf
SQL = SQL & "    drop procedure SheetRestock" & vbCrLf
ExecuteScript False, SQL

SQL = "create procedure [dbo].[SheetRestock]" & vbCrLf
SQL = SQL & "   @UserLotNo varchar(40)," & vbCrLf
SQL = SQL & "   @User varchar(4)," & vbCrLf
SQL = SQL & "   @Comments varchar(2048)," & vbCrLf
SQL = SQL & "   @Location varchar(4)," & vbCrLf
SQL = SQL & "   @Params varchar(2000)   -- LOIRECORD,NEWHT,NEWLEN,... repeat (include comma at end)" & vbCrLf
SQL = SQL & "as" & vbCrLf
SQL = SQL & "/*" & vbCrLf
SQL = SQL & "restock sheet LOI records" & vbCrLf
SQL = SQL & "exec SheetRestock '029373-1-A', 'MGR', '2,36,96,0,12,72,'" & vbCrLf
SQL = SQL & "*/" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "begin tran" & vbCrLf
SQL = SQL & "create table #rect" & vbCrLf
SQL = SQL & "(" & vbCrLf
SQL = SQL & "   ParentRecord int," & vbCrLf
SQL = SQL & "   NewHeight decimal(12,4)," & vbCrLf
SQL = SQL & "   NewLength decimal(12,4)," & vbCrLf
SQL = SQL & "   NewRecord int," & vbCrLf
SQL = SQL & "   Qty decimal(12,4)," & vbCrLf
SQL = SQL & "   NewIANumber int" & vbCrLf
SQL = SQL & ")" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "declare @nextRecord int, @nextIANumber int" & vbCrLf
SQL = SQL & "declare @LotNo char(15), @id int, @SO int" & vbCrLf
SQL = SQL & "select @LotNo = LOTNUMBER from LohdTable where LOTUSERLOTID = @UserLotNo" & vbCrLf
SQL = SQL & "select @nextRecord = max(LOIRECORD) + 1 , @SO = max(LOISONUMBER) from LoitTable where LOINUMBER = @LotNo" & vbCrLf
SQL = SQL & "select @nextIANumber = max(INNUMBER) + 1 from InvaTable" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- first update the lot header" & vbCrLf
SQL = SQL & "update LohdTable set LOTCOMMENTS = @Comments, LOTLOCATION = @Location where LOTNUMBER = @LotNo" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- extract parameters" & vbCrLf
SQL = SQL & "DECLARE @start INT, @end INT" & vbCrLf
SQL = SQL & "declare @stringId varchar(10), @stringHt varchar(10), @stringLen varchar(10)" & vbCrLf
SQL = SQL & "SELECT @start = 1, @end = CHARINDEX(',', @Params) " & vbCrLf
SQL = SQL & "WHILE @start < LEN(@Params) + 1 BEGIN " & vbCrLf
SQL = SQL & "    IF @end = 0 break" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "    set @stringId = SUBSTRING(@Params, @start, @end - @start)" & vbCrLf
SQL = SQL & "    SET @start = @end + 1 " & vbCrLf
SQL = SQL & "    SET @end = CHARINDEX(',', @Params, @start)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "    IF @end = 0 break" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "    set @stringHt = SUBSTRING(@Params, @start, @end - @start)" & vbCrLf
SQL = SQL & "    SET @start = @end + 1 " & vbCrLf
SQL = SQL & "    SET @end = CHARINDEX(',', @Params, @start)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "    IF @end = 0 break" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "    set @stringLen = SUBSTRING(@Params, @start, @end - @start)" & vbCrLf
SQL = SQL & "    SET @start = @end + 1 " & vbCrLf
SQL = SQL & "    SET @end = CHARINDEX(',', @Params, @start)" & vbCrLf
SQL = SQL & "   " & vbCrLf
SQL = SQL & "   declare @ht decimal(12,4), @len decimal(12,4)" & vbCrLf
SQL = SQL & "   set @ht = cast(@stringHt as decimal(12,4))" & vbCrLf
SQL = SQL & "   set @len = cast(@stringLen as decimal(12,4))" & vbCrLf
SQL = SQL & "   insert into #rect (ParentRecord, NewHeight, NewLength, NewRecord, NewIANumber)" & vbCrLf
SQL = SQL & "   values (cast(@stringId as int), @ht, @len," & vbCrLf
SQL = SQL & "       case when @ht*@len = 0 then 0 else @nextRecord end," & vbCrLf
SQL = SQL & "       case when @ht*@len = 0 then 0 else @nextIANumber end)" & vbCrLf
SQL = SQL & "   if (@ht*@len) <> 0 " & vbCrLf
SQL = SQL & "   begin" & vbCrLf
SQL = SQL & "       set @nextRecord = @nextRecord + 1" & vbCrLf
SQL = SQL & "       set @nextIANumber = @nextIANumber + 1" & vbCrLf
SQL = SQL & "   end" & vbCrLf
SQL = SQL & "END " & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "update #rect set Qty = NewHeight * NewLength" & vbCrLf
SQL = SQL & "update #rect set ParentRecord = isnull((select top 1 ParentRecord from #rect where ParentRecord <> 0 ),0)" & vbCrLf
SQL = SQL & "where ParentRecord = 0" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "--select * from #rect" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "declare @partRef varchar(30), @currentTime datetime, @uom char(2), @type int" & vbCrLf
SQL = SQL & "declare @unitCost decimal(12,4), @nextINNUMBER int, @totalQty decimal(12,4)" & vbCrLf
SQL = SQL & "select @partRef = LOTPARTREF, @unitCost = LOTUNITCOST, @totalQty = LOTREMAININGQTY from LohdTable where LOTNUMBER = @LotNo" & vbCrLf
SQL = SQL & "select @uom = PAUNITS from PartTable where PARTREF = @partRef" & vbCrLf
SQL = SQL & "set @currentTime = getdate()" & vbCrLf
SQL = SQL & "select @nextINNUMBER = max(INNUMBER) + 1 from InvaTable" & vbCrLf
SQL = SQL & "set @type = 19     -- manual adjustment" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- update existing lot items" & vbCrLf
SQL = SQL & "Update li" & vbCrLf
SQL = SQL & "   set LOIINACTIVE = 1" & vbCrLf
SQL = SQL & "from LoitTable li " & vbCrLf
SQL = SQL & "join #rect r on li.LOINUMBER = @LotNo and li.LOIRECORD = r.ParentRecord" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- remove rectangles with no quantity remaining.  These items will not be restocked." & vbCrLf
SQL = SQL & "delete from #rect where Qty = 0" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- create new lot items" & vbCrLf
SQL = SQL & "INSERT INTO [dbo].[LoitTable]" & vbCrLf
SQL = SQL & "           ([LOINUMBER]" & vbCrLf
SQL = SQL & "           ,[LOIRECORD]" & vbCrLf
SQL = SQL & "           ,[LOITYPE]" & vbCrLf
SQL = SQL & "           ,[LOIPARTREF]" & vbCrLf
SQL = SQL & "           ,[LOIADATE]" & vbCrLf
SQL = SQL & "           ,[LOIPDATE]" & vbCrLf
SQL = SQL & "           ,[LOIQUANTITY]" & vbCrLf
SQL = SQL & "           ,[LOIMOPARTREF]" & vbCrLf
SQL = SQL & "           ,[LOIMORUNNO]" & vbCrLf
SQL = SQL & "           ,[LOIPONUMBER]" & vbCrLf
SQL = SQL & "           ,[LOIPOITEM]" & vbCrLf
SQL = SQL & "           ,[LOIPOREV]" & vbCrLf
SQL = SQL & "           ,[LOIPSNUMBER]" & vbCrLf
SQL = SQL & "           ,[LOIPSITEM]" & vbCrLf
SQL = SQL & "           ,[LOICUSTINVNO]" & vbCrLf
SQL = SQL & "           ,[LOICUST]" & vbCrLf
SQL = SQL & "           ,[LOIVENDINVNO]" & vbCrLf
SQL = SQL & "           ,[LOIVENDOR]" & vbCrLf
SQL = SQL & "           ,[LOIACTIVITY]" & vbCrLf
SQL = SQL & "           ,[LOICOMMENT]" & vbCrLf
SQL = SQL & "           ,[LOIUNITS]" & vbCrLf
SQL = SQL & "           ,[LOIMOPKCANCEL]" & vbCrLf
SQL = SQL & "           ,[LOIHEIGHT]" & vbCrLf
SQL = SQL & "           ,[LOILENGTH]" & vbCrLf
SQL = SQL & "           ,[LOIUSER]" & vbCrLf
SQL = SQL & "          ,LOIPARENTREC" & vbCrLf
SQL = SQL & "           ,[LOISONUMBER]" & vbCrLf
SQL = SQL & "          ,LOISHEETACTTYPE" & vbCrLf
SQL = SQL & "          )" & vbCrLf
SQL = SQL & "     SELECT" & vbCrLf
SQL = SQL & "           @LotNo" & vbCrLf
SQL = SQL & "           ,r.NewRecord" & vbCrLf
SQL = SQL & "           ,@type              -- manual adjustment" & vbCrLf
SQL = SQL & "           ,@partRef" & vbCrLf
SQL = SQL & "           ,@currentTime" & vbCrLf
SQL = SQL & "           ,@currentTime" & vbCrLf
SQL = SQL & "           ,r.Qty" & vbCrLf
SQL = SQL & "           ,null   --LOIMOPARTREF, char(30),>" & vbCrLf
SQL = SQL & "           ,null   --<LOIMORUNNO, int,>" & vbCrLf
SQL = SQL & "           ,null   --<LOIPONUMBER, int,>" & vbCrLf
SQL = SQL & "           ,null   --<LOIPOITEM, smallint,>" & vbCrLf
SQL = SQL & "           ,null   --<LOIPOREV, char(2),>" & vbCrLf
SQL = SQL & "           ,null   --<LOIPSNUMBER, char(8),>" & vbCrLf
SQL = SQL & "           ,null   --<LOIPSITEM, smallint,>" & vbCrLf
SQL = SQL & "           ,null   --<LOICUSTINVNO, int,>" & vbCrLf
SQL = SQL & "           ,null   --<LOICUST, char(10),>" & vbCrLf
SQL = SQL & "           ,null   --<LOIVENDINVNO, char(20),>" & vbCrLf
SQL = SQL & "           ,null   --<LOIVENDOR, char(10),>" & vbCrLf
SQL = SQL & "           ,null   --<LOIACTIVITY, int,> points to InvaTable.INNO when IA is created" & vbCrLf
SQL = SQL & "           ,'sheet restock'    --<LOICOMMENT, varchar(40),>" & vbCrLf
SQL = SQL & "           ,@uom   --<LOIUNITS, char(2),>" & vbCrLf
SQL = SQL & "           ,null   --<LOIMOPKCANCEL, smallint,>" & vbCrLf
SQL = SQL & "           ,r.NewHeight    --<LOIHEIGHT, decimal(12,4),>" & vbCrLf
SQL = SQL & "           ,r.NewLength    --<LOILENGTH, decimal(12,4),>" & vbCrLf
SQL = SQL & "           ,@User      --<LOIUSER, varchar(4),>" & vbCrLf
SQL = SQL & "          ,r.ParentRecord  --LOIPICKEDFROMREC" & vbCrLf
SQL = SQL & "           ,@SO        --<LOISONUMBER, int,>" & vbCrLf
SQL = SQL & "          ,'RS'    --LOISHEETACTTYPE" & vbCrLf
SQL = SQL & "       from #rect r" & vbCrLf
SQL = SQL & "       where r.Qty <> 0" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "--select distinct li.* from LoitTable li " & vbCrLf
SQL = SQL & "--join #rect r on li.LOINUMBER = @LotNo and li.LOIRECORD > 1" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- set LOTREMAININGQTY and remove reservation" & vbCrLf
SQL = SQL & "declare @sum decimal(12,4)" & vbCrLf
SQL = SQL & "select @sum = sum(Qty) from #rect" & vbCrLf
SQL = SQL & "update LohdTable " & vbCrLf
SQL = SQL & "   set LOTREMAININGQTY = LOTREMAININGQTY + @sum," & vbCrLf
SQL = SQL & "   LOTRESERVEDBY = NULL," & vbCrLf
SQL = SQL & "   LOTRESERVEDON = NULL" & vbCrLf
SQL = SQL & "   where LOTNUMBER = @LotNo" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- create new ia items" & vbCrLf
SQL = SQL & "INSERT INTO [dbo].[InvaTable]" & vbCrLf
SQL = SQL & "           ([INTYPE]" & vbCrLf
SQL = SQL & "           ,[INPART]" & vbCrLf
SQL = SQL & "           ,[INREF1]" & vbCrLf
SQL = SQL & "           ,[INREF2]" & vbCrLf
SQL = SQL & "           ,[INPDATE]" & vbCrLf
SQL = SQL & "           ,[INADATE]" & vbCrLf
SQL = SQL & "           ,[INPQTY]" & vbCrLf
SQL = SQL & "           ,[INAQTY]" & vbCrLf
SQL = SQL & "           ,[INAMT]" & vbCrLf
SQL = SQL & "           ,[INTOTMATL]" & vbCrLf
SQL = SQL & "           ,[INTOTLABOR]" & vbCrLf
SQL = SQL & "           ,[INTOTEXP]" & vbCrLf
SQL = SQL & "           ,[INTOTOH]" & vbCrLf
SQL = SQL & "           ,[INTOTHRS]" & vbCrLf
SQL = SQL & "           ,[INCREDITACCT]" & vbCrLf
SQL = SQL & "           ,[INDEBITACCT]" & vbCrLf
SQL = SQL & "           ,[INGLJOURNAL]" & vbCrLf
SQL = SQL & "           ,[INGLPOSTED]" & vbCrLf
SQL = SQL & "           ,[INGLDATE]" & vbCrLf
SQL = SQL & "           ,[INMOPART]" & vbCrLf
SQL = SQL & "           ,[INMORUN]" & vbCrLf
SQL = SQL & "           ,[INSONUMBER]" & vbCrLf
SQL = SQL & "           ,[INSOITEM]" & vbCrLf
SQL = SQL & "           ,[INSOREV]" & vbCrLf
SQL = SQL & "           ,[INPONUMBER]" & vbCrLf
SQL = SQL & "           ,[INPORELEASE]" & vbCrLf
SQL = SQL & "           ,[INPOITEM]" & vbCrLf
SQL = SQL & "           ,[INPOREV]" & vbCrLf
SQL = SQL & "           ,[INPSNUMBER]" & vbCrLf
SQL = SQL & "           ,[INPSITEM]" & vbCrLf
SQL = SQL & "           ,[INWIPLABACCT]" & vbCrLf
SQL = SQL & "           ,[INWIPMATACCT]" & vbCrLf
SQL = SQL & "           ,[INWIPOHDACCT]" & vbCrLf
SQL = SQL & "           ,[INWIPEXPACCT]" & vbCrLf
SQL = SQL & "           ,[INNUMBER]" & vbCrLf
SQL = SQL & "           ,[INLOTNUMBER]" & vbCrLf
SQL = SQL & "           ,[INUSER]" & vbCrLf
SQL = SQL & "           ,[INUNITS]" & vbCrLf
SQL = SQL & "           ,[INDRLABACCT]" & vbCrLf
SQL = SQL & "           ,[INDRMATACCT]" & vbCrLf
SQL = SQL & "           ,[INDREXPACCT]" & vbCrLf
SQL = SQL & "           ,[INDROHDACCT]" & vbCrLf
SQL = SQL & "           ,[INCRLABACCT]" & vbCrLf
SQL = SQL & "           ,[INCRMATACCT]" & vbCrLf
SQL = SQL & "           ,[INCREXPACCT]" & vbCrLf
SQL = SQL & "           ,[INCROHDACCT]" & vbCrLf
SQL = SQL & "           ,[INLOTTRACK]" & vbCrLf
SQL = SQL & "           ,[INUSEACTUALCOST]" & vbCrLf
SQL = SQL & "           ,[INCOSTEDBY]" & vbCrLf
SQL = SQL & "           ,[INMAINTCOSTED])" & vbCrLf
SQL = SQL & "     select" & vbCrLf
SQL = SQL & "           @type               --<INTYPE, int,>" & vbCrLf
SQL = SQL & "           ,@partRef           --char(30),>" & vbCrLf
SQL = SQL & "           ,'Manual Adjustment'    --<INREF1, char(20),>" & vbCrLf
SQL = SQL & "           ,'Sheet Inventory'  --<INREF2, char(40),>" & vbCrLf
SQL = SQL & "           ,@currentTime       --<INPDATE, smalldatetime,>" & vbCrLf
SQL = SQL & "           ,@currentTime       --<INADATE, smalldatetime,>" & vbCrLf
SQL = SQL & "           ,r.Qty          --<INPQTY, decimal(12,4),>" & vbCrLf
SQL = SQL & "           ,r.Qty          --<INAQTY, decimal(12,4),>" & vbCrLf
SQL = SQL & "           ,@unitCost          -- <INAMT, decimal(12,4),>" & vbCrLf
SQL = SQL & "           ,0.0                    --<INTOTMATL, decimal(12,4),>" & vbCrLf
SQL = SQL & "           ,0.0                    --<INTOTLABOR, decimal(12,4),>" & vbCrLf
SQL = SQL & "           ,0.0                    --<INTOTEXP, decimal(12,4),>" & vbCrLf
SQL = SQL & "           ,0.0                    --<INTOTOH, decimal(12,4),>" & vbCrLf
SQL = SQL & "           ,0.0                    --<INTOTHRS, decimal(12,4),>" & vbCrLf
SQL = SQL & "           ,''                 --<INCREDITACCT, char(12),>" & vbCrLf
SQL = SQL & "           ,''                 --<INDEBITACCT, char(12),>" & vbCrLf
SQL = SQL & "           ,''                 --<INGLJOURNAL, char(12),>" & vbCrLf
SQL = SQL & "           ,0                  --<INGLPOSTED, tinyint,>" & vbCrLf
SQL = SQL & "           ,null               --<INGLDATE, smalldatetime,>" & vbCrLf
SQL = SQL & "           ,''                 --<INMOPART, char(30),>" & vbCrLf
SQL = SQL & "           ,0                  --<INMORUN, int,>" & vbCrLf
SQL = SQL & "           ,0                  --<INSONUMBER, int,>" & vbCrLf
SQL = SQL & "           ,0                  --<INSOITEM, int,>" & vbCrLf
SQL = SQL & "           ,''                 --<INSOREV, char(2),>" & vbCrLf
SQL = SQL & "           ,0                  --<INPONUMBER, int,>" & vbCrLf
SQL = SQL & "           ,0                  --<INPORELEASE, smallint,>" & vbCrLf
SQL = SQL & "           ,0                  --<INPOITEM, smallint,>" & vbCrLf
SQL = SQL & "           ,''                 --<INPOREV, char(2),>" & vbCrLf
SQL = SQL & "           ,''                 --<INPSNUMBER, char(8),>" & vbCrLf
SQL = SQL & "           ,0                  --<INPSITEM, smallint,>" & vbCrLf
SQL = SQL & "           ,''                 --<INWIPLABACCT, char(12),>" & vbCrLf
SQL = SQL & "           ,''                 --<INWIPMATACCT, char(12),>" & vbCrLf
SQL = SQL & "           ,''                 --<INWIPOHDACCT, char(12),>" & vbCrLf
SQL = SQL & "           ,''                 --<INWIPEXPACCT, char(12),>" & vbCrLf
SQL = SQL & "           ,r.NewIANumber      --<INNUMBER, int,>" & vbCrLf
SQL = SQL & "           ,@LotNo             --<INLOTNUMBER, char(15),>" & vbCrLf
SQL = SQL & "           ,@User              --<INUSER, char(4),>" & vbCrLf
SQL = SQL & "           ,@uom               --<INUNITS, char(2),>" & vbCrLf
SQL = SQL & "           ,''                 --<INDRLABACCT, char(12),>" & vbCrLf
SQL = SQL & "           ,''                 --<INDRMATACCT, char(12),>" & vbCrLf
SQL = SQL & "           ,''                 --<INDREXPACCT, char(12),>" & vbCrLf
SQL = SQL & "           ,''                 --<INDROHDACCT, char(12),>" & vbCrLf
SQL = SQL & "           ,''                 --<INCRLABACCT, char(12),>" & vbCrLf
SQL = SQL & "           ,''                 --<INCRMATACCT, char(12),>" & vbCrLf
SQL = SQL & "           ,''                 --<INCREXPACCT, char(12),>" & vbCrLf
SQL = SQL & "           ,''                 --<INCROHDACCT, char(12),>" & vbCrLf
SQL = SQL & "           ,null               --<INLOTTRACK, bit,>" & vbCrLf
SQL = SQL & "           ,null               --<INUSEACTUALCOST, bit,>" & vbCrLf
SQL = SQL & "           ,null               --<INCOSTEDBY, char(4),>" & vbCrLf
SQL = SQL & "           ,0                  --<INMAINTCOSTED, int,>)" & vbCrLf
SQL = SQL & "       from #rect r" & vbCrLf
SQL = SQL & "       where r.Qty <> 0" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- now update part QOH" & vbCrLf
SQL = SQL & "update PartTable set PAQOH = PAQOH + @totalQty where PARTREF = @partRef" & vbCrLf
SQL = SQL & "commit tran" & vbCrLf
ExecuteScript False, SQL

SQL = "update pt set PAQOH = (select sum(lotremainingqty) from LohdTable where LOTPARTREF = partref)" & vbCrLf
SQL = SQL & "from PartTable pt " & vbCrLf
SQL = SQL & "join ComnTable on COUSESHEETINVENTORY = 1" & vbCrLf
SQL = SQL & "where PAPUNITS = 'SH'" & vbCrLf
ExecuteScript False, SQL


''''''''''''''''''''''''''''''''''''''''''''''''

        ' update the version
        ExecuteScript False, "Update Version Set Version = " & newver

    End If
End Function

Private Function UpdateDatabase87()

'update database version template
'set version at top of this file
'set version below
'add SQL updates


   Dim SQL As String
   SQL = ""

   newver = 162     ' set actual version
   If ver < newver Then

        clsADOCon.ADOErrNum = 0

''''''''''''''''''''''''''''''''''''''''''''''''''

SQL = "CREATE TABLE [dbo].[MrpPartComments](" & vbCrLf
SQL = SQL & "  [CommentID] [int] IDENTITY(1,1) NOT NULL," & vbCrLf
SQL = SQL & "  [MrpPart] [char](30) NOT NULL," & vbCrLf
SQL = SQL & "  [CreatedOn] [datetime] NOT NULL," & vbCrLf
SQL = SQL & "  [CreatedBy] [varchar](3) NOT NULL," & vbCrLf
SQL = SQL & "  [Comment] [varchar](max) NOT NULL," & vbCrLf
SQL = SQL & " CONSTRAINT [PK_MrpPartComments] PRIMARY KEY CLUSTERED " & vbCrLf
SQL = SQL & "(" & vbCrLf
SQL = SQL & "  [CommentID] ASC" & vbCrLf
SQL = SQL & ")" & vbCrLf
SQL = SQL & ")" & vbCrLf
SQL = SQL & "" & vbCrLf
ExecuteScript False, SQL

SQL = "ALTER TABLE [dbo].[MrpPartComments] ADD  CONSTRAINT [DF_Table_1_CommentDate]  DEFAULT (getdate()) FOR [CreatedOn]" & vbCrLf
ExecuteScript False, SQL

SQL = "ALTER TABLE [dbo].[MrpPartComments]  WITH CHECK ADD  CONSTRAINT [FK_MrpPartComments_PartTable] FOREIGN KEY([MrpPart])" & vbCrLf
SQL = SQL & "REFERENCES [dbo].[PartTable] ([PARTREF])" & vbCrLf
ExecuteScript False, SQL

SQL = "ALTER TABLE [dbo].[MrpPartComments] CHECK CONSTRAINT [FK_MrpPartComments_PartTable]" & vbCrLf
ExecuteScript False, SQL


SQL = "if object_id('RptMRPMOQtyShortage') IS NOT NULL" & vbCrLf
SQL = SQL & "    drop procedure RptMRPMOQtyShortage" & vbCrLf
ExecuteScript False, SQL


SQL = "create PROCEDURE [dbo].[RptMRPMOQtyShortage]" & vbCrLf
SQL = SQL & "      @InMOPart as varchar(30), @StartDate as datetime, @EndDate as datetime" & vbCrLf
SQL = SQL & "AS " & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "   declare @ChildKey as varchar(1024)" & vbCrLf
SQL = SQL & "   declare @GLSortKey as varchar(1024)" & vbCrLf
SQL = SQL & "   declare @SortKey as varchar(1024)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "   declare @MOPart as varchar(30)" & vbCrLf
SQL = SQL & "   declare @MORun as Integer" & vbCrLf
SQL = SQL & "   declare @MOQtyRqd as decimal(12,4)" & vbCrLf
SQL = SQL & "   declare @MOPartRqDt as datetime " & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "   declare @Part as varchar(30)" & vbCrLf
SQL = SQL & "   declare @PAQOH as decimal(12,4)" & vbCrLf
SQL = SQL & "   declare @RunTot as decimal(12,4)" & vbCrLf
SQL = SQL & "   declare @AssyPart as varchar(30)" & vbCrLf
SQL = SQL & "   declare @BMQtyReq as decimal(12,4)" & vbCrLf
SQL = SQL & "   declare @RunQtyReq as decimal (12, 4)" & vbCrLf
SQL = SQL & "   declare @PartDateQrd as datetime" & vbCrLf
SQL = SQL & "   " & vbCrLf
SQL = SQL & "   --DROP TABLE #tempMOPartsDetail " & vbCrLf
SQL = SQL & "   DELETE FROM tempMrplPartShort" & vbCrLf
SQL = SQL & "   " & vbCrLf
SQL = SQL & "  BEGIN" & vbCrLf
SQL = SQL & "   IF (@InMOPart = '')" & vbCrLf
SQL = SQL & "      SET @InMOPart = @InMOPart + '%'" & vbCrLf
SQL = SQL & "  " & vbCrLf
SQL = SQL & "  DECLARE curMrpExp CURSOR  FOR" & vbCrLf
SQL = SQL & "   SELECT MRP_PARTREF,0 as RUNNO, MRP_PARTQTYRQD, MRP_ACTIONDATE" & vbCrLf
SQL = SQL & "   FROM MrplTable, PartTable   " & vbCrLf
SQL = SQL & "   WHERE MRP_PARTREF = PartRef   " & vbCrLf
SQL = SQL & "      AND MrplTable.MRP_PARTREF LIKE @InMOPart" & vbCrLf
SQL = SQL & "      AND MrplTable.MRP_PARTPRODCODE LIKE '%'  " & vbCrLf
SQL = SQL & "      AND MrplTable.MRP_PARTCLASS LIKE '%'  " & vbCrLf
SQL = SQL & "      AND MrplTable.MRP_POBUYER LIKE '%'  " & vbCrLf
SQL = SQL & "      AND MrplTable.MRP_PARTDATERQD BETWEEN @StartDate AND @EndDate" & vbCrLf
SQL = SQL & "      AND MrplTable.MRP_TYPE IN (6, 5)   " & vbCrLf
SQL = SQL & "      AND PartTable.PAMAKEBUY ='M'" & vbCrLf
SQL = SQL & "   UNION" & vbCrLf
SQL = SQL & "      SELECT DISTINCT RUNREF, RUNNO, RUNQTY,runpkstart  as MRP_ACTIONDATE FROM RunsTable WHERE " & vbCrLf
SQL = SQL & "         RUNREF LIKE @InMOPart AND RUNSTATUS = 'SC'" & vbCrLf
SQL = SQL & "         AND RUNPKSTART BETWEEN @StartDate  AND @EndDate + ' 23:00' order by MRP_ACTIONDATE" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "  OPEN curMrpExp" & vbCrLf
SQL = SQL & "  FETCH NEXT FROM curMrpExp INTO @MOPart, @MORun, @MOQtyRqd, @MOPartRqDt" & vbCrLf
SQL = SQL & "  WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
SQL = SQL & "  BEGIN" & vbCrLf
SQL = SQL & "     IF (@@FETCH_STATUS <> -2)" & vbCrLf
SQL = SQL & "     BEGIN" & vbCrLf
SQL = SQL & "--print 'MO:' + @MOPart + '; RUN:' + Convert(varchar(10), @MORun) + '; Date:' + Convert(varchar(24), @MOPartRqDt, 101);" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "      with cte" & vbCrLf
SQL = SQL & "      as (select BMASSYPART,BMPARTREF,BMPARTREV, BMQTYREQD , RTrim(BMUNITS) BMUNITS, " & vbCrLf
SQL = SQL & "            BMCONVERSION, BMSEQUENCE, 0 as level," & vbCrLf
SQL = SQL & "            cast(LTRIM(RTrim(BMASSYPART)) + char(36)+ COALESCE(cast(BMSEQUENCE as varchar(4)), '') + LTRIM(RTrim(BMPARTREF)) as varchar(max)) as SortKey" & vbCrLf
SQL = SQL & "         from BmplTable" & vbCrLf
SQL = SQL & "         where BMASSYPART = @MOPart" & vbCrLf
SQL = SQL & "         union all" & vbCrLf
SQL = SQL & "         select a.BMASSYPART,a.BMPARTREF,a.BMPARTREV, a.BMQTYREQD , RTrim(a.BMUNITS) BMUNITS, " & vbCrLf
SQL = SQL & "            a.BMCONVERSION, a.BMSEQUENCE, level + 1," & vbCrLf
SQL = SQL & "            cast(COALESCE(SortKey,'') + char(36) + COALESCE(cast(a.BMSEQUENCE as varchar(4)), '') + COALESCE(LTRIM(RTrim(a.BMPARTREF)) ,'') as varchar(max))as SortKey" & vbCrLf
SQL = SQL & "         from cte" & vbCrLf
SQL = SQL & "            inner join BmplTable a" & vbCrLf
SQL = SQL & "on cte.BMPARTREF = a.BMASSYPART" & vbCrLf
SQL = SQL & "     ) " & vbCrLf
SQL = SQL & "     INSERT INTO tempMrplPartShort(BMASSYPART,BMPARTREF,BMQTYREQD," & vbCrLf
SQL = SQL & "      SORTKEYLEVEL,BMSEQUENCE, SortKey, PAQOH, RUNNO,MRP_PARTQTYRQD, MRP_ACTIONDATE)" & vbCrLf
SQL = SQL & "     select BMASSYPART, BMPARTREF,BMQTYREQD,level,BMSEQUENCE, SortKey, PAQOH, @MORun, @MOQtyRqd, @MOPartRqDt" & vbCrLf
SQL = SQL & "       from cte, PartTable WHERE PARTREF = BMPARTREF  AND BMPARTREF <> 'NULL' order by SortKey,BMSEQUENCE" & vbCrLf
SQL = SQL & "        " & vbCrLf
SQL = SQL & "   End" & vbCrLf
SQL = SQL & "   FETCH NEXT FROM curMrpExp INTO @MOPart, @MORun, @MOQtyRqd, @MOPartRqDt" & vbCrLf
SQL = SQL & "  End" & vbCrLf
SQL = SQL & "  Close curMrpExp" & vbCrLf
SQL = SQL & "  DEALLOCATE curMrpExp" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "  DECLARE curRunTot CURSOR  FOR" & vbCrLf
SQL = SQL & "  select DISTINCT BMPARTREF, PAQOH from tempMrplPartShort order by BMPARTREF" & vbCrLf
SQL = SQL & "  OPEN curRunTot" & vbCrLf
SQL = SQL & "  FETCH NEXT FROM curRunTot INTO @Part, @PAQOH" & vbCrLf
SQL = SQL & "  WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
SQL = SQL & "  BEGIN" & vbCrLf
SQL = SQL & "     IF (@@FETCH_STATUS <> -2)" & vbCrLf
SQL = SQL & "     BEGIN" & vbCrLf
SQL = SQL & "        SET @RunTot = 0.0000" & vbCrLf
SQL = SQL & "        SET @RunTot = @PAQOH" & vbCrLf
SQL = SQL & "        DECLARE curRunTot1 CURSOR  FOR" & vbCrLf
SQL = SQL & "         select DISTINCT BMASSYPART, BMQTYREQD, MRP_PARTQTYRQD, MRP_ACTIONDATE from tempMrplPartShort " & vbCrLf
SQL = SQL & "            WHERE BMPARTREF = @Part AND sortkeylevel = 0 " & vbCrLf
SQL = SQL & "         order by MRP_ACTIONDATE  -- BMASSYPART, " & vbCrLf
SQL = SQL & "        OPEN curRunTot1" & vbCrLf
SQL = SQL & "        FETCH NEXT FROM curRunTot1 INTO @AssyPart, @BMQtyReq, @RunQtyReq, @PartDateQrd" & vbCrLf
SQL = SQL & "        WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
SQL = SQL & "        BEGIN" & vbCrLf
SQL = SQL & "          IF (@@FETCH_STATUS <> -2)" & vbCrLf
SQL = SQL & "          BEGIN" & vbCrLf
SQL = SQL & "            --Set @RunTot = ROUND(@RunTot,4)" & vbCrLf
SQL = SQL & "            Set @RunTot = @RunTot -  ( @BMQtyReq * @RunQtyReq)" & vbCrLf
SQL = SQL & "            UPDATE tempMrplPartShort SET PAQRUNTOT = @RunTot WHERE " & vbCrLf
SQL = SQL & "BMASSYPART = @AssyPart AND BMPARTREF = @Part AND MRP_ACTIONDATE = @PartDateQrd" & vbCrLf
SQL = SQL & "          END" & vbCrLf
SQL = SQL & "          FETCH NEXT FROM curRunTot1 INTO @AssyPart, @BMQtyReq, @RunQtyReq,@PartDateQrd" & vbCrLf
SQL = SQL & "        End" & vbCrLf
SQL = SQL & "        Close curRunTot1" & vbCrLf
SQL = SQL & "        DEALLOCATE curRunTot1" & vbCrLf
SQL = SQL & "     END" & vbCrLf
SQL = SQL & "     FETCH NEXT FROM curRunTot INTO @Part, @PAQOH" & vbCrLf
SQL = SQL & "  End" & vbCrLf
SQL = SQL & "  Close curRunTot" & vbCrLf
SQL = SQL & "  DEALLOCATE curRunTot" & vbCrLf
SQL = SQL & " END" & vbCrLf
SQL = SQL & "END" & vbCrLf
ExecuteScript False, SQL


''''''''''''''''''''''''''''''''''''''''''''''''''

        ' update the version
        ExecuteScript False, "Update Version Set Version = " & newver

    End If
End Function

Private Function UpdateDatabase88()

   Dim SQL As String
   SQL = ""

   newver = 163
   If ver < newver Then

        clsADOCon.ADOErrNum = 0

''''''''''''''''''''''''''''''''''''''''''''''''''

SQL = "alter table SSRSInfo add WebUrl varchar(255) null" & vbCrLf
ExecuteScript False, SQL

SQL = "update SSRSInfo set WebUrl = 'http://localhost/Fusion/' where WebUrl is null" & vbCrLf
ExecuteScript False, SQL

SQL = "update SSRSInfo set SSRSFolderUrl = REPLACE(SSRSFolderUrl,'/Reports','/ReportServer') " & vbCrLf
SQL = SQL & "where SSRSFolderUrl not like '%/ReportServer%'" & vbCrLf
ExecuteScript False, SQL

SQL = "update SSRSInfo set SSRSFolderUrl = REPLACE(SSRSFolderUrl,'/Report.aspx?ItemPath=','/ReportViewer.aspx?') " & vbCrLf
SQL = SQL & "where SSRSFolderUrl not like '%/ReportViewer.aspx%'" & vbCrLf
ExecuteScript False, SQL

''''''''''''''''''''''''''''''''''''''''''''''''''

        ' update the version
        ExecuteScript False, "Update Version Set Version = " & newver

    End If
End Function


Private Function UpdateDatabase89()

'update database version template
'set version at top of this file
'set version below
'add SQL updates


   Dim SQL As String
   SQL = ""

   newver = 164     ' set actual version
   If ver < newver Then

        clsADOCon.ADOErrNum = 0

''''''''''''''''''''''''''''''''''''''''''''''''''


' TOOL_MONUM may have been dropped in a prior update.  attempt add it back just in case
If Not ColumnExists("TlnhdTableNew", "TOOL_MONUM") Then
   ExecuteScript False, "ALTER TABLE TlnhdTableNew ADD TOOL_MONUM varchar(20)"
End If

SQL = "alter table TlnhdTableNew add TOOL_CODE varchar(6)" & vbCrLf
ExecuteScript False, SQL

SQL = "alter table TlnhdTableNew add TOOL_UNITNUM varchar(1)" & vbCrLf
ExecuteScript False, SQL

SQL = "alter table TlnhdTableNew add TOOL_GOVPRIMECONTRACT varchar(20)" & vbCrLf
ExecuteScript False, SQL

SQL = "alter table TlnhdTableNew add TOOL_CATEGORY varchar(1)" & vbCrLf
ExecuteScript False, SQL

SQL = "alter table TlnhdTableNew add TOOL_LASTINVDATE datetime null" & vbCrLf
ExecuteScript False, SQL

SQL = "create table ToolNewCategories" & vbCrLf
SQL = SQL & "(" & vbCrLf
SQL = SQL & "  ToolCategory varchar(2) not null primary key clustered" & vbCrLf
SQL = SQL & ")" & vbCrLf
ExecuteScript False, SQL

SQL = "insert ToolNewCategories (ToolCategory) values( '' )" & vbCrLf
SQL = SQL & "insert ToolNewCategories (ToolCategory) values( '1' )" & vbCrLf
SQL = SQL & "insert ToolNewCategories (ToolCategory) values( '2' )" & vbCrLf
SQL = SQL & "insert ToolNewCategories (ToolCategory) values( '3' )" & vbCrLf
ExecuteScript False, SQL

' change data yes/no/true/false fields to bits
SQL = "update TlnhdTableNew set TOOL_GOVOWNED = '1' where TOOL_GOVOWNED = 'True'" & vbCrLf
ExecuteScript False, SQL
SQL = "update TlnhdTableNew set TOOL_GOVOWNED = '0' where ISNULL(TOOL_GOVOWNED,'0') <> '1'" & vbCrLf
ExecuteScript False, SQL
SQL = "alter table tlnhdtablenew alter column TOOL_GOVOWNED bit not null" & vbCrLf
ExecuteScript False, SQL
SQL = "ALTER TABLE TlnhdTableNew ADD CONSTRAINT DF__TlnhdTabl__TOOL_GOVOWNED DEFAULT 0 FOR TOOL_GOVOWNED" & vbCrLf
ExecuteScript False, SQL

SQL = "alter table TlnhdTableNew drop constraint DF__TlnhdTabl__TOOL_ITAR" & vbCrLf
ExecuteScript False, SQL
SQL = "alter table TlnhdTableNew alter column TOOL_ITAR bit not null" & vbCrLf
ExecuteScript False, SQL
SQL = "ALTER TABLE TlnhdTableNew ADD CONSTRAINT DF__TlnhdTabl__TOOL_ITAR DEFAULT 0 FOR TOOL_ITAR" & vbCrLf
ExecuteScript False, SQL



SQL = "alter table TlnhdTableNew alter column TOOL_ACCTTO varchar(20)" & vbCrLf
ExecuteScript False, SQL
SQL = "alter table TlnhdTableNew alter column TOOL_BLANKPONUM varchar(20)" & vbCrLf
ExecuteScript False, SQL
SQL = "alter table TlnhdTableNew alter column TOOL_CAVNUM varchar(20)" & vbCrLf
ExecuteScript False, SQL
SQL = "alter table TlnhdTableNew alter column TOOL_CGPONUM varchar(30)" & vbCrLf
ExecuteScript False, SQL
SQL = "alter table TlnhdTableNew alter column TOOL_CGSOPONUM varchar(30)" & vbCrLf
ExecuteScript False, SQL
SQL = "alter table TlnhdTableNew alter column TOOL_CLASS varchar(12)" & vbCrLf
ExecuteScript False, SQL
SQL = "alter table TlnhdTableNew alter column TOOL_CUSTPONUM varchar(30)" & vbCrLf
ExecuteScript False, SQL
SQL = "alter table TlnhdTableNew alter column TOOL_DIM varchar(20)" & vbCrLf
ExecuteScript False, SQL
SQL = "alter table TlnhdTableNew alter column TOOL_DISPSTAT varchar(20)" & vbCrLf
ExecuteScript False, SQL
SQL = "alter table TlnhdTableNew alter column TOOL_DTADDED varchar(12)" & vbCrLf
ExecuteScript False, SQL
SQL = "alter table TlnhdTableNew alter column TOOL_GRID varchar(30)" & vbCrLf
ExecuteScript False, SQL
SQL = "alter table TlnhdTableNew alter column TOOL_HOMEAISLE varchar(30)" & vbCrLf
ExecuteScript False, SQL
SQL = "alter table TlnhdTableNew alter column TOOL_HOMEBLDG varchar(30)" & vbCrLf
ExecuteScript False, SQL
SQL = "alter table TlnhdTableNew alter column TOOL_LOCNUM varchar(30)" & vbCrLf
ExecuteScript False, SQL
SQL = "alter table TlnhdTableNew alter column TOOL_MAKEPN varchar(20)" & vbCrLf
ExecuteScript False, SQL
SQL = "alter table TlnhdTableNew alter column TOOL_MONUM varchar(20)" & vbCrLf
ExecuteScript False, SQL
SQL = "alter table TlnhdTableNew alter column TOOL_NUM varchar(30)" & vbCrLf
ExecuteScript False, SQL
SQL = "alter table TlnhdTableNew alter column TOOL_OWNER varchar(20)" & vbCrLf
ExecuteScript False, SQL
SQL = "alter table TlnhdTableNew alter column TOOL_SHELFNUM varchar(30)" & vbCrLf
ExecuteScript False, SQL
SQL = "alter table TlnhdTableNew alter column TOOL_SN varchar(20)" & vbCrLf
ExecuteScript False, SQL
SQL = "alter table TlnhdTableNew alter column TOOL_SRVSTAT varchar(20)" & vbCrLf
ExecuteScript False, SQL
SQL = "alter table TlnhdTableNew alter column TOOL_STORAGESTAT varchar(20)" & vbCrLf
ExecuteScript False, SQL
SQL = "alter table TlnhdTableNew alter column TOOL_TOOLMATSTAT varchar(20)" & vbCrLf
ExecuteScript False, SQL

SQL = "update TlnhdTableNew set TOOL_ACCTTO = RTRIM(TOOL_ACCTTO)" & vbCrLf
ExecuteScript False, SQL
SQL = "update TlnhdTableNew set TOOL_BLANKPONUM = RTRIM(TOOL_BLANKPONUM)" & vbCrLf
ExecuteScript False, SQL
SQL = "update TlnhdTableNew set TOOL_CATEGORY = RTRIM(TOOL_CATEGORY)" & vbCrLf
ExecuteScript False, SQL
SQL = "update TlnhdTableNew set TOOL_CAVNUM = RTRIM(TOOL_CAVNUM)" & vbCrLf
ExecuteScript False, SQL
SQL = "update TlnhdTableNew set TOOL_CGPONUM = RTRIM(TOOL_CGPONUM)" & vbCrLf
ExecuteScript False, SQL
SQL = "update TlnhdTableNew set TOOL_CGSOPONUM = RTRIM(TOOL_CGSOPONUM)" & vbCrLf
ExecuteScript False, SQL
SQL = "update TlnhdTableNew set TOOL_CLASS = RTRIM(TOOL_CLASS)" & vbCrLf
ExecuteScript False, SQL
SQL = "update TlnhdTableNew set TOOL_CODE = RTRIM(TOOL_CODE)" & vbCrLf
ExecuteScript False, SQL
SQL = "update TlnhdTableNew set TOOL_COMMENTS = RTRIM(TOOL_COMMENTS)" & vbCrLf
ExecuteScript False, SQL
SQL = "update TlnhdTableNew set TOOL_CUSTPONUM = RTRIM(TOOL_CUSTPONUM)" & vbCrLf
ExecuteScript False, SQL
SQL = "update TlnhdTableNew set TOOL_DIM = RTRIM(TOOL_DIM)" & vbCrLf
ExecuteScript False, SQL
SQL = "update TlnhdTableNew set TOOL_DISPSTAT = RTRIM(TOOL_DISPSTAT)" & vbCrLf
ExecuteScript False, SQL
SQL = "update TlnhdTableNew set TOOL_DTADDED = RTRIM(TOOL_DTADDED)" & vbCrLf
ExecuteScript False, SQL
SQL = "update TlnhdTableNew set TOOL_GOVPRIMECONTRACT = RTRIM(TOOL_GOVPRIMECONTRACT)" & vbCrLf
ExecuteScript False, SQL
SQL = "update TlnhdTableNew set TOOL_GRID = RTRIM(TOOL_GRID)" & vbCrLf
ExecuteScript False, SQL
SQL = "update TlnhdTableNew set TOOL_HOMEAISLE = RTRIM(TOOL_HOMEAISLE)" & vbCrLf
ExecuteScript False, SQL
SQL = "update TlnhdTableNew set TOOL_HOMEBLDG = RTRIM(TOOL_HOMEBLDG)" & vbCrLf
ExecuteScript False, SQL
SQL = "update TlnhdTableNew set TOOL_LOCNUM = RTRIM(TOOL_LOCNUM)" & vbCrLf
ExecuteScript False, SQL
SQL = "update TlnhdTableNew set TOOL_MAKEPN = RTRIM(TOOL_MAKEPN)" & vbCrLf
ExecuteScript False, SQL
SQL = "update TlnhdTableNew set TOOL_MONUM = RTRIM(TOOL_MONUM)" & vbCrLf
ExecuteScript False, SQL
SQL = "update TlnhdTableNew set TOOL_NUM = RTRIM(TOOL_NUM)" & vbCrLf
ExecuteScript False, SQL
SQL = "update TlnhdTableNew set TOOL_NUMREF = RTRIM(TOOL_NUMREF)" & vbCrLf
ExecuteScript False, SQL
SQL = "update TlnhdTableNew set TOOL_OWNER = RTRIM(TOOL_OWNER)" & vbCrLf
ExecuteScript False, SQL
SQL = "update TlnhdTableNew set TOOL_SHELFNUM = RTRIM(TOOL_SHELFNUM)" & vbCrLf
ExecuteScript False, SQL
SQL = "update TlnhdTableNew set TOOL_SN = RTRIM(TOOL_SN)" & vbCrLf
ExecuteScript False, SQL
SQL = "update TlnhdTableNew set TOOL_SRVSTAT = RTRIM(TOOL_SRVSTAT)" & vbCrLf
ExecuteScript False, SQL
SQL = "update TlnhdTableNew set TOOL_STORAGESTAT = RTRIM(TOOL_STORAGESTAT)" & vbCrLf
ExecuteScript False, SQL
SQL = "update TlnhdTableNew set TOOL_TOOLMATSTAT = RTRIM(TOOL_TOOLMATSTAT)" & vbCrLf
ExecuteScript False, SQL
SQL = "update TlnhdTableNew set TOOL_UNITNUM = RTRIM(TOOL_UNITNUM)" & vbCrLf
ExecuteScript False, SQL
SQL = "update TlnhdTableNew set TOOL_WEIGHT = RTRIM(TOOL_WEIGHT)" & vbCrLf
ExecuteScript False, SQL

'fix problem with WIP Report
If Not ColumnExists("EsReportWIP", "WIPRUNQTY") Then
   SQL = "alter table EsReportWIP add WIPRUNQTY decimal(12,4) null" & vbCrLf
   ExecuteScript False, SQL
End If

If Not ColumnExists("EsReportWIP", "WIPRUNPARTIALQTY") Then
   SQL = "alter table EsReportWIP add WIPRUNPARTIALQTY decimal(12,4) null" & vbCrLf
   ExecuteScript False, SQL
End If

' change tool reference
SQL = "alter table TlitTableNew drop constraint DF_TlitTableNew_TOOL_NUM" & vbCrLf
ExecuteScript False, SQL

SQL = "ALTER TABLE [TlitTableNew] ALTER COLUMN TOOL_NUMREF varchar(30) NOT NULL" & vbCrLf
ExecuteScript False, SQL

SQL = "update TlitTableNew set TOOL_NUMREF = RTRIM(tool_numref)" & vbCrLf
ExecuteScript False, SQL

''''''''''''''''''''''''''''''''''''''''''''''''''

        ' update the version
        ExecuteScript False, "Update Version Set Version = " & newver

    End If
End Function


Private Function UpdateDatabase90()

'update database version template
'set version at top of this file
'set version below
'add SQL updates


   Dim SQL As String
   SQL = ""

   newver = 165     ' set actual version
   If ver < newver Then

        clsADOCon.ADOErrNum = 0

''''''''''''''''''''''''''''''''''''''''''''''''''

SQL = "alter table Preferences add EngineeringLaborRate decimal(12,2) null" & vbCrLf
ExecuteScript False, SQL

SQL = "alter table EmplTable add PREMENGINEER bit not null constraint DF_EmplTable_PREMENGINEER default 0" & vbCrLf
ExecuteScript False, SQL

SQL = "IF EXISTS (SELECT * FROM sys.objects WHERE type = 'P' AND name = 'AddEngrTimeCharge')" & vbCrLf
SQL = SQL & "  DROP PROCEDURE AddEngrTimeCharge" & vbCrLf
ExecuteScript False, SQL

SQL = "create procedure AddEngrTimeCharge" & vbCrLf
SQL = SQL & "  @EmpNo as int," & vbCrLf
SQL = SQL & "  @Date as datetime," & vbCrLf
SQL = SQL & "  @MoPartRef as varchar(30)," & vbCrLf
SQL = SQL & "  @RunNo as int," & vbCrLf
SQL = SQL & "  @OpNo as int," & vbCrLf
SQL = SQL & "  @Hours as decimal(12,2)," & vbCrLf
SQL = SQL & "  @Comment as varchar(1024)," & vbCrLf
SQL = SQL & "  @journalId as varchar(12)" & vbCrLf
SQL = SQL & "as" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "/* add a time charge, creating a new time card if required" & vbCrLf
SQL = SQL & "9/15/17 TEL - created for CASGAS Engineering Time Charges" & vbCrLf
SQL = SQL & "*/" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- if time card does not exist for employee, add it" & vbCrLf
SQL = SQL & "declare @card char(11)" & vbCrLf
SQL = SQL & "select @card = TMCARD from TchdTable where TMEMP = @EmpNo and TMDAY = @date" & vbCrLf
SQL = SQL & "if @card is null " & vbCrLf
SQL = SQL & "begin" & vbCrLf
SQL = SQL & "  declare @now as datetime, @nowDays int, @nowMs int" & vbCrLf
SQL = SQL & "  set @now = getdate()" & vbCrLf
SQL = SQL & "  set @nowDays = DATEDIFF(DAY,'1/1/1900',cast(@now as date))" & vbCrLf
SQL = SQL & "  set @nowMs = 1000000.0 *cast(DATEDIFF(MILLISECOND,'1/1/1900',cast(@now as time)) as float)/(3600.0*24*1000)" & vbCrLf
SQL = SQL & "  set @card = cast(@nowDays as varchar(5)) + cast(@nowMs as varchar(6))" & vbCrLf
SQL = SQL & "  insert into TchdTable (TMCARD,TMEMP,TMDAY) values (@card, @EmpNo, @Date)" & vbCrLf
SQL = SQL & "end" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- calculate fields needed for time charge" & vbCrLf
SQL = SQL & "declare @startTime smalldatetime, @stopTime smalldatetime" & vbCrLf
SQL = SQL & "set @startTime = DATEADD(dd, DATEDIFF(dd, 0, @Date), 0)    -- truncate time portion" & vbCrLf
SQL = SQL & "set @stopTime = DATEADD(MINUTE, @Hours * 60, @startTime)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- construct hh:mma/p version of times" & vbCrLf
SQL = SQL & "declare @start varchar(6), @stop varchar(6)" & vbCrLf
SQL = SQL & "set @start = REPLACE(SUBSTRING(CONVERT(VARCHAR(20),@startTime,0),13,6),' ','0')" & vbCrLf
SQL = SQL & "set @stop = REPLACE(SUBSTRING(CONVERT(VARCHAR(20),@stopTime,0),13,6),' ','0')" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- calculate # minutes" & vbCrLf
SQL = SQL & "declare @time datetime" & vbCrLf
SQL = SQL & "set @time = dateadd(minute,datediff(MINUTE,@startTime, @stopTime),'1/1/1900')" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- get regular timecode" & vbCrLf
SQL = SQL & "declare @timecode varchar(2)" & vbCrLf
SQL = SQL & "select @timecode = TYPECODE from TmcdTable where typetype = 'R'" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- get engineering rate" & vbCrLf
SQL = SQL & "declare @rate decimal(10,2)" & vbCrLf
SQL = SQL & "select @rate = EngineeringLaborRate from Preferences " & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- get employee account number" & vbCrLf
SQL = SQL & "declare @acct varchar(12)" & vbCrLf
SQL = SQL & "select @acct = EmplTable.PREMACCTS from EmplTable where PREMNUMBER = @EmpNo" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- get shop and wc for operation" & vbCrLf
SQL = SQL & "declare @shop varchar(12), @wc varchar(12)" & vbCrLf
SQL = SQL & "select @shop = OPSHOP, @wc = OPCENTER " & vbCrLf
SQL = SQL & "from RnopTable where opref = @MoPartRef and oprun = @RunNo and OPNO = @OpNo" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- get journal id" & vbCrLf
SQL = SQL & "--declare @journalId varchar(12)" & vbCrLf
SQL = SQL & "--set @journalId = dbo.fnGetOpenJournalID('TJ', @Date)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- now insert the new time charge" & vbCrLf
SQL = SQL & "INSERT INTO TcitTable (TCCARD,TCEMP,TCSTART,TCSTOP,TCSTARTTIME,TCSTOPTIME," & vbCrLf
SQL = SQL & "      TCHOURS,TCTIME,TCCODE,TCRATE,TCOHRATE,TCRATENO,TCACCT,TCACCOUNT," & vbCrLf
SQL = SQL & "      TCSHOP,TCWC,TCPAYTYPE,TCSURUN,TCYIELD,TCPARTREF,TCRUNNO," & vbCrLf
SQL = SQL & "      TCOPNO,TCSORT,TCOHFIXED,TCGLJOURNAL,TCGLREF,TCSOURCE," & vbCrLf
SQL = SQL & "      TCMULTIJOB,TCACCEPT,TCREJECT,TCSCRAP,TCCOMMENTS)" & vbCrLf
SQL = SQL & "values( @card,@EmpNo, @start,@stop,@startTime, @stopTime," & vbCrLf
SQL = SQL & "      @Hours,@time,@timecode,@rate,@rate,1,@acct,@acct," & vbCrLf
SQL = SQL & "      @shop,@wc,0,'I',0,@MoPartRef,@RunNo," & vbCrLf
SQL = SQL & "    @OpNo,0,0,@journalId,0,'Engr'," & vbCrLf
SQL = SQL & "      0,0,0,0,@Comment)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- now roll up totals for this timecard" & vbCrLf
SQL = SQL & "EXECUTE UpdateTimeCardTotals @EmpNo, @Date" & vbCrLf
ExecuteScript False, SQL


''''''''''''''''''''''''''''''''''''''''''''''''''

        ' update the version
        ExecuteScript False, "Update Version Set Version = " & newver

    End If
End Function


Private Function UpdateDatabase91()

'update database version template
'set version at top of this file
'set version below
'add SQL updates


   Dim SQL As String
   SQL = ""

   newver = 166     ' set actual version
   If ver < newver Then

        clsADOCon.ADOErrNum = 0

''''''''''''''''''''''''''''''''''''''''''''''''''

' convert sheet inventory to use closed date for lot items instead of the LOIINACTIVE flag.
' this will allow you to run a 7/1 inventory on some other date

' convert inactive to datetime
SQL = "alter table LoitTable add LOICLOSED datetime" & vbCrLf
ExecuteScript False, SQL

' set closed date = date of child activity
SQL = "update parent set LOICLOSED = cast(CONVERT(VARCHAR(10),child.LOIADATE,101) as datetime)" & vbCrLf
SQL = SQL & "from LoitTable parent join LoitTable child on child.LOINUMBER = parent.LOINUMBER and child.LOIPARENTREC = parent.LOIRECORD" & vbCrLf
SQL = SQL & "and parent.LOIINACTIVE = 1      -- 314" & vbCrLf
ExecuteScript False, SQL

' for any remaining inactive items, set closed date = date of the activity
SQL = "update LoitTable set LOICLOSED = cast(CONVERT(VARCHAR(10),LOIADATE,101) as datetime) where LOIINACTIVE = 1 and LOICLOSED is null" & vbCrLf
ExecuteScript False, SQL

SQL = "alter table LoitTable drop column LOIINACTIVE" & vbCrLf
ExecuteScript False, SQL

SQL = "IF EXISTS (SELECT * FROM sys.objects WHERE type = 'P' AND name = 'SheetPick')" & vbCrLf
SQL = SQL & "  DROP PROCEDURE SheetPick" & vbCrLf
ExecuteScript False, SQL

SQL = "create procedure SheetPick" & vbCrLf
SQL = SQL & "   @UserLotNo varchar(40),     -- lotuserlotid" & vbCrLf
SQL = SQL & "   @User varchar(4)," & vbCrLf
SQL = SQL & "   @SO int," & vbCrLf
SQL = SQL & "   @PickDate datetime" & vbCrLf
SQL = SQL & "   " & vbCrLf
SQL = SQL & "as" & vbCrLf
SQL = SQL & "/*" & vbCrLf
SQL = SQL & "Pick a sheet" & vbCrLf
SQL = SQL & "exec SheetPick '029373-1-A','MGR',222222" & vbCrLf
SQL = SQL & "*/" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- remove time from pick date" & vbCrLf
SQL = SQL & "set @PickDate = cast(convert(varchar(10),@PickDate,101)as datetime)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- find all rectangles in lot" & vbCrLf
SQL = SQL & "begin tran" & vbCrLf
SQL = SQL & "create table #rect" & vbCrLf
SQL = SQL & "(" & vbCrLf
SQL = SQL & "   id int identity," & vbCrLf
SQL = SQL & "   ParentRecord int," & vbCrLf
SQL = SQL & "   Height decimal(12,4)," & vbCrLf
SQL = SQL & "   Length decimal(12,4)," & vbCrLf
SQL = SQL & "   NewRecord int," & vbCrLf
SQL = SQL & "   Qty decimal(12,4)" & vbCrLf
SQL = SQL & ")" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "declare @LotNo char(15)" & vbCrLf
SQL = SQL & "select @LotNo = LOTNUMBER from LohdTable where LOTUSERLOTID = @UserLotNo" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "insert #rect (ParentRecord,Height,Length,NewRecord,Qty)" & vbCrLf
SQL = SQL & "select li.LOIRECORD,li.LOIHEIGHT,li.LOILENGTH,0,cast(li.LOIHEIGHT*li.LOILENGTH as decimal(12,4)) from LoitTable li" & vbCrLf
SQL = SQL & "   join LohdTable lh on lh.LOTNUMBER = li.LOINUMBER" & vbCrLf
SQL = SQL & "   where lh.LOTNUMBER = @LotNo and LOIQUANTITY > 0 " & vbCrLf
SQL = SQL & "   and li.LOICLOSED is null" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- assign new recordnumbers" & vbCrLf
SQL = SQL & "declare @max int" & vbCrLf
SQL = SQL & "select @max = max(LOIRECORD) from LoitTable where LOINUMBER = @LotNo" & vbCrLf
SQL = SQL & "update #rect set NewRecord = @max + id" & vbCrLf
SQL = SQL & "   " & vbCrLf
SQL = SQL & "declare @partRef varchar(30), @currentTime datetime, @uom char(2), @type int" & vbCrLf
SQL = SQL & "declare @unitCost decimal(12,4), @nextINNUMBER int, @totalQty decimal(12,4)" & vbCrLf
SQL = SQL & "select @partRef = LOTPARTREF, @unitCost = LOTUNITCOST, @totalQty = LOTREMAININGQTY from LohdTable where LOTNUMBER = @LotNo" & vbCrLf
SQL = SQL & "select @uom = PAUNITS from PartTable where PARTREF = @partRef" & vbCrLf
SQL = SQL & "set @currentTime = getdate()" & vbCrLf
SQL = SQL & "select @nextINNUMBER = max(INNUMBER) + 1 from InvaTable" & vbCrLf
SQL = SQL & "set @type = 19     -- manual adjustment" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- deactivate rectangles being picked so they won't show up again" & vbCrLf
SQL = SQL & "Update li " & vbCrLf
SQL = SQL & "set li.LOICLOSED = @PickDate" & vbCrLf
SQL = SQL & "from LoitTable li " & vbCrLf
SQL = SQL & "join #rect r on li.LOINUMBER = @LotNo and li.LOIRECORD = r.ParentRecord" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- create new LoitTable record to zero lot quantity" & vbCrLf
SQL = SQL & "INSERT INTO [dbo].[LoitTable]" & vbCrLf
SQL = SQL & "           ([LOINUMBER]" & vbCrLf
SQL = SQL & "           ,[LOIRECORD]" & vbCrLf
SQL = SQL & "           ,[LOITYPE]" & vbCrLf
SQL = SQL & "           ,[LOIPARTREF]" & vbCrLf
SQL = SQL & "           ,[LOIADATE]" & vbCrLf
SQL = SQL & "           ,[LOIPDATE]" & vbCrLf
SQL = SQL & "           ,[LOIQUANTITY]" & vbCrLf
SQL = SQL & "           ,[LOIMOPARTREF]" & vbCrLf
SQL = SQL & "           ,[LOIMORUNNO]" & vbCrLf
SQL = SQL & "           ,[LOIPONUMBER]" & vbCrLf
SQL = SQL & "           ,[LOIPOITEM]" & vbCrLf
SQL = SQL & "           ,[LOIPOREV]" & vbCrLf
SQL = SQL & "           ,[LOIPSNUMBER]" & vbCrLf
SQL = SQL & "           ,[LOIPSITEM]" & vbCrLf
SQL = SQL & "           ,[LOICUSTINVNO]" & vbCrLf
SQL = SQL & "           ,[LOICUST]" & vbCrLf
SQL = SQL & "           ,[LOIVENDINVNO]" & vbCrLf
SQL = SQL & "           ,[LOIVENDOR]" & vbCrLf
SQL = SQL & "           ,[LOIACTIVITY]" & vbCrLf
SQL = SQL & "           ,[LOICOMMENT]" & vbCrLf
SQL = SQL & "           ,[LOIUNITS]" & vbCrLf
SQL = SQL & "           ,[LOIMOPKCANCEL]" & vbCrLf
SQL = SQL & "           ,[LOIHEIGHT]" & vbCrLf
SQL = SQL & "           ,[LOILENGTH]" & vbCrLf
SQL = SQL & "           ,[LOIUSER]" & vbCrLf
SQL = SQL & "          ,LOIPARENTREC" & vbCrLf
SQL = SQL & "           ,[LOISONUMBER]" & vbCrLf
SQL = SQL & "          ,LOISHEETACTTYPE" & vbCrLf
SQL = SQL & "          )" & vbCrLf
SQL = SQL & "     SELECT" & vbCrLf
SQL = SQL & "           @LotNo" & vbCrLf
SQL = SQL & "           ,r.NewRecord" & vbCrLf
SQL = SQL & "           ,@type              -- manual adjustment" & vbCrLf
SQL = SQL & "           ,@partRef" & vbCrLf
SQL = SQL & "           ,@PickDate" & vbCrLf
SQL = SQL & "           ,@PickDate" & vbCrLf
SQL = SQL & "           ,-r.Qty" & vbCrLf
SQL = SQL & "           ,null   --LOIMOPARTREF, char(30),>" & vbCrLf
SQL = SQL & "           ,null   --<LOIMORUNNO, int,>" & vbCrLf
SQL = SQL & "           ,null   --<LOIPONUMBER, int,>" & vbCrLf
SQL = SQL & "           ,null   --<LOIPOITEM, smallint,>" & vbCrLf
SQL = SQL & "           ,null   --<LOIPOREV, char(2),>" & vbCrLf
SQL = SQL & "           ,null   --<LOIPSNUMBER, char(8),>" & vbCrLf
SQL = SQL & "           ,null   --<LOIPSITEM, smallint,>" & vbCrLf
SQL = SQL & "           ,null   --<LOICUSTINVNO, int,>" & vbCrLf
SQL = SQL & "           ,null   --<LOICUST, char(10),>" & vbCrLf
SQL = SQL & "           ,null   --<LOIVENDINVNO, char(20),>" & vbCrLf
SQL = SQL & "           ,null   --<LOIVENDOR, char(10),>" & vbCrLf
SQL = SQL & "           ,null   --<LOIACTIVITY, int,> points to InvaTable.INNO when IA is created" & vbCrLf
SQL = SQL & "           ,'sheet pick'   --<LOICOMMENT, varchar(40),>" & vbCrLf
SQL = SQL & "           ,@uom   --<LOIUNITS, char(2),>" & vbCrLf
SQL = SQL & "           ,null   --<LOIMOPKCANCEL, smallint,>" & vbCrLf
SQL = SQL & "           ,r.HEIGHT   --<LOIHEIGHT, decimal(12,4),>" & vbCrLf
SQL = SQL & "           ,r.LENGTH   --<LOILENGTH, decimal(12,4),>" & vbCrLf
SQL = SQL & "           ,@User          --<LOIUSER, varchar(4),>" & vbCrLf
SQL = SQL & "          ,r.ParentRecord  --LOIPARENTREC" & vbCrLf
SQL = SQL & "           ,@SO                --<LOISONUMBER, int,>" & vbCrLf
SQL = SQL & "          ,'PK'            --LOISHEETACTTYPE" & vbCrLf
SQL = SQL & "       from #rect r" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- set lot quantity = 0" & vbCrLf
SQL = SQL & "update LohdTable set LOTREMAININGQTY = 0 where LOTNUMBER = @LotNo" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- create new IA record to reduce part quantity" & vbCrLf
SQL = SQL & "INSERT INTO [dbo].[InvaTable]" & vbCrLf
SQL = SQL & "           ([INTYPE]" & vbCrLf
SQL = SQL & "           ,[INPART]" & vbCrLf
SQL = SQL & "           ,[INREF1]" & vbCrLf
SQL = SQL & "           ,[INREF2]" & vbCrLf
SQL = SQL & "           ,[INPDATE]" & vbCrLf
SQL = SQL & "           ,[INADATE]" & vbCrLf
SQL = SQL & "           ,[INPQTY]" & vbCrLf
SQL = SQL & "           ,[INAQTY]" & vbCrLf
SQL = SQL & "           ,[INAMT]" & vbCrLf
SQL = SQL & "           ,[INTOTMATL]" & vbCrLf
SQL = SQL & "           ,[INTOTLABOR]" & vbCrLf
SQL = SQL & "           ,[INTOTEXP]" & vbCrLf
SQL = SQL & "           ,[INTOTOH]" & vbCrLf
SQL = SQL & "           ,[INTOTHRS]" & vbCrLf
SQL = SQL & "           ,[INCREDITACCT]" & vbCrLf
SQL = SQL & "           ,[INDEBITACCT]" & vbCrLf
SQL = SQL & "           ,[INGLJOURNAL]" & vbCrLf
SQL = SQL & "           ,[INGLPOSTED]" & vbCrLf
SQL = SQL & "           ,[INGLDATE]" & vbCrLf
SQL = SQL & "           ,[INMOPART]" & vbCrLf
SQL = SQL & "           ,[INMORUN]" & vbCrLf
SQL = SQL & "           ,[INSONUMBER]" & vbCrLf
SQL = SQL & "           ,[INSOITEM]" & vbCrLf
SQL = SQL & "           ,[INSOREV]" & vbCrLf
SQL = SQL & "           ,[INPONUMBER]" & vbCrLf
SQL = SQL & "           ,[INPORELEASE]" & vbCrLf
SQL = SQL & "           ,[INPOITEM]" & vbCrLf
SQL = SQL & "           ,[INPOREV]" & vbCrLf
SQL = SQL & "           ,[INPSNUMBER]" & vbCrLf
SQL = SQL & "           ,[INPSITEM]" & vbCrLf
SQL = SQL & "           ,[INWIPLABACCT]" & vbCrLf
SQL = SQL & "           ,[INWIPMATACCT]" & vbCrLf
SQL = SQL & "           ,[INWIPOHDACCT]" & vbCrLf
SQL = SQL & "           ,[INWIPEXPACCT]" & vbCrLf
SQL = SQL & "           ,[INNUMBER]" & vbCrLf
SQL = SQL & "           ,[INLOTNUMBER]" & vbCrLf
SQL = SQL & "           ,[INUSER]" & vbCrLf
SQL = SQL & "           ,[INUNITS]" & vbCrLf
SQL = SQL & "           ,[INDRLABACCT]" & vbCrLf
SQL = SQL & "           ,[INDRMATACCT]" & vbCrLf
SQL = SQL & "           ,[INDREXPACCT]" & vbCrLf
SQL = SQL & "           ,[INDROHDACCT]" & vbCrLf
SQL = SQL & "           ,[INCRLABACCT]" & vbCrLf
SQL = SQL & "           ,[INCRMATACCT]" & vbCrLf
SQL = SQL & "           ,[INCREXPACCT]" & vbCrLf
SQL = SQL & "           ,[INCROHDACCT]" & vbCrLf
SQL = SQL & "           ,[INLOTTRACK]" & vbCrLf
SQL = SQL & "           ,[INUSEACTUALCOST]" & vbCrLf
SQL = SQL & "           ,[INCOSTEDBY]" & vbCrLf
SQL = SQL & "           ,[INMAINTCOSTED])" & vbCrLf
SQL = SQL & "     select" & vbCrLf
SQL = SQL & "           @type               --<INTYPE, int,>" & vbCrLf
SQL = SQL & "           ,@partRef           --char(30),>" & vbCrLf
SQL = SQL & "           ,'Manual Adjustment'    --<INREF1, char(20),>" & vbCrLf
SQL = SQL & "           ,'Sheet Inventory'  --<INREF2, char(40),>" & vbCrLf
SQL = SQL & "           ,@PickDate       --<INPDATE, smalldatetime,>" & vbCrLf
SQL = SQL & "           ,@PickDate       --<INADATE, smalldatetime,>" & vbCrLf
SQL = SQL & "           ,-r.Qty         --<INPQTY, decimal(12,4),>" & vbCrLf
SQL = SQL & "           ,-r.Qty         --<INAQTY, decimal(12,4),>" & vbCrLf
SQL = SQL & "           ,@unitCost          -- <INAMT, decimal(12,4),>" & vbCrLf
SQL = SQL & "           ,0.0                    --<INTOTMATL, decimal(12,4),>" & vbCrLf
SQL = SQL & "           ,0.0                    --<INTOTLABOR, decimal(12,4),>" & vbCrLf
SQL = SQL & "           ,0.0                    --<INTOTEXP, decimal(12,4),>" & vbCrLf
SQL = SQL & "           ,0.0                    --<INTOTOH, decimal(12,4),>" & vbCrLf
SQL = SQL & "           ,0.0                    --<INTOTHRS, decimal(12,4),>" & vbCrLf
SQL = SQL & "           ,''                 --<INCREDITACCT, char(12),>" & vbCrLf
SQL = SQL & "           ,''                 --<INDEBITACCT, char(12),>" & vbCrLf
SQL = SQL & "           ,''                 --<INGLJOURNAL, char(12),>" & vbCrLf
SQL = SQL & "           ,0                  --<INGLPOSTED, tinyint,>" & vbCrLf
SQL = SQL & "           ,null               --<INGLDATE, smalldatetime,>" & vbCrLf
SQL = SQL & "           ,''                 --<INMOPART, char(30),>" & vbCrLf
SQL = SQL & "           ,0                  --<INMORUN, int,>" & vbCrLf
SQL = SQL & "           ,0                  --<INSONUMBER, int,>" & vbCrLf
SQL = SQL & "           ,0                  --<INSOITEM, int,>" & vbCrLf
SQL = SQL & "           ,''                 --<INSOREV, char(2),>" & vbCrLf
SQL = SQL & "           ,0                  --<INPONUMBER, int,>" & vbCrLf
SQL = SQL & "           ,0                  --<INPORELEASE, smallint,>" & vbCrLf
SQL = SQL & "           ,0                  --<INPOITEM, smallint,>" & vbCrLf
SQL = SQL & "           ,''                 --<INPOREV, char(2),>" & vbCrLf
SQL = SQL & "           ,''                 --<INPSNUMBER, char(8),>" & vbCrLf
SQL = SQL & "           ,0                  --<INPSITEM, smallint,>" & vbCrLf
SQL = SQL & "           ,''                 --<INWIPLABACCT, char(12),>" & vbCrLf
SQL = SQL & "           ,''                 --<INWIPMATACCT, char(12),>" & vbCrLf
SQL = SQL & "           ,''                 --<INWIPOHDACCT, char(12),>" & vbCrLf
SQL = SQL & "           ,''                 --<INWIPEXPACCT, char(12),>" & vbCrLf
SQL = SQL & "           ,@nextINNUMBER      --<INNUMBER, int,>" & vbCrLf
SQL = SQL & "           ,@LotNo             --<INLOTNUMBER, char(15),>" & vbCrLf
SQL = SQL & "           ,@User              --<INUSER, char(4),>" & vbCrLf
SQL = SQL & "           ,@uom               --<INUNITS, char(2),>" & vbCrLf
SQL = SQL & "           ,''                 --<INDRLABACCT, char(12),>" & vbCrLf
SQL = SQL & "           ,''                 --<INDRMATACCT, char(12),>" & vbCrLf
SQL = SQL & "           ,''                 --<INDREXPACCT, char(12),>" & vbCrLf
SQL = SQL & "           ,''                 --<INDROHDACCT, char(12),>" & vbCrLf
SQL = SQL & "           ,''                 --<INCRLABACCT, char(12),>" & vbCrLf
SQL = SQL & "           ,''                 --<INCRMATACCT, char(12),>" & vbCrLf
SQL = SQL & "           ,''                 --<INCREXPACCT, char(12),>" & vbCrLf
SQL = SQL & "           ,''                 --<INCROHDACCT, char(12),>" & vbCrLf
SQL = SQL & "           ,null               --<INLOTTRACK, bit,>" & vbCrLf
SQL = SQL & "           ,null               --<INUSEACTUALCOST, bit,>" & vbCrLf
SQL = SQL & "           ,null               --<INCOSTEDBY, char(4),>" & vbCrLf
SQL = SQL & "           ,0                  --<INMAINTCOSTED, int,>)" & vbCrLf
SQL = SQL & "       from #rect r" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- now update part QOH" & vbCrLf
SQL = SQL & "update PartTable set PAQOH = PAQOH - @totalQty where PARTREF = @partRef" & vbCrLf
SQL = SQL & "commit tran" & vbCrLf
ExecuteScript False, SQL

SQL = "IF EXISTS (SELECT * FROM sys.objects WHERE type = 'P' AND name = 'SheetRestock')" & vbCrLf
SQL = SQL & "  DROP PROCEDURE SheetRestock" & vbCrLf
ExecuteScript False, SQL

SQL = "create procedure SheetRestock" & vbCrLf
SQL = SQL & "   @UserLotNo varchar(40)," & vbCrLf
SQL = SQL & "   @User varchar(4)," & vbCrLf
SQL = SQL & "   @Comments varchar(2048)," & vbCrLf
SQL = SQL & "   @Location varchar(4)," & vbCrLf
SQL = SQL & "   @Params varchar(2000)   -- LOIRECORD,NEWHT,NEWLEN,... repeat (include comma at end)" & vbCrLf
SQL = SQL & "as" & vbCrLf
SQL = SQL & "/*" & vbCrLf
SQL = SQL & "restock sheet LOI records" & vbCrLf
SQL = SQL & "exec SheetRestock '029373-1-A', 'MGR', '2,36,96,0,12,72,'" & vbCrLf
SQL = SQL & "*/" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "begin tran" & vbCrLf
SQL = SQL & "create table #rect" & vbCrLf
SQL = SQL & "(" & vbCrLf
SQL = SQL & "   ParentRecord int," & vbCrLf
SQL = SQL & "   NewHeight decimal(12,4)," & vbCrLf
SQL = SQL & "   NewLength decimal(12,4)," & vbCrLf
SQL = SQL & "   NewRecord int," & vbCrLf
SQL = SQL & "   Qty decimal(12,4)," & vbCrLf
SQL = SQL & "   NewIANumber int" & vbCrLf
SQL = SQL & ")" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "declare @nextRecord int, @nextIANumber int" & vbCrLf
SQL = SQL & "declare @LotNo char(15), @id int, @SO int" & vbCrLf
SQL = SQL & "select @LotNo = LOTNUMBER from LohdTable where LOTUSERLOTID = @UserLotNo" & vbCrLf
SQL = SQL & "select @nextRecord = max(LOIRECORD) + 1 , @SO = max(LOISONUMBER) from LoitTable where LOINUMBER = @LotNo" & vbCrLf
SQL = SQL & "select @nextIANumber = max(INNUMBER) + 1 from InvaTable" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- first update the lot header" & vbCrLf
SQL = SQL & "update LohdTable set LOTCOMMENTS = @Comments, LOTLOCATION = @Location where LOTNUMBER = @LotNo" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- extract parameters" & vbCrLf
SQL = SQL & "DECLARE @start INT, @end INT" & vbCrLf
SQL = SQL & "declare @stringId varchar(10), @stringHt varchar(10), @stringLen varchar(10)" & vbCrLf
SQL = SQL & "SELECT @start = 1, @end = CHARINDEX(',', @Params) " & vbCrLf
SQL = SQL & "WHILE @start < LEN(@Params) + 1 BEGIN " & vbCrLf
SQL = SQL & "    IF @end = 0 break" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "    set @stringId = SUBSTRING(@Params, @start, @end - @start)" & vbCrLf
SQL = SQL & "    SET @start = @end + 1 " & vbCrLf
SQL = SQL & "    SET @end = CHARINDEX(',', @Params, @start)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "    IF @end = 0 break" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "    set @stringHt = SUBSTRING(@Params, @start, @end - @start)" & vbCrLf
SQL = SQL & "    SET @start = @end + 1 " & vbCrLf
SQL = SQL & "    SET @end = CHARINDEX(',', @Params, @start)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "    IF @end = 0 break" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "    set @stringLen = SUBSTRING(@Params, @start, @end - @start)" & vbCrLf
SQL = SQL & "    SET @start = @end + 1 " & vbCrLf
SQL = SQL & "    SET @end = CHARINDEX(',', @Params, @start)" & vbCrLf
SQL = SQL & "   " & vbCrLf
SQL = SQL & "   declare @ht decimal(12,4), @len decimal(12,4)" & vbCrLf
SQL = SQL & "   set @ht = cast(@stringHt as decimal(12,4))" & vbCrLf
SQL = SQL & "   set @len = cast(@stringLen as decimal(12,4))" & vbCrLf
SQL = SQL & "   insert into #rect (ParentRecord, NewHeight, NewLength, NewRecord, NewIANumber)" & vbCrLf
SQL = SQL & "   values (cast(@stringId as int), @ht, @len," & vbCrLf
SQL = SQL & "       case when @ht*@len = 0 then 0 else @nextRecord end," & vbCrLf
SQL = SQL & "       case when @ht*@len = 0 then 0 else @nextIANumber end)" & vbCrLf
SQL = SQL & "   if (@ht*@len) <> 0 " & vbCrLf
SQL = SQL & "   begin" & vbCrLf
SQL = SQL & "       set @nextRecord = @nextRecord + 1" & vbCrLf
SQL = SQL & "       set @nextIANumber = @nextIANumber + 1" & vbCrLf
SQL = SQL & "   end" & vbCrLf
SQL = SQL & "END " & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "update #rect set Qty = NewHeight * NewLength" & vbCrLf
SQL = SQL & "update #rect set ParentRecord = isnull((select top 1 ParentRecord from #rect where ParentRecord <> 0 ),0)" & vbCrLf
SQL = SQL & "where ParentRecord = 0" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "--select * from #rect" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "declare @partRef varchar(30), @currentTime datetime, @uom char(2), @type int" & vbCrLf
SQL = SQL & "declare @unitCost decimal(12,4), @nextINNUMBER int, @totalQty decimal(12,4)" & vbCrLf
SQL = SQL & "select @partRef = LOTPARTREF, @unitCost = LOTUNITCOST, @totalQty = LOTREMAININGQTY from LohdTable where LOTNUMBER = @LotNo" & vbCrLf
SQL = SQL & "select @uom = PAUNITS from PartTable where PARTREF = @partRef" & vbCrLf
SQL = SQL & "set @currentTime = getdate()" & vbCrLf
SQL = SQL & "select @nextINNUMBER = max(INNUMBER) + 1 from InvaTable" & vbCrLf
SQL = SQL & "set @type = 19     -- manual adjustment" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- deactivate picked rectangles so they won't show up again" & vbCrLf
SQL = SQL & "Update li " & vbCrLf
SQL = SQL & "set li.LOICLOSED = cast(convert(varchar(10),@currentTime,101) as datetime)" & vbCrLf
SQL = SQL & "from LoitTable li " & vbCrLf
SQL = SQL & "join #rect r on li.LOINUMBER = @LotNo and li.LOIRECORD = r.ParentRecord" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- remove rectangles with no quantity remaining.  These items will not be restocked." & vbCrLf
SQL = SQL & "delete from #rect where Qty = 0" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- create new lot items" & vbCrLf
SQL = SQL & "INSERT INTO [dbo].[LoitTable]" & vbCrLf
SQL = SQL & "           ([LOINUMBER]" & vbCrLf
SQL = SQL & "           ,[LOIRECORD]" & vbCrLf
SQL = SQL & "           ,[LOITYPE]" & vbCrLf
SQL = SQL & "           ,[LOIPARTREF]" & vbCrLf
SQL = SQL & "           ,[LOIADATE]" & vbCrLf
SQL = SQL & "           ,[LOIPDATE]" & vbCrLf
SQL = SQL & "           ,[LOIQUANTITY]" & vbCrLf
SQL = SQL & "           ,[LOIMOPARTREF]" & vbCrLf
SQL = SQL & "           ,[LOIMORUNNO]" & vbCrLf
SQL = SQL & "           ,[LOIPONUMBER]" & vbCrLf
SQL = SQL & "           ,[LOIPOITEM]" & vbCrLf
SQL = SQL & "           ,[LOIPOREV]" & vbCrLf
SQL = SQL & "           ,[LOIPSNUMBER]" & vbCrLf
SQL = SQL & "           ,[LOIPSITEM]" & vbCrLf
SQL = SQL & "           ,[LOICUSTINVNO]" & vbCrLf
SQL = SQL & "           ,[LOICUST]" & vbCrLf
SQL = SQL & "           ,[LOIVENDINVNO]" & vbCrLf
SQL = SQL & "           ,[LOIVENDOR]" & vbCrLf
SQL = SQL & "           ,[LOIACTIVITY]" & vbCrLf
SQL = SQL & "           ,[LOICOMMENT]" & vbCrLf
SQL = SQL & "           ,[LOIUNITS]" & vbCrLf
SQL = SQL & "           ,[LOIMOPKCANCEL]" & vbCrLf
SQL = SQL & "           ,[LOIHEIGHT]" & vbCrLf
SQL = SQL & "           ,[LOILENGTH]" & vbCrLf
SQL = SQL & "           ,[LOIUSER]" & vbCrLf
SQL = SQL & "          ,LOIPARENTREC" & vbCrLf
SQL = SQL & "           ,[LOISONUMBER]" & vbCrLf
SQL = SQL & "          ,LOISHEETACTTYPE" & vbCrLf
SQL = SQL & "          )" & vbCrLf
SQL = SQL & "     SELECT" & vbCrLf
SQL = SQL & "           @LotNo" & vbCrLf
SQL = SQL & "           ,r.NewRecord" & vbCrLf
SQL = SQL & "           ,@type              -- manual adjustment" & vbCrLf
SQL = SQL & "           ,@partRef" & vbCrLf
SQL = SQL & "           ,@currentTime" & vbCrLf
SQL = SQL & "           ,@currentTime" & vbCrLf
SQL = SQL & "           ,r.Qty" & vbCrLf
SQL = SQL & "           ,null   --LOIMOPARTREF, char(30),>" & vbCrLf
SQL = SQL & "           ,null   --<LOIMORUNNO, int,>" & vbCrLf
SQL = SQL & "           ,null   --<LOIPONUMBER, int,>" & vbCrLf
SQL = SQL & "           ,null   --<LOIPOITEM, smallint,>" & vbCrLf
SQL = SQL & "           ,null   --<LOIPOREV, char(2),>" & vbCrLf
SQL = SQL & "           ,null   --<LOIPSNUMBER, char(8),>" & vbCrLf
SQL = SQL & "           ,null   --<LOIPSITEM, smallint,>" & vbCrLf
SQL = SQL & "           ,null   --<LOICUSTINVNO, int,>" & vbCrLf
SQL = SQL & "           ,null   --<LOICUST, char(10),>" & vbCrLf
SQL = SQL & "           ,null   --<LOIVENDINVNO, char(20),>" & vbCrLf
SQL = SQL & "           ,null   --<LOIVENDOR, char(10),>" & vbCrLf
SQL = SQL & "           ,null   --<LOIACTIVITY, int,> points to InvaTable.INNO when IA is created" & vbCrLf
SQL = SQL & "           ,'sheet restock'    --<LOICOMMENT, varchar(40),>" & vbCrLf
SQL = SQL & "           ,@uom   --<LOIUNITS, char(2),>" & vbCrLf
SQL = SQL & "           ,null   --<LOIMOPKCANCEL, smallint,>" & vbCrLf
SQL = SQL & "           ,r.NewHeight    --<LOIHEIGHT, decimal(12,4),>" & vbCrLf
SQL = SQL & "           ,r.NewLength    --<LOILENGTH, decimal(12,4),>" & vbCrLf
SQL = SQL & "           ,@User      --<LOIUSER, varchar(4),>" & vbCrLf
SQL = SQL & "          ,r.ParentRecord  --LOIPICKEDFROMREC" & vbCrLf
SQL = SQL & "           ,@SO        --<LOISONUMBER, int,>" & vbCrLf
SQL = SQL & "          ,'RS'    --LOISHEETACTTYPE" & vbCrLf
SQL = SQL & "       from #rect r" & vbCrLf
SQL = SQL & "       where r.Qty <> 0" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "--select distinct li.* from LoitTable li " & vbCrLf
SQL = SQL & "--join #rect r on li.LOINUMBER = @LotNo and li.LOIRECORD > 1" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- set LOTREMAININGQTY and remove reservation" & vbCrLf
SQL = SQL & "declare @sum decimal(12,4)" & vbCrLf
SQL = SQL & "select @sum = sum(Qty) from #rect" & vbCrLf
SQL = SQL & "update LohdTable " & vbCrLf
SQL = SQL & "   set LOTREMAININGQTY = LOTREMAININGQTY + @sum," & vbCrLf
SQL = SQL & "   LOTRESERVEDBY = NULL," & vbCrLf
SQL = SQL & "   LOTRESERVEDON = NULL" & vbCrLf
SQL = SQL & "   where LOTNUMBER = @LotNo" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- create new ia items" & vbCrLf
SQL = SQL & "INSERT INTO [dbo].[InvaTable]" & vbCrLf
SQL = SQL & "           ([INTYPE]" & vbCrLf
SQL = SQL & "           ,[INPART]" & vbCrLf
SQL = SQL & "           ,[INREF1]" & vbCrLf
SQL = SQL & "           ,[INREF2]" & vbCrLf
SQL = SQL & "           ,[INPDATE]" & vbCrLf
SQL = SQL & "           ,[INADATE]" & vbCrLf
SQL = SQL & "           ,[INPQTY]" & vbCrLf
SQL = SQL & "           ,[INAQTY]" & vbCrLf
SQL = SQL & "           ,[INAMT]" & vbCrLf
SQL = SQL & "           ,[INTOTMATL]" & vbCrLf
SQL = SQL & "           ,[INTOTLABOR]" & vbCrLf
SQL = SQL & "           ,[INTOTEXP]" & vbCrLf
SQL = SQL & "           ,[INTOTOH]" & vbCrLf
SQL = SQL & "           ,[INTOTHRS]" & vbCrLf
SQL = SQL & "           ,[INCREDITACCT]" & vbCrLf
SQL = SQL & "           ,[INDEBITACCT]" & vbCrLf
SQL = SQL & "           ,[INGLJOURNAL]" & vbCrLf
SQL = SQL & "           ,[INGLPOSTED]" & vbCrLf
SQL = SQL & "           ,[INGLDATE]" & vbCrLf
SQL = SQL & "           ,[INMOPART]" & vbCrLf
SQL = SQL & "           ,[INMORUN]" & vbCrLf
SQL = SQL & "           ,[INSONUMBER]" & vbCrLf
SQL = SQL & "           ,[INSOITEM]" & vbCrLf
SQL = SQL & "           ,[INSOREV]" & vbCrLf
SQL = SQL & "           ,[INPONUMBER]" & vbCrLf
SQL = SQL & "           ,[INPORELEASE]" & vbCrLf
SQL = SQL & "           ,[INPOITEM]" & vbCrLf
SQL = SQL & "           ,[INPOREV]" & vbCrLf
SQL = SQL & "           ,[INPSNUMBER]" & vbCrLf
SQL = SQL & "           ,[INPSITEM]" & vbCrLf
SQL = SQL & "           ,[INWIPLABACCT]" & vbCrLf
SQL = SQL & "           ,[INWIPMATACCT]" & vbCrLf
SQL = SQL & "           ,[INWIPOHDACCT]" & vbCrLf
SQL = SQL & "           ,[INWIPEXPACCT]" & vbCrLf
SQL = SQL & "           ,[INNUMBER]" & vbCrLf
SQL = SQL & "           ,[INLOTNUMBER]" & vbCrLf
SQL = SQL & "           ,[INUSER]" & vbCrLf
SQL = SQL & "           ,[INUNITS]" & vbCrLf
SQL = SQL & "           ,[INDRLABACCT]" & vbCrLf
SQL = SQL & "           ,[INDRMATACCT]" & vbCrLf
SQL = SQL & "           ,[INDREXPACCT]" & vbCrLf
SQL = SQL & "           ,[INDROHDACCT]" & vbCrLf
SQL = SQL & "           ,[INCRLABACCT]" & vbCrLf
SQL = SQL & "           ,[INCRMATACCT]" & vbCrLf
SQL = SQL & "           ,[INCREXPACCT]" & vbCrLf
SQL = SQL & "           ,[INCROHDACCT]" & vbCrLf
SQL = SQL & "           ,[INLOTTRACK]" & vbCrLf
SQL = SQL & "           ,[INUSEACTUALCOST]" & vbCrLf
SQL = SQL & "           ,[INCOSTEDBY]" & vbCrLf
SQL = SQL & "           ,[INMAINTCOSTED])" & vbCrLf
SQL = SQL & "     select" & vbCrLf
SQL = SQL & "           @type               --<INTYPE, int,>" & vbCrLf
SQL = SQL & "           ,@partRef           --char(30),>" & vbCrLf
SQL = SQL & "           ,'Manual Adjustment'    --<INREF1, char(20),>" & vbCrLf
SQL = SQL & "           ,'Sheet Inventory'  --<INREF2, char(40),>" & vbCrLf
SQL = SQL & "           ,@currentTime       --<INPDATE, smalldatetime,>" & vbCrLf
SQL = SQL & "           ,@currentTime       --<INADATE, smalldatetime,>" & vbCrLf
SQL = SQL & "           ,r.Qty          --<INPQTY, decimal(12,4),>" & vbCrLf
SQL = SQL & "           ,r.Qty          --<INAQTY, decimal(12,4),>" & vbCrLf
SQL = SQL & "           ,@unitCost          -- <INAMT, decimal(12,4),>" & vbCrLf
SQL = SQL & "           ,0.0                    --<INTOTMATL, decimal(12,4),>" & vbCrLf
SQL = SQL & "           ,0.0                    --<INTOTLABOR, decimal(12,4),>" & vbCrLf
SQL = SQL & "           ,0.0                    --<INTOTEXP, decimal(12,4),>" & vbCrLf
SQL = SQL & "           ,0.0                    --<INTOTOH, decimal(12,4),>" & vbCrLf
SQL = SQL & "           ,0.0                    --<INTOTHRS, decimal(12,4),>" & vbCrLf
SQL = SQL & "           ,''                 --<INCREDITACCT, char(12),>" & vbCrLf
SQL = SQL & "           ,''                 --<INDEBITACCT, char(12),>" & vbCrLf
SQL = SQL & "           ,''                 --<INGLJOURNAL, char(12),>" & vbCrLf
SQL = SQL & "           ,0                  --<INGLPOSTED, tinyint,>" & vbCrLf
SQL = SQL & "           ,null               --<INGLDATE, smalldatetime,>" & vbCrLf
SQL = SQL & "           ,''                 --<INMOPART, char(30),>" & vbCrLf
SQL = SQL & "           ,0                  --<INMORUN, int,>" & vbCrLf
SQL = SQL & "           ,0                  --<INSONUMBER, int,>" & vbCrLf
SQL = SQL & "           ,0                  --<INSOITEM, int,>" & vbCrLf
SQL = SQL & "           ,''                 --<INSOREV, char(2),>" & vbCrLf
SQL = SQL & "           ,0                  --<INPONUMBER, int,>" & vbCrLf
SQL = SQL & "           ,0                  --<INPORELEASE, smallint,>" & vbCrLf
SQL = SQL & "           ,0                  --<INPOITEM, smallint,>" & vbCrLf
SQL = SQL & "           ,''                 --<INPOREV, char(2),>" & vbCrLf
SQL = SQL & "           ,''                 --<INPSNUMBER, char(8),>" & vbCrLf
SQL = SQL & "           ,0                  --<INPSITEM, smallint,>" & vbCrLf
SQL = SQL & "           ,''                 --<INWIPLABACCT, char(12),>" & vbCrLf
SQL = SQL & "           ,''                 --<INWIPMATACCT, char(12),>" & vbCrLf
SQL = SQL & "           ,''                 --<INWIPOHDACCT, char(12),>" & vbCrLf
SQL = SQL & "           ,''                 --<INWIPEXPACCT, char(12),>" & vbCrLf
SQL = SQL & "           ,r.NewIANumber      --<INNUMBER, int,>" & vbCrLf
SQL = SQL & "           ,@LotNo             --<INLOTNUMBER, char(15),>" & vbCrLf
SQL = SQL & "           ,@User              --<INUSER, char(4),>" & vbCrLf
SQL = SQL & "           ,@uom               --<INUNITS, char(2),>" & vbCrLf
SQL = SQL & "           ,''                 --<INDRLABACCT, char(12),>" & vbCrLf
SQL = SQL & "           ,''                 --<INDRMATACCT, char(12),>" & vbCrLf
SQL = SQL & "           ,''                 --<INDREXPACCT, char(12),>" & vbCrLf
SQL = SQL & "           ,''                 --<INDROHDACCT, char(12),>" & vbCrLf
SQL = SQL & "           ,''                 --<INCRLABACCT, char(12),>" & vbCrLf
SQL = SQL & "           ,''                 --<INCRMATACCT, char(12),>" & vbCrLf
SQL = SQL & "           ,''                 --<INCREXPACCT, char(12),>" & vbCrLf
SQL = SQL & "           ,''                 --<INCROHDACCT, char(12),>" & vbCrLf
SQL = SQL & "           ,null               --<INLOTTRACK, bit,>" & vbCrLf
SQL = SQL & "           ,null               --<INUSEACTUALCOST, bit,>" & vbCrLf
SQL = SQL & "           ,null               --<INCOSTEDBY, char(4),>" & vbCrLf
SQL = SQL & "           ,0                  --<INMAINTCOSTED, int,>)" & vbCrLf
SQL = SQL & "       from #rect r" & vbCrLf
SQL = SQL & "       where r.Qty <> 0" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- now update part QOH" & vbCrLf
SQL = SQL & "update PartTable set PAQOH = PAQOH + @totalQty where PARTREF = @partRef" & vbCrLf
SQL = SQL & "commit tran" & vbCrLf
ExecuteScript False, SQL


''''''''''''''''''''''''''''''''''''''''''''''''''

        ' update the version
        ExecuteScript False, "Update Version Set Version = " & newver

    End If
End Function

Private Function UpdateDatabase92()

'update database version template
'set version at top of this file
'set version below
'add SQL updates


   Dim SQL As String
   SQL = ""

   newver = 167     ' set actual version
   If ver < newver Then

        clsADOCon.ADOErrNum = 0

''''''''''''''''''''''''''''''''''''''''''''''''''

SQL = "IF EXISTS (SELECT * FROM sys.objects WHERE type = 'P' AND name = 'AddOrUpdateColumn')" & vbCrLf
SQL = SQL & "  DROP PROCEDURE AddOrUpdateColumn" & vbCrLf
ExecuteScript False, SQL

SQL = "create procedure dbo.AddOrUpdateColumn " & vbCrLf
SQL = SQL & "  @Table varchar(40)," & vbCrLf
SQL = SQL & "  @Column varchar(40)," & vbCrLf
SQL = SQL & "  @Properties varchar(80)" & vbCrLf
SQL = SQL & "as" & vbCrLf
SQL = SQL & "/* create or update a column" & vbCrLf
SQL = SQL & "test:" & vbCrLf
SQL = SQL & "  AddOrUpdateColumn 'ComnTable', 'DenyLoginIfPriorOpOpen', 'tinyint null'" & vbCrLf
SQL = SQL & "*/" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "begin" & vbCrLf
SQL = SQL & "  declare @sql varchar(120)" & vbCrLf
SQL = SQL & "  if exists (select COLUMN_NAME from INFORMATION_SCHEMA.COLUMNS where TABLE_NAME = @Table " & vbCrLf
SQL = SQL & "  and COLUMN_NAME = @Column )" & vbCrLf
SQL = SQL & "     set @sql = 'ALTER TABLE ' + @Table + ' ALTER COLUMN ' + @Column + ' ' + @Properties" & vbCrLf
SQL = SQL & "  else" & vbCrLf
SQL = SQL & "     set @sql = 'ALTER TABLE ' + @Table + ' ADD ' + @Column + ' ' + @Properties" & vbCrLf
SQL = SQL & "  execute (@sql)" & vbCrLf
SQL = SQL & "end" & vbCrLf
ExecuteScript False, SQL

SQL = "IF EXISTS (SELECT * FROM sys.objects WHERE type = 'P' AND name = 'DeleteStoredProcedureIfExists')" & vbCrLf
SQL = SQL & "  DROP PROCEDURE DeleteStoredProcedureIfExists" & vbCrLf
ExecuteScript False, SQL

SQL = "create procedure DeleteStoredProcedureIfExists" & vbCrLf
SQL = SQL & "  @Proc_Name varchar(50)" & vbCrLf
SQL = SQL & "as" & vbCrLf
SQL = SQL & "begin" & vbCrLf
SQL = SQL & "  IF EXISTS (SELECT * FROM sys.objects WHERE type = 'P' AND name = @Proc_Name)" & vbCrLf
SQL = SQL & "  begin" & vbCrLf
SQL = SQL & "     declare @sql varchar(100)" & vbCrLf
SQL = SQL & "     set @sql = 'DROP PROCEDURE ' + @Proc_Name" & vbCrLf
SQL = SQL & "     execute(@sql)" & vbCrLf
SQL = SQL & "  end" & vbCrLf
SQL = SQL & "end" & vbCrLf
ExecuteScript False, SQL

SQL = "AddOrUpdateColumn 'ComnTable', 'DenyLoginIfPriorOpOpen', 'tinyint null'" & vbCrLf
ExecuteScript False, SQL

' Inactive Inventory (MANSERV)

'Rename the stored procedure.
SQL = "EXEC sp_rename 'InventoryExcessReport', 'InventoryExcessReport_Old';" & vbCrLf
ExecuteScript False, SQL

SQL = "EXEC DeleteStoredProcedureIfExists 'InventoryExcessReport'" & vbCrLf
ExecuteScript False, SQL

SQL = "create PROCEDURE dbo.InventoryExcessReport" & vbCrLf
SQL = SQL & "          @BeginDate as varchar(16), @EndDate as varchar(16), @PartClass as Varchar(16), " & vbCrLf
SQL = SQL & "          @PartCode as varchar(8), @InclZQty as Integer, @PartType1 as Integer, " & vbCrLf
SQL = SQL & "          @PartType2 as Integer, @PartType3 as Integer, @PartType4 as Integer" & vbCrLf
SQL = SQL & "AS" & vbCrLf
SQL = SQL & "/*" & vbCrLf
SQL = SQL & "exec dbo.InventoryExcessReport '1/1/2015','12/31/2015','','',1,1,1,1,1" & vbCrLf
SQL = SQL & "*/                                    " & vbCrLf
SQL = SQL & "BEGIN                                 " & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "declare @sqlZQty as varchar(12)   " & vbCrLf
SQL = SQL & "                                            " & vbCrLf
SQL = SQL & "IF (@PartClass = 'ALL')           " & vbCrLf
SQL = SQL & "BEGIN                             " & vbCrLf
SQL = SQL & "  SET @PartClass = ''           " & vbCrLf
SQL = SQL & "End                               " & vbCrLf
SQL = SQL & "IF (@PartCode = 'ALL')            " & vbCrLf
SQL = SQL & "BEGIN                             " & vbCrLf
SQL = SQL & "  SET @PartCode = ''            " & vbCrLf
SQL = SQL & "End                               " & vbCrLf
SQL = SQL & "                                            " & vbCrLf
SQL = SQL & "IF (@PartType1 = 1)               " & vbCrLf
SQL = SQL & "  SET @PartType1 = 1            " & vbCrLf
SQL = SQL & "Else                              " & vbCrLf
SQL = SQL & "  SET @PartType1 = 0            " & vbCrLf
SQL = SQL & "                                            " & vbCrLf
SQL = SQL & "IF (@PartType2 = 1)               " & vbCrLf
SQL = SQL & "  SET @PartType2 = 2            " & vbCrLf
SQL = SQL & "Else                              " & vbCrLf
SQL = SQL & "  SET @PartType2 = 0                " & vbCrLf
SQL = SQL & "                                          " & vbCrLf
SQL = SQL & "IF (@PartType3 = 1)                   " & vbCrLf
SQL = SQL & "  SET @PartType3 = 3                " & vbCrLf
SQL = SQL & "Else                                  " & vbCrLf
SQL = SQL & "  SET @PartType3 = 0                " & vbCrLf
SQL = SQL & "                                          " & vbCrLf
SQL = SQL & "IF (@PartType4 = 1)                   " & vbCrLf
SQL = SQL & "  SET @PartType4 = 4                " & vbCrLf
SQL = SQL & "Else                                  " & vbCrLf
SQL = SQL & "  SET @PartType4 = 0   " & vbCrLf
SQL = SQL & "     " & vbCrLf
SQL = SQL & "-- create a list of matching parts" & vbCrLf
SQL = SQL & "select PARTNUM, PARTREF, PACLASS, PAPRODCODE, PALEVEL,PADESC, PAEXTDESC, PAQOH AS QOH_Then, " & vbCrLf
SQL = SQL & "  PAQOH AS QOH_Now, cast('' as char(1)) AS MRP_Activity into #tempParts from PartTable" & vbCrLf
SQL = SQL & "where PACLASS LIKE '%' + @PartClass + '%'                     " & vbCrLf
SQL = SQL & "AND PAPRODCODE LIKE '%' + @PartCode + '%'                       " & vbCrLf
SQL = SQL & "AND PALEVEL IN (@PartType1, @PartType2, @PartType3, @PartType4)  " & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- delete parts that did not exist until after end date" & vbCrLf
SQL = SQL & "delete from #tempParts where not exists " & vbCrLf
SQL = SQL & "(select INADATE from InvaTable where INPART = #tempParts.PARTREF and INADATE <= @EndDate)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- determine which parts have past-due MRP activity" & vbCrLf
SQL = SQL & "update #tempParts set MRP_Activity = 'X' where exists" & vbCrLf
SQL = SQL & "  (SELECT mrp_Partref FROM dbo.MrplTable      " & vbCrLf
SQL = SQL & "    WHERE MRP_PARTREF = #tempParts.PARTREF and mrp_type IN (2, 3, 4, 11, 12, 17)" & vbCrLf
SQL = SQL & "    AND mrp_partDateRQD < DATEADD(dd, +1 , @EndDate))    " & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- delete parts where there has been inventory activity in the date range" & vbCrLf
SQL = SQL & "delete from #tempParts" & vbCrLf
SQL = SQL & "where exists (SELECT INPART FROM invaTable where INPART = PARTREF " & vbCrLf
SQL = SQL & "  and INADATE BETWEEN @BeginDate and @EndDate)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- determine quantity at end date, if the date is different" & vbCrLf
SQL = SQL & "declare @today datetime" & vbCrLf
SQL = SQL & "set @today = cast(convert(varchar(10), getdate(), 101) as datetime)" & vbCrLf
SQL = SQL & "if @today <> @EndDate" & vbCrLf
SQL = SQL & "begin" & vbCrLf
SQL = SQL & "  update #tempParts set QOH_Then = QOH_Then " & vbCrLf
SQL = SQL & "     - ISNULL((select sum(INAQTY) from InvaTable where INPART = PARTREF and INADATE > @EndDate),0)" & vbCrLf
SQL = SQL & "end" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- if zero quantity parts are not included, remove those with zero quantity at the end date" & vbCrLf
SQL = SQL & "if @InclZQty = 0" & vbCrLf
SQL = SQL & "begin" & vbCrLf
SQL = SQL & "  delete from #tempParts where QOH_Then = 0 and QOH_Now = 0 and MRP_Activity = ''" & vbCrLf
SQL = SQL & "end" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- return results" & vbCrLf
SQL = SQL & "select * from #tempParts order by PARTREF" & vbCrLf
SQL = SQL & "drop table #tempParts" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "END" & vbCrLf
ExecuteScript False, SQL


''''''''''''''''''''''''''''''''''''''''''''''''''

        ' update the version
        ExecuteScript False, "Update Version Set Version = " & newver

    End If
End Function

Private Function UpdateDatabase93()

'update database version template
'set version at top of this file
'set version below
'add SQL updates


   Dim SQL As String
   SQL = ""

   newver = 168     ' set actual version
   If ver < newver Then

        clsADOCon.ADOErrNum = 0

''''''''''''''''''''''''''''''''''''''''''''''''''

SQL = "IF EXISTS (SELECT * FROM sys.objects WHERE type = 'P' AND name = 'DropStoredProcedureIfExists')" & vbCrLf
SQL = SQL & "  DROP PROCEDURE DeleteStoredProcedureIfExists" & vbCrLf
ExecuteScript False, SQL

SQL = "create procedure DropStoredProcedureIfExists" & vbCrLf
SQL = SQL & "  @Proc_Name varchar(50)" & vbCrLf
SQL = SQL & "as" & vbCrLf
SQL = SQL & "begin" & vbCrLf
SQL = SQL & "  IF EXISTS (SELECT * FROM sys.objects WHERE type = 'P' AND name = @Proc_Name)" & vbCrLf
SQL = SQL & "  begin" & vbCrLf
SQL = SQL & "     declare @sql varchar(100)" & vbCrLf
SQL = SQL & "     set @sql = 'DROP PROCEDURE ' + @Proc_Name" & vbCrLf
SQL = SQL & "     execute(@sql)" & vbCrLf
SQL = SQL & "  end" & vbCrLf
SQL = SQL & "end" & vbCrLf
ExecuteScript False, SQL

' script to correctly associate sheet inventory lots and invatable rows

' first update duplicate INNUMBERS resulting from errors in SheetPick and SheetRestock sp's
SQL = "if exists (select 1 from ComnTable where COUSESHEETINVENTORY = 1)" & vbCrLf
SQL = SQL & "begin" & vbCrLf
SQL = SQL & "begin tran" & vbCrLf
SQL = SQL & "declare @dups TABLE (INNUMBER int)" & vbCrLf
SQL = SQL & "insert @dups" & vbCrLf
SQL = SQL & "select innumber from invatable" & vbCrLf
SQL = SQL & "where INPART in (select partref from PartTable where PAPUNITS = 'SH')" & vbCrLf
SQL = SQL & "group by innumber having count(*) > 1" & vbCrLf
SQL = SQL & "declare @maxINNUMBER int" & vbCrLf
SQL = SQL & "select @maxINNUMBER = max(INNUMBER) FROM InvaTable" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "declare @dups2 table (INNUMBER int, Qty decimal(12,2), newINNUMBER int)" & vbCrLf
SQL = SQL & "insert @dups2" & vbCrLf
SQL = SQL & "select ia.INNUMBER, INAQTY, @maxINNUMBER + ROW_NUMBER() OVER (ORDER BY ia.INNUMBER, ia.INAQTY)" & vbCrLf
SQL = SQL & "from @dups join InvaTable ia on ia.INNUMBER = [@dups].INNUMBER" & vbCrLf
SQL = SQL & "where INAQTY <> (select min(INAQTY) from @dups join InvaTable ia2 on ia2.INNUMBER = [@dups].INNUMBER where ia2.INNUMBER = ia.INNUMBER)" & vbCrLf
SQL = SQL & "order by ia.INNUMBER, INAQTY" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "update ia" & vbCrLf
SQL = SQL & "set ia.INNUMBER = d.newINNUMBER" & vbCrLf
SQL = SQL & "from InvaTable ia join @dups2 d on d.INNUMBER = ia.INNUMBER and d.Qty = ia.INAQTY" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- now find matching lot item records and point them at the appropriate INNUMBERS" & vbCrLf
SQL = SQL & "update  loi" & vbCrLf
SQL = SQL & "set LOIACTIVITY = INNUMBER" & vbCrLf
SQL = SQL & "from LoitTable loi join InvaTable ia on ia.INLOTNUMBER = loi.LOINUMBER" & vbCrLf
SQL = SQL & "and ia.INAQTY = loi.LOIQUANTITY" & vbCrLf
SQL = SQL & "and ia.INADATE = loi.LOIADATE" & vbCrLf
SQL = SQL & "where LOIPARTREF in (select partref from PartTable where PAPUNITS = 'SH')" & vbCrLf
SQL = SQL & "and LOIACTIVITY is null" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "commit tran" & vbCrLf
SQL = SQL & "end" & vbCrLf
ExecuteScript False, SQL

SQL = "DropStoredProcedureIfExists 'SheetCancelPick'" & vbCrLf
ExecuteScript False, SQL

SQL = "create procedure SheetCancelPick" & vbCrLf
SQL = SQL & "@LotUserLotID varchar(40)" & vbCrLf
SQL = SQL & "as" & vbCrLf
SQL = SQL & "begin tran" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- get the lot id" & vbCrLf
SQL = SQL & "declare @LotID varchar(15)" & vbCrLf
SQL = SQL & "select @LotID = LOTNUMBER from LohdTable where LOTUSERLOTID = @LotUserLotID" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- remember the parent records" & vbCrLf
SQL = SQL & "declare @parents TABLE" & vbCrLf
SQL = SQL & "(" & vbCrLf
SQL = SQL & "Record int," & vbCrLf
SQL = SQL & "Area decimal(12,4)," & vbCrLf
SQL = SQL & "INNUMBER int" & vbCrLf
SQL = SQL & ")" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "INSERT @parents" & vbCrLf
SQL = SQL & "SELECT LOIPARENTREC, LOIAREA, LOIACTIVITY" & vbCrLf
SQL = SQL & "from LoitTable" & vbCrLf
SQL = SQL & "where LOINUMBER = @LotID AND LOICLOSED is NULL" & vbCrLf
SQL = SQL & "and LOISHEETACTTYPE = 'PK'" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- delete the pick records" & vbCrLf
SQL = SQL & "delete LoitTable" & vbCrLf
SQL = SQL & "where LOINUMBER = @LotID AND LOICLOSED is NULL" & vbCrLf
SQL = SQL & "and LOISHEETACTTYPE = 'PK'" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- delete inventory activity records" & vbCrLf
SQL = SQL & "delete InvaTable" & vbCrLf
SQL = SQL & "from InvaTable" & vbCrLf
SQL = SQL & "where INLOTNUMBER = @LotID" & vbCrLf
SQL = SQL & "and INNUMBER in (select INNUMBER from @parents)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- restore the parent records to pickable status" & vbCrLf
SQL = SQL & "update li" & vbCrLf
SQL = SQL & "set LOICLOSED = NULL" & vbCrLf
SQL = SQL & "from LoitTable li" & vbCrLf
SQL = SQL & "where LOINUMBER = @LotID AND LOIRECORD in (select Record from @parents)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- restore LOTREMAININGQTY" & vbCrLf
SQL = SQL & "declare @area decimal(12,4)" & vbCrLf
SQL = SQL & "select @area = sum(Area) from @parents" & vbCrLf
SQL = SQL & "update LohdTable set LOTREMAININGQTY = LOTREMAININGQTY + @area where LOTNUMBER = @LotID" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- restore part QOH" & vbCrLf
SQL = SQL & "update PartTable set PAQOH = PAQOH + @area" & vbCrLf
SQL = SQL & "from PartTable join LohdTable on PARTREF = LOTPARTREF" & vbCrLf
SQL = SQL & "where LOTNUMBER = @LotID" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "commit tran" & vbCrLf
ExecuteScript False, SQL

SQL = "DropStoredProcedureIfExists 'SheetPick'" & vbCrLf
ExecuteScript False, SQL

SQL = "create procedure [dbo].[SheetPick]" & vbCrLf
SQL = SQL & "@UserLotNo varchar(40),     -- lotuserlotid" & vbCrLf
SQL = SQL & "@User varchar(4)," & vbCrLf
SQL = SQL & "@SO int," & vbCrLf
SQL = SQL & "@PickDate datetime" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "as" & vbCrLf
SQL = SQL & "/*" & vbCrLf
SQL = SQL & "Pick a sheet" & vbCrLf
SQL = SQL & "exec SheetPick '029373-1-A','MGR',222222" & vbCrLf
SQL = SQL & "*/" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- remove time from pick date" & vbCrLf
SQL = SQL & "set @PickDate = cast(convert(varchar(10),@PickDate,101)as datetime)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- find all rectangles in lot" & vbCrLf
SQL = SQL & "begin tran" & vbCrLf
SQL = SQL & "create table #rect" & vbCrLf
SQL = SQL & "(" & vbCrLf
SQL = SQL & "id int identity," & vbCrLf
SQL = SQL & "ParentRecord int," & vbCrLf
SQL = SQL & "Height decimal(12,4)," & vbCrLf
SQL = SQL & "Length decimal(12,4)," & vbCrLf
SQL = SQL & "NewRecord int," & vbCrLf
SQL = SQL & "Qty decimal(12,4)," & vbCrLf
SQL = SQL & "NewINNUMBER int" & vbCrLf
SQL = SQL & ")" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "declare @LotNo char(15)" & vbCrLf
SQL = SQL & "select @LotNo = LOTNUMBER from LohdTable where LOTUSERLOTID = @UserLotNo" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "insert #rect (ParentRecord,Height,Length,NewRecord,Qty)" & vbCrLf
SQL = SQL & "select li.LOIRECORD,li.LOIHEIGHT,li.LOILENGTH,0,cast(li.LOIHEIGHT*li.LOILENGTH as decimal(12,4)) from LoitTable li" & vbCrLf
SQL = SQL & "join LohdTable lh on lh.LOTNUMBER = li.LOINUMBER" & vbCrLf
SQL = SQL & "where lh.LOTNUMBER = @LotNo and LOIQUANTITY > 0" & vbCrLf
SQL = SQL & "and li.LOICLOSED is null" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- assign new LoitTable record numbers" & vbCrLf
SQL = SQL & "declare @max int" & vbCrLf
SQL = SQL & "select @max = max(LOIRECORD) from LoitTable where LOINUMBER = @LotNo" & vbCrLf
SQL = SQL & "update #rect set NewRecord = @max + id" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "declare @partRef varchar(30), @uom char(2), @type int" & vbCrLf
SQL = SQL & "declare @unitCost decimal(12,4), @maxINNUMBER int, @totalQty decimal(12,4)" & vbCrLf
SQL = SQL & "select @partRef = LOTPARTREF, @unitCost = LOTUNITCOST, @totalQty = LOTREMAININGQTY from LohdTable where LOTNUMBER = @LotNo" & vbCrLf
SQL = SQL & "select @uom = PAUNITS from PartTable where PARTREF = @partRef" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- assign" & vbCrLf
SQL = SQL & "select @maxINNUMBER = max(INNUMBER) from InvaTable" & vbCrLf
SQL = SQL & "update #rect set NewINNUMBER = @maxINNUMBER + id" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "set @type = 19     -- manual adjustment" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- deactivate rectangles being picked so they won't show up again" & vbCrLf
SQL = SQL & "Update li" & vbCrLf
SQL = SQL & "set li.LOICLOSED = @PickDate" & vbCrLf
SQL = SQL & "from LoitTable li" & vbCrLf
SQL = SQL & "join #rect r on li.LOINUMBER = @LotNo and li.LOIRECORD = r.ParentRecord" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- create new LoitTable record to zero lot quantity" & vbCrLf
SQL = SQL & "INSERT INTO [dbo].[LoitTable]" & vbCrLf
SQL = SQL & "([LOINUMBER]" & vbCrLf
SQL = SQL & ",[LOIRECORD]" & vbCrLf
SQL = SQL & ",[LOITYPE]" & vbCrLf
SQL = SQL & ",[LOIPARTREF]" & vbCrLf
SQL = SQL & ",[LOIADATE]" & vbCrLf
SQL = SQL & ",[LOIPDATE]" & vbCrLf
SQL = SQL & ",[LOIQUANTITY]" & vbCrLf
SQL = SQL & ",[LOIMOPARTREF]" & vbCrLf
SQL = SQL & ",[LOIMORUNNO]" & vbCrLf
SQL = SQL & ",[LOIPONUMBER]" & vbCrLf
SQL = SQL & ",[LOIPOITEM]" & vbCrLf
SQL = SQL & ",[LOIPOREV]" & vbCrLf
SQL = SQL & ",[LOIPSNUMBER]" & vbCrLf
SQL = SQL & ",[LOIPSITEM]" & vbCrLf
SQL = SQL & ",[LOICUSTINVNO]" & vbCrLf
SQL = SQL & ",[LOICUST]" & vbCrLf
SQL = SQL & ",[LOIVENDINVNO]" & vbCrLf
SQL = SQL & ",[LOIVENDOR]" & vbCrLf
SQL = SQL & ",[LOIACTIVITY]" & vbCrLf
SQL = SQL & ",[LOICOMMENT]" & vbCrLf
SQL = SQL & ",[LOIUNITS]" & vbCrLf
SQL = SQL & ",[LOIMOPKCANCEL]" & vbCrLf
SQL = SQL & ",[LOIHEIGHT]" & vbCrLf
SQL = SQL & ",[LOILENGTH]" & vbCrLf
SQL = SQL & ",[LOIUSER]" & vbCrLf
SQL = SQL & ",LOIPARENTREC" & vbCrLf
SQL = SQL & ",[LOISONUMBER]" & vbCrLf
SQL = SQL & ",LOISHEETACTTYPE" & vbCrLf
SQL = SQL & ")" & vbCrLf
SQL = SQL & "SELECT" & vbCrLf
SQL = SQL & "@LotNo" & vbCrLf
SQL = SQL & ",r.NewRecord" & vbCrLf
SQL = SQL & ",@type              -- manual adjustment" & vbCrLf
SQL = SQL & ",@partRef" & vbCrLf
SQL = SQL & ",@PickDate" & vbCrLf
SQL = SQL & ",@PickDate" & vbCrLf
SQL = SQL & ",-r.Qty" & vbCrLf
SQL = SQL & ",null   --LOIMOPARTREF, char(30),>" & vbCrLf
SQL = SQL & ",null   --<LOIMORUNNO, int,>" & vbCrLf
SQL = SQL & ",null   --<LOIPONUMBER, int,>" & vbCrLf
SQL = SQL & ",null   --<LOIPOITEM, smallint,>" & vbCrLf
SQL = SQL & ",null   --<LOIPOREV, char(2),>" & vbCrLf
SQL = SQL & ",null   --<LOIPSNUMBER, char(8),>" & vbCrLf
SQL = SQL & ",null   --<LOIPSITEM, smallint,>" & vbCrLf
SQL = SQL & ",null   --<LOICUSTINVNO, int,>" & vbCrLf
SQL = SQL & ",null   --<LOICUST, char(10),>" & vbCrLf
SQL = SQL & ",null   --<LOIVENDINVNO, char(20),>" & vbCrLf
SQL = SQL & ",null   --<LOIVENDOR, char(10),>" & vbCrLf
SQL = SQL & ",r.NewINNUMBER   --<LOIACTIVITY, int,> points to InvaTable.INNUMBER when IA is created" & vbCrLf
SQL = SQL & ",'sheet pick'   --<LOICOMMENT, varchar(40),>" & vbCrLf
SQL = SQL & ",@uom   --<LOIUNITS, char(2),>" & vbCrLf
SQL = SQL & ",null   --<LOIMOPKCANCEL, smallint,>" & vbCrLf
SQL = SQL & ",r.HEIGHT   --<LOIHEIGHT, decimal(12,4),>" & vbCrLf
SQL = SQL & ",r.LENGTH   --<LOILENGTH, decimal(12,4),>" & vbCrLf
SQL = SQL & ",@User          --<LOIUSER, varchar(4),>" & vbCrLf
SQL = SQL & ",r.ParentRecord  --LOIPARENTREC" & vbCrLf
SQL = SQL & ",@SO                --<LOISONUMBER, int,>" & vbCrLf
SQL = SQL & ",'PK'            --LOISHEETACTTYPE" & vbCrLf
SQL = SQL & "from #rect r" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- set lot quantity = 0" & vbCrLf
SQL = SQL & "update LohdTable set LOTREMAININGQTY = 0 where LOTNUMBER = @LotNo" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- create new IA record to reduce part quantity" & vbCrLf
SQL = SQL & "INSERT INTO [dbo].[InvaTable]" & vbCrLf
SQL = SQL & "([INTYPE]" & vbCrLf
SQL = SQL & ",[INPART]" & vbCrLf
SQL = SQL & ",[INREF1]" & vbCrLf
SQL = SQL & ",[INREF2]" & vbCrLf
SQL = SQL & ",[INPDATE]" & vbCrLf
SQL = SQL & ",[INADATE]" & vbCrLf
SQL = SQL & ",[INPQTY]" & vbCrLf
SQL = SQL & ",[INAQTY]" & vbCrLf
SQL = SQL & ",[INAMT]" & vbCrLf
SQL = SQL & ",[INTOTMATL]" & vbCrLf
SQL = SQL & ",[INTOTLABOR]" & vbCrLf
SQL = SQL & ",[INTOTEXP]" & vbCrLf
SQL = SQL & ",[INTOTOH]" & vbCrLf
SQL = SQL & ",[INTOTHRS]" & vbCrLf
SQL = SQL & ",[INCREDITACCT]" & vbCrLf
SQL = SQL & ",[INDEBITACCT]" & vbCrLf
SQL = SQL & ",[INGLJOURNAL]" & vbCrLf
SQL = SQL & ",[INGLPOSTED]" & vbCrLf
SQL = SQL & ",[INGLDATE]" & vbCrLf
SQL = SQL & ",[INMOPART]" & vbCrLf
SQL = SQL & ",[INMORUN]" & vbCrLf
SQL = SQL & ",[INSONUMBER]" & vbCrLf
SQL = SQL & ",[INSOITEM]" & vbCrLf
SQL = SQL & ",[INSOREV]" & vbCrLf
SQL = SQL & ",[INPONUMBER]" & vbCrLf
SQL = SQL & ",[INPORELEASE]" & vbCrLf
SQL = SQL & ",[INPOITEM]" & vbCrLf
SQL = SQL & ",[INPOREV]" & vbCrLf
SQL = SQL & ",[INPSNUMBER]" & vbCrLf
SQL = SQL & ",[INPSITEM]" & vbCrLf
SQL = SQL & ",[INWIPLABACCT]" & vbCrLf
SQL = SQL & ",[INWIPMATACCT]" & vbCrLf
SQL = SQL & ",[INWIPOHDACCT]" & vbCrLf
SQL = SQL & ",[INWIPEXPACCT]" & vbCrLf
SQL = SQL & ",[INNUMBER]" & vbCrLf
SQL = SQL & ",[INLOTNUMBER]" & vbCrLf
SQL = SQL & ",[INUSER]" & vbCrLf
SQL = SQL & ",[INUNITS]" & vbCrLf
SQL = SQL & ",[INDRLABACCT]" & vbCrLf
SQL = SQL & ",[INDRMATACCT]" & vbCrLf
SQL = SQL & ",[INDREXPACCT]" & vbCrLf
SQL = SQL & ",[INDROHDACCT]" & vbCrLf
SQL = SQL & ",[INCRLABACCT]" & vbCrLf
SQL = SQL & ",[INCRMATACCT]" & vbCrLf
SQL = SQL & ",[INCREXPACCT]" & vbCrLf
SQL = SQL & ",[INCROHDACCT]" & vbCrLf
SQL = SQL & ",[INLOTTRACK]" & vbCrLf
SQL = SQL & ",[INUSEACTUALCOST]" & vbCrLf
SQL = SQL & ",[INCOSTEDBY]" & vbCrLf
SQL = SQL & ",[INMAINTCOSTED])" & vbCrLf
SQL = SQL & "select" & vbCrLf
SQL = SQL & "@type               --<INTYPE, int,>" & vbCrLf
SQL = SQL & ",@partRef           --char(30),>" & vbCrLf
SQL = SQL & ",'Manual Adjustment'    --<INREF1, char(20),>" & vbCrLf
SQL = SQL & ",'Sheet Inventory'  --<INREF2, char(40),>" & vbCrLf
SQL = SQL & ",@PickDate       --<INPDATE, smalldatetime,>" & vbCrLf
SQL = SQL & ",@PickDate       --<INADATE, smalldatetime,>" & vbCrLf
SQL = SQL & ",-r.Qty         --<INPQTY, decimal(12,4),>" & vbCrLf
SQL = SQL & ",-r.Qty         --<INAQTY, decimal(12,4),>" & vbCrLf
SQL = SQL & ",@unitCost          -- <INAMT, decimal(12,4),>" & vbCrLf
SQL = SQL & ",0.0                    --<INTOTMATL, decimal(12,4),>" & vbCrLf
SQL = SQL & ",0.0                    --<INTOTLABOR, decimal(12,4),>" & vbCrLf
SQL = SQL & ",0.0                    --<INTOTEXP, decimal(12,4),>" & vbCrLf
SQL = SQL & ",0.0                    --<INTOTOH, decimal(12,4),>" & vbCrLf
SQL = SQL & ",0.0                    --<INTOTHRS, decimal(12,4),>" & vbCrLf
SQL = SQL & ",''                 --<INCREDITACCT, char(12),>" & vbCrLf
SQL = SQL & ",''                 --<INDEBITACCT, char(12),>" & vbCrLf
SQL = SQL & ",''                 --<INGLJOURNAL, char(12),>" & vbCrLf
SQL = SQL & ",0                  --<INGLPOSTED, tinyint,>" & vbCrLf
SQL = SQL & ",null               --<INGLDATE, smalldatetime,>" & vbCrLf
SQL = SQL & ",''                 --<INMOPART, char(30),>" & vbCrLf
SQL = SQL & ",0                  --<INMORUN, int,>" & vbCrLf
SQL = SQL & ",0                  --<INSONUMBER, int,>" & vbCrLf
SQL = SQL & ",0                  --<INSOITEM, int,>" & vbCrLf
SQL = SQL & ",''                 --<INSOREV, char(2),>" & vbCrLf
SQL = SQL & ",0                  --<INPONUMBER, int,>" & vbCrLf
SQL = SQL & ",0                  --<INPORELEASE, smallint,>" & vbCrLf
SQL = SQL & ",0                  --<INPOITEM, smallint,>" & vbCrLf
SQL = SQL & ",''                 --<INPOREV, char(2),>" & vbCrLf
SQL = SQL & ",''                 --<INPSNUMBER, char(8),>" & vbCrLf
SQL = SQL & ",0                  --<INPSITEM, smallint,>" & vbCrLf
SQL = SQL & ",''                 --<INWIPLABACCT, char(12),>" & vbCrLf
SQL = SQL & ",''                 --<INWIPMATACCT, char(12),>" & vbCrLf
SQL = SQL & ",''                 --<INWIPOHDACCT, char(12),>" & vbCrLf
SQL = SQL & ",''                 --<INWIPEXPACCT, char(12),>" & vbCrLf
SQL = SQL & ",R.NewINNUMBER      --<INNUMBER, int,>" & vbCrLf
SQL = SQL & ",@LotNo             --<INLOTNUMBER, char(15),>" & vbCrLf
SQL = SQL & ",@User              --<INUSER, char(4),>" & vbCrLf
SQL = SQL & ",@uom               --<INUNITS, char(2),>" & vbCrLf
SQL = SQL & ",''                 --<INDRLABACCT, char(12),>" & vbCrLf
SQL = SQL & ",''                 --<INDRMATACCT, char(12),>" & vbCrLf
SQL = SQL & ",''                 --<INDREXPACCT, char(12),>" & vbCrLf
SQL = SQL & ",''                 --<INDROHDACCT, char(12),>" & vbCrLf
SQL = SQL & ",''                 --<INCRLABACCT, char(12),>" & vbCrLf
SQL = SQL & ",''                 --<INCRMATACCT, char(12),>" & vbCrLf
SQL = SQL & ",''                 --<INCREXPACCT, char(12),>" & vbCrLf
SQL = SQL & ",''                 --<INCROHDACCT, char(12),>" & vbCrLf
SQL = SQL & ",null               --<INLOTTRACK, bit,>" & vbCrLf
SQL = SQL & ",null               --<INUSEACTUALCOST, bit,>" & vbCrLf
SQL = SQL & ",null               --<INCOSTEDBY, char(4),>" & vbCrLf
SQL = SQL & ",0                  --<INMAINTCOSTED, int,>)" & vbCrLf
SQL = SQL & "from #rect r" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- now update part QOH" & vbCrLf
SQL = SQL & "update PartTable set PAQOH = PAQOH - @totalQty where PARTREF = @partRef" & vbCrLf
SQL = SQL & "commit tran" & vbCrLf
SQL = SQL & "" & vbCrLf
ExecuteScript False, SQL

SQL = "DropStoredProcedureIfExists 'SheetRestock'" & vbCrLf
ExecuteScript False, SQL

SQL = "create procedure SheetRestock" & vbCrLf
SQL = SQL & "@UserLotNo varchar(40)," & vbCrLf
SQL = SQL & "@User varchar(4)," & vbCrLf
SQL = SQL & "@Comments varchar(2048)," & vbCrLf
SQL = SQL & "@Location varchar(4)," & vbCrLf
SQL = SQL & "@RestockDate datetime," & vbCrLf
SQL = SQL & "@Params varchar(2000)   -- LOIRECORD,NEWHT,NEWLEN,... repeat (include comma at end)" & vbCrLf
SQL = SQL & "as" & vbCrLf
SQL = SQL & "/*" & vbCrLf
SQL = SQL & "restock sheet LOI records" & vbCrLf
SQL = SQL & "exec SheetRestock '029373-1-A', 'MGR', '2,36,96,0,12,72,'" & vbCrLf
SQL = SQL & "*/" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "begin tran" & vbCrLf
SQL = SQL & "create table #rect" & vbCrLf
SQL = SQL & "(" & vbCrLf
SQL = SQL & "ParentRecord int," & vbCrLf
SQL = SQL & "NewHeight decimal(12,4)," & vbCrLf
SQL = SQL & "NewLength decimal(12,4)," & vbCrLf
SQL = SQL & "NewRecord int," & vbCrLf
SQL = SQL & "Qty decimal(12,4)," & vbCrLf
SQL = SQL & "NewINNUMBER int" & vbCrLf
SQL = SQL & ")" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "declare @nextRecord int, @nextIANumber int" & vbCrLf
SQL = SQL & "declare @LotNo char(15), @id int, @SO int" & vbCrLf
SQL = SQL & "select @LotNo = LOTNUMBER from LohdTable where LOTUSERLOTID = @UserLotNo" & vbCrLf
SQL = SQL & "select @nextRecord = max(LOIRECORD) + 1 , @SO = max(LOISONUMBER) from LoitTable where LOINUMBER = @LotNo" & vbCrLf
SQL = SQL & "select @nextIANumber = max(INNUMBER) + 1 from InvaTable" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- first update the lot header" & vbCrLf
SQL = SQL & "update LohdTable set LOTCOMMENTS = @Comments, LOTLOCATION = @Location where LOTNUMBER = @LotNo" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- extract parameters" & vbCrLf
SQL = SQL & "DECLARE @start INT, @end INT" & vbCrLf
SQL = SQL & "declare @stringId varchar(10), @stringHt varchar(10), @stringLen varchar(10)" & vbCrLf
SQL = SQL & "SELECT @start = 1, @end = CHARINDEX(',', @Params)" & vbCrLf
SQL = SQL & "WHILE @start < LEN(@Params) + 1 BEGIN" & vbCrLf
SQL = SQL & "IF @end = 0 break" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "set @stringId = SUBSTRING(@Params, @start, @end - @start)" & vbCrLf
SQL = SQL & "SET @start = @end + 1" & vbCrLf
SQL = SQL & "SET @end = CHARINDEX(',', @Params, @start)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "IF @end = 0 break" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "set @stringHt = SUBSTRING(@Params, @start, @end - @start)" & vbCrLf
SQL = SQL & "SET @start = @end + 1" & vbCrLf
SQL = SQL & "SET @end = CHARINDEX(',', @Params, @start)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "IF @end = 0 break" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "set @stringLen = SUBSTRING(@Params, @start, @end - @start)" & vbCrLf
SQL = SQL & "SET @start = @end + 1" & vbCrLf
SQL = SQL & "SET @end = CHARINDEX(',', @Params, @start)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "declare @ht decimal(12,4), @len decimal(12,4)" & vbCrLf
SQL = SQL & "set @ht = cast(@stringHt as decimal(12,4))" & vbCrLf
SQL = SQL & "set @len = cast(@stringLen as decimal(12,4))" & vbCrLf
SQL = SQL & "insert into #rect (ParentRecord, NewHeight, NewLength, NewRecord, NewINNUMBER)" & vbCrLf
SQL = SQL & "values (cast(@stringId as int), @ht, @len," & vbCrLf
SQL = SQL & "case when @ht*@len = 0 then 0 else @nextRecord end," & vbCrLf
SQL = SQL & "case when @ht*@len = 0 then 0 else @nextIANumber end)" & vbCrLf
SQL = SQL & "if (@ht*@len) <> 0" & vbCrLf
SQL = SQL & "begin" & vbCrLf
SQL = SQL & "set @nextRecord = @nextRecord + 1" & vbCrLf
SQL = SQL & "set @nextIANumber = @nextIANumber + 1" & vbCrLf
SQL = SQL & "end" & vbCrLf
SQL = SQL & "END" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "update #rect set Qty = NewHeight * NewLength" & vbCrLf
SQL = SQL & "update #rect set ParentRecord = isnull((select top 1 ParentRecord from #rect where ParentRecord <> 0 ),0)" & vbCrLf
SQL = SQL & "where ParentRecord = 0" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "--select * from #rect" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "declare @partRef varchar(30), @uom char(2), @type int" & vbCrLf
SQL = SQL & "declare @unitCost decimal(12,4), @nextINNUMBER int, @totalQty decimal(12,4)" & vbCrLf
SQL = SQL & "select @partRef = LOTPARTREF, @unitCost = LOTUNITCOST, @totalQty = LOTREMAININGQTY from LohdTable where LOTNUMBER = @LotNo" & vbCrLf
SQL = SQL & "select @uom = PAUNITS from PartTable where PARTREF = @partRef" & vbCrLf
SQL = SQL & "select @nextINNUMBER = max(INNUMBER) + 1 from InvaTable" & vbCrLf
SQL = SQL & "set @type = 19     -- manual adjustment" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- deactivate picked rectangles so they won't show up again" & vbCrLf
SQL = SQL & "Update li" & vbCrLf
SQL = SQL & "set li.LOICLOSED = cast(convert(varchar(10),@RestockDate,101) as datetime)" & vbCrLf
SQL = SQL & "from LoitTable li" & vbCrLf
SQL = SQL & "join #rect r on li.LOINUMBER = @LotNo and li.LOIRECORD = r.ParentRecord" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- remove rectangles with no quantity remaining.  These items will not be restocked." & vbCrLf
SQL = SQL & "delete from #rect where Qty = 0" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- create new lot items" & vbCrLf
SQL = SQL & "INSERT INTO [dbo].[LoitTable]" & vbCrLf
SQL = SQL & "([LOINUMBER]" & vbCrLf
SQL = SQL & ",[LOIRECORD]" & vbCrLf
SQL = SQL & ",[LOITYPE]" & vbCrLf
SQL = SQL & ",[LOIPARTREF]" & vbCrLf
SQL = SQL & ",[LOIADATE]" & vbCrLf
SQL = SQL & ",[LOIPDATE]" & vbCrLf
SQL = SQL & ",[LOIQUANTITY]" & vbCrLf
SQL = SQL & ",[LOIMOPARTREF]" & vbCrLf
SQL = SQL & ",[LOIMORUNNO]" & vbCrLf
SQL = SQL & ",[LOIPONUMBER]" & vbCrLf
SQL = SQL & ",[LOIPOITEM]" & vbCrLf
SQL = SQL & ",[LOIPOREV]" & vbCrLf
SQL = SQL & ",[LOIPSNUMBER]" & vbCrLf
SQL = SQL & ",[LOIPSITEM]" & vbCrLf
SQL = SQL & ",[LOICUSTINVNO]" & vbCrLf
SQL = SQL & ",[LOICUST]" & vbCrLf
SQL = SQL & ",[LOIVENDINVNO]" & vbCrLf
SQL = SQL & ",[LOIVENDOR]" & vbCrLf
SQL = SQL & ",[LOIACTIVITY]" & vbCrLf
SQL = SQL & ",[LOICOMMENT]" & vbCrLf
SQL = SQL & ",[LOIUNITS]" & vbCrLf
SQL = SQL & ",[LOIMOPKCANCEL]" & vbCrLf
SQL = SQL & ",[LOIHEIGHT]" & vbCrLf
SQL = SQL & ",[LOILENGTH]" & vbCrLf
SQL = SQL & ",[LOIUSER]" & vbCrLf
SQL = SQL & ",LOIPARENTREC" & vbCrLf
SQL = SQL & ",[LOISONUMBER]" & vbCrLf
SQL = SQL & ",LOISHEETACTTYPE" & vbCrLf
SQL = SQL & ")" & vbCrLf
SQL = SQL & "SELECT" & vbCrLf
SQL = SQL & "@LotNo" & vbCrLf
SQL = SQL & ",r.NewRecord" & vbCrLf
SQL = SQL & ",@type              -- manual adjustment" & vbCrLf
SQL = SQL & ",@partRef" & vbCrLf
SQL = SQL & ",@RestockDate" & vbCrLf
SQL = SQL & ",@RestockDate" & vbCrLf
SQL = SQL & ",r.Qty" & vbCrLf
SQL = SQL & ",null   --LOIMOPARTREF, char(30),>" & vbCrLf
SQL = SQL & ",null   --<LOIMORUNNO, int,>" & vbCrLf
SQL = SQL & ",null   --<LOIPONUMBER, int,>" & vbCrLf
SQL = SQL & ",null   --<LOIPOITEM, smallint,>" & vbCrLf
SQL = SQL & ",null   --<LOIPOREV, char(2),>" & vbCrLf
SQL = SQL & ",null   --<LOIPSNUMBER, char(8),>" & vbCrLf
SQL = SQL & ",null   --<LOIPSITEM, smallint,>" & vbCrLf
SQL = SQL & ",null   --<LOICUSTINVNO, int,>" & vbCrLf
SQL = SQL & ",null   --<LOICUST, char(10),>" & vbCrLf
SQL = SQL & ",null   --<LOIVENDINVNO, char(20),>" & vbCrLf
SQL = SQL & ",null   --<LOIVENDOR, char(10),>" & vbCrLf
SQL = SQL & ",r.NewINNUMBER   --<LOIACTIVITY, int,> points to InvaTable.INNUMBER when IA is created" & vbCrLf
SQL = SQL & ",'sheet restock'    --<LOICOMMENT, varchar(40),>" & vbCrLf
SQL = SQL & ",@uom   --<LOIUNITS, char(2),>" & vbCrLf
SQL = SQL & ",null   --<LOIMOPKCANCEL, smallint,>" & vbCrLf
SQL = SQL & ",r.NewHeight    --<LOIHEIGHT, decimal(12,4),>" & vbCrLf
SQL = SQL & ",r.NewLength    --<LOILENGTH, decimal(12,4),>" & vbCrLf
SQL = SQL & ",@User      --<LOIUSER, varchar(4),>" & vbCrLf
SQL = SQL & ",r.ParentRecord  --LOIPICKEDFROMREC" & vbCrLf
SQL = SQL & ",@SO        --<LOISONUMBER, int,>" & vbCrLf
SQL = SQL & ",'RS'    --LOISHEETACTTYPE" & vbCrLf
SQL = SQL & "from #rect r" & vbCrLf
SQL = SQL & "where r.Qty <> 0" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "--select distinct li.* from LoitTable li" & vbCrLf
SQL = SQL & "--join #rect r on li.LOINUMBER = @LotNo and li.LOIRECORD > 1" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- set LOTREMAININGQTY and remove reservation" & vbCrLf
SQL = SQL & "declare @sum decimal(12,4)" & vbCrLf
SQL = SQL & "select @sum = sum(Qty) from #rect" & vbCrLf
SQL = SQL & "update LohdTable" & vbCrLf
SQL = SQL & "set LOTREMAININGQTY = LOTREMAININGQTY + @sum," & vbCrLf
SQL = SQL & "LOTRESERVEDBY = NULL," & vbCrLf
SQL = SQL & "LOTRESERVEDON = NULL" & vbCrLf
SQL = SQL & "where LOTNUMBER = @LotNo" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- create new ia items" & vbCrLf
SQL = SQL & "INSERT INTO [dbo].[InvaTable]" & vbCrLf
SQL = SQL & "([INTYPE]" & vbCrLf
SQL = SQL & ",[INPART]" & vbCrLf
SQL = SQL & ",[INREF1]" & vbCrLf
SQL = SQL & ",[INREF2]" & vbCrLf
SQL = SQL & ",[INPDATE]" & vbCrLf
SQL = SQL & ",[INADATE]" & vbCrLf
SQL = SQL & ",[INPQTY]" & vbCrLf
SQL = SQL & ",[INAQTY]" & vbCrLf
SQL = SQL & ",[INAMT]" & vbCrLf
SQL = SQL & ",[INTOTMATL]" & vbCrLf
SQL = SQL & ",[INTOTLABOR]" & vbCrLf
SQL = SQL & ",[INTOTEXP]" & vbCrLf
SQL = SQL & ",[INTOTOH]" & vbCrLf
SQL = SQL & ",[INTOTHRS]" & vbCrLf
SQL = SQL & ",[INCREDITACCT]" & vbCrLf
SQL = SQL & ",[INDEBITACCT]" & vbCrLf
SQL = SQL & ",[INGLJOURNAL]" & vbCrLf
SQL = SQL & ",[INGLPOSTED]" & vbCrLf
SQL = SQL & ",[INGLDATE]" & vbCrLf
SQL = SQL & ",[INMOPART]" & vbCrLf
SQL = SQL & ",[INMORUN]" & vbCrLf
SQL = SQL & ",[INSONUMBER]" & vbCrLf
SQL = SQL & ",[INSOITEM]" & vbCrLf
SQL = SQL & ",[INSOREV]" & vbCrLf
SQL = SQL & ",[INPONUMBER]" & vbCrLf
SQL = SQL & ",[INPORELEASE]" & vbCrLf
SQL = SQL & ",[INPOITEM]" & vbCrLf
SQL = SQL & ",[INPOREV]" & vbCrLf
SQL = SQL & ",[INPSNUMBER]" & vbCrLf
SQL = SQL & ",[INPSITEM]" & vbCrLf
SQL = SQL & ",[INWIPLABACCT]" & vbCrLf
SQL = SQL & ",[INWIPMATACCT]" & vbCrLf
SQL = SQL & ",[INWIPOHDACCT]" & vbCrLf
SQL = SQL & ",[INWIPEXPACCT]" & vbCrLf
SQL = SQL & ",[INNUMBER]" & vbCrLf
SQL = SQL & ",[INLOTNUMBER]" & vbCrLf
SQL = SQL & ",[INUSER]" & vbCrLf
SQL = SQL & ",[INUNITS]" & vbCrLf
SQL = SQL & ",[INDRLABACCT]" & vbCrLf
SQL = SQL & ",[INDRMATACCT]" & vbCrLf
SQL = SQL & ",[INDREXPACCT]" & vbCrLf
SQL = SQL & ",[INDROHDACCT]" & vbCrLf
SQL = SQL & ",[INCRLABACCT]" & vbCrLf
SQL = SQL & ",[INCRMATACCT]" & vbCrLf
SQL = SQL & ",[INCREXPACCT]" & vbCrLf
SQL = SQL & ",[INCROHDACCT]" & vbCrLf
SQL = SQL & ",[INLOTTRACK]" & vbCrLf
SQL = SQL & ",[INUSEACTUALCOST]" & vbCrLf
SQL = SQL & ",[INCOSTEDBY]" & vbCrLf
SQL = SQL & ",[INMAINTCOSTED])" & vbCrLf
SQL = SQL & "select" & vbCrLf
SQL = SQL & "@type               --<INTYPE, int,>" & vbCrLf
SQL = SQL & ",@partRef           --char(30),>" & vbCrLf
SQL = SQL & ",'Manual Adjustment'    --<INREF1, char(20),>" & vbCrLf
SQL = SQL & ",'Sheet Inventory'  --<INREF2, char(40),>" & vbCrLf
SQL = SQL & ",@RestockDate       --<INPDATE, smalldatetime,>" & vbCrLf
SQL = SQL & ",@RestockDate       --<INADATE, smalldatetime,>" & vbCrLf
SQL = SQL & ",r.Qty          --<INPQTY, decimal(12,4),>" & vbCrLf
SQL = SQL & ",r.Qty          --<INAQTY, decimal(12,4),>" & vbCrLf
SQL = SQL & ",@unitCost          -- <INAMT, decimal(12,4),>" & vbCrLf
SQL = SQL & ",0.0                    --<INTOTMATL, decimal(12,4),>" & vbCrLf
SQL = SQL & ",0.0                    --<INTOTLABOR, decimal(12,4),>" & vbCrLf
SQL = SQL & ",0.0                    --<INTOTEXP, decimal(12,4),>" & vbCrLf
SQL = SQL & ",0.0                    --<INTOTOH, decimal(12,4),>" & vbCrLf
SQL = SQL & ",0.0                    --<INTOTHRS, decimal(12,4),>" & vbCrLf
SQL = SQL & ",''                 --<INCREDITACCT, char(12),>" & vbCrLf
SQL = SQL & ",''                 --<INDEBITACCT, char(12),>" & vbCrLf
SQL = SQL & ",''                 --<INGLJOURNAL, char(12),>" & vbCrLf
SQL = SQL & ",0                  --<INGLPOSTED, tinyint,>" & vbCrLf
SQL = SQL & ",null               --<INGLDATE, smalldatetime,>" & vbCrLf
SQL = SQL & ",''                 --<INMOPART, char(30),>" & vbCrLf
SQL = SQL & ",0                  --<INMORUN, int,>" & vbCrLf
SQL = SQL & ",0                  --<INSONUMBER, int,>" & vbCrLf
SQL = SQL & ",0                  --<INSOITEM, int,>" & vbCrLf
SQL = SQL & ",''                 --<INSOREV, char(2),>" & vbCrLf
SQL = SQL & ",0                  --<INPONUMBER, int,>" & vbCrLf
SQL = SQL & ",0                  --<INPORELEASE, smallint,>" & vbCrLf
SQL = SQL & ",0                  --<INPOITEM, smallint,>" & vbCrLf
SQL = SQL & ",''                 --<INPOREV, char(2),>" & vbCrLf
SQL = SQL & ",''                 --<INPSNUMBER, char(8),>" & vbCrLf
SQL = SQL & ",0                  --<INPSITEM, smallint,>" & vbCrLf
SQL = SQL & ",''                 --<INWIPLABACCT, char(12),>" & vbCrLf
SQL = SQL & ",''                 --<INWIPMATACCT, char(12),>" & vbCrLf
SQL = SQL & ",''                 --<INWIPOHDACCT, char(12),>" & vbCrLf
SQL = SQL & ",''                 --<INWIPEXPACCT, char(12),>" & vbCrLf
SQL = SQL & ",r.NewINNUMBER      --<INNUMBER, int,>" & vbCrLf
SQL = SQL & ",@LotNo             --<INLOTNUMBER, char(15),>" & vbCrLf
SQL = SQL & ",@User              --<INUSER, char(4),>" & vbCrLf
SQL = SQL & ",@uom               --<INUNITS, char(2),>" & vbCrLf
SQL = SQL & ",''                 --<INDRLABACCT, char(12),>" & vbCrLf
SQL = SQL & ",''                 --<INDRMATACCT, char(12),>" & vbCrLf
SQL = SQL & ",''                 --<INDREXPACCT, char(12),>" & vbCrLf
SQL = SQL & ",''                 --<INDROHDACCT, char(12),>" & vbCrLf
SQL = SQL & ",''                 --<INCRLABACCT, char(12),>" & vbCrLf
SQL = SQL & ",''                 --<INCRMATACCT, char(12),>" & vbCrLf
SQL = SQL & ",''                 --<INCREXPACCT, char(12),>" & vbCrLf
SQL = SQL & ",''                 --<INCROHDACCT, char(12),>" & vbCrLf
SQL = SQL & ",null               --<INLOTTRACK, bit,>" & vbCrLf
SQL = SQL & ",null               --<INUSEACTUALCOST, bit,>" & vbCrLf
SQL = SQL & ",null               --<INCOSTEDBY, char(4),>" & vbCrLf
SQL = SQL & ",0                  --<INMAINTCOSTED, int,>)" & vbCrLf
SQL = SQL & "from #rect r" & vbCrLf
SQL = SQL & "where r.Qty <> 0" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- now update part QOH" & vbCrLf
SQL = SQL & "update PartTable set PAQOH = PAQOH + @totalQty where PARTREF = @partRef" & vbCrLf
SQL = SQL & "commit tran" & vbCrLf
ExecuteScript False, SQL



''''''''''''''''''''''''''''''''''''''''''''''''''

        ' update the version
        ExecuteScript False, "Update Version Set Version = " & newver

    End If
End Function


Private Function UpdateDatabase94()

'update database version template
'set version at top of this file
'set version below
'add SQL updates


   Dim SQL As String
   SQL = ""

   newver = 169     ' set actual version
   If ver < newver Then

        clsADOCon.ADOErrNum = 0

''''''''''''''''''''''''''''''''''''''''''''''''''

SQL = "AddOrUpdateColumn 'EsReportVendorStmt', 'Journal', 'varchar(12) NULL'" & vbCrLf
ExecuteScript False, SQL

''''''''''''''''''''''''''''''''''''''''''''''''''

        ' update the version
        ExecuteScript False, "Update Version Set Version = " & newver

    End If
End Function

Private Function UpdateDatabase95()

'update database version template
'set version at top of this file
'set version below
'add SQL updates


   Dim SQL As String
   SQL = ""

   newver = 170     ' set actual version
   If ver < newver Then

        clsADOCon.ADOErrNum = 0

''''''''''''''''''''''''''''''''''''''''''''''''''

SQL = "DropStoredProcedureIfExists 'InventoryExcessReport'" & vbCrLf
ExecuteScript False, SQL

SQL = "create PROCEDURE [dbo].[InventoryExcessReport]" & vbCrLf
SQL = SQL & "@BeginDate as varchar(16), @EndDate as varchar(16), @PartClass as Varchar(16)," & vbCrLf
SQL = SQL & "@PartCode as varchar(8), @InclZQty as Integer, @PartType1 as Integer," & vbCrLf
SQL = SQL & "@PartType2 as Integer, @PartType3 as Integer, @PartType4 as Integer" & vbCrLf
SQL = SQL & "AS" & vbCrLf
SQL = SQL & "/*" & vbCrLf
SQL = SQL & "exec dbo.InventoryExcessReport '1/1/2015','12/31/2015','','',1,1,1,1,1" & vbCrLf
SQL = SQL & "*/" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "declare @sqlZQty as varchar(12)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "IF (@PartClass = 'ALL')" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "SET @PartClass = ''" & vbCrLf
SQL = SQL & "End" & vbCrLf
SQL = SQL & "IF (@PartCode = 'ALL')" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "SET @PartCode = ''" & vbCrLf
SQL = SQL & "End" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "IF (@PartType1 = 1)" & vbCrLf
SQL = SQL & "SET @PartType1 = 1" & vbCrLf
SQL = SQL & "Else" & vbCrLf
SQL = SQL & "SET @PartType1 = 0" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "IF (@PartType2 = 1)" & vbCrLf
SQL = SQL & "SET @PartType2 = 2" & vbCrLf
SQL = SQL & "Else" & vbCrLf
SQL = SQL & "SET @PartType2 = 0" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "IF (@PartType3 = 1)" & vbCrLf
SQL = SQL & "SET @PartType3 = 3" & vbCrLf
SQL = SQL & "Else" & vbCrLf
SQL = SQL & "SET @PartType3 = 0" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "IF (@PartType4 = 1)" & vbCrLf
SQL = SQL & "SET @PartType4 = 4" & vbCrLf
SQL = SQL & "Else" & vbCrLf
SQL = SQL & "SET @PartType4 = 0" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- create a list of matching parts" & vbCrLf
SQL = SQL & "select PARTNUM, PARTREF, PACLASS, PAPRODCODE, PALEVEL,PADESC, PAEXTDESC, PAQOH AS QOH_Then," & vbCrLf
SQL = SQL & "PAQOH AS QOH_Now, cast('' as char(1)) AS MRP_Activity into #tempParts from PartTable" & vbCrLf
SQL = SQL & "where PACLASS LIKE '%' + @PartClass + '%'" & vbCrLf
SQL = SQL & "AND PAPRODCODE LIKE '%' + @PartCode + '%'" & vbCrLf
SQL = SQL & "AND PALEVEL IN (@PartType1, @PartType2, @PartType3, @PartType4)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- delete parts that did not exist until after end date" & vbCrLf
SQL = SQL & "delete from #tempParts where not exists" & vbCrLf
SQL = SQL & "(select INADATE from InvaTable where INPART = #tempParts.PARTREF and INADATE <= @EndDate)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- determine which parts have past-due MRP activity" & vbCrLf
SQL = SQL & "update #tempParts set MRP_Activity = 'X' where exists" & vbCrLf
SQL = SQL & "(SELECT mrp_Partref FROM dbo.MrplTable" & vbCrLf
SQL = SQL & "WHERE MRP_PARTREF = #tempParts.PARTREF and mrp_type IN (2, 3, 4, 11, 12, 17)" & vbCrLf
SQL = SQL & "AND mrp_partDateRQD < DATEADD(dd, +1 , @EndDate))" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- delete parts where there has been inventory activity in the date range" & vbCrLf
SQL = SQL & "delete from #tempParts" & vbCrLf
SQL = SQL & "where exists (SELECT INPART FROM invaTable where INPART = PARTREF" & vbCrLf
SQL = SQL & "and INADATE BETWEEN @BeginDate and @EndDate" & vbCrLf
SQL = SQL & "and INTYPE not in (19,30))   -- ignore manual adjustments and ABC cycle counts" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- determine quantity at end date, if the date is different" & vbCrLf
SQL = SQL & "declare @today datetime" & vbCrLf
SQL = SQL & "set @today = cast(convert(varchar(10), getdate(), 101) as datetime)" & vbCrLf
SQL = SQL & "if @today <> @EndDate" & vbCrLf
SQL = SQL & "begin" & vbCrLf
SQL = SQL & "update #tempParts set QOH_Then = QOH_Then" & vbCrLf
SQL = SQL & "- ISNULL((select sum(INAQTY) from InvaTable where INPART = PARTREF and INADATE > @EndDate),0)" & vbCrLf
SQL = SQL & "end" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- if zero quantity parts are not included, remove those with zero quantity at the end date" & vbCrLf
SQL = SQL & "if @InclZQty = 0" & vbCrLf
SQL = SQL & "begin" & vbCrLf
SQL = SQL & "delete from #tempParts where QOH_Then = 0 and QOH_Now = 0 and MRP_Activity = ''" & vbCrLf
SQL = SQL & "end" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- return results" & vbCrLf
SQL = SQL & "select * from #tempParts order by PARTREF" & vbCrLf
SQL = SQL & "drop table #tempParts" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "END" & vbCrLf
SQL = SQL & "" & vbCrLf
ExecuteScript False, SQL

' BOM Fix
SQL = "update BmhdTable set BMHRELEASED = 1 where BMHRELEASED = 2"
ExecuteScript False, SQL

' CGS Detail Report fixes
SQL = "DropStoredProcedureIfExists 'RptMOCostDetail'" & vbCrLf
ExecuteScript False, SQL

SQL = "CREATE PROCEDURE RptMOCostDetail" & vbCrLf
SQL = SQL & "@MOPart as varchar(30),@MORun as int, @MOQty as decimal(15,4)" & vbCrLf
SQL = SQL & "AS" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "declare @SumTotMat decimal(15,4)" & vbCrLf
SQL = SQL & "declare @SumTotLabor decimal(15,4)" & vbCrLf
SQL = SQL & "declare @SumTotExp decimal(15,4)" & vbCrLf
SQL = SQL & "declare @SumTotOH decimal(15,4)" & vbCrLf
SQL = SQL & "declare @level as integer" & vbCrLf
SQL = SQL & "declare @Part as varchar(30)" & vbCrLf
SQL = SQL & "declare @PrevParent  as varchar(30)" & vbCrLf
SQL = SQL & "declare @RowCount as integer" & vbCrLf
SQL = SQL & "declare @ChildPart as varchar(30)" & vbCrLf
SQL = SQL & "declare @ParentPart as varchar(30)" & vbCrLf
SQL = SQL & "declare @MOPart1 as varchar(30)" & vbCrLf
SQL = SQL & "declare @MoRun1 as varchar(20)" & vbCrLf
SQL = SQL & "declare @Part1 as varchar(30)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "declare @ChildKey as varchar(1024)" & vbCrLf
SQL = SQL & "declare @GLSortKey as varchar(1024)" & vbCrLf
SQL = SQL & "declare @SortKey as varchar(1024)" & vbCrLf
SQL = SQL & "declare @ParentLotNum as varchar(15)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "declare @Maxlevel as int" & vbCrLf
SQL = SQL & "declare @LotRunNo as int" & vbCrLf
SQL = SQL & "declare @LotOrgQty as decimal(15,4)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "declare @LotUSpMat decimal(15,4)" & vbCrLf
SQL = SQL & "declare @LotUSpLabor decimal(15,4)" & vbCrLf
SQL = SQL & "declare @LotUSpExp decimal(15,4)" & vbCrLf
SQL = SQL & "declare @LotUSpOH decimal(15,4)" & vbCrLf
SQL = SQL & "declare @LotMatl decimal(15,4)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "declare @MOLotNum as varchar(15)" & vbCrLf
SQL = SQL & "declare @SplitLot as varchar(15)" & vbCrLf
SQL = SQL & "declare @cnt  as int" & vbCrLf
SQL = SQL & "declare @sumQty decimal(15,4)" & vbCrLf
SQL = SQL & "declare @MOPartRunKey as Varchar(30)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "--DROP TABLE #tempMOPartsDetail" & vbCrLf
SQL = SQL & "-- DELETE FROM #tempMOPartsDetail" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "SET @MOPartRunKey = RTRIM(@MOPart) + '_' + Convert(varchar(10), @MORun)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "CREATE TABLE #tempMOPartsDetail" & vbCrLf
SQL = SQL & "(" & vbCrLf
SQL = SQL & "LOTMOPARTRUNKEY varchar(50) NULL," & vbCrLf
SQL = SQL & "INMOPART Varchar(30) NULL," & vbCrLf
SQL = SQL & "INMORUN int NULL ," & vbCrLf
SQL = SQL & "INPART varchar(30) NULL ," & vbCrLf
SQL = SQL & "LOTNUMBER varchar(15) NULL," & vbCrLf
SQL = SQL & "LOTUSERLOTID varchar(40) NULL," & vbCrLf
SQL = SQL & "INTOTMATL decimal(12,4) NULL," & vbCrLf
SQL = SQL & "INTOTLABOR decimal(12,4) NULL," & vbCrLf
SQL = SQL & "INTOTEXP decimal(12,4) NULL," & vbCrLf
SQL = SQL & "INTOTOH decimal(12,4) NULL," & vbCrLf
SQL = SQL & "LOTTOTMATL decimal(12,4) NULL," & vbCrLf
SQL = SQL & "LOTTOTLABOR decimal(12,4) NULL," & vbCrLf
SQL = SQL & "LOTTOTEXP decimal(12,4) NULL," & vbCrLf
SQL = SQL & "LOTTOTOH decimal(12,4) NULL," & vbCrLf
SQL = SQL & "SUMTOTMAL decimal(12,4) NULL," & vbCrLf
SQL = SQL & "SUMTOTLABOR decimal(12,4) NULL," & vbCrLf
SQL = SQL & "SUMTOTEXP decimal(12,4) NULL," & vbCrLf
SQL = SQL & "SUMTOTOH decimal(12,4) NULL," & vbCrLf
SQL = SQL & "LOTDATECOSTED smalldatetime NULL," & vbCrLf
SQL = SQL & "SortKey varchar(512) NULL," & vbCrLf
SQL = SQL & "HASCHILD int NULL," & vbCrLf
SQL = SQL & "SORTKEYLEVEL tinyint NULL," & vbCrLf
SQL = SQL & "SortKeyRev varchar(512)," & vbCrLf
SQL = SQL & "PARTSUM varchar(40)," & vbCrLf
SQL = SQL & "BMQTYREQD decimal(12,4) NULL," & vbCrLf
SQL = SQL & "LOTORGQTY decimal(12,4) NULL," & vbCrLf
SQL = SQL & "BMTOTOH decimal(12,4) NULL," & vbCrLf
SQL = SQL & "LOTSPLITFROMSYS varchar(15)," & vbCrLf
SQL = SQL & "INVNO int NULL," & vbCrLf
SQL = SQL & "ITPSNUMBER varchar(8) NULL," & vbCrLf
SQL = SQL & "ITPSITEM smallint NULL," & vbCrLf
SQL = SQL & "PICKQTY decimal(12,4) NULL" & vbCrLf
SQL = SQL & ")" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "with cte" & vbCrLf
SQL = SQL & "as" & vbCrLf
SQL = SQL & "(select BMASSYPART, BMPARTREF,  BMQTYREQD,0 as level, cast('1' + char(36)+ BMPARTREF as varchar(max)) as SortKey" & vbCrLf
SQL = SQL & "from BmplTable" & vbCrLf
SQL = SQL & "where BMASSYPART = @MOPart" & vbCrLf
SQL = SQL & "union all" & vbCrLf
SQL = SQL & "select a.BMASSYPART, a.BMPARTREF, a.BMQTYREQD, level + 1," & vbCrLf
SQL = SQL & "cast(COALESCE(SortKey,'') + char(36) + COALESCE(a.BMPARTREF,'') as varchar(max))as SortKey" & vbCrLf
SQL = SQL & "from cte" & vbCrLf
SQL = SQL & "inner join BmplTable a" & vbCrLf
SQL = SQL & "on cte.BMPARTREF = a.BMASSYPART" & vbCrLf
SQL = SQL & ")" & vbCrLf
SQL = SQL & "INSERT INTO #tempMOPartsDetail(INMOPART,INPART,BMQTYREQD,SORTKEYLEVEL,SortKey)" & vbCrLf
SQL = SQL & "select BMASSYPART, BMPARTREF,BMQTYREQD,level,SortKey" & vbCrLf
SQL = SQL & "from cte order by SortKey" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "END" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "SET @cnt = 0" & vbCrLf
SQL = SQL & "print 'Update Start:' + cast(getdate() as char(25))" & vbCrLf
SQL = SQL & "print 'Count :' + Convert(varchar(10), @cnt)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "UPDATE #tempMOPartsDetail SET INMORUN = @MORun, LOTNUMBER = b.INLOTNUMBER," & vbCrLf
SQL = SQL & "LOTSPLITFROMSYS = c.LOTSPLITFROMSYS" & vbCrLf
SQL = SQL & "FROM dbo.LohdTable AS c INNER JOIN" & vbCrLf
SQL = SQL & "dbo.InvaTable AS b ON c.LOTNUMBER = b.INLOTNUMBER AND c.LOTPARTREF = b.INPART LEFT OUTER JOIN" & vbCrLf
SQL = SQL & "dbo.#tempMOPartsDetail AS d ON b.INMOPART = d.INMOPART AND b.INPART = d.INPART" & vbCrLf
SQL = SQL & "WHERE     (b.INMOPART = @MOPart) AND (b.INMORUN = @MORun) AND (b.INTYPE = 10) AND (d.SORTKEYLEVEL = 0)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "UPDATE #tempMOPartsDetail SET PICKQTY = sumqty * -1" & vbCrLf
SQL = SQL & "FROM #tempMOPartsDetail," & vbCrLf
SQL = SQL & "(SELECT SUM(b.INAQTY) sumqty, d.INMOPART mopart, d.INMORUN morun, d.LOTNUMBER lotnum, d.INPART subpart" & vbCrLf
SQL = SQL & "FROM dbo.LohdTable AS c INNER JOIN" & vbCrLf
SQL = SQL & "dbo.InvaTable AS b ON c.LOTNUMBER = b.INLOTNUMBER AND c.LOTPARTREF = b.INPART LEFT OUTER JOIN" & vbCrLf
SQL = SQL & "dbo.#tempMOPartsDetail AS d ON b.INMOPART = d.INMOPART AND b.INPART = d.INPART" & vbCrLf
SQL = SQL & "WHERE     b.INMOPART = @MOPart AND b.INMORUN  = @MORun AND (b.INTYPE = 10) AND (d.SORTKEYLEVEL = 0)" & vbCrLf
SQL = SQL & "GROUP BY d.INMOPART, d.INMORUN, d.LOTNUMBER, d.INPART" & vbCrLf
SQL = SQL & ") as f" & vbCrLf
SQL = SQL & "WHERE INMOPART = f.mopart AND INMORUN = f.morun" & vbCrLf
SQL = SQL & "AND LOTNUMBER = lotnum AND INPART = subpart" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "--// Update the" & vbCrLf
SQL = SQL & "--// update the top level" & vbCrLf
SQL = SQL & "UPDATE #tempMOPartsDetail SET INMORUN = @MORun, LOTNUMBER = b.INLOTNUMBER," & vbCrLf
SQL = SQL & "LOTUSERLOTID = c.LOTUSERLOTID," & vbCrLf
SQL = SQL & "INTOTMATL = b.INTOTMATL, INTOTLABOR = b.INTOTLABOR," & vbCrLf
SQL = SQL & "INTOTEXP = b.INTOTEXP, INTOTOH = b.INTOTOH," & vbCrLf
SQL = SQL & "LOTTOTMATL = (c.LOTTOTMATL * PICKQTY) / c.LOTORIGINALQTY," & vbCrLf
SQL = SQL & "LOTTOTLABOR = (c.LOTTOTLABOR * PICKQTY) / c.LOTORIGINALQTY," & vbCrLf
SQL = SQL & "LOTTOTEXP = (c.LOTTOTEXP * PICKQTY) / c.LOTORIGINALQTY," & vbCrLf
SQL = SQL & "LOTTOTOH = (c.LOTTOTOH * PICKQTY) / c.LOTORIGINALQTY," & vbCrLf
SQL = SQL & "LOTDATECOSTED = c.LOTDATECOSTED, LOTORGQTY = c.LOTORIGINALQTY," & vbCrLf
SQL = SQL & "BMTOTOH = (c.LOTTOTOH * PICKQTY) / c.LOTORIGINALQTY," & vbCrLf
SQL = SQL & "LOTSPLITFROMSYS = c.LOTSPLITFROMSYS" & vbCrLf
SQL = SQL & "FROM dbo.LohdTable AS c INNER JOIN" & vbCrLf
SQL = SQL & "dbo.InvaTable AS b ON c.LOTNUMBER = b.INLOTNUMBER AND c.LOTPARTREF = b.INPART LEFT OUTER JOIN" & vbCrLf
SQL = SQL & "dbo.#tempMOPartsDetail AS d ON b.INMOPART = d.INMOPART AND b.INPART = d.INPART" & vbCrLf
SQL = SQL & "WHERE     (b.INMOPART = @MOPart) AND (b.INMORUN = @MORun) AND (b.INTYPE = 10) AND (d.SORTKEYLEVEL = 0)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "print 'Update 2:' + cast(getdate() as char(25))" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "--FROM #tempMOPartsDetail d, InvaTable b, LohdTable c" & vbCrLf
SQL = SQL & "--WHERE d.INMOPART = b.INMOPART AND d.INPART = b.INPART" & vbCrLf
SQL = SQL & "-- AND b.INLOTNUMBER = c.LOTnumber" & vbCrLf
SQL = SQL & "-- and c.lotpartref = b.INPART" & vbCrLf
SQL = SQL & "-- and b.INMOPART = @MOPart AND b.INMORUN  = @MORun" & vbCrLf
SQL = SQL & "-- AND b.INTYPE = 10 AND SORTKEYLEVEL = 0" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "--// set the totals for" & vbCrLf
SQL = SQL & "SELECT @Maxlevel =  MAX(SORTKEYLEVEL) FROM #tempMOPartsDetail" & vbCrLf
SQL = SQL & "SET @level  = 1" & vbCrLf
SQL = SQL & "WHILE (@level <= @Maxlevel )" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "DECLARE curMORun CURSOR  FOR" & vbCrLf
SQL = SQL & "SELECT DISTINCT INMOPART,INPART" & vbCrLf
SQL = SQL & "FROM #tempMOPartsDetail WHERE SORTKEYLEVEL = @level" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "OPEN curMORun" & vbCrLf
SQL = SQL & "FETCH NEXT FROM curMORun INTO @MOPart, @Part" & vbCrLf
SQL = SQL & "WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "IF (@@FETCH_STATUS <> -2)" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "SELECT @ParentLotNum = LOTNUMBER FROM #tempMOPartsDetail WHERE" & vbCrLf
SQL = SQL & "INPART = @MOPart AND SORTKEYLEVEL = @level - 1" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "SELECT @LotRunNo = LOTMORUNNO, @LotOrgQty = LOTORIGINALQTY" & vbCrLf
SQL = SQL & "FROM lohdTable where LOTNUMBER = @ParentLotNum" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "UPDATE #tempMOPartsDetail SET INMORUN = @LotRunNo, LOTNUMBER = b.INLOTNUMBER," & vbCrLf
SQL = SQL & "LOTSPLITFROMSYS = c.LOTSPLITFROMSYS" & vbCrLf
SQL = SQL & "FROM #tempMOPartsDetail d, InvaTable b, LohdTable c" & vbCrLf
SQL = SQL & "WHERE d.INMOPART = b.INMOPART AND d.INPART = b.INPART" & vbCrLf
SQL = SQL & "AND b.INLOTNUMBER = c.LOTnumber" & vbCrLf
SQL = SQL & "and c.lotpartref = b.INPART" & vbCrLf
SQL = SQL & "and b.INMOPART = @MOPart AND b.INMORUN  = @LotRunNo" & vbCrLf
SQL = SQL & "AND b.INTYPE = 10 AND SORTKEYLEVEL = @level" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "UPDATE #tempMOPartsDetail SET PICKQTY = sumqty * -1" & vbCrLf
SQL = SQL & "FROM" & vbCrLf
SQL = SQL & "(SELECT SUM(b.INAQTY) sumqty, d.INMOPART mopart, d.INMORUN morun, d.LOTNUMBER lotnum, d.INPART subpart" & vbCrLf
SQL = SQL & "FROM dbo.LohdTable AS c INNER JOIN" & vbCrLf
SQL = SQL & "dbo.InvaTable AS b ON c.LOTNUMBER = b.INLOTNUMBER AND c.LOTPARTREF = b.INPART LEFT OUTER JOIN" & vbCrLf
SQL = SQL & "dbo.#tempMOPartsDetail AS d ON b.INMOPART = d.INMOPART AND b.INPART = d.INPART" & vbCrLf
SQL = SQL & "WHERE     b.INMOPART = @MOPart AND b.INMORUN  = @LotRunNo AND (b.INTYPE = 10) AND (d.SORTKEYLEVEL = @level)" & vbCrLf
SQL = SQL & "GROUP BY d.INMOPART, d.INMORUN, d.LOTNUMBER, d.INPART" & vbCrLf
SQL = SQL & ") as f" & vbCrLf
SQL = SQL & "WHERE INMOPART = mopart AND INMORUN = morun" & vbCrLf
SQL = SQL & "AND LOTNUMBER = lotnum AND INPART = subpart" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "--// update the top level" & vbCrLf
SQL = SQL & "UPDATE #tempMOPartsDetail SET INMORUN = @LotRunNo, LOTNUMBER = b.INLOTNUMBER," & vbCrLf
SQL = SQL & "LOTUSERLOTID = c.LOTUSERLOTID," & vbCrLf
SQL = SQL & "INTOTMATL = b.INTOTMATL, INTOTLABOR = b.INTOTLABOR," & vbCrLf
SQL = SQL & "INTOTEXP = b.INTOTEXP, INTOTOH = b.INTOTOH," & vbCrLf
SQL = SQL & "LOTTOTMATL = (c.LOTTOTMATL * PICKQTY) / c.LOTORIGINALQTY," & vbCrLf
SQL = SQL & "LOTTOTLABOR = (c.LOTTOTLABOR * PICKQTY) / c.LOTORIGINALQTY," & vbCrLf
SQL = SQL & "LOTTOTEXP = (c.LOTTOTEXP * PICKQTY) / c.LOTORIGINALQTY," & vbCrLf
SQL = SQL & "LOTTOTOH = (c.LOTTOTOH * PICKQTY) / c.LOTORIGINALQTY," & vbCrLf
SQL = SQL & "LOTDATECOSTED = c.LOTDATECOSTED, LOTORGQTY = @LotOrgQty," & vbCrLf
SQL = SQL & "BMTOTOH = (c.LOTTOTOH * PICKQTY) / @LotOrgQty," & vbCrLf
SQL = SQL & "LOTSPLITFROMSYS = c.LOTSPLITFROMSYS" & vbCrLf
SQL = SQL & "FROM #tempMOPartsDetail d, InvaTable b, LohdTable c" & vbCrLf
SQL = SQL & "WHERE d.INMOPART = b.INMOPART AND d.INPART = b.INPART" & vbCrLf
SQL = SQL & "AND b.INLOTNUMBER = c.LOTnumber" & vbCrLf
SQL = SQL & "and c.lotpartref = b.INPART" & vbCrLf
SQL = SQL & "and b.INMOPART = @MOPart AND b.INMORUN  = @LotRunNo" & vbCrLf
SQL = SQL & "AND b.INTYPE = 10 AND SORTKEYLEVEL = @level" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "End" & vbCrLf
SQL = SQL & "FETCH NEXT FROM curMORun INTO @MOPart, @Part" & vbCrLf
SQL = SQL & "End" & vbCrLf
SQL = SQL & "Close curMORun" & vbCrLf
SQL = SQL & "DEALLOCATE curMORun" & vbCrLf
SQL = SQL & "SET @level = @level + 1" & vbCrLf
SQL = SQL & "End" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "print 'Update 2:'+ cast(getdate() as char(25))" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "DECLARE curMOSplit CURSOR  FOR" & vbCrLf
SQL = SQL & "SELECT DISTINCT LOTNUMBER, LOTSPLITFROMSYS, LOTTOTMATL--, LOTTOTLABOR, LOTTOTEXP, LOTTOTOH" & vbCrLf
SQL = SQL & "FROM #tempMOPartsDetail WHERE LOTSPLITFROMSYS <> ''" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "OPEN curMOSplit" & vbCrLf
SQL = SQL & "FETCH NEXT FROM curMOSplit INTO @MOLotNum, @SplitLot, @LotMatl" & vbCrLf
SQL = SQL & "WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "IF (@@FETCH_STATUS <> -2)" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "print 'LotSplit LotNum:' + @SplitLot" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "IF @LotMatl = 0" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "SELECT @LotUSpMat = (LOTTOTMATL / LOTORIGINALQTY)," & vbCrLf
SQL = SQL & "@LotUSpLabor = (LOTTOTLABOR / LOTORIGINALQTY)," & vbCrLf
SQL = SQL & "@LotUSpExp = (LOTTOTEXP / LOTORIGINALQTY)," & vbCrLf
SQL = SQL & "@LotUSpOH = (LOTTOTOH / LOTORIGINALQTY)" & vbCrLf
SQL = SQL & "FROM Lohdtable WHERE LOTNUMBER = @SplitLot" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "UPDATE #tempMOPartsDetail SET LOTTOTMATL = (@LotUSpMat * PICKQTY)," & vbCrLf
SQL = SQL & "LOTTOTLABOR = (@LotUSpLabor * PICKQTY)," & vbCrLf
SQL = SQL & "LOTTOTEXP = (@LotUSpExp * PICKQTY)," & vbCrLf
SQL = SQL & "LOTTOTOH = (@LotUSpOH * PICKQTY)" & vbCrLf
SQL = SQL & "WHERE LOTNUMBER = @MOLotNum AND LOTSPLITFROMSYS = @SplitLot" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "END" & vbCrLf
SQL = SQL & "End" & vbCrLf
SQL = SQL & "FETCH NEXT FROM curMOSplit INTO @MOLotNum, @SplitLot, @LotMatl" & vbCrLf
SQL = SQL & "End" & vbCrLf
SQL = SQL & "Close curMOSplit" & vbCrLf
SQL = SQL & "DEALLOCATE curMOSplit" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "SELECT @level =  MAX(SORTKEYLEVEL) FROM #tempMOPartsDetail" & vbCrLf
SQL = SQL & "WHILE (@level >= 0 )" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "DECLARE curMODet CURSOR  FOR" & vbCrLf
SQL = SQL & "--SELECT INPART, LOTTOTMATL, LOTTOTLABOR, LOTTOTEXP , LOTTOTOH FROM #tempMOPartsDetail" & vbCrLf
SQL = SQL & "-- WHERE INPART = '775345149'" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "SELECT INMOPART," & vbCrLf
SQL = SQL & "SUM(IsNull(LOTTOTMATL, 0)), SUM(ISNULL(LOTTOTLABOR,0)) ," & vbCrLf
SQL = SQL & "Sum (IsNull(LOTTOTEXP, 0)) , SUM(IsNull(BMTOTOH, 0))" & vbCrLf
SQL = SQL & "From" & vbCrLf
SQL = SQL & "(SELECT DISTINCT INMOPART,INMORUN,INPART,LOTTOTMATL,LOTTOTLABOR," & vbCrLf
SQL = SQL & "LOTTOTEXP,LOTTOTOH,SUMTOTMAL,SUMTOTLABOR, SUMTOTEXP, SUMTOTOH,BMTOTOH" & vbCrLf
SQL = SQL & "FROM #tempMOPartsDetail WHERE SORTKEYLEVEL = @level) as foo" & vbCrLf
SQL = SQL & "group by INMOPART" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "OPEN curMODet" & vbCrLf
SQL = SQL & "FETCH NEXT FROM curMODet INTO @MOPart, @SumTotMat, @SumTotLabor,@SumTotExp,@SumTotOH" & vbCrLf
SQL = SQL & "WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "IF (@@FETCH_STATUS <> -2)" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "print 'PartNum : ' + @MOPart" & vbCrLf
SQL = SQL & "print 'SumTotoh : ' + Convert(varchar(24), @SumTotOH)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "UPDATE #tempMOPartsDetail SET SUMTOTMAL = LOTTOTMATL + @SumTotMat," & vbCrLf
SQL = SQL & "SUMTOTLABOR = LOTTOTLABOR + @SumTotLabor," & vbCrLf
SQL = SQL & "SUMTOTEXP = LOTTOTEXP + @SumTotExp, SUMTOTOH = (BMTOTOH + @SumTotOH) * @MOQty ," & vbCrLf
SQL = SQL & "HASCHILD = 1,PARTSUM = 'TOTAL ' + LTRIM(INPART)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "WHERE INPART = @MOPart AND SORTKEYLEVEL = @level - 1" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "End" & vbCrLf
SQL = SQL & "FETCH NEXT FROM curMODet INTO @MOPart, @SumTotMat, @SumTotLabor,@SumTotExp,@SumTotOH" & vbCrLf
SQL = SQL & "End" & vbCrLf
SQL = SQL & "Close curMODet" & vbCrLf
SQL = SQL & "DEALLOCATE curMODet" & vbCrLf
SQL = SQL & "SET @level = @level - 1" & vbCrLf
SQL = SQL & "End" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "--// update the Lower level cost detail" & vbCrLf
SQL = SQL & "UPDATE #tempMOPartsDetail SET SUMTOTMAL = LOTTOTMATL, SUMTOTLABOR = LOTTOTLABOR," & vbCrLf
SQL = SQL & "SUMTOTEXP = LOTTOTEXP, SUMTOTOH = BMTOTOH WHERE HASCHILD IS NULL" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "SET @SumTotMat  = 0" & vbCrLf
SQL = SQL & "SET @SumTotLabor  = 0" & vbCrLf
SQL = SQL & "SET @SumTotExp  = 0" & vbCrLf
SQL = SQL & "SET @SumTotOH  = 0" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "--// Udpate the Root total" & vbCrLf
SQL = SQL & "SELECT @SumTotMat = SUM(SUMTOTMAL), @SumTotLabor = SUM(SUMTOTLABOR)," & vbCrLf
SQL = SQL & "@SumTotExp = SUM(SUMTOTEXP) ,@SumTotOH = SUM(SUMTOTOH)" & vbCrLf
SQL = SQL & "FROM #tempMOPartsDetail WHERE SORTKEYLEVEL = 0" & vbCrLf
SQL = SQL & "AND  RTRIM(INMOPART) <> RTRIM(INPART)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "UPDATE #tempMOPartsDetail SET PARTSUM = INPART" & vbCrLf
SQL = SQL & "WHERE PARTSUM IS NULL" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "----  SELECT * FROM #tempMOPartsDetail WHERE SORTKEYLEVEL = 0" & vbCrLf
SQL = SQL & "----AND  RTRIM(INMOPART) = RTRIM(INPART)" & vbCrLf
SQL = SQL & "--// Reverse the partnumbers." & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "set @level = 0" & vbCrLf
SQL = SQL & "SET @RowCount = 1" & vbCrLf
SQL = SQL & "SET @PrevParent = ''" & vbCrLf
SQL = SQL & "DECLARE curAcctStruc CURSOR  FOR" & vbCrLf
SQL = SQL & "SELECT INMOPART, SortKey" & vbCrLf
SQL = SQL & "FROM #tempMOPartsDetail" & vbCrLf
SQL = SQL & "WHERE HASCHILD IS NULL --GLFSLEVEL = 8 --AND GLMASTER ='AA10'--GLTOPMaster = 1 AND" & vbCrLf
SQL = SQL & "ORDER BY SortKey" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "OPEN curAcctStruc" & vbCrLf
SQL = SQL & "FETCH NEXT FROM curAcctStruc INTO @ParentPart, @SortKey" & vbCrLf
SQL = SQL & "WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "IF (@@FETCH_STATUS <> -2)" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "if (@PrevParent <> @ParentPart)" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "UPDATE #tempMOPartsDetail SET" & vbCrLf
SQL = SQL & "SortKeyRev = RIGHT ('0000'+ Cast(@RowCount as varchar), 4) + char(36)+ @ParentPart" & vbCrLf
SQL = SQL & "WHERE INMOPART = @ParentPart AND HASCHILD IS NULL --GLFSLEVEL = 8 --AND GLTOPMaster = 1" & vbCrLf
SQL = SQL & "SET @RowCount = @RowCount + 1" & vbCrLf
SQL = SQL & "SET @PrevParent = @ParentPart" & vbCrLf
SQL = SQL & "END" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "End" & vbCrLf
SQL = SQL & "FETCH NEXT FROM curAcctStruc INTO @ParentPart, @SortKey" & vbCrLf
SQL = SQL & "End" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "Close curAcctStruc" & vbCrLf
SQL = SQL & "DEALLOCATE curAcctStruc" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "UPDATE #tempMOPartsDetail SET LOTMOPARTRUNKEY = @MOPartRunKey" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "INSERT INTO EsMOPartsCostDetail (LOTMOPARTRUNKEY, INMOPART,INMORUN,INPART,PARTSUM,LOTNUMBER,LOTUSERLOTID," & vbCrLf
SQL = SQL & "LOTTOTMATL,SUMTOTMAL, LOTTOTLABOR,SUMTOTLABOR, LOTTOTEXP, SUMTOTEXP, LOTTOTOH,SUMTOTOH,BMTOTOH," & vbCrLf
SQL = SQL & "LOTDATECOSTED, BMQTYREQD, LOTORGQTY, SORTKEYLEVEL,SortKey,SortKeyRev,HASCHILD, PICKQTY)" & vbCrLf
SQL = SQL & "SELECT LOTMOPARTRUNKEY,INMOPART,INMORUN,INPART,PARTSUM,LOTNUMBER,LOTUSERLOTID," & vbCrLf
SQL = SQL & "LOTTOTMATL,SUMTOTMAL, LOTTOTLABOR,SUMTOTLABOR, LOTTOTEXP, SUMTOTEXP, LOTTOTOH,SUMTOTOH,BMTOTOH," & vbCrLf
SQL = SQL & "LOTDATECOSTED, BMQTYREQD, LOTORGQTY, SORTKEYLEVEL,SortKey,SortKeyRev,HASCHILD, PICKQTY" & vbCrLf
SQL = SQL & "FROM #tempMOPartsDetail--WHERE SORTKEYLEVEL = 1" & vbCrLf
SQL = SQL & "order by SortKey--SortKeyRev" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "DROP table #tempMOPartsDetail" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "END" & vbCrLf
ExecuteScript False, SQL

SQL = "create procedure DropFunctionIfExists" & vbCrLf
SQL = SQL & "@Function_Name varchar(50)" & vbCrLf
SQL = SQL & "as" & vbCrLf
SQL = SQL & "/* drop a function if it exists" & vbCrLf
SQL = SQL & "test:" & vbCrLf
SQL = SQL & "DropFunctionIfExists 'WCHoursBeforeTime'" & vbCrLf
SQL = SQL & "*/" & vbCrLf
SQL = SQL & "begin" & vbCrLf
SQL = SQL & "IF EXISTS (" & vbCrLf
SQL = SQL & "SELECT * FROM sysobjects WHERE id = object_id(@Function_Name)" & vbCrLf
SQL = SQL & "AND xtype IN (N'FN', N'IF', N'TF')" & vbCrLf
SQL = SQL & ")" & vbCrLf
SQL = SQL & "begin" & vbCrLf
SQL = SQL & "declare @sql varchar(100)" & vbCrLf
SQL = SQL & "set @sql = 'DROP FUNCTION ' + @Function_Name" & vbCrLf
SQL = SQL & "execute(@sql)" & vbCrLf
SQL = SQL & "end" & vbCrLf
SQL = SQL & "end" & vbCrLf
SQL = SQL & "" & vbCrLf
ExecuteScript False, SQL

SQL = "DropFunctionIfExists 'WCHoursBeforeTime'" & vbCrLf
ExecuteScript False, SQL

SQL = "create function dbo.WCHoursBeforeTime" & vbCrLf
SQL = SQL & "(" & vbCrLf
SQL = SQL & "@shop varchar(12)," & vbCrLf
SQL = SQL & "@wc varchar(12)," & vbCrLf
SQL = SQL & "@cutoffDateTime datetime" & vbCrLf
SQL = SQL & ")" & vbCrLf
SQL = SQL & "returns decimal(9,2)" & vbCrLf
SQL = SQL & "as" & vbCrLf
SQL = SQL & "/*" & vbCrLf
SQL = SQL & "get remaining WC hours for day < the start time of the next operation in MO op scheduling" & vbCrLf
SQL = SQL & "Author: Terry Lindeman" & vbCrLf
SQL = SQL & "test" & vbCrLf
SQL = SQL & "select dbo.WCHoursBeforeTime( 'ST','CPSH','10/27/2017 2:00 PM' )" & vbCrLf
SQL = SQL & "*/" & vbCrLf
SQL = SQL & "begin" & vbCrLf
SQL = SQL & "-- if no hours in calendar, return" & vbCrLf
SQL = SQL & "declare @date datetime, @fullWcHours decimal(9,4), @hours decimal(9,4)" & vbCrLf
SQL = SQL & "declare @Hours1 decimal(9,4),@Hours2 decimal(9,4),@Hours3 decimal(9,4),@Hours4 decimal(9,4)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "set @date = cast(CONVERT(varchar(10),@cutoffDateTime,101) as datetime) -- remove time portion" & vbCrLf
SQL = SQL & "select @Hours1 = isnull(sum(WCCSHH1),0)," & vbCrLf
SQL = SQL & "@Hours2 = isnull(sum(WCCSHH2),0)," & vbCrLf
SQL = SQL & "@Hours3 = isnull(sum(WCCSHH3),0)," & vbCrLf
SQL = SQL & "@Hours4 = isnull(sum(WCCSHH4),0)" & vbCrLf
SQL = SQL & "from WcclTable" & vbCrLf
SQL = SQL & "where WCCDATE = @date and WCCSHOP = @shop and WCCCENTER = @wc" & vbCrLf
SQL = SQL & "set @hours = @Hours1 + @Hours2 + @Hours3 + @Hours4" & vbCrLf
SQL = SQL & "if @hours = 0" & vbCrLf
SQL = SQL & "begin" & vbCrLf
SQL = SQL & "return @hours" & vbCrLf
SQL = SQL & "end" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "declare @day varchar(3)" & vbCrLf
SQL = SQL & "set @day = UPPER(DATENAME(weekday,@cutoffDateTime))" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- get shift start times" & vbCrLf
SQL = SQL & "declare @Start1 varchar(6),@Start2 varchar(6),@Start3 varchar(6),@Start4 varchar(6)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "if @day = 'SUN'" & vbCrLf
SQL = SQL & "select @Start1 = WCNSUNSH1, @Start2 = WCNSUNSH2, @Start3 = WCNSUNSH3, @Start4 = WCNSUNSH4" & vbCrLf
SQL = SQL & "from WcntTable  where WCNSHOP = @shop and WCNREF = @wc" & vbCrLf
SQL = SQL & "else if @day = 'MON'" & vbCrLf
SQL = SQL & "select @Start1 = WCNMONSH1, @Start2 = WCNMONSH2, @Start3 = WCNMONSH3, @Start4 = WCNMONSH4" & vbCrLf
SQL = SQL & "from WcntTable  where WCNSHOP = @shop and WCNREF = @wc" & vbCrLf
SQL = SQL & "else if @day = 'TUE'" & vbCrLf
SQL = SQL & "select @Start1 = WCNTUESH1, @Start2 = WCNTUESH2, @Start3 = WCNTUESH3, @Start4 = WCNTUESH4" & vbCrLf
SQL = SQL & "from WcntTable  where WCNSHOP = @shop and WCNREF = @wc" & vbCrLf
SQL = SQL & "else if @day = 'WED'" & vbCrLf
SQL = SQL & "select @Start1 = WCNWEDSH1, @Start2 = WCNWEDSH2, @Start3 = WCNWEDSH3, @Start4 = WCNWEDSH4" & vbCrLf
SQL = SQL & "from WcntTable  where WCNSHOP = @shop and WCNREF = @wc" & vbCrLf
SQL = SQL & "else if @day = 'THU'" & vbCrLf
SQL = SQL & "select @Start1 = WCNTHUSH1, @Start2 = WCNTHUSH2, @Start3 = WCNTHUSH3, @Start4 = WCNTHUSH4" & vbCrLf
SQL = SQL & "from WcntTable  where WCNSHOP = @shop and WCNREF = @wc" & vbCrLf
SQL = SQL & "else if @day = 'FRI'" & vbCrLf
SQL = SQL & "select @Start1 = WCNFRISH1, @Start2 = WCNFRISH2, @Start3 = WCNFRISH3, @Start4 = WCNFRISH4" & vbCrLf
SQL = SQL & "from WcntTable  where WCNSHOP = @shop and WCNREF = @wc" & vbCrLf
SQL = SQL & "else" & vbCrLf
SQL = SQL & "select @Start1 = WCNSATSH1, @Start2 = WCNSATSH2, @Start3 = WCNSATSH3, @Start4 = WCNSATSH4" & vbCrLf
SQL = SQL & "from WcntTable  where WCNSHOP = @shop and WCNREF = @wc" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "declare @temp table" & vbCrLf
SQL = SQL & "(" & vbCrLf
SQL = SQL & "ShiftNo int," & vbCrLf
SQL = SQL & "ShiftHours decimal(9,4)," & vbCrLf
SQL = SQL & "ShiftStart varchar(6)," & vbCrLf
SQL = SQL & "StartTime datetime," & vbCrLf
SQL = SQL & "MinutesBeforeCutoff decimal(9,4)" & vbCrLf
SQL = SQL & ")" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "insert @temp (ShiftNo, ShiftHours, ShiftStart) values ( 1, @Hours1, @Start1 )" & vbCrLf
SQL = SQL & "insert @temp (ShiftNo, ShiftHours, ShiftStart) values ( 1, @Hours2, @Start2 )" & vbCrLf
SQL = SQL & "insert @temp (ShiftNo, ShiftHours, ShiftStart) values ( 1, @Hours3, @Start3 )" & vbCrLf
SQL = SQL & "insert @temp (ShiftNo, ShiftHours, ShiftStart) values ( 1, @Hours4, @Start4 )" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "update @temp set ShiftStart = rtrim(ShiftStart)" & vbCrLf
SQL = SQL & "delete from @temp where ShiftHours = 0 or ShiftStart = ''" & vbCrLf
SQL = SQL & "update @temp set StartTime = cast(CONVERT(varchar(10), @date, 101) + ' ' + ShiftStart + 'm' as datetime)" & vbCrLf
SQL = SQL & "update @temp set MinutesBeforeCutoff = DATEDIFF(minute, StartTime, @cutoffDateTime)" & vbCrLf
SQL = SQL & "delete from @temp where MinutesBeforeCutoff < 0" & vbCrLf
SQL = SQL & "update @temp set MinutesBeforeCutoff = 60 * ShiftHours where MinutesBeforeCutoff > 60 * ShiftHours" & vbCrLf
SQL = SQL & "select @hours = isnull(sum(MinutesBeforeCutoff),0) / 60. from @temp" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "return @hours" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "end" & vbCrLf
ExecuteScript False, SQL




''''''''''''''''''''''''''''''''''''''''''''''''''

        ' update the version
        ExecuteScript False, "Update Version Set Version = " & newver

    End If
End Function

Private Function UpdateDatabase96()

'update database version template
'set version at top of this file
'set version below
'add SQL updates


   Dim SQL As String
   SQL = ""

   newver = 171
   If ver < newver Then

        clsADOCon.ADOErrNum = 0

''''''''''''''''''''''''''''''''''''''''''''''''''

SQL = "DropFunctionIfExists 'WCHoursBeforeTime'" & vbCrLf
ExecuteScript False, SQL

SQL = "create function dbo.WCHoursBeforeTime" & vbCrLf
SQL = SQL & "(" & vbCrLf
SQL = SQL & "@shop varchar(12)," & vbCrLf
SQL = SQL & "@wc varchar(12)," & vbCrLf
SQL = SQL & "@cutoffDateTime datetime" & vbCrLf
SQL = SQL & ")" & vbCrLf
SQL = SQL & "returns decimal(9,2)" & vbCrLf
SQL = SQL & "as" & vbCrLf
SQL = SQL & "/*" & vbCrLf
SQL = SQL & "get remaining WC hours for day < the start time of the next operation in MO op scheduling" & vbCrLf
SQL = SQL & "Author: Terry Lindeman" & vbCrLf
SQL = SQL & "test" & vbCrLf
SQL = SQL & "select dbo.WCHoursBeforeTime( 'ST','CPSH','10/27/2017 2:00 PM' ) -- LAFEGG" & vbCrLf
SQL = SQL & "*/" & vbCrLf
SQL = SQL & "begin" & vbCrLf
SQL = SQL & "-- if no hours in calendar, return" & vbCrLf
SQL = SQL & "declare @date datetime, @fullWcHours decimal(9,4), @hours decimal(9,4)" & vbCrLf
SQL = SQL & "declare @Hours1 decimal(9,4),@Hours2 decimal(9,4),@Hours3 decimal(9,4),@Hours4 decimal(9,4)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "set @date = cast(CONVERT(varchar(10),@cutoffDateTime,101) as datetime) -- remove time portion" & vbCrLf
SQL = SQL & "select @Hours1 = isnull(sum(WCCSHH1),0)," & vbCrLf
SQL = SQL & "@Hours2 = isnull(sum(WCCSHH2),0)," & vbCrLf
SQL = SQL & "@Hours3 = isnull(sum(WCCSHH3),0)," & vbCrLf
SQL = SQL & "@Hours4 = isnull(sum(WCCSHH4),0)" & vbCrLf
SQL = SQL & "from WcclTable" & vbCrLf
SQL = SQL & "where WCCDATE = @date and WCCSHOP = @shop and WCCCENTER = @wc" & vbCrLf
SQL = SQL & "set @hours = @Hours1 + @Hours2 + @Hours3 + @Hours4" & vbCrLf
SQL = SQL & "if @hours = 0" & vbCrLf
SQL = SQL & "begin" & vbCrLf
SQL = SQL & "return @hours" & vbCrLf
SQL = SQL & "end" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "declare @day varchar(3)" & vbCrLf
SQL = SQL & "set @day = UPPER(DATENAME(weekday,@cutoffDateTime))" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- get shift start times" & vbCrLf
SQL = SQL & "declare @Start1 varchar(6),@Start2 varchar(6),@Start3 varchar(6),@Start4 varchar(6)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "if @day = 'SUN'" & vbCrLf
SQL = SQL & "select @Start1 = WCNSUNSH1, @Start2 = WCNSUNSH2, @Start3 = WCNSUNSH3, @Start4 = WCNSUNSH4" & vbCrLf
SQL = SQL & "from WcntTable  where WCNSHOP = @shop and WCNREF = @wc" & vbCrLf
SQL = SQL & "else if @day = 'MON'" & vbCrLf
SQL = SQL & "select @Start1 = WCNMONSH1, @Start2 = WCNMONSH2, @Start3 = WCNMONSH3, @Start4 = WCNMONSH4" & vbCrLf
SQL = SQL & "from WcntTable  where WCNSHOP = @shop and WCNREF = @wc" & vbCrLf
SQL = SQL & "else if @day = 'TUE'" & vbCrLf
SQL = SQL & "select @Start1 = WCNTUESH1, @Start2 = WCNTUESH2, @Start3 = WCNTUESH3, @Start4 = WCNTUESH4" & vbCrLf
SQL = SQL & "from WcntTable  where WCNSHOP = @shop and WCNREF = @wc" & vbCrLf
SQL = SQL & "else if @day = 'WED'" & vbCrLf
SQL = SQL & "select @Start1 = WCNWEDSH1, @Start2 = WCNWEDSH2, @Start3 = WCNWEDSH3, @Start4 = WCNWEDSH4" & vbCrLf
SQL = SQL & "from WcntTable  where WCNSHOP = @shop and WCNREF = @wc" & vbCrLf
SQL = SQL & "else if @day = 'THU'" & vbCrLf
SQL = SQL & "select @Start1 = WCNTHUSH1, @Start2 = WCNTHUSH2, @Start3 = WCNTHUSH3, @Start4 = WCNTHUSH4" & vbCrLf
SQL = SQL & "from WcntTable  where WCNSHOP = @shop and WCNREF = @wc" & vbCrLf
SQL = SQL & "else if @day = 'FRI'" & vbCrLf
SQL = SQL & "select @Start1 = WCNFRISH1, @Start2 = WCNFRISH2, @Start3 = WCNFRISH3, @Start4 = WCNFRISH4" & vbCrLf
SQL = SQL & "from WcntTable  where WCNSHOP = @shop and WCNREF = @wc" & vbCrLf
SQL = SQL & "else" & vbCrLf
SQL = SQL & "select @Start1 = WCNSATSH1, @Start2 = WCNSATSH2, @Start3 = WCNSATSH3, @Start4 = WCNSATSH4" & vbCrLf
SQL = SQL & "from WcntTable  where WCNSHOP = @shop and WCNREF = @wc" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "declare @temp table" & vbCrLf
SQL = SQL & "(" & vbCrLf
SQL = SQL & "ShiftNo int," & vbCrLf
SQL = SQL & "ShiftHours decimal(9,4)," & vbCrLf
SQL = SQL & "ShiftStart varchar(6)," & vbCrLf
SQL = SQL & "StartTime datetime," & vbCrLf
SQL = SQL & "MinutesBeforeCutoff decimal(9,4)" & vbCrLf
SQL = SQL & ")" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "insert @temp (ShiftNo, ShiftHours, ShiftStart) values ( 1, @Hours1, @Start1 )" & vbCrLf
SQL = SQL & "insert @temp (ShiftNo, ShiftHours, ShiftStart) values ( 1, @Hours2, @Start2 )" & vbCrLf
SQL = SQL & "insert @temp (ShiftNo, ShiftHours, ShiftStart) values ( 1, @Hours3, @Start3 )" & vbCrLf
SQL = SQL & "insert @temp (ShiftNo, ShiftHours, ShiftStart) values ( 1, @Hours4, @Start4 )" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "update @temp set ShiftStart = rtrim(ShiftStart)" & vbCrLf
SQL = SQL & "delete from @temp where ShiftHours = 0 or ShiftStart = ''" & vbCrLf
SQL = SQL & "update @temp set StartTime = cast(CONVERT(varchar(10), @date, 101) + ' ' + ShiftStart + 'm' as datetime)" & vbCrLf
SQL = SQL & "update @temp set MinutesBeforeCutoff = DATEDIFF(minute, StartTime, @cutoffDateTime)" & vbCrLf
SQL = SQL & "delete from @temp where MinutesBeforeCutoff < 0" & vbCrLf
SQL = SQL & "update @temp set MinutesBeforeCutoff = 60 * ShiftHours where MinutesBeforeCutoff > 60 * ShiftHours" & vbCrLf
SQL = SQL & "select @hours = isnull(sum(MinutesBeforeCutoff),0) / 60. from @temp" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "return @hours" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "end" & vbCrLf
SQL = SQL & "" & vbCrLf
ExecuteScript False, SQL


''''''''''''''''''''''''''''''''''''''''''''''''''

        ' update the version
        ExecuteScript False, "Update Version Set Version = " & newver

    End If
End Function

Private Function UpdateDatabase97()

'update database version template
'set version at top of this file
'set version below
'add SQL updates


   Dim SQL As String
   SQL = ""

   newver = 172     ' set actual version
   If ver < newver Then

      clsADOCon.ADOErrNum = 0

''''''''''''''''''''''''''''''''''''''''''''''''''

      SQL = "AddOrUpdateColumn 'SohdTable', 'SOITAREAR', 'bit null default 0'"
      ExecuteScript False, SQL
      
      SQL = "Update SohdTable set SOITAREAR = 0"
      ExecuteScript False, SQL
      
      SQL = "AddOrUpdateColumn 'SohdTable', 'SOITAREAR', 'bit not null'"
      ExecuteScript False, SQL
      
      SQL = "DropStoredProcedureIfExists 'AddEngrTimeCharge'" & vbCrLf
      ExecuteScript False, SQL

SQL = "create procedure AddEngrTimeCharge" & vbCrLf
SQL = SQL & "@EmpNo as int," & vbCrLf
SQL = SQL & "@Date as datetime," & vbCrLf
SQL = SQL & "@MoPartRef as varchar(30)," & vbCrLf
SQL = SQL & "@RunNo as int," & vbCrLf
SQL = SQL & "@OpNo as int," & vbCrLf
SQL = SQL & "@Hours as decimal(12,2)," & vbCrLf
SQL = SQL & "@Comment as varchar(1024)," & vbCrLf
SQL = SQL & "@journalId as varchar(12)" & vbCrLf
SQL = SQL & "as" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "/* add a time charge, creating a new time card if required" & vbCrLf
SQL = SQL & "9/15/17 TEL - created for CASGAS Engineering Time Charges" & vbCrLf
SQL = SQL & "*/" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- if time card does not exist for employee, add it" & vbCrLf
SQL = SQL & "declare @card char(11)" & vbCrLf
SQL = SQL & "select @card = TMCARD from TchdTable where TMEMP = @EmpNo and TMDAY = @date" & vbCrLf
SQL = SQL & "if @card is null" & vbCrLf
SQL = SQL & "begin" & vbCrLf
SQL = SQL & "declare @now as datetime, @nowDays int, @nowMs int, @today datetime, @time datetime" & vbCrLf
SQL = SQL & "set @now = getdate()" & vbCrLf
SQL = SQL & "set @today = cast(convert(varchar(10), @now,101) as datetime)" & vbCrLf
SQL = SQL & "set @time = cast(convert(varchar(50), @now, 114) as datetime)" & vbCrLf
SQL = SQL & "set @nowDays = DATEDIFF(DAY,'1/1/1900',@today)" & vbCrLf
SQL = SQL & "set @nowMs = 1000000.0 *cast(DATEDIFF(MILLISECOND,'1/1/1900',@time) as float)/(3600.0*24*1000)" & vbCrLf
SQL = SQL & "set @card = cast(@nowDays as varchar(5)) + cast(@nowMs as varchar(6))" & vbCrLf
SQL = SQL & "insert into TchdTable (TMCARD,TMEMP,TMDAY) values (@card, @EmpNo, @Date)" & vbCrLf
SQL = SQL & "end" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- calculate fields needed for time charge" & vbCrLf
SQL = SQL & "declare @startTime smalldatetime, @stopTime smalldatetime" & vbCrLf
SQL = SQL & "set @startTime = DATEADD(dd, DATEDIFF(dd, 0, @Date), 0)    -- truncate time portion" & vbCrLf
SQL = SQL & "set @stopTime = DATEADD(MINUTE, @Hours * 60, @startTime)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- construct hh:mma/p version of times" & vbCrLf
SQL = SQL & "declare @start varchar(6), @stop varchar(6)" & vbCrLf
SQL = SQL & "set @start = REPLACE(SUBSTRING(CONVERT(VARCHAR(20),@startTime,0),13,6),' ','0')" & vbCrLf
SQL = SQL & "set @stop = REPLACE(SUBSTRING(CONVERT(VARCHAR(20),@stopTime,0),13,6),' ','0')" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- calculate # minutes" & vbCrLf
SQL = SQL & "set @time = dateadd(minute,datediff(MINUTE,@startTime, @stopTime),'1/1/1900')" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- get regular timecode" & vbCrLf
SQL = SQL & "declare @timecode varchar(2)" & vbCrLf
SQL = SQL & "select @timecode = TYPECODE from TmcdTable where typetype = 'R'" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- get engineering rate" & vbCrLf
SQL = SQL & "declare @rate decimal(10,2)" & vbCrLf
SQL = SQL & "select @rate = EngineeringLaborRate from Preferences" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- get employee account number" & vbCrLf
SQL = SQL & "declare @acct varchar(12)" & vbCrLf
SQL = SQL & "select @acct = EmplTable.PREMACCTS from EmplTable where PREMNUMBER = @EmpNo" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- get shop and wc for operation" & vbCrLf
SQL = SQL & "declare @shop varchar(12), @wc varchar(12)" & vbCrLf
SQL = SQL & "select @shop = OPSHOP, @wc = OPCENTER" & vbCrLf
SQL = SQL & "from RnopTable where opref = @MoPartRef and oprun = @RunNo and OPNO = @OpNo" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- get journal id" & vbCrLf
SQL = SQL & "--declare @journalId varchar(12)" & vbCrLf
SQL = SQL & "--set @journalId = dbo.fnGetOpenJournalID('TJ', @Date)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- now insert the new time charge" & vbCrLf
SQL = SQL & "INSERT INTO TcitTable (TCCARD,TCEMP,TCSTART,TCSTOP,TCSTARTTIME,TCSTOPTIME," & vbCrLf
SQL = SQL & "TCHOURS,TCTIME,TCCODE,TCRATE,TCOHRATE,TCRATENO,TCACCT,TCACCOUNT," & vbCrLf
SQL = SQL & "TCSHOP,TCWC,TCPAYTYPE,TCSURUN,TCYIELD,TCPARTREF,TCRUNNO," & vbCrLf
SQL = SQL & "TCOPNO,TCSORT,TCOHFIXED,TCGLJOURNAL,TCGLREF,TCSOURCE," & vbCrLf
SQL = SQL & "TCMULTIJOB,TCACCEPT,TCREJECT,TCSCRAP,TCCOMMENTS)" & vbCrLf
SQL = SQL & "values( @card,@EmpNo, @start,@stop,@startTime, @stopTime," & vbCrLf
SQL = SQL & "@Hours,@time,@timecode,@rate,@rate,1,@acct,@acct," & vbCrLf
SQL = SQL & "@shop,@wc,0,'I',0,@MoPartRef,@RunNo," & vbCrLf
SQL = SQL & "@OpNo,0,0,@journalId,0,'Engr'," & vbCrLf
SQL = SQL & "0,0,0,0,@Comment)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- now roll up totals for this timecard" & vbCrLf
SQL = SQL & "EXECUTE UpdateTimeCardTotals @EmpNo, @Date" & vbCrLf
ExecuteScript False, SQL

      

''''''''''''''''''''''''''''''''''''''''''''''''''

      ' update the version
      ExecuteScript False, "Update Version Set Version = " & newver

   End If
End Function

Private Function UpdateDatabase98()

   Dim SQL As String
   SQL = ""

   newver = 173     ' set actual version
   If ver < newver Then

      clsADOCon.ADOErrNum = 0

''''''''''''''''''''''''''''''''''''''''''''''''''


' ANDELE PO HISTORY BY VENDOR - used by prdpr21.rpt, Purchasing History by Vendor to Date Costing

SQL = "dbo.DropStoredProcedureIfExists 'RptPoHistoryByVendor'" & vbCrLf
ExecuteScript False, SQL

SQL = "create procedure [dbo].[RptPoHistoryByVendor]" & vbCrLf
SQL = SQL & "(" & vbCrLf
SQL = SQL & "@StartDate varchar(16)," & vbCrLf
SQL = SQL & "@EndDate varchar(16)," & vbCrLf
SQL = SQL & "@Vendor varchar(10)," & vbCrLf
SQL = SQL & "@PartRef varchar(30)," & vbCrLf
SQL = SQL & "@PartClass varchar(4)," & vbCrLf
SQL = SQL & "@ProdCode varchar(6)," & vbCrLf
SQL = SQL & "@UsePoDate integer,       -- if 0, use projected date (PIPDATE), if 1, use PO date (PODATE)" & vbCrLf
SQL = SQL & "@IncludeOpen14 integer," & vbCrLf
SQL = SQL & "@IncludeReceived15 integer," & vbCrLf
SQL = SQL & "@IncludeCanceled16 integer," & vbCrLf
SQL = SQL & "@IncludeInvoiced17 integer" & vbCrLf
SQL = SQL & ")" & vbCrLf
SQL = SQL & "as" & vbCrLf
SQL = SQL & "/* created for ANDELE version of the report" & vbCrLf
SQL = SQL & "test:" & vbCrLf
SQL = SQL & "RptPoHistoryByVendor '9/1/2017','12/31/2017','','','','',1,1,1,1,1" & vbCrLf
SQL = SQL & "RptPoHistoryByVendor '9/1/2017','12/31/2017','','85','','',1,1,1,1,1" & vbCrLf
SQL = SQL & "RptPoHistoryByVendor '9/1/2017','12/4/2017','ACOPIAN','','','',1,1,1,1,1" & vbCrLf
SQL = SQL & "RptPoHistoryByVendor 'ALL','ALL','ACOPIAN','','','',1,1,1,1,1" & vbCrLf
SQL = SQL & "*/" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "declare @Start datetime" & vbCrLf
SQL = SQL & "declare @End datetime" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "if @StartDate = 'ALL' set @Start = '1/1/1900'" & vbCrLf
SQL = SQL & "else set  @Start = cast(@StartDate as datetime)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "if @EndDate = 'ALL' set @End = '12/31/2199'" & vbCrLf
SQL = SQL & "else set @End = cast(@EndDate as datetime)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "print @Start" & vbCrLf
SQL = SQL & "print @End" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "set @Vendor = rtrim(@Vendor)" & vbCrLf
SQL = SQL & "set @PartRef = rtrim(@PartRef)" & vbCrLf
SQL = SQL & "set @PartClass = rtrim(@PartClass)" & vbCrLf
SQL = SQL & "set @ProdCode = rtrim(@ProdCode)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "if @Vendor = 'ALL'set @Vendor = '%' else if len(@Vendor) < 10 set @Vendor = @Vendor + '%'" & vbCrLf
SQL = SQL & "if @PartRef = 'ALL' set @PartRef = '%' else if len(@PartRef) < 30 set @PartRef = @PartRef + '%'" & vbCrLf
SQL = SQL & "if @PartClass = 'ALL' set @PartClass = '%' else if len(@PartClass) < 4 set @PartClass = @PartClass + '%'" & vbCrLf
SQL = SQL & "if @ProdCode = 'ALL' set @ProdCode = '%' else if len(@ProdCode) < 6 set @ProdCode = @ProdCode + '%'" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "if @IncludeOpen14 = 1 set @IncludeOpen14 = 14 else set @IncludeOpen14 = 0" & vbCrLf
SQL = SQL & "if @IncludeReceived15 = 1 set @IncludeReceived15 = 15  else set @IncludeReceived15 = 0" & vbCrLf
SQL = SQL & "if @IncludeCanceled16 = 1 set @IncludeCanceled16 = 16  else set @IncludeCanceled16 = 0" & vbCrLf
SQL = SQL & "if @IncludeInvoiced17 = 1 set @IncludeInvoiced17 = 17  else set @IncludeInvoiced17 = 0" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "SELECT distinct ViitTable.VITCOST, InvaTable.INAMT, PoitTable.PIESTUNIT," & vbCrLf
SQL = SQL & "coalesce(ViitTable.VITCOST, InvaTable.INAMT, PoitTable.PIESTUNIT) as UnitCost," & vbCrLf
SQL = SQL & "rtrim(VEBCITY) + ', ' + RTRIM(VEBSTATE) + ' ' + RTRIM(VEBZIP) as Address," & vbCrLf
SQL = SQL & "PoitTable.PIPQTY, PohdTable.POVENDOR, PoitTable.PINUMBER, PoitTable.PIITEM, PoitTable.PIREV," & vbCrLf
SQL = SQL & "PartTable.PARTNUM, PoitTable.PITYPE, PartTable.PAUNITS, PohdTable.PODATE, PoitTable.PIPDATE," & vbCrLf
SQL = SQL & "VndrTable.VENUMBER, VndrTable.VENICKNAME, VndrTable.VEBPHONE, VndrTable.VEBNAME, PoitTable.PICOMT," & vbCrLf
SQL = SQL & "PartTable.PAEXTDESC, PartTable.PADESC, PoitTable.PIAMT, PohdTable.PONUMBER," & vbCrLf
SQL = SQL & "case when @UsePoDate = 1 then PohdTable.PODATE else PoitTable.PIPDATE end as TranDate," & vbCrLf
SQL = SQL & "case PITYPE when 14 then 'O' when 15 then 'R' when 16 then 'C' else 'I' end as tp" & vbCrLf
SQL = SQL & "FROM   ((PartTable PartTable" & vbCrLf
SQL = SQL & "INNER JOIN PoitTable PoitTable ON PartTable.PARTREF=PoitTable.PIPART)" & vbCrLf
SQL = SQL & "INNER JOIN PohdTable PohdTable ON PoitTable.PINUMBER=PohdTable.PONUMBER)" & vbCrLf
SQL = SQL & "INNER JOIN VndrTable VndrTable ON PohdTable.POVENDOR=VndrTable.VEREF" & vbCrLf
SQL = SQL & "LEFT JOIN InvaTable on InvaTable.INPONUMBER = PoitTable.PINUMBER and InvaTable.INPOITEM = PoitTable.PIITEM and InvaTable.INPOREV = PoitTable.PIREV" & vbCrLf
SQL = SQL & "LEFT JOIN ViitTable on ViitTable.VITPO = PoitTable.PINUMBER and ViitTable.VITPOITEM = PoitTable.PIITEM and ViitTable.VITPOITEMREV = PoitTable.PIREV" & vbCrLf
SQL = SQL & "where PIPDATE between @Start and @End" & vbCrLf
SQL = SQL & "and PITYPE in (@IncludeOpen14, @IncludeReceived15, @IncludeCanceled16, @IncludeInvoiced17)" & vbCrLf
SQL = SQL & "and VndrTable.VEREF like @Vendor and PartTable.PAPRODCODE like @ProdCode" & vbCrLf
SQL = SQL & "and PartTable.PACLASS like @PartClass" & vbCrLf
SQL = SQL & "and PARTREF like @PartRef" & vbCrLf
SQL = SQL & "ORDER BY PohdTable.POVENDOR, PONUMBER" & vbCrLf
ExecuteScript False, SQL

SQL = "DropStoredProcedureIfExists 'RptLaborEfficiency'" & vbCrLf
ExecuteScript False, SQL

SQL = "create procedure dbo.RptLaborEfficiency" & vbCrLf
SQL = SQL & "(" & vbCrLf
SQL = SQL & "@RunPart varchar(30)," & vbCrLf
SQL = SQL & "@RunNo int" & vbCrLf
SQL = SQL & ")" & vbCrLf
SQL = SQL & "/*" & vbCrLf
SQL = SQL & "Get Labor Efficiency Report Data for Crystal Report, EngRt08.rpt" & vbCrLf
SQL = SQL & "Created 1/5/2018 TEL" & vbCrLf
SQL = SQL & "test:" & vbCrLf
SQL = SQL & "exec RptLaborEfficiency '315W1582-1', 67" & vbCrLf
SQL = SQL & "*/" & vbCrLf
SQL = SQL & "as" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "declare @RunRef varchar(30)" & vbCrLf
SQL = SQL & "set @RunRef = dbo.fnCompress(@RunPart)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "select ISNULL(OPNO,TCOPNO) as OP, ISNULL(OPSHOP,TCSHOP) as Shop, ISNULL(OPCENTER,TCWC) as WC," & vbCrLf
SQL = SQL & "[Rtg SU], [Rtg Run], isnull([TC SU], 0.00) as [TC SU], isnull([TC Run],0.0) as [TC Run]," & vbCrLf
SQL = SQL & "isnull([Emp No],'') as [Emp No], isnull([Emp Name],'') as [Emp Name], isnull([Date],'') as [Date]," & vbCrLf
SQL = SQL & "RANK() OVER (PARTITION BY ISNULL(OPNO,TCOPNO) ORDER BY TCSTARTTIME) as Seq, 1 as [Group]" & vbCrLf
SQL = SQL & "from" & vbCrLf
SQL = SQL & "(select TCSHOP, TCWC, TCOPNO," & vbCrLf
SQL = SQL & "cast(TCEMP as varchar(8)) as [Emp No], CONVERT(varchar(10), TCSTARTTIME, 101) as [Date]," & vbCrLf
SQL = SQL & "case when TCSURUN = 'S' then cast(TCHOURS as decimal(12,2)) else 0.00 end as [TC SU]," & vbCrLf
SQL = SQL & "case when TCSURUN <> 'S' then cast(TCHOURS as decimal(12,2)) else 0.00 end as [TC Run]," & vbCrLf
SQL = SQL & "rtrim(PREMFSTNAME) + ' ' + rtrim(PREMLSTNAME) as [Emp Name], TCSTARTTIME" & vbCrLf
SQL = SQL & "from TcitTable" & vbCrLf
SQL = SQL & "join EmplTable on PREMNUMBER = TCEMP" & vbCrLf
SQL = SQL & "where TCPARTREF = @RunRef and TCRUNNO = @RunNo) tm" & vbCrLf
SQL = SQL & "full outer join (select OPSHOP, OPCENTER, OPNO, Cast(OPSETUP as decimal(12,2)) as [Rtg SU], OPUNIT, RUNQTY, cast(OPUNIT * RUNQTY as decimal(12,2)) as [Rtg Run]" & vbCrLf
SQL = SQL & "from RtopTable join RunsTable on OPREF = RUNREF and RUNNO = @RunNo where OPREF = @RunRef) op" & vbCrLf
SQL = SQL & "on tm.TCOPNO = op.OPNO" & vbCrLf
SQL = SQL & "order by ISNULL(OPNO,TCOPNO), [Date]" & vbCrLf
ExecuteScript False, SQL

' script to correctly associate sheet inventory lots and invatable rows
' in a prior update SQL2005 could not handle order by INNUMBER.  It was changed to order by ia.INNUMBER
' first update duplicate INNUMBERS resulting from errors in SheetPick and SheetRestock sp's
SQL = "if exists (select 1 from ComnTable where COUSESHEETINVENTORY = 1)" & vbCrLf
SQL = SQL & "begin" & vbCrLf
SQL = SQL & "begin tran" & vbCrLf
SQL = SQL & "declare @dups TABLE (INNUMBER int)" & vbCrLf
SQL = SQL & "insert @dups" & vbCrLf
SQL = SQL & "select innumber from invatable" & vbCrLf
SQL = SQL & "where INPART in (select partref from PartTable where PAPUNITS = 'SH')" & vbCrLf
SQL = SQL & "group by innumber having count(*) > 1" & vbCrLf
SQL = SQL & "declare @maxINNUMBER int" & vbCrLf
SQL = SQL & "select @maxINNUMBER = max(INNUMBER) FROM InvaTable" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "declare @dups2 table (INNUMBER int, Qty decimal(12,2), newINNUMBER int)" & vbCrLf
SQL = SQL & "insert @dups2" & vbCrLf
SQL = SQL & "select ia.INNUMBER, INAQTY, @maxINNUMBER + ROW_NUMBER() OVER (ORDER BY ia.INNUMBER, ia.INAQTY)" & vbCrLf
SQL = SQL & "from @dups join InvaTable ia on ia.INNUMBER = [@dups].INNUMBER" & vbCrLf
SQL = SQL & "where INAQTY <> (select min(INAQTY) from @dups join InvaTable ia2 on ia2.INNUMBER = [@dups].INNUMBER where ia2.INNUMBER = ia.INNUMBER)" & vbCrLf
SQL = SQL & "order by ia.INNUMBER, INAQTY" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "update ia" & vbCrLf
SQL = SQL & "set ia.INNUMBER = d.newINNUMBER" & vbCrLf
SQL = SQL & "from InvaTable ia join @dups2 d on d.INNUMBER = ia.INNUMBER and d.Qty = ia.INAQTY" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- now find matching lot item records and point them at the appropriate INNUMBERS" & vbCrLf
SQL = SQL & "update  loi" & vbCrLf
SQL = SQL & "set LOIACTIVITY = INNUMBER" & vbCrLf
SQL = SQL & "from LoitTable loi join InvaTable ia on ia.INLOTNUMBER = loi.LOINUMBER" & vbCrLf
SQL = SQL & "and ia.INAQTY = loi.LOIQUANTITY" & vbCrLf
SQL = SQL & "and ia.INADATE = loi.LOIADATE" & vbCrLf
SQL = SQL & "where LOIPARTREF in (select partref from PartTable where PAPUNITS = 'SH')" & vbCrLf
SQL = SQL & "and LOIACTIVITY is null" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "commit tran" & vbCrLf
SQL = SQL & "end" & vbCrLf
ExecuteScript False, SQL

SQL = "dropstoredprocedureifexists 'InvMrPExcessReport'" & vbCrLf
ExecuteScript False, SQL

SQL = "create procedure InvMRPExcessReport" & vbCrLf
SQL = SQL & "@PartClass as Varchar(16), @PartCode as varchar(8), @PartType1 as Integer," & vbCrLf
SQL = SQL & "@PartType2 as Integer, @PartType3 as Integer, @PartType4 as Integer" & vbCrLf
SQL = SQL & "AS" & vbCrLf
SQL = SQL & "/*" & vbCrLf
SQL = SQL & "sp for Excess Inventory Report, InvExcess.rpt" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "test" & vbCrLf
SQL = SQL & "InvMRPExcessReport '', '', 1, 1, 1, 1" & vbCrLf
SQL = SQL & "*/" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "IF (@PartClass = 'ALL')" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "SET @PartClass = ''" & vbCrLf
SQL = SQL & "End" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "IF (@PartCode = 'ALL')" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "SET @PartCode = ''" & vbCrLf
SQL = SQL & "End" & vbCrLf
SQL = SQL & "IF (@PartType1 = 1)" & vbCrLf
SQL = SQL & "SET @PartType1 = 1" & vbCrLf
SQL = SQL & "Else" & vbCrLf
SQL = SQL & "SET @PartType1 = 0" & vbCrLf
SQL = SQL & "IF (@PartType2 = 1)" & vbCrLf
SQL = SQL & "SET @PartType2 = 2" & vbCrLf
SQL = SQL & "Else" & vbCrLf
SQL = SQL & "SET @PartType2 = 0" & vbCrLf
SQL = SQL & "IF (@PartType3 = 1)" & vbCrLf
SQL = SQL & "SET @PartType3 = 3" & vbCrLf
SQL = SQL & "Else" & vbCrLf
SQL = SQL & "SET @PartType3 = 0" & vbCrLf
SQL = SQL & "IF (@PartType4 = 1)" & vbCrLf
SQL = SQL & "SET @PartType4 = 4" & vbCrLf
SQL = SQL & "Else" & vbCrLf
SQL = SQL & "SET @PartType4 = 0" & vbCrLf
SQL = SQL & "CREATE TABLE #tempMrpExRpt" & vbCrLf
SQL = SQL & "(" & vbCrLf
SQL = SQL & "PACLASS varchar(4) NULL ," & vbCrLf
SQL = SQL & "PAPRODCODE varchar(6) NULL ," & vbCrLf
SQL = SQL & "PALEVEL tinyint NULL ," & vbCrLf
SQL = SQL & "PARTREF varchar(30) NULL ," & vbCrLf
SQL = SQL & "PARTNUM varchar(30) NULL ," & vbCrLf
SQL = SQL & "PADESC varchar(30) NULL ," & vbCrLf
SQL = SQL & "PAEXTDESC varchar(3072) NULL ," & vbCrLf
SQL = SQL & "LOTNUMBER varchar(15) NULL," & vbCrLf
SQL = SQL & "LOTUSERLOTID varchar(40) NULL," & vbCrLf
SQL = SQL & "MRP_QTYREM int NULL," & vbCrLf
SQL = SQL & "LOTUNITCOST decimal(12,4) NULL ," & vbCrLf
SQL = SQL & "PASTDCOST decimal(12,4) NULL ," & vbCrLf
SQL = SQL & "PAUSEACTUALCOST tinyint NULL ," & vbCrLf
SQL = SQL & "PALOTTRACK tinyint NULL," & vbCrLf
SQL = SQL & "MRP_ACTIVITY tinyint NULL," & vbCrLf
SQL = SQL & "Row int NULL," & vbCrLf
SQL = SQL & "LOTREMAININGQTY int NULL," & vbCrLf
SQL = SQL & "PriorLotQty int null," & vbCrLf
SQL = SQL & "QtyToShow int NULL" & vbCrLf
SQL = SQL & ")" & vbCrLf
SQL = SQL & "SELECT mrp_partref, SUM(mrp_partqtyrqd) as rem, cast(0 as bit) as active" & vbCrLf
SQL = SQL & "into #temp" & vbCrLf
SQL = SQL & "from MrplTable" & vbCrLf
SQL = SQL & "WHERE mrp_type NOT IN ('5', '7')" & vbCrLf
SQL = SQL & "GROUP BY mrp_partref Having Sum(mrp_partqtyrqd) >= 1" & vbCrLf
SQL = SQL & "order by MRP_PARTREF" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "update #temp set Active = 1 where exists (select 1 from MrplTable x where x.mrp_partref = #temp.MRP_PARTREF and mrp_type NOT IN ('1','17', '5', '6'))" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "INSERT INTO #tempMrpExRpt (PACLASS, PAPRODCODE, PALEVEL," & vbCrLf
SQL = SQL & "PARTREF, PARTNUM, PADESC, PAEXTDESC, LOTNUMBER, LOTUSERLOTID," & vbCrLf
SQL = SQL & "MRP_QTYREM, LOTUNITCOST, PASTDCOST, PAUSEACTUALCOST, PALOTTRACK, MRP_ACTIVITY," & vbCrLf
SQL = SQL & "Row,LOTREMAININGQTY,PriorLotQty,QtyToShow )" & vbCrLf
SQL = SQL & "SELECT PACLASS, PAPRODCODE, PALEVEL, PARTREF, PARTNUM, PADESC," & vbCrLf
SQL = SQL & "PAEXTDESC, LOTNUMBER, LOTUSERLOTID, #temp.rem,LOTUNITCOST," & vbCrLf
SQL = SQL & "PASTDCOST , PAUSEACTUALCOST, PALOTTRACK, #temp.active," & vbCrLf
SQL = SQL & "row_number() over (partition by PARTREF order by LOTADATE desc)," & vbCrLf
SQL = SQL & "LOTREMAININGQTY,0,0" & vbCrLf
SQL = SQL & "From ViewLohdPartTable join #temp on #temp.MRP_PARTREF = PARTREF" & vbCrLf
SQL = SQL & "WHERE PACLASS LIKE '%' + @PartClass + '%'" & vbCrLf
SQL = SQL & "AND PAPRODCODE LIKE '%' + @PartCode + '%'" & vbCrLf
SQL = SQL & "AND PALEVEL IN (@PartType1, @PartType2, @PartType3, @PartType4)" & vbCrLf
SQL = SQL & "and LOTREMAININGQTY > 0" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- calculate running totals for each part" & vbCrLf
SQL = SQL & "update #tempMrpExRpt set PriorLotQty = isnull((select sum(t2.LOTREMAININGQTY) from #tempMrpExRpt t2" & vbCrLf
SQL = SQL & "where t2.PARTREF = #tempMrpExRpt.PARTREF and t2.Row < #tempMrpExRpt.Row),0)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "update #tempMrpExRpt set QtyToShow = case when LOTREMAININGQTY > (MRP_QTYREM - PriorLotQty) then (MRP_QTYREM - PriorLotQty) else LOTREMAININGQTY end" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "delete from #tempMrpExRpt where QtyToShow <= 0" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "select * from #tempMrpExRpt order by PARTREF, Row" & vbCrLf
SQL = SQL & "drop table #tempMrpExRpt" & vbCrLf
SQL = SQL & "drop table #temp" & vbCrLf
SQL = SQL & "end" & vbCrLf
SQL = SQL & "" & vbCrLf
ExecuteScript False, SQL



''''''''''''''''''''''''''''''''''''''''''''''''''

      ' update the version
      ExecuteScript False, "Update Version Set Version = " & newver

   End If
End Function


Private Function UpdateDatabase99()

'update database version template
'set version at top of this file
'set version below
'add SQL updates


   Dim SQL As String
   SQL = ""

   newver = 174     ' set actual version
   If ver < newver Then

      clsADOCon.ADOErrNum = 0

''''''''''''''''''''''''''''''''''''''''''''''''''

SQL = "dropstoredprocedureifexists 'InvMRPExcessReport'" & vbCrLf
ExecuteScript False, SQL
SQL = "create procedure InvMRPExcessReport" & vbCrLf
SQL = SQL & "@PartClass as Varchar(16), @PartCode as varchar(8), @PartType1 as Integer," & vbCrLf
SQL = SQL & "@PartType2 as Integer, @PartType3 as Integer, @PartType4 as Integer" & vbCrLf
SQL = SQL & "AS" & vbCrLf
SQL = SQL & "/*" & vbCrLf
SQL = SQL & "sp for Excess Inventory Report, InvExcess.rpt" & vbCrLf
SQL = SQL & "revised 2/5/2018 for MANSER - TEL" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "test" & vbCrLf
SQL = SQL & "InvMRPExcessReport '', '', 1, 1, 1, 1" & vbCrLf
SQL = SQL & "*/" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "IF (@PartClass = 'ALL')" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "SET @PartClass = ''" & vbCrLf
SQL = SQL & "End" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "IF (@PartCode = 'ALL')" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "SET @PartCode = ''" & vbCrLf
SQL = SQL & "End" & vbCrLf
SQL = SQL & "IF (@PartType1 = 1)" & vbCrLf
SQL = SQL & "SET @PartType1 = 1" & vbCrLf
SQL = SQL & "Else" & vbCrLf
SQL = SQL & "SET @PartType1 = 0" & vbCrLf
SQL = SQL & "IF (@PartType2 = 1)" & vbCrLf
SQL = SQL & "SET @PartType2 = 2" & vbCrLf
SQL = SQL & "Else" & vbCrLf
SQL = SQL & "SET @PartType2 = 0" & vbCrLf
SQL = SQL & "IF (@PartType3 = 1)" & vbCrLf
SQL = SQL & "SET @PartType3 = 3" & vbCrLf
SQL = SQL & "Else" & vbCrLf
SQL = SQL & "SET @PartType3 = 0" & vbCrLf
SQL = SQL & "IF (@PartType4 = 1)" & vbCrLf
SQL = SQL & "SET @PartType4 = 4" & vbCrLf
SQL = SQL & "Else" & vbCrLf
SQL = SQL & "SET @PartType4 = 0" & vbCrLf
SQL = SQL & "CREATE TABLE #tempMrpExRpt" & vbCrLf
SQL = SQL & "(" & vbCrLf
SQL = SQL & "PACLASS varchar(4) NULL ," & vbCrLf
SQL = SQL & "PAPRODCODE varchar(6) NULL ," & vbCrLf
SQL = SQL & "PALEVEL tinyint NULL ," & vbCrLf
SQL = SQL & "PARTREF varchar(30) NULL ," & vbCrLf
SQL = SQL & "PARTNUM varchar(30) NULL ," & vbCrLf
SQL = SQL & "PADESC varchar(30) NULL ," & vbCrLf
SQL = SQL & "PAEXTDESC varchar(3072) NULL ," & vbCrLf
SQL = SQL & "MRP_QTYREM int NULL," & vbCrLf
SQL = SQL & "LOT_QTYREM int NULL," & vbCrLf
SQL = SQL & "LOT_COST decimal(12,4) NULL ," & vbCrLf
SQL = SQL & "PASTDCOST decimal(12,4) NULL ," & vbCrLf
SQL = SQL & "USE_COST decimal(12,4) NULL," & vbCrLf
SQL = SQL & "TOTAL_COST decimal(12,2) NULL," & vbCrLf
SQL = SQL & "PAUSEACTUALCOST tinyint NULL ," & vbCrLf
SQL = SQL & "PALOTTRACK tinyint NULL," & vbCrLf
SQL = SQL & "MRP_ACTIVITY tinyint NULL" & vbCrLf
SQL = SQL & ")" & vbCrLf
SQL = SQL & "SELECT mrp_partref, SUM(mrp_partqtyrqd) as rem, cast(0 as bit) as active" & vbCrLf
SQL = SQL & "into #temp" & vbCrLf
SQL = SQL & "from MrplTable" & vbCrLf
SQL = SQL & "WHERE mrp_type NOT IN ('5', '7')" & vbCrLf
SQL = SQL & "GROUP BY mrp_partref Having Sum(mrp_partqtyrqd) >= 1" & vbCrLf
SQL = SQL & "order by MRP_PARTREF" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "update #temp set Active = 1 where exists (select 1 from MrplTable x where x.mrp_partref = #temp.MRP_PARTREF and mrp_type NOT IN ('1','17', '5', '6'))" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "INSERT INTO #tempMrpExRpt (PACLASS, PAPRODCODE, PALEVEL,PARTREF, PARTNUM, PADESC, PAEXTDESC,MRP_QTYREM," & vbCrLf
SQL = SQL & "LOT_COST," & vbCrLf
SQL = SQL & "PASTDCOST, PAUSEACTUALCOST, PALOTTRACK, MRP_ACTIVITY," & vbCrLf
SQL = SQL & "LOT_QTYREM," & vbCrLf
SQL = SQL & "USE_COST, TOTAL_COST )" & vbCrLf
SQL = SQL & "SELECT PACLASS, PAPRODCODE, PALEVEL, PARTREF, PARTNUM, PADESC,PAEXTDESC, #temp.rem," & vbCrLf
SQL = SQL & "ISNULL((select top 1 LOTUNITCOST from LohdTable lh where LOTPARTREF = pt.PARTREF and LOTREMAININGQTY > 0 order by LOTADATE desc ),0)," & vbCrLf
SQL = SQL & "PASTDCOST , PAUSEACTUALCOST, PALOTTRACK, #temp.active," & vbCrLf
SQL = SQL & "ISNULL((select sum(LOTREMAININGQTY) from LohdTable lh2 where lh2.LOTPARTREF = pt.PARTREF and LOTREMAININGQTY > 0 ),0)," & vbCrLf
SQL = SQL & "0,0" & vbCrLf
SQL = SQL & "From PartTable pt" & vbCrLf
SQL = SQL & "join #temp on #temp.MRP_PARTREF = PARTREF" & vbCrLf
SQL = SQL & "WHERE PACLASS LIKE '%' + @PartClass + '%'" & vbCrLf
SQL = SQL & "AND PAPRODCODE LIKE '%' + @PartCode + '%'" & vbCrLf
SQL = SQL & "AND PALEVEL IN (@PartType1, @PartType2, @PartType3, @PartType4)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "--select cost to apply" & vbCrLf
SQL = SQL & "--1. If PAUSEACTUALCOST = 1 and there is a lot cost, use the lot cost" & vbCrLf
SQL = SQL & "--2. If PAUSEACTUALCOST = 1 and the lot cost is zero, use standard cost" & vbCrLf
SQL = SQL & "--3. If PAUSEACTUALCOST = 0 use standard cost" & vbCrLf
SQL = SQL & "update #tempMrpExRpt set USE_COST = case when PAUSEACTUALCOST = 1 AND LOT_COST > 0 then LOT_COST else PASTDCOST end" & vbCrLf
SQL = SQL & "update #tempMrpExRpt set TOTAL_COST = MRP_QTYREM * USE_COST" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "select * from #tempMrpExRpt" & vbCrLf
SQL = SQL & "order by PARTREF" & vbCrLf
SQL = SQL & "drop table #tempMrpExRpt" & vbCrLf
SQL = SQL & "drop table #temp" & vbCrLf
SQL = SQL & "end" & vbCrLf
ExecuteScript False, SQL

' import IMAINC payroll data to GL
SQL = "dropstoredprocedureifexists 'InsertPayrollJournal'" & vbCrLf
ExecuteScript False, SQL

SQL = "create procedure InsertPayrollJournal" & vbCrLf
SQL = SQL & "@CSV varchar(MAX),     -- (''ACCT1'',AMT1),(''ACCT2'',AMT2)...  (Amount is minus for a credit)" & vbCrLf
SQL = SQL & "@User varchar(3)," & vbCrLf
SQL = SQL & "@PayrollDate datetime" & vbCrLf
SQL = SQL & "as" & vbCrLf
SQL = SQL & "/* aggregate IMAINC payroll journal data from an Excel file and create a summary GL Journal" & vbCrLf
SQL = SQL & "returns blank if successful" & vbCrLf
SQL = SQL & "returns error message if unsuccessful" & vbCrLf
SQL = SQL & "*/" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "SET NOCOUNT ON      -- required to avoid an error in sp with inserts and updates" & vbCrLf
SQL = SQL & "SET ANSI_WARNINGS OFF" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "begin" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "if exists (select 1 from INFORMATION_SCHEMA.TABLES where TABLE_NAME = '_PayrollTemp')" & vbCrLf
SQL = SQL & "drop table _PayrollTemp" & vbCrLf
SQL = SQL & "if exists (select 1 from INFORMATION_SCHEMA.TABLES where TABLE_NAME = '_PayrollTemp2')" & vbCrLf
SQL = SQL & "drop table _PayrollTemp2" & vbCrLf
SQL = SQL & "if exists (select 1 from INFORMATION_SCHEMA.TABLES where TABLE_NAME = '_PayrollTemp3')" & vbCrLf
SQL = SQL & "drop table _PayrollTemp3" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- create journal name" & vbCrLf
SQL = SQL & "declare @JournalName varchar(12)" & vbCrLf
SQL = SQL & "set @JournalName = 'PR-' + cast(year(@PayrollDate) as varchar(4)) + '-'" & vbCrLf
SQL = SQL & "+ RIGHT('0' + MONTH(@PayrollDate),2) + RIGHT('0' + DAY(@PayrollDate),2)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- create table of raw data" & vbCrLf
SQL = SQL & "create table _PayrollTemp (Account varchar(12), Amount decimal(12,2))" & vbCrLf
SQL = SQL & "declare @sql varchar(max) = 'insert _PayRollTemp (Account,Amount) values' + char(13) + char(10) + @csv" & vbCrLf
SQL = SQL & "exec (@sql)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- roll up into accounts" & vbCrLf
SQL = SQL & "select Account," & vbCrLf
SQL = SQL & "sum(cast(Amount as decimal(12,2))) as Total" & vbCrLf
SQL = SQL & "into _PayrollTemp2" & vbCrLf
SQL = SQL & "from _PayrollTemp" & vbCrLf
SQL = SQL & "group by [Account]" & vbCrLf
SQL = SQL & "order by Account" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- construct data to insert" & vbCrLf
SQL = SQL & "select @JournalName as JINAME, 1 as JITRAN," & vbCrLf
SQL = SQL & "ROW_NUMBER() over (ORDER BY Account) as JIREF," & vbCrLf
SQL = SQL & "Account as JIACCOUNT," & vbCrLf
SQL = SQL & "case when Total < 0 then 0.00 else Total end as JIDEB," & vbCrLf
SQL = SQL & "case when Total < 0 then -Total else 0.00 end as JICRD" & vbCrLf
SQL = SQL & "into _PayrollTemp3" & vbCrLf
SQL = SQL & "from _PayrollTemp2" & vbCrLf
SQL = SQL & "where Total <> 0" & vbCrLf
SQL = SQL & "order by Account" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- attempt to create journal" & vbCrLf
SQL = SQL & "begin tran" & vbCrLf
SQL = SQL & "if exists (select * from GjhdTable where GJNAME = @JournalName)" & vbCrLf
SQL = SQL & "begin" & vbCrLf
SQL = SQL & "rollback tran" & vbCrLf
SQL = SQL & "select 'Journal ' + @JournalName + ' already exists.'" & vbCrLf
SQL = SQL & "end" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "else" & vbCrLf
SQL = SQL & "begin" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "INSERT INTO dbo.GjhdTable" & vbCrLf
SQL = SQL & "(" & vbCrLf
SQL = SQL & "GJNAME" & vbCrLf
SQL = SQL & ",GJDESC" & vbCrLf
SQL = SQL & ",GJOPEN" & vbCrLf
SQL = SQL & ",GJPOST" & vbCrLf
SQL = SQL & ",GJPOSTED" & vbCrLf
SQL = SQL & ",GJREVERSE" & vbCrLf
SQL = SQL & ",GJCLOSE" & vbCrLf
SQL = SQL & ",GJREVID" & vbCrLf
SQL = SQL & ",GJREVDATE" & vbCrLf
SQL = SQL & ",GJEXTDESC" & vbCrLf
SQL = SQL & ",GJTEMPLATE" & vbCrLf
SQL = SQL & ",GJYEAREND" & vbCrLf
SQL = SQL & ")" & vbCrLf
SQL = SQL & "VALUES" & vbCrLf
SQL = SQL & "(" & vbCrLf
SQL = SQL & "@JournalName" & vbCrLf
SQL = SQL & ",''" & vbCrLf
SQL = SQL & ",CAST(getdate() as date)" & vbCrLf
SQL = SQL & ",null" & vbCrLf
SQL = SQL & ",0" & vbCrLf
SQL = SQL & ",0" & vbCrLf
SQL = SQL & ",0" & vbCrLf
SQL = SQL & ",''" & vbCrLf
SQL = SQL & ",null" & vbCrLf
SQL = SQL & ",'PAYROLL JOURNAL FOR PAY DATE '" & vbCrLf
SQL = SQL & "+ cast(year(@PayrollDate) as varchar(4)) + ' '" & vbCrLf
SQL = SQL & "+ right('0' + cast(month(@PayrollDate) as varchar(2)),2) + ' '" & vbCrLf
SQL = SQL & "+ right('0' + cast(DAY(@PayrollDate) as varchar(2)),2)" & vbCrLf
SQL = SQL & ",0" & vbCrLf
SQL = SQL & ",0" & vbCrLf
SQL = SQL & ")" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- now insert the items" & vbCrLf
SQL = SQL & "declare @now datetime = cast(convert(varchar(19),getdate(),100) as datetime)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "INSERT INTO dbo.GjitTable" & vbCrLf
SQL = SQL & "(" & vbCrLf
SQL = SQL & "JINAME" & vbCrLf
SQL = SQL & ",JIDESC" & vbCrLf
SQL = SQL & ",JITRAN" & vbCrLf
SQL = SQL & ",JIREF" & vbCrLf
SQL = SQL & ",JIACCOUNT" & vbCrLf
SQL = SQL & ",JIDEB" & vbCrLf
SQL = SQL & ",JICRD" & vbCrLf
SQL = SQL & ",JIDATE" & vbCrLf
SQL = SQL & ",JILASTREVBY" & vbCrLf
SQL = SQL & ",JICLEAR" & vbCrLf
SQL = SQL & ")" & vbCrLf
SQL = SQL & "select" & vbCrLf
SQL = SQL & "JINAME" & vbCrLf
SQL = SQL & ",''" & vbCrLf
SQL = SQL & ",JITRAN" & vbCrLf
SQL = SQL & ",JIREF" & vbCrLf
SQL = SQL & ",JIACCOUNT" & vbCrLf
SQL = SQL & ",JIDEB" & vbCrLf
SQL = SQL & ",JICRD" & vbCrLf
SQL = SQL & ",@now" & vbCrLf
SQL = SQL & ",@User" & vbCrLf
SQL = SQL & ",null" & vbCrLf
SQL = SQL & "from _PayrollTemp3" & vbCrLf
SQL = SQL & "order by JITRAN, JIREF" & vbCrLf
SQL = SQL & "commit tran" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- show debits and credits" & vbCrLf
SQL = SQL & "declare @debits decimal(12,2), @credits decimal(12,2)" & vbCrLf
SQL = SQL & "select @debits = sum(jideb), @credits = sum(jicrd) from GjitTable where jiname = @JournalName" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "select 'Payroll Journal ' + @JournalName + ' created.  debits = ' + format(@debits,'N') + '  credits = ' + format(@credits, 'N')" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "end" & vbCrLf
SQL = SQL & "end" & vbCrLf
ExecuteScript False, SQL

'SQL = "AddOrUpdateColumn 'EmplTable', 'PREMEMAIL', 'varchar(60) NULL'"    'do it in 102
'ExecuteScript False, SQL


''''''''''''''''''''''''''''''''''''''''''''''''''

      ' update the version
      ExecuteScript False, "Update Version Set Version = " & newver

   End If
End Function

Private Function UpdateDatabase100()

'update database version template
'set version at top of this file
'set version below
'add SQL updates


   Dim SQL As String
   SQL = ""

   newver = 175     ' set actual version
   If ver < newver Then

      clsADOCon.ADOErrNum = 0

''''''''''''''''''''''''''''''''''''''''''''''''''

SQL = "exec DropStoredProcedureIfExists 'SheetCancelRestock'" & vbCrLf
ExecuteScript False, SQL

SQL = "create procedure [dbo].SheetCancelRestock" & vbCrLf
SQL = SQL & "@UserLotNo varchar(40)as" & vbCrLf
SQL = SQL & "/*" & vbCrLf
SQL = SQL & "cancel restock sheet LOI records.  Make it as if it never happened." & vbCrLf
SQL = SQL & "exec SheetCancelRestock '030061-2'" & vbCrLf
SQL = SQL & "*/" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "begin tran" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "declare @lot varchar(15), @when datetime, @part varchar(30)" & vbCrLf
SQL = SQL & "select @lot = LOTNUMBER, @part = LOTPARTREF from LohdTable where LOTUSERLOTID = @UserLotNo" & vbCrLf
SQL = SQL & "select @when = (select top 1 LOIADATE from LoitTable where LOINUMBER = @lot and LOICLOSED is null and LOISHEETACTTYPE = 'RS')" & vbCrLf
SQL = SQL & "--select @lot, @part, @when" & vbCrLf
SQL = SQL & "if @lot is null or @part is null or @when is null" & vbCrLf
SQL = SQL & "begin" & vbCrLf
SQL = SQL & "rollback tran" & vbCrLf
SQL = SQL & "return" & vbCrLf
SQL = SQL & "end" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- get total change in quantity" & vbCrLf
SQL = SQL & "declare @qty decimal(12,4)" & vbCrLf
SQL = SQL & "select @qty = (select sum(LOIQUANTITY) from LoitTable where LOINUMBER = @lot and LOICLOSED is null and LOISHEETACTTYPE = 'RS')" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- re-open previous pick records" & vbCrLf
SQL = SQL & "update LoitTable set LOICLOSED = NULL where LOINUMBER = @lot and LOISHEETACTTYPE = 'PK'" & vbCrLf
SQL = SQL & "and LOIRECORD in (select LOIPARENTREC from LoitTable where LOINUMBER = @lot and LOICLOSED is null and LOISHEETACTTYPE = 'RS')" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- delete the inventory activity records" & vbCrLf
SQL = SQL & "delete from InvaTable" & vbCrLf
SQL = SQL & "where INLOTNUMBER = @lot and INADATE = @when" & vbCrLf
SQL = SQL & "and INAQTY in (select LOIQUANTITY FROM LoitTable WHERE LOINUMBER = @lot and LOICLOSED is null and LOISHEETACTTYPE = 'RS')" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- delete the restock records" & vbCrLf
SQL = SQL & "delete from LoitTable where LOINUMBER = @lot and LOICLOSED is null and LOISHEETACTTYPE = 'RS'" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- remove canceled quantity from LohdTable and PartTable" & vbCrLf
SQL = SQL & "update LohdTable set LOTREMAININGQTY = LOTREMAININGQTY - @qty WHERE LOTNUMBER = @LOT" & vbCrLf
SQL = SQL & "update PartTable set PAQOH = PAQOH - @qty where partref = @part" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "commit tran" & vbCrLf
ExecuteScript False, SQL


''''''''''''''''''''''''''''''''''''''''''''''''''

      ' update the version
      ExecuteScript False, "Update Version Set Version = " & newver

   End If
End Function


Private Function UpdateDatabase101()

'update database version template
'set version at top of this file
'set version below
'add SQL updates


   Dim SQL As String
   SQL = ""

   newver = 176     ' set actual version
   If ver < newver Then

      clsADOCon.ADOErrNum = 0

''''''''''''''''''''''''''''''''''''''''''''''''''

SQL = "DropStoredProcedureIfExists 'UpdateTimeCardTotals'" & vbCrLf
ExecuteScript False, SQL

sSql = "create procedure [dbo].[UpdateTimeCardTotals]" & vbCrLf
sSql = sSql & " @EmpNo int," & vbCrLf
sSql = sSql & " @Date datetime" & vbCrLf
sSql = sSql & "as " & vbCrLf
sSql = sSql & "/* test" & vbCrLf
sSql = sSql & "    UpdateTimeCardTotals 52, '9/8/2008'" & vbCrLf
sSql = sSql & "*/" & vbCrLf
sSql = sSql & "update TchdTable " & vbCrLf
sSql = sSql & "set TMSTART = (select top 1 TCSTART From TcitTable " & vbCrLf
sSql = sSql & "join TchdTable on TCCARD = TMCARD" & vbCrLf
sSql = sSql & "where TCEMP = @EmpNo and TMDAY = @Date and TCSTOP <> ''" & vbCrLf
sSql = sSql & "and ISDATE(TCSTART + 'm') = 1 and ISDATE(TCSTOP + 'm') = 1" & vbCrLf
sSql = sSql & "order by tcstarttime)," & vbCrLf
sSql = sSql & "TMSTOP = (select top 1 TCSTOP From TcitTable" & vbCrLf
sSql = sSql & "join TchdTable on TCCARD = TMCARD" & vbCrLf
sSql = sSql & "where TCEMP = @EmpNo and TMDAY = @Date and TCSTOP <> ''" & vbCrLf
sSql = sSql & "and ISDATE(TCSTART + 'm') = 1 and ISDATE(TCSTOP + 'm') = 1" & vbCrLf
sSql = sSql & "order by TCSTOPTIME desc)" & vbCrLf
sSql = sSql & "where TMEMP = @EmpNo and TMDAY = @Date" & vbCrLf
sSql = sSql & "" & vbCrLf
sSql = sSql & "update TchdTable " & vbCrLf
sSql = sSql & "set TMREGHRS = (select isnull(sum(hrs), 0.000) from viewTimeCardHours" & vbCrLf
sSql = sSql & "where EmpNo = @EmpNo" & vbCrLf
sSql = sSql & "and chgDay = @Date" & vbCrLf
sSql = sSql & "and type = 'R')," & vbCrLf
sSql = sSql & "TMOVTHRS = (select isnull(sum(hrs), 0.000) from viewTimeCardHours" & vbCrLf
sSql = sSql & "where EmpNo = @EmpNo" & vbCrLf
sSql = sSql & "and chgDay = @Date" & vbCrLf
sSql = sSql & "and type = 'O')," & vbCrLf
sSql = sSql & "TMDBLHRS = (select isnull(sum(hrs), 0.000) from viewTimeCardHours" & vbCrLf
sSql = sSql & "where EmpNo = @EmpNo" & vbCrLf
sSql = sSql & "and chgDay = @Date" & vbCrLf
sSql = sSql & "and type = 'D')" & vbCrLf
sSql = sSql & "where TMEMP = @EmpNo and TMDAY = @Date"
ExecuteScript False, sSql

' this should have happened in UpdateDatabase27, but that did not happen for all users.
SQL = "DropStoredProcedureIfExists 'RptChartOfAccount'" & vbCrLf
ExecuteScript False, SQL

SQL = "CREATE  PROCEDURE [dbo].[RptChartOfAccount]  " & vbCrLf
SQL = SQL & "    @InclIncAcct as varchar(1)" & vbCrLf
SQL = SQL & "AS " & vbCrLf
SQL = SQL & "/*" & vbCrLf
SQL = SQL & "test" & vbCrLf
SQL = SQL & "  exec RptChartOfAccount 0" & vbCrLf
SQL = SQL & "*/" & vbCrLf
SQL = SQL & "BEGIN " & vbCrLf
SQL = SQL & " " & vbCrLf
SQL = SQL & "   declare @glAcctRef as varchar(10) " & vbCrLf
SQL = SQL & "   declare @glMsAcct as varchar(10) " & vbCrLf
SQL = SQL & "   declare @TopLevelDesc as varchar(30)" & vbCrLf
SQL = SQL & " " & vbCrLf
SQL = SQL & "   declare @level as varchar(12)" & vbCrLf
SQL = SQL & "   declare @InclInAcct as Integer" & vbCrLf
SQL = SQL & " " & vbCrLf
SQL = SQL & "   if (@InclIncAcct = '1')" & vbCrLf
SQL = SQL & "      SET @InclInAcct = ''" & vbCrLf
SQL = SQL & "   else" & vbCrLf
SQL = SQL & "      SET @InclInAcct = '0'" & vbCrLf
SQL = SQL & " " & vbCrLf
SQL = SQL & "   CREATE TABLE #tempChartOfAcct(   " & vbCrLf
SQL = SQL & "   [TOPLEVEL] [varchar](12) NULL,  " & vbCrLf
SQL = SQL & "   [TOPLEVELDESC] [varchar](30) NULL, " & vbCrLf
SQL = SQL & "   [GLACCTREF] [varchar](112) NULL,         " & vbCrLf
SQL = SQL & "   [GLDESCR] [varchar](120) NULL,  " & vbCrLf
SQL = SQL & "   [GLMASTER] [varchar](12) NULL,   " & vbCrLf
SQL = SQL & "   [GLFSLEVEL] [INT] NULL," & vbCrLf
SQL = SQL & "   [GLINACTIVE] [int] NULL," & vbCrLf
SQL = SQL & "   [SORTKEYLEVEL] [int] NULL,           " & vbCrLf
SQL = SQL & "   [GLACCSORTKEY] [varchar](512) NULL           " & vbCrLf
SQL = SQL & ")                             " & vbCrLf
SQL = SQL & " " & vbCrLf
SQL = SQL & " " & vbCrLf
SQL = SQL & "   DECLARE balAcctStruc CURSOR  FOR " & vbCrLf
SQL = SQL & "      SELECT COASSTACCT, COASSTDESC FROM GlmsTable" & vbCrLf
SQL = SQL & "      UNION ALL" & vbCrLf
SQL = SQL & "      SELECT COLIABACCT, COLIABDESC FROM GlmsTable" & vbCrLf
SQL = SQL & "      UNION ALL" & vbCrLf
SQL = SQL & "      SELECT COINCMACCT, COINCMDESC FROM GlmsTable" & vbCrLf
SQL = SQL & "      UNION ALL " & vbCrLf
SQL = SQL & "      SELECT COEQTYACCT, COEQTYDESC FROM GlmsTable" & vbCrLf
SQL = SQL & "      UNION ALL" & vbCrLf
SQL = SQL & "      SELECT COCOGSACCT, COCOGSDESC FROM GlmsTable" & vbCrLf
SQL = SQL & "      UNION ALL" & vbCrLf
SQL = SQL & "      SELECT COEXPNACCT, COEXPNDESC FROM GlmsTable" & vbCrLf
SQL = SQL & "      UNION ALL" & vbCrLf
SQL = SQL & "      SELECT COOINCACCT, COOINCDESC FROM GlmsTable" & vbCrLf
SQL = SQL & "      UNION ALL" & vbCrLf
SQL = SQL & "      SELECT COFDTXACCT, COFDTXDESC FROM GlmsTable" & vbCrLf
SQL = SQL & "      UNION ALL" & vbCrLf
SQL = SQL & "     SELECT COOEXPACCT, COOEXPDESC FROM GlmsTable" & vbCrLf
SQL = SQL & "      --UNION ALL" & vbCrLf
SQL = SQL & "      --SELECT COFDTXACCT, COFDTXDESC FROM GlmsTable" & vbCrLf
SQL = SQL & " " & vbCrLf
SQL = SQL & "   OPEN balAcctStruc" & vbCrLf
SQL = SQL & "   FETCH NEXT FROM balAcctStruc INTO @level, @TopLevelDesc" & vbCrLf
SQL = SQL & "   WHILE (@@FETCH_STATUS <> -1) " & vbCrLf
SQL = SQL & "   BEGIN " & vbCrLf
SQL = SQL & "      IF (@@FETCH_STATUS <> -2) " & vbCrLf
SQL = SQL & "      BEGIN " & vbCrLf
SQL = SQL & "         " & vbCrLf
SQL = SQL & "         INSERT INTO #tempChartOfAcct(TOPLEVEL, TOPLEVELDESC, GLACCTREF, GLDESCR, GLMASTER, GLFSLEVEL,GLINACTIVE, SORTKEYLEVEL,GLACCSORTKEY)" & vbCrLf
SQL = SQL & "         select @level as TopLevel, @TopLevelDesc as TopLevelDesc, @level as GLACCTREF, " & vbCrLf
SQL = SQL & "            @TopLevelDesc as GLDESCR, '' as GLMASTER, 0 as GLFSLEVEL, 0,0 as level, @level as SortKey;" & vbCrLf
SQL = SQL & " " & vbCrLf
SQL = SQL & "         with cte" & vbCrLf
SQL = SQL & "         as" & vbCrLf
SQL = SQL & "         (select GLACCTREF, GLDESCR, GLMASTER, GLFSLEVEL, GLINACTIVE, 0 as level," & vbCrLf
SQL = SQL & "            cast(cast(@level as varchar(12))+ char(36)+ GLACCTREF as varchar(max)) as SortKey" & vbCrLf
SQL = SQL & "         from GlacTable" & vbCrLf
SQL = SQL & "         where GLMASTER = cast(@level as varchar(12)) AND GLINACTIVE LIKE @InclInAcct" & vbCrLf
SQL = SQL & "         union all" & vbCrLf
SQL = SQL & "         select a.GLACCTREF, a.GLDESCR, a.GLMASTER, a.GLFSLEVEL, a.GLINACTIVE, level + 1," & vbCrLf
SQL = SQL & "          cast(COALESCE(SortKey,'') + char(36) + COALESCE(a.GLACCTREF,'') as varchar(max))as SortKey" & vbCrLf
SQL = SQL & "         from cte" & vbCrLf
SQL = SQL & "            inner join GlacTable a" & vbCrLf
SQL = SQL & "               on cte.GLACCTREF = a.GLMASTER" & vbCrLf
SQL = SQL & "            WHERE a.GLINACTIVE LIKE @InclInAcct" & vbCrLf
SQL = SQL & "         )" & vbCrLf
SQL = SQL & " " & vbCrLf
SQL = SQL & "         INSERT INTO #tempChartOfAcct(TOPLEVEL, TOPLEVELDESC, GLACCTREF, GLDESCR, GLMASTER, GLFSLEVEL,GLINACTIVE, SORTKEYLEVEL,GLACCSORTKEY)" & vbCrLf
SQL = SQL & "         select @level as TopLevel, @TopLevelDesc as TopLevelDesc, " & vbCrLf
SQL = SQL & "               Replicate('  ', level) + GLACCTREF as GLACCTREF, " & vbCrLf
SQL = SQL & "               Replicate('  ', level) + GLDESCR as GLDESCR, GLMASTER, " & vbCrLf
SQL = SQL & "               GLFSLEVEL, GLINACTIVE,level, SortKey" & vbCrLf
SQL = SQL & "         from cte order by SortKey" & vbCrLf
SQL = SQL & "         " & vbCrLf
SQL = SQL & "      END" & vbCrLf
SQL = SQL & "      FETCH NEXT FROM balAcctStruc INTO @level, @TopLevelDesc" & vbCrLf
SQL = SQL & "   END         " & vbCrLf
SQL = SQL & "   CLOSE balAcctStruc" & vbCrLf
SQL = SQL & "   DEALLOCATE balAcctStruc" & vbCrLf
SQL = SQL & " " & vbCrLf
SQL = SQL & "   SELECT TOPLEVEL, TOPLEVELDESC, GLACCTREF, GLDESCR, GLMASTER, " & vbCrLf
SQL = SQL & "      GLFSLEVEL,GLINACTIVE, SORTKEYLEVEL,GLACCSORTKEY " & vbCrLf
SQL = SQL & "   FROM #tempChartOfAcct ORDER BY GLACCSORTKEY" & vbCrLf
SQL = SQL & "                                           " & vbCrLf
SQL = SQL & "   DROP table #tempChartOfAcct            " & vbCrLf
SQL = SQL & " " & vbCrLf
SQL = SQL & "End" & vbCrLf
SQL = SQL & "" & vbCrLf
ExecuteScript False, SQL


''''''''''''''''''''''''''''''''''''''''''''''''''

      ' update the version
      ExecuteScript False, "Update Version Set Version = " & newver

   End If
End Function

Private Function UpdateDatabase102()

'update database version template
'set version at top of this file
'set version below
'add SQL updates


   Dim SQL As String
   SQL = ""

   newver = 177
   If ver < newver Then

      clsADOCon.ADOErrNum = 0

''''''''''''''''''''''''''''''''''''''''''''''''''

SQL = "AddOrUpdateColumn 'EmplTable', 'PREMEMAIL', 'varchar(60) NULL'"
ExecuteScript False, SQL

SQL = "AddOrUpdateColumn 'EmplTable', 'PREMPREVTERMDT', 'smalldatetime NULL'"
ExecuteScript False, SQL

' turn SOTEXT into a computed column so it can never be wrong
SQL = "DropFunctionIfExists 'GetDefaultConstraintName'" & vbCrLf
ExecuteScript False, SQL

SQL = "create function dbo.GetDefaultConstraintName" & vbCrLf
SQL = SQL & "(" & vbCrLf
SQL = SQL & "@schema varchar(100)," & vbCrLf
SQL = SQL & "@table varchar(100)," & vbCrLf
SQL = SQL & "@column varchar(100)" & vbCrLf
SQL = SQL & ")" & vbCrLf
SQL = SQL & "returns varchar(100)" & vbCrLf
SQL = SQL & "/* get default name for a column.  returns blank if none" & vbCrLf
SQL = SQL & "test:" & vbCrLf
SQL = SQL & "select dbo.GetDefaultConstraintName('dbo','SohdTable','SOTEXT')" & vbCrLf
SQL = SQL & "*/" & vbCrLf
SQL = SQL & "as" & vbCrLf
SQL = SQL & "begin" & vbCrLf
SQL = SQL & "declare @name varchar(100)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "select @name =" & vbCrLf
SQL = SQL & "default_constraints.name" & vbCrLf
SQL = SQL & "from sys.all_columns" & vbCrLf
SQL = SQL & "INNER JOIN sys.tables ON all_columns.object_id = tables.object_id" & vbCrLf
SQL = SQL & "INNER JOIN sys.schemas ON tables.schema_id = schemas.schema_id" & vbCrLf
SQL = SQL & "INNER JOIN sys.default_constraints ON all_columns.default_object_id = default_constraints.object_id" & vbCrLf
SQL = SQL & "where schemas.name = @schema" & vbCrLf
SQL = SQL & "AND tables.name = @table" & vbCrLf
SQL = SQL & "AND all_columns.name = @column" & vbCrLf
SQL = SQL & "return isnull(@name,'')" & vbCrLf
SQL = SQL & "end" & vbCrLf
ExecuteScript False, SQL

SQL = "declare @constraintname varchar(100)" & vbCrLf
SQL = SQL & "declare @sql varchar(200)" & vbCrLf
SQL = SQL & "set @constraintname = dbo.GetDefaultConstraintName('dbo','SohdTable','SOTEXT')" & vbCrLf
SQL = SQL & "if @constraintname <> ''" & vbCrLf
SQL = SQL & "begin" & vbCrLf
SQL = SQL & "set @sql = 'alter table SohdTable drop constraint ' + @constraintname" & vbCrLf
SQL = SQL & "exec (@sql)" & vbCrLf
SQL = SQL & "end" & vbCrLf
ExecuteScript False, SQL

SQL = "alter table SohdTable drop column SOTEXT" & vbCrLf
ExecuteScript False, SQL

SQL = "alter table SohdTable add SOTEXT as right('000000' + cast(SONUMBER as varchar(6)),6)" & vbCrLf
ExecuteScript False, SQL

'from updatedatabase34 -- not everyone has it
      If StoreProcedureExists("RptAcctBalanceSheet") Then
         sSql = "DROP PROCEDURE RptAcctBalanceSheet"
         ExecuteScript False, sSql
      End If
      
      sSql = "CREATE PROCEDURE [dbo].[RptAcctBalanceSheet]" & vbCrLf
      sSql = sSql & "   @StartDate as varchar(12),@EndDate as varchar(12)," & vbCrLf
      sSql = sSql & "   @InclInAcct as varchar(1)" & vbCrLf
      sSql = sSql & "AS" & vbCrLf
      sSql = sSql & "BEGIN " & vbCrLf
      sSql = sSql & "   declare @glAcctRef as varchar(10)" & vbCrLf
      sSql = sSql & "   declare @glMsAcct as varchar(10)" & vbCrLf
      sSql = sSql & "   declare @SumCurBal decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @SumPrevBal as decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @level as integer" & vbCrLf
      sSql = sSql & "   declare @TopLevelDesc as varchar(30)" & vbCrLf
      sSql = sSql & "   declare @TopLevAcct as varchar(20)" & vbCrLf
      sSql = sSql & "   declare @PrevMaster as varchar(10)" & vbCrLf
      sSql = sSql & "   declare @RowCount as integer" & vbCrLf
      sSql = sSql & "   declare @GlMasterAcc as varchar(10)" & vbCrLf
      sSql = sSql & "   declare @GlChildAcct as varchar(10)" & vbCrLf
      sSql = sSql & "   declare @ChildKey as varchar(1024)" & vbCrLf
      sSql = sSql & "   declare @GLSortKey as varchar(1024)" & vbCrLf
      sSql = sSql & "   declare @SortKey as varchar(1024)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   DELETE FROM EsReportBalanceSheet" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   if (@InclInAcct = '1')" & vbCrLf
      sSql = sSql & "      SET @InclInAcct = '%'" & vbCrLf
      sSql = sSql & "   Else" & vbCrLf
      sSql = sSql & "      SET @InclInAcct = '0'" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   DECLARE balAcctStruc CURSOR  FOR" & vbCrLf
      sSql = sSql & "      SELECT '1', COASSTACCT, COASSTDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      Union All" & vbCrLf
      sSql = sSql & "      SELECT '2', COLIABACCT, COLIABDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "      Union All" & vbCrLf
      sSql = sSql & "      SELECT '3', COEQTYACCT, COEQTYDESC FROM GlmsTable" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   OPEN balAcctStruc" & vbCrLf
      sSql = sSql & "   FETCH NEXT FROM balAcctStruc INTO @level, @TopLevAcct, @TopLevelDesc" & vbCrLf
      sSql = sSql & "   WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "   BEGIN " & vbCrLf
      sSql = sSql & "      IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "      BEGIN " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "         ;with cte" & vbCrLf
      sSql = sSql & "         as" & vbCrLf
      sSql = sSql & "         (select GLACCTREF, GLDESCR, GLMASTER, GLFSLEVEL, 0 as level," & vbCrLf
      sSql = sSql & "            cast(cast(@level as varchar(4))+ char(36)+ GLACCTREF as varchar(max)) as SortKey" & vbCrLf
      sSql = sSql & "         From GlacTable" & vbCrLf
      sSql = sSql & "         where GLMASTER = cast(@TopLevAcct as varchar(20)) AND GLINACTIVE LIKE @InclInAcct" & vbCrLf
      sSql = sSql & "         Union All" & vbCrLf
      sSql = sSql & "         select a.GLACCTREF, a.GLDESCR, a.GLMASTER, a.GLFSLEVEL, level + 1," & vbCrLf
      sSql = sSql & "          cast(COALESCE(SortKey,'') + char(36) + COALESCE(a.GLACCTREF,'') as varchar(max))as SortKey" & vbCrLf
      sSql = sSql & "         From cte" & vbCrLf
      sSql = sSql & "            inner join GlacTable a" & vbCrLf
      sSql = sSql & "               on cte.GLACCTREF = a.GLMASTER" & vbCrLf
      sSql = sSql & "            WHERE GLINACTIVE LIKE @InclInAcct" & vbCrLf
      sSql = sSql & "         )" & vbCrLf
      sSql = sSql & "         INSERT INTO EsReportBalanceSheet (GLTOPMaster, GLTOPMASTERDESC, GLACCTREF, GLDESCR, GLMASTER, GLFSLEVEL,SORTKEYLEVEL,GLACCSORTKEY)" & vbCrLf
      sSql = sSql & "         select @level, @TopLevelDesc," & vbCrLf
      sSql = sSql & "         GLACCTREF , GLDESCR, GLMASTER, GLFSLEVEL, Level, SortKey" & vbCrLf
      sSql = sSql & "         from cte order by SortKey" & vbCrLf
      sSql = sSql & "         " & vbCrLf
      sSql = sSql & "      End" & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM balAcctStruc INTO @level, @TopLevAcct, @TopLevelDesc" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "   Close balAcctStruc" & vbCrLf
      sSql = sSql & "   DEALLOCATE balAcctStruc" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   UPDATE EsReportBalanceSheet SET CurrentBal = foo.Balance" & vbCrLf
      sSql = sSql & "   From" & vbCrLf
      sSql = sSql & "       (SELECT SUM(GjitTable.JIDEB) - SUM(GjitTable.JICRD) as Balance, JIACCOUNT" & vbCrLf
      sSql = sSql & "         FROM GjhdTable INNER JOIN GjitTable ON GJNAME = JINAME" & vbCrLf
      sSql = sSql & "      WHERE GJPOST BETWEEN @StartDate AND @EndDate" & vbCrLf
      sSql = sSql & "         AND GjhdTable.GJPOSTED = 1" & vbCrLf
      sSql = sSql & "      GROUP BY JIACCOUNT) as foo" & vbCrLf
      sSql = sSql & "   Where foo.JIACCOUNT = GLACCTREF" & vbCrLf
      sSql = sSql & "  " & vbCrLf
      sSql = sSql & " UPDATE EsReportBalanceSheet SET PreviousBal = foo.Balance" & vbCrLf
      sSql = sSql & "   From" & vbCrLf
      sSql = sSql & "      (SELECT JIACCOUNT,SUM(GjitTable.JIDEB) - SUM(GjitTable.JICRD) AS Balance" & vbCrLf
      sSql = sSql & "         FROM GjhdTable INNER JOIN GjitTable ON GJNAME = JINAME" & vbCrLf
      sSql = sSql & "      WHERE (GJPOST  <  @StartDate)" & vbCrLf
      sSql = sSql & "         AND GjhdTable.GJPOSTED = 1" & vbCrLf
      sSql = sSql & "      GROUP BY JIACCOUNT) as foo" & vbCrLf
      sSql = sSql & "   Where foo.JIACCOUNT = GLACCTREF" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   set @level = 9" & vbCrLf
      sSql = sSql & "   WHILE (@level >= 1 )" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "      DECLARE curAcctStruc CURSOR  FOR" & vbCrLf
      sSql = sSql & "      SELECT GLMASTER, SUM(ISNULL(SUMCURBAL,0) + (ISNULL(CurrentBal,0))) ," & vbCrLf
      sSql = sSql & "         Sum (IsNull(SUMPREVBAL, 0) + (IsNull(PreviousBal, 0)))" & vbCrLf
      sSql = sSql & "      From" & vbCrLf
      sSql = sSql & "         (SELECT DISTINCT GLACCTREF, GLDESCR, GLMASTER," & vbCrLf
      sSql = sSql & "         CurrentBal , PreviousBal, SUMCURBAL, SUMPREVBAL" & vbCrLf
      sSql = sSql & "         FROM EsReportBalanceSheet WHERE GLFSLEVEL = @level) as foo" & vbCrLf
      sSql = sSql & "      group by GLMASTER" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "      OPEN curAcctStruc" & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM curAcctStruc INTO @glMsAcct, @SumCurBal, @SumPrevBal" & vbCrLf
      sSql = sSql & "      WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "      BEGIN" & vbCrLf
      sSql = sSql & "         IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "         BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "           UPDATE EsReportBalanceSheet SET SUMCURBAL = (ISNULL(SUMCURBAL, 0) + @SumCurBal)," & vbCrLf
      sSql = sSql & "               SUMPREVBAL = (ISNULL(SUMPREVBAL, 0) + @SumPrevBal), GLDESCR = 'TOTAL '+ LTRIM(GLDESCR)," & vbCrLf
      sSql = sSql & "            HASCHILD = 1" & vbCrLf
      sSql = sSql & "            WHERE GLACCTREF = @glMsAcct" & vbCrLf
      sSql = sSql & "         End" & vbCrLf
      sSql = sSql & "         FETCH NEXT FROM curAcctStruc INTO @glMsAcct, @SumCurBal, @SumPrevBal" & vbCrLf
      sSql = sSql & "      End" & vbCrLf
      sSql = sSql & "            " & vbCrLf
      sSql = sSql & "      Close curAcctStruc" & vbCrLf
      sSql = sSql & "      DEALLOCATE curAcctStruc" & vbCrLf
      sSql = sSql & "      " & vbCrLf
      sSql = sSql & "      SET @level = @level - 1" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   UPDATE EsReportBalanceSheet SET SUMCURBAL = CurrentBal WHERE SUMCURBAL IS NULL" & vbCrLf
      sSql = sSql & "   UPDATE EsReportBalanceSheet SET SUMPREVBAL = PreviousBal WHERE SUMPREVBAL IS NULL" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   set @level = 0" & vbCrLf
      sSql = sSql & "   set @RowCount = 1" & vbCrLf
      sSql = sSql & "   SET @PrevMaster = ''" & vbCrLf
      sSql = sSql & "   DECLARE curAcctStruc CURSOR  FOR" & vbCrLf
      sSql = sSql & "      SELECT GLMASTER, GLACCSORTKEY" & vbCrLf
      sSql = sSql & "      From EsReportBalanceSheet" & vbCrLf
      sSql = sSql & "         WHERE HASCHILD IS NULL" & vbCrLf
      sSql = sSql & "      ORDER BY GLACCSORTKEY" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   OPEN curAcctStruc" & vbCrLf
      sSql = sSql & "   FETCH NEXT FROM curAcctStruc INTO @GlMasterAcc, @GLSortKey" & vbCrLf
      sSql = sSql & "   WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "    IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "    BEGIN" & vbCrLf
      sSql = sSql & "      if (@PrevMaster <> @GlMasterAcc)" & vbCrLf
      sSql = sSql & "      BEGIN" & vbCrLf
      sSql = sSql & "         UPDATE EsReportBalanceSheet SET" & vbCrLf
      sSql = sSql & "            SortKeyRev = RIGHT ('0000'+ Cast(@RowCount as varchar), 4) + char(36)+ @GlMasterAcc" & vbCrLf
      sSql = sSql & "         WHERE GLMASTER = @GlMasterAcc AND HASCHILD IS NULL" & vbCrLf
      sSql = sSql & "         SET @RowCount = @RowCount + 1" & vbCrLf
      sSql = sSql & "         SET @PrevMaster = @GlMasterAcc" & vbCrLf
      sSql = sSql & "      End" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "    End" & vbCrLf
      sSql = sSql & "    FETCH NEXT FROM curAcctStruc INTO @GlMasterAcc, @GLSortKey" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "       " & vbCrLf
      sSql = sSql & "   Close curAcctStruc" & vbCrLf
      sSql = sSql & "   DEALLOCATE curAcctStruc" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   set @level = 7" & vbCrLf
      sSql = sSql & "   WHILE (@level >= 1 )" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "      SET @PrevMaster = ''" & vbCrLf
      sSql = sSql & "        DECLARE curAcctStruc1 CURSOR  FOR" & vbCrLf
      sSql = sSql & "         SELECT DISTINCT GLACCTREF, GLMASTER, GLACCSORTKEY" & vbCrLf
      sSql = sSql & "         From EsReportBalanceSheet" & vbCrLf
      sSql = sSql & "            WHERE GLFSLEVEL = @level AND HASCHILD IS NOT NULL" & vbCrLf
      sSql = sSql & "         order by GLACCSORTKEY" & vbCrLf
      sSql = sSql & "    " & vbCrLf
      sSql = sSql & "        OPEN curAcctStruc1" & vbCrLf
      sSql = sSql & "        FETCH NEXT FROM curAcctStruc1 INTO @GlChildAcct, @GlMasterAcc, @GLSortKey" & vbCrLf
      sSql = sSql & "        WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "        BEGIN" & vbCrLf
      sSql = sSql & "          IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "          BEGIN" & vbCrLf
      sSql = sSql & "            if (@PrevMaster <> @GlChildAcct)" & vbCrLf
      sSql = sSql & "            BEGIN" & vbCrLf
      sSql = sSql & "               SELECT TOP 1 @ChildKey = SortKeyRev,@SortKey = GLACCSORTKEY" & vbCrLf
      sSql = sSql & "               From EsReportBalanceSheet" & vbCrLf
      sSql = sSql & "                  WHERE GLFSLEVEL > @level AND GLMASTER = @GlChildAcct" & vbCrLf
      sSql = sSql & "               order by GLACCSORTKEY desc" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "               UPDATE EsReportBalanceSheet SET" & vbCrLf
      sSql = sSql & "                  SortKeyRev = Cast(@ChildKey as varchar(512)) + char(36)+ @GlMasterAcc" & vbCrLf
      sSql = sSql & "               WHERE GLACCTREF = @GlChildAcct AND GLMASTER = @GlMasterAcc" & vbCrLf
      sSql = sSql & "                  AND GLFSLEVEL = @level" & vbCrLf
      sSql = sSql & "               SET @PrevMaster = @GlChildAcct" & vbCrLf
      sSql = sSql & "            End" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "          End" & vbCrLf
      sSql = sSql & "          FETCH NEXT FROM curAcctStruc1 INTO @GlChildAcct, @GlMasterAcc, @GLSortKey" & vbCrLf
      sSql = sSql & "        End" & vbCrLf
      sSql = sSql & "               " & vbCrLf
      sSql = sSql & "        Close curAcctStruc1" & vbCrLf
      sSql = sSql & "        DEALLOCATE curAcctStruc1" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "        SET @level = @level - 1" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   SELECT GLTOPMaster, GLTOPMASTERDESC, GLACCTREF, GLACCTNO, GLDESCR, GLMASTER, GLTYPE,GLINACTIVE, GLFSLEVEL," & vbCrLf
      sSql = sSql & "      SUMCURBAL , CurrentBal, SUMPREVBAL, PreviousBal, SORTKEYLEVEL, GLACCSORTKEY, SortKeyRev,HASCHILD" & vbCrLf
      sSql = sSql & "   FROM EsReportBalanceSheet ORDER BY SortKeyRev" & vbCrLf
      sSql = sSql & "End"
      
      ExecuteScript False, sSql
      
      'not everyone has this
      If StoreProcedureExists("RptAcctTopBalanceSheet") Then
         sSql = "DROP PROCEDURE RptAcctTopBalanceSheet"
         ExecuteScript False, sSql
      End If

      sSql = "CREATE PROCEDURE [dbo].[RptAcctTopBalanceSheet]" & vbCrLf
      sSql = sSql & "   @StartDate as varchar(12),@EndDate as varchar(12)," & vbCrLf
      sSql = sSql & "   @InclInAcct as varchar(1)" & vbCrLf
      sSql = sSql & "AS" & vbCrLf
      sSql = sSql & "BEGIN " & vbCrLf
      sSql = sSql & "   declare @glAcctRef as varchar(10)" & vbCrLf
      sSql = sSql & "   declare @glMsAcct as varchar(10)" & vbCrLf
      sSql = sSql & "   declare @SumCurBal decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @SumPrevBal as decimal(15,4)" & vbCrLf
      sSql = sSql & "   declare @level as integer" & vbCrLf
      sSql = sSql & "   declare @TopLevelDesc as varchar(30)" & vbCrLf
      sSql = sSql & "   declare @TopLevAcct as varchar(20)" & vbCrLf
      sSql = sSql & "   declare @PrevMaster as varchar(10)" & vbCrLf
      sSql = sSql & "   declare @RowCount as integer" & vbCrLf
      sSql = sSql & "   declare @GlMasterAcc as varchar(10)" & vbCrLf
      sSql = sSql & "   declare @GlChildAcct as varchar(10)" & vbCrLf
      sSql = sSql & "   declare @ChildKey as varchar(1024)" & vbCrLf
      sSql = sSql & "   declare @GLSortKey as varchar(1024)" & vbCrLf
      sSql = sSql & "   declare @SortKey as varchar(1024)" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   DELETE FROM EsReportBalanceSheet" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   if (@InclInAcct = '1')" & vbCrLf
      sSql = sSql & "      SET @InclInAcct = '%'" & vbCrLf
      sSql = sSql & "   Else" & vbCrLf
      sSql = sSql & "      SET @InclInAcct = '0'" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   DECLARE balAcctStruc CURSOR  FOR" & vbCrLf
      sSql = sSql & "      SELECT '1', COASSTACCT, COASSTDESC FROM GlmsTopTable" & vbCrLf
      sSql = sSql & "      Union All" & vbCrLf
      sSql = sSql & "      SELECT '2', COLIABACCT, COLIABDESC FROM GlmsTopTable" & vbCrLf
      sSql = sSql & "      Union All" & vbCrLf
      sSql = sSql & "      SELECT '3', COEQTYACCT, COEQTYDESC FROM GlmsTopTable" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   OPEN balAcctStruc" & vbCrLf
      sSql = sSql & "   FETCH NEXT FROM balAcctStruc INTO @level, @TopLevAcct, @TopLevelDesc" & vbCrLf
      sSql = sSql & "   WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "   BEGIN " & vbCrLf
      sSql = sSql & "      IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "      BEGIN " & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "         ;with cte" & vbCrLf
      sSql = sSql & "         as" & vbCrLf
      sSql = sSql & "         (select GLACCTREF, GLDESCR, GLMASTER, GLFSLEVEL, 0 as level," & vbCrLf
      sSql = sSql & "            cast(cast(@level as varchar(4))+ char(36)+ GLACCTREF as varchar(max)) as SortKey" & vbCrLf
      sSql = sSql & "         From GlacTopTable" & vbCrLf
      sSql = sSql & "         where GLMASTER = cast(@TopLevAcct as varchar(20)) AND GLINACTIVE LIKE @InclInAcct" & vbCrLf
      sSql = sSql & "         Union All" & vbCrLf
      sSql = sSql & "         select a.GLACCTREF, a.GLDESCR, a.GLMASTER, a.GLFSLEVEL, level + 1," & vbCrLf
      sSql = sSql & "          cast(COALESCE(SortKey,'') + char(36) + COALESCE(a.GLACCTREF,'') as varchar(max))as SortKey" & vbCrLf
      sSql = sSql & "         From cte" & vbCrLf
      sSql = sSql & "            inner join GlacTopTable a" & vbCrLf
      sSql = sSql & "               on cte.GLACCTREF = a.GLMASTER" & vbCrLf
      sSql = sSql & "            WHERE GLINACTIVE LIKE @InclInAcct" & vbCrLf
      sSql = sSql & "         )" & vbCrLf
      sSql = sSql & "         INSERT INTO EsReportBalanceSheet (GLTOPMaster, GLTOPMASTERDESC, GLACCTREF, GLDESCR, GLMASTER, GLFSLEVEL,SORTKEYLEVEL,GLACCSORTKEY)" & vbCrLf
      sSql = sSql & "         select @level, @TopLevelDesc," & vbCrLf
      sSql = sSql & "         GLACCTREF , GLDESCR, GLMASTER, GLFSLEVEL, Level, SortKey" & vbCrLf
      sSql = sSql & "         from cte order by SortKey" & vbCrLf
      sSql = sSql & "         " & vbCrLf
      sSql = sSql & "      End" & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM balAcctStruc INTO @level, @TopLevAcct, @TopLevelDesc" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "   Close balAcctStruc" & vbCrLf
      sSql = sSql & "   DEALLOCATE balAcctStruc" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   UPDATE EsReportBalanceSheet SET CurrentBal = foo.Balance" & vbCrLf
      sSql = sSql & "   From" & vbCrLf
      sSql = sSql & "       (SELECT SUM(GjitTopTable.JIDEB) - SUM(GjitTopTable.JICRD) as Balance, JIACCOUNT" & vbCrLf
      sSql = sSql & "         FROM GjhdTable INNER JOIN GjitTopTable ON GJNAME = JINAME" & vbCrLf
      sSql = sSql & "      WHERE GJPOST BETWEEN @StartDate AND @EndDate" & vbCrLf
      sSql = sSql & "         AND GjhdTable.GJPOSTED = 1" & vbCrLf
      sSql = sSql & "      GROUP BY JIACCOUNT) as foo" & vbCrLf
      sSql = sSql & "   Where foo.JIACCOUNT = GLACCTREF" & vbCrLf
      sSql = sSql & "  " & vbCrLf
      sSql = sSql & " UPDATE EsReportBalanceSheet SET PreviousBal = foo.Balance" & vbCrLf
      sSql = sSql & "   From" & vbCrLf
      sSql = sSql & "      (SELECT JIACCOUNT,SUM(GjitTopTable.JIDEB) - SUM(GjitTopTable.JICRD) AS Balance" & vbCrLf
      sSql = sSql & "         FROM GjhdTable INNER JOIN GjitTopTable ON GJNAME = JINAME" & vbCrLf
      sSql = sSql & "      WHERE (GJPOST  <  @StartDate)" & vbCrLf
      sSql = sSql & "         AND GjhdTable.GJPOSTED = 1" & vbCrLf
      sSql = sSql & "      GROUP BY JIACCOUNT) as foo" & vbCrLf
      sSql = sSql & "   Where foo.JIACCOUNT = GLACCTREF" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   set @level = 9" & vbCrLf
      sSql = sSql & "   WHILE (@level >= 1 )" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "      DECLARE curAcctStruc CURSOR  FOR" & vbCrLf
      sSql = sSql & "      SELECT GLMASTER, SUM(ISNULL(SUMCURBAL,0) + (ISNULL(CurrentBal,0))) ," & vbCrLf
      sSql = sSql & "         Sum (IsNull(SUMPREVBAL, 0) + (IsNull(PreviousBal, 0)))" & vbCrLf
      sSql = sSql & "      From" & vbCrLf
      sSql = sSql & "         (SELECT DISTINCT GLACCTREF, GLDESCR, GLMASTER," & vbCrLf
      sSql = sSql & "         CurrentBal , PreviousBal, SUMCURBAL, SUMPREVBAL" & vbCrLf
      sSql = sSql & "         FROM EsReportBalanceSheet WHERE SORTKEYLEVEL = @level) as foo" & vbCrLf
      sSql = sSql & "      group by GLMASTER" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "      OPEN curAcctStruc" & vbCrLf
      sSql = sSql & "      FETCH NEXT FROM curAcctStruc INTO @glMsAcct, @SumCurBal, @SumPrevBal" & vbCrLf
      sSql = sSql & "      WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "      BEGIN" & vbCrLf
      sSql = sSql & "         IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "         BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "           UPDATE EsReportBalanceSheet SET SUMCURBAL = (ISNULL(SUMCURBAL, 0) + @SumCurBal)," & vbCrLf
      sSql = sSql & "               SUMPREVBAL = (ISNULL(SUMPREVBAL, 0) + @SumPrevBal), GLDESCR = 'TOTAL '+ LTRIM(GLDESCR)," & vbCrLf
      sSql = sSql & "            HASCHILD = 1" & vbCrLf
      sSql = sSql & "            WHERE GLACCTREF = @glMsAcct" & vbCrLf
      sSql = sSql & "         End" & vbCrLf
      sSql = sSql & "         FETCH NEXT FROM curAcctStruc INTO @glMsAcct, @SumCurBal, @SumPrevBal" & vbCrLf
      sSql = sSql & "      End" & vbCrLf
      sSql = sSql & "            " & vbCrLf
      sSql = sSql & "      Close curAcctStruc" & vbCrLf
      sSql = sSql & "      DEALLOCATE curAcctStruc" & vbCrLf
      sSql = sSql & "      " & vbCrLf
      sSql = sSql & "      SET @level = @level - 1" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   " & vbCrLf
      sSql = sSql & "   UPDATE EsReportBalanceSheet SET SUMCURBAL = CurrentBal WHERE SUMCURBAL IS NULL" & vbCrLf
      sSql = sSql & "   UPDATE EsReportBalanceSheet SET SUMPREVBAL = PreviousBal WHERE SUMPREVBAL IS NULL" & vbCrLf
      sSql = sSql & " " & vbCrLf
      sSql = sSql & "   set @level = 0" & vbCrLf
      sSql = sSql & "   set @RowCount = 1" & vbCrLf
      sSql = sSql & "   SET @PrevMaster = ''" & vbCrLf
      sSql = sSql & "   DECLARE curAcctStruc CURSOR  FOR" & vbCrLf
      sSql = sSql & "      SELECT GLMASTER, GLACCSORTKEY" & vbCrLf
      sSql = sSql & "      From EsReportBalanceSheet" & vbCrLf
      sSql = sSql & "         WHERE HASCHILD IS NULL" & vbCrLf
      sSql = sSql & "      ORDER BY GLACCSORTKEY" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   OPEN curAcctStruc" & vbCrLf
      sSql = sSql & "   FETCH NEXT FROM curAcctStruc INTO @GlMasterAcc, @GLSortKey" & vbCrLf
      sSql = sSql & "   WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "    IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "    BEGIN" & vbCrLf
      sSql = sSql & "      if (@PrevMaster <> @GlMasterAcc)" & vbCrLf
      sSql = sSql & "      BEGIN" & vbCrLf
      sSql = sSql & "         UPDATE EsReportBalanceSheet SET" & vbCrLf
      sSql = sSql & "            SortKeyRev = RIGHT ('0000'+ Cast(@RowCount as varchar), 4) + char(36)+ @GlMasterAcc" & vbCrLf
      sSql = sSql & "         WHERE GLMASTER = @GlMasterAcc AND HASCHILD IS NULL" & vbCrLf
      sSql = sSql & "         SET @RowCount = @RowCount + 1" & vbCrLf
      sSql = sSql & "         SET @PrevMaster = @GlMasterAcc" & vbCrLf
      sSql = sSql & "      End" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "    End" & vbCrLf
      sSql = sSql & "    FETCH NEXT FROM curAcctStruc INTO @GlMasterAcc, @GLSortKey" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "       " & vbCrLf
      sSql = sSql & "   Close curAcctStruc" & vbCrLf
      sSql = sSql & "   DEALLOCATE curAcctStruc" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   set @level = 8" & vbCrLf
      sSql = sSql & "   WHILE (@level >= 0)" & vbCrLf
      sSql = sSql & "   BEGIN" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "      SET @PrevMaster = ''" & vbCrLf
      sSql = sSql & "        DECLARE curAcctStruc1 CURSOR  FOR" & vbCrLf
      sSql = sSql & "         SELECT DISTINCT GLACCTREF, GLMASTER, GLACCSORTKEY" & vbCrLf
      sSql = sSql & "         From EsReportBalanceSheet" & vbCrLf
      sSql = sSql & "            WHERE SORTKEYLEVEL = @level AND HASCHILD IS NOT NULL" & vbCrLf
      sSql = sSql & "         order by GLACCSORTKEY" & vbCrLf
      sSql = sSql & "    " & vbCrLf
      sSql = sSql & "        OPEN curAcctStruc1" & vbCrLf
      sSql = sSql & "        FETCH NEXT FROM curAcctStruc1 INTO @GlChildAcct, @GlMasterAcc, @GLSortKey" & vbCrLf
      sSql = sSql & "        WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
      sSql = sSql & "        BEGIN" & vbCrLf
      sSql = sSql & "          IF (@@FETCH_STATUS <> -2)" & vbCrLf
      sSql = sSql & "          BEGIN" & vbCrLf
      sSql = sSql & "            if (@PrevMaster <> @GlChildAcct)" & vbCrLf
      sSql = sSql & "            BEGIN" & vbCrLf
      sSql = sSql & "               SELECT TOP 1 @ChildKey = SortKeyRev,@SortKey = GLACCSORTKEY" & vbCrLf
      sSql = sSql & "               From EsReportBalanceSheet" & vbCrLf
      sSql = sSql & "                  WHERE SORTKEYLEVEL > @level AND GLMASTER = @GlChildAcct" & vbCrLf
      sSql = sSql & "               order by GLACCSORTKEY desc" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "               UPDATE EsReportBalanceSheet SET" & vbCrLf
      sSql = sSql & "                  SortKeyRev = Cast(@ChildKey as varchar(512)) + char(36)+ @GlMasterAcc" & vbCrLf
      sSql = sSql & "               WHERE GLACCTREF = @GlChildAcct AND GLMASTER = @GlMasterAcc" & vbCrLf
      sSql = sSql & "                  AND SORTKEYLEVEL = @level" & vbCrLf
      sSql = sSql & "               SET @PrevMaster = @GlChildAcct" & vbCrLf
      sSql = sSql & "            End" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "          End" & vbCrLf
      sSql = sSql & "          FETCH NEXT FROM curAcctStruc1 INTO @GlChildAcct, @GlMasterAcc, @GLSortKey" & vbCrLf
      sSql = sSql & "        End" & vbCrLf
      sSql = sSql & "               " & vbCrLf
      sSql = sSql & "        Close curAcctStruc1" & vbCrLf
      sSql = sSql & "        DEALLOCATE curAcctStruc1" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "        SET @level = @level - 1" & vbCrLf
      sSql = sSql & "   End" & vbCrLf
      sSql = sSql & "" & vbCrLf
      sSql = sSql & "   SELECT GLTOPMaster, GLTOPMASTERDESC, GLACCTREF, GLACCTNO, GLDESCR, GLMASTER, GLTYPE,GLINACTIVE, GLFSLEVEL," & vbCrLf
      sSql = sSql & "      SUMCURBAL , CurrentBal, SUMPREVBAL, PreviousBal, SORTKEYLEVEL, GLACCSORTKEY, SortKeyRev,HASCHILD" & vbCrLf
      sSql = sSql & "   FROM EsReportBalanceSheet ORDER BY SortKeyRev" & vbCrLf
      sSql = sSql & "End"
      ExecuteScript False, sSql

SQL = "DropStoredProcedureIfExists 'GetMOOverHead'" & vbCrLf
ExecuteScript False, SQL

SQL = "create PROCEDURE [dbo].[GetMOOverHead]" & vbCrLf
SQL = SQL & "@InputLotNum as varchar(15),@MOPart as varchar(30),@MORun as int," & vbCrLf
SQL = SQL & "@MOQty as decimal(15,4), @CalTotOH decimal(15,4) OUTPUT" & vbCrLf
SQL = SQL & "-- modified 5/7/2018 by TEL -- never worked! semicolon before with CTE, dup set stmt, and comment out prints" & vbCrLf
SQL = SQL & "AS" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "set nocount on" & vbCrLf
SQL = SQL & "declare @SumTotMat decimal(15,4)" & vbCrLf
SQL = SQL & "declare @SumTotLabor decimal(15,4)" & vbCrLf
SQL = SQL & "declare @SumTotExp decimal(15,4)" & vbCrLf
SQL = SQL & "declare @SumTotOH decimal(15,4)" & vbCrLf
SQL = SQL & "declare @LotTotOH decimal (15,4)" & vbCrLf
SQL = SQL & "declare @level as integer" & vbCrLf
SQL = SQL & "declare @Part as varchar(30)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "declare @PrevParent  as varchar(30)" & vbCrLf
SQL = SQL & "declare @RowCount as integer" & vbCrLf
SQL = SQL & "declare @ChildPart as varchar(30)" & vbCrLf
SQL = SQL & "declare @ParentPart as varchar(30)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "declare @ChildKey as varchar(1024)" & vbCrLf
SQL = SQL & "declare @GLSortKey as varchar(1024)" & vbCrLf
SQL = SQL & "declare @SortKey as varchar(1024)" & vbCrLf
SQL = SQL & "declare @ParentLotNum as varchar(15)" & vbCrLf
SQL = SQL & "declare @Maxlevel as int" & vbCrLf
SQL = SQL & "declare @LotRunNo as int" & vbCrLf
SQL = SQL & "declare @LotOrgQty as decimal(15,4)" & vbCrLf
SQL = SQL & "--declare @MOPart as varchar(30)" & vbCrLf
SQL = SQL & "--declare @MORun as int" & vbCrLf
SQL = SQL & "--declare @MOQty as decimal(15,4)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "CREATE TABLE #tempMOPartsDetail" & vbCrLf
SQL = SQL & "(" & vbCrLf
SQL = SQL & "INMOPART Varchar(30) NULL," & vbCrLf
SQL = SQL & "INMORUN int NULL ," & vbCrLf
SQL = SQL & "INPART varchar(30) NULL ," & vbCrLf
SQL = SQL & "LOTNUMBER varchar(15) NULL," & vbCrLf
SQL = SQL & "INTOTMATL decimal(12,4) NULL," & vbCrLf
SQL = SQL & "INTOTLABOR decimal(12,4) NULL," & vbCrLf
SQL = SQL & "INTOTEXP decimal(12,4) NULL," & vbCrLf
SQL = SQL & "INTOTOH decimal(12,4) NULL," & vbCrLf
SQL = SQL & "LOTTOTMATL decimal(12,4) NULL," & vbCrLf
SQL = SQL & "LOTTOTLABOR decimal(12,4) NULL," & vbCrLf
SQL = SQL & "LOTTOTEXP decimal(12,4) NULL," & vbCrLf
SQL = SQL & "LOTTOTOH decimal(12,4) NULL," & vbCrLf
SQL = SQL & "SUMTOTMAL decimal(12,4) NULL," & vbCrLf
SQL = SQL & "SUMTOTLABOR decimal(12,4) NULL," & vbCrLf
SQL = SQL & "SUMTOTEXP decimal(12,4) NULL," & vbCrLf
SQL = SQL & "SUMTOTOH decimal(12,4) NULL," & vbCrLf
SQL = SQL & "LOTDATECOSTED smalldatetime NULL," & vbCrLf
SQL = SQL & "SortKey varchar(512) NULL," & vbCrLf
SQL = SQL & "HASCHILD int NULL," & vbCrLf
SQL = SQL & "SORTKEYLEVEL tinyint NULL," & vbCrLf
SQL = SQL & "SortKeyRev varchar(512)," & vbCrLf
SQL = SQL & "PARTSUM varchar(40)," & vbCrLf
SQL = SQL & "BMQTYREQD decimal(12,4) NULL," & vbCrLf
SQL = SQL & "LOTORGQTY decimal(12,4) NULL," & vbCrLf
SQL = SQL & "BMTOTOH decimal(12,4) NULL" & vbCrLf
SQL = SQL & ")" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "--ALTER TABLE tempMOPartsDetail ADD SortKeyRev varchar(512)" & vbCrLf
SQL = SQL & "--ALTER TABLE tempMOPartsDetail ADD PARTSUM varchar(40)" & vbCrLf
SQL = SQL & "--ALTER TABLE tempMOPartsDetail ADD BMQTYREQD decimal(12,4) NULL, LOTORGQTY decimal(12,4) NULL" & vbCrLf
SQL = SQL & "--ALTER TABLE tempMOPartsDetail ADD BMTOTOH decimal(12,4) NULL" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- DELETE FROM tempMOPartsDetail" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "IF (@InputLotNum <> '')" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "SELECT @MOPart = LOTMOPARTREF,@MORun =LOTMORUNNO, @MOQty = LOTORIGINALQTY" & vbCrLf
SQL = SQL & "FROM LohdTable WHERE LOTNUMBER = @InputLotNum" & vbCrLf
SQL = SQL & "END" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & ";with cte" & vbCrLf
SQL = SQL & "as" & vbCrLf
SQL = SQL & "(select BMASSYPART, BMPARTREF,  BMQTYREQD,0 as level, cast('1' + char(36)+ BMPARTREF as varchar(max)) as SortKey" & vbCrLf
SQL = SQL & "from BmplTable" & vbCrLf
SQL = SQL & "where BMASSYPART = @MOPart" & vbCrLf
SQL = SQL & "union all" & vbCrLf
SQL = SQL & "select a.BMASSYPART, a.BMPARTREF, a.BMQTYREQD, level + 1," & vbCrLf
SQL = SQL & "cast(COALESCE(SortKey,'') + char(36) + COALESCE(a.BMPARTREF,'') as varchar(max))as SortKey" & vbCrLf
SQL = SQL & "from cte" & vbCrLf
SQL = SQL & "inner join BmplTable a" & vbCrLf
SQL = SQL & "on cte.BMPARTREF = a.BMASSYPART" & vbCrLf
SQL = SQL & ")" & vbCrLf
SQL = SQL & "INSERT INTO #tempMOPartsDetail(INMOPART,INPART,BMQTYREQD,SORTKEYLEVEL,SortKey)" & vbCrLf
SQL = SQL & "select BMASSYPART, BMPARTREF,BMQTYREQD,level,SortKey" & vbCrLf
SQL = SQL & "from cte order by SortKey" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "END" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "--print 'TopLevel:' + @MOPart + ' RUN:' + convert(varchar(10), @MORun)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "--// update the top level" & vbCrLf
SQL = SQL & "UPDATE #tempMOPartsDetail SET INMORUN = @MORun, LOTNUMBER = b.INLOTNUMBER," & vbCrLf
SQL = SQL & "INTOTMATL = b.INTOTMATL, INTOTLABOR = b.INTOTLABOR," & vbCrLf
SQL = SQL & "INTOTEXP = b.INTOTEXP, INTOTOH = b.INTOTOH," & vbCrLf
SQL = SQL & "LOTTOTMATL = c.LOTTOTMATL, LOTTOTLABOR = c.LOTTOTLABOR," & vbCrLf
SQL = SQL & "LOTTOTEXP = c.LOTTOTEXP, LOTTOTOH = c.LOTTOTOH," & vbCrLf
SQL = SQL & "LOTDATECOSTED = c.LOTDATECOSTED, LOTORGQTY = c.LOTORIGINALQTY," & vbCrLf
SQL = SQL & "BMTOTOH = (c.LOTTOTOH * BMQTYREQD) / c.LOTORIGINALQTY" & vbCrLf
SQL = SQL & "FROM #tempMOPartsDetail d, InvaTable b, LohdTable c" & vbCrLf
SQL = SQL & "WHERE d.INMOPART = b.INMOPART AND d.INPART = b.INPART" & vbCrLf
SQL = SQL & "AND b.INLOTNUMBER = c.LOTnumber" & vbCrLf
SQL = SQL & "and c.lotpartref = b.INPART" & vbCrLf
SQL = SQL & "and b.INMOPART = @MOPart AND b.INMORUN  = @MORun" & vbCrLf
SQL = SQL & "AND b.INTYPE = 10 AND SORTKEYLEVEL = 0" & vbCrLf
SQL = SQL & "AND c.LOTORIGINALQTY <> 0" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "--// set the totals for" & vbCrLf
SQL = SQL & "SELECT @Maxlevel =  MAX(SORTKEYLEVEL) FROM #tempMOPartsDetail" & vbCrLf
SQL = SQL & "SET @level  = 1" & vbCrLf
SQL = SQL & "WHILE (@level <= @Maxlevel )" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "DECLARE curMORun CURSOR  FOR" & vbCrLf
SQL = SQL & "SELECT DISTINCT INMOPART,INPART" & vbCrLf
SQL = SQL & "FROM #tempMOPartsDetail WHERE SORTKEYLEVEL = @level" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "OPEN curMORun" & vbCrLf
SQL = SQL & "FETCH NEXT FROM curMORun INTO @MOPart, @Part" & vbCrLf
SQL = SQL & "WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "IF (@@FETCH_STATUS <> -2)" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "SELECT @ParentLotNum = LOTNUMBER FROM #tempMOPartsDetail  WHERE" & vbCrLf
SQL = SQL & "INPART = @MOPart AND SORTKEYLEVEL = @level - 1" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "SELECT @LotRunNo = LOTMORUNNO, @LotOrgQty = LOTORIGINALQTY" & vbCrLf
SQL = SQL & "FROM lohdTable where LOTNUMBER = @ParentLotNum" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "--print 'InLoopLevel:' + @MOPart + ' RUN:' + convert(varchar(10), @LotRunNo)" & vbCrLf
SQL = SQL & "--// update the top level" & vbCrLf
SQL = SQL & "UPDATE #tempMOPartsDetail SET INMORUN = @LotRunNo, LOTNUMBER = b.INLOTNUMBER," & vbCrLf
SQL = SQL & "INTOTMATL = b.INTOTMATL, INTOTLABOR = b.INTOTLABOR," & vbCrLf
SQL = SQL & "INTOTEXP = b.INTOTEXP, INTOTOH = b.INTOTOH," & vbCrLf
SQL = SQL & "LOTTOTMATL = c.LOTTOTMATL, LOTTOTLABOR = c.LOTTOTLABOR," & vbCrLf
SQL = SQL & "LOTTOTEXP = c.LOTTOTEXP, LOTTOTOH = c.LOTTOTOH," & vbCrLf
SQL = SQL & "LOTDATECOSTED = c.LOTDATECOSTED, LOTORGQTY = @LotOrgQty," & vbCrLf
SQL = SQL & "BMTOTOH = (c.LOTTOTOH * BMQTYREQD) / @LotOrgQty" & vbCrLf
SQL = SQL & "FROM #tempMOPartsDetail d, InvaTable b, LohdTable c" & vbCrLf
SQL = SQL & "WHERE d.INMOPART = b.INMOPART AND d.INPART = b.INPART" & vbCrLf
SQL = SQL & "AND b.INLOTNUMBER = c.LOTnumber" & vbCrLf
SQL = SQL & "and c.lotpartref = b.INPART" & vbCrLf
SQL = SQL & "and b.INMOPART = @MOPart AND b.INMORUN  = @LotRunNo" & vbCrLf
SQL = SQL & "AND b.INTYPE = 10 AND SORTKEYLEVEL = @level" & vbCrLf
SQL = SQL & "AND c.LOTORIGINALQTY <> 0" & vbCrLf
SQL = SQL & "End" & vbCrLf
SQL = SQL & "FETCH NEXT FROM curMORun INTO @MOPart, @Part" & vbCrLf
SQL = SQL & "End" & vbCrLf
SQL = SQL & "Close curMORun" & vbCrLf
SQL = SQL & "DEALLOCATE curMORun" & vbCrLf
SQL = SQL & "SET @level = @level + 1" & vbCrLf
SQL = SQL & "End" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "SELECT @level =  MAX(SORTKEYLEVEL) FROM #tempMOPartsDetail" & vbCrLf
SQL = SQL & "WHILE (@level >= 0 )" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "DECLARE curMODet CURSOR  FOR" & vbCrLf
SQL = SQL & "--SELECT INPART, LOTTOTMATL, LOTTOTLABOR, LOTTOTEXP , LOTTOTOH FROM tempMOPartsDetail" & vbCrLf
SQL = SQL & "-- WHERE INPART = '775345149'" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "SELECT INMOPART," & vbCrLf
SQL = SQL & "SUM(IsNull(LOTTOTMATL, 0)), SUM(ISNULL(LOTTOTLABOR,0)) ," & vbCrLf
SQL = SQL & "Sum (IsNull(LOTTOTEXP, 0)) , SUM(IsNull(BMTOTOH, 0))" & vbCrLf
SQL = SQL & "From" & vbCrLf
SQL = SQL & "(SELECT DISTINCT INMOPART,INMORUN,INPART,LOTTOTMATL,LOTTOTLABOR," & vbCrLf
SQL = SQL & "LOTTOTEXP,LOTTOTOH,SUMTOTMAL,SUMTOTLABOR, SUMTOTEXP, SUMTOTOH,BMTOTOH" & vbCrLf
SQL = SQL & "FROM #tempMOPartsDetail WHERE SORTKEYLEVEL = @level) as foo" & vbCrLf
SQL = SQL & "group by INMOPART" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "OPEN curMODet" & vbCrLf
SQL = SQL & "FETCH NEXT FROM curMODet INTO @MOPart, @SumTotMat, @SumTotLabor,@SumTotExp,@SumTotOH" & vbCrLf
SQL = SQL & "WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "IF (@@FETCH_STATUS <> -2)" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "--print 'PartNum : ' + @MOPart" & vbCrLf
SQL = SQL & "--print 'SumTotoh : ' + Convert(varchar(24), @SumTotOH)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "UPDATE #tempMOPartsDetail SET SUMTOTMAL = LOTTOTMATL + @SumTotMat," & vbCrLf
SQL = SQL & "SUMTOTLABOR = LOTTOTLABOR + @SumTotLabor," & vbCrLf
SQL = SQL & "SUMTOTEXP = LOTTOTEXP + @SumTotExp, SUMTOTOH = (BMTOTOH + @SumTotOH) * @MOQty ," & vbCrLf
SQL = SQL & "HASCHILD = 1,PARTSUM = 'TOTAL ' + LTRIM(INPART)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "WHERE INPART = @MOPart AND SORTKEYLEVEL = @level - 1" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "End" & vbCrLf
SQL = SQL & "FETCH NEXT FROM curMODet INTO @MOPart, @SumTotMat, @SumTotLabor,@SumTotExp,@SumTotOH" & vbCrLf
SQL = SQL & "End" & vbCrLf
SQL = SQL & "Close curMODet" & vbCrLf
SQL = SQL & "DEALLOCATE curMODet" & vbCrLf
SQL = SQL & "SET @level = @level - 1" & vbCrLf
SQL = SQL & "End" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "--// update the Lower level cost detail" & vbCrLf
SQL = SQL & "UPDATE #tempMOPartsDetail SET SUMTOTMAL = LOTTOTMATL, SUMTOTLABOR = LOTTOTLABOR," & vbCrLf
SQL = SQL & "SUMTOTEXP = LOTTOTEXP, SUMTOTOH = BMTOTOH WHERE HASCHILD IS NULL" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "SET @SumTotMat  = 0" & vbCrLf
SQL = SQL & "SET @SumTotLabor  = 0" & vbCrLf
SQL = SQL & "SET @SumTotExp  = 0" & vbCrLf
SQL = SQL & "SET @SumTotOH  = 0" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "--// Udpate the Root total" & vbCrLf
SQL = SQL & "SELECT @SumTotMat = SUM(SUMTOTMAL), @SumTotLabor = SUM(SUMTOTLABOR)," & vbCrLf
SQL = SQL & "@SumTotExp = SUM(SUMTOTEXP) ,@SumTotOH = SUM(SUMTOTOH)" & vbCrLf
SQL = SQL & "FROM #tempMOPartsDetail WHERE SORTKEYLEVEL = 0" & vbCrLf
SQL = SQL & "AND  RTRIM(INMOPART) <> RTRIM(INPART)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "UPDATE #tempMOPartsDetail SET PARTSUM = INPART" & vbCrLf
SQL = SQL & "WHERE PARTSUM IS NULL" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "----  SELECT * FROM tempMOPartsDetail WHERE SORTKEYLEVEL = 0" & vbCrLf
SQL = SQL & "----AND  RTRIM(INMOPART) = RTRIM(INPART)" & vbCrLf
SQL = SQL & "--// Reverse the partnumbers." & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "set @level = 0" & vbCrLf
SQL = SQL & "SET @RowCount = 1" & vbCrLf
SQL = SQL & "SET @PrevParent = ''" & vbCrLf
SQL = SQL & "DECLARE curAcctStruc CURSOR  FOR" & vbCrLf
SQL = SQL & "SELECT INMOPART, SortKey" & vbCrLf
SQL = SQL & "FROM #tempMOPartsDetail" & vbCrLf
SQL = SQL & "WHERE HASCHILD IS NULL --GLFSLEVEL = 8 --AND GLMASTER ='AA10'--GLTOPMaster = 1 AND" & vbCrLf
SQL = SQL & "ORDER BY SortKey" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "OPEN curAcctStruc" & vbCrLf
SQL = SQL & "FETCH NEXT FROM curAcctStruc INTO @ParentPart, @SortKey" & vbCrLf
SQL = SQL & "WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "IF (@@FETCH_STATUS <> -2)" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "if (@PrevParent <> @ParentPart)" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "UPDATE #tempMOPartsDetail SET" & vbCrLf
SQL = SQL & "SortKeyRev = RIGHT ('0000'+ Cast(@RowCount as varchar), 4) + char(36)+ @ParentPart" & vbCrLf
SQL = SQL & "WHERE INMOPART = @ParentPart AND HASCHILD IS NULL --GLFSLEVEL = 8 --AND GLTOPMaster = 1" & vbCrLf
SQL = SQL & "SET @RowCount = @RowCount + 1" & vbCrLf
SQL = SQL & "SET @PrevParent = @ParentPart" & vbCrLf
SQL = SQL & "END" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "End" & vbCrLf
SQL = SQL & "FETCH NEXT FROM curAcctStruc INTO @ParentPart, @SortKey" & vbCrLf
SQL = SQL & "End" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "Close curAcctStruc" & vbCrLf
SQL = SQL & "DEALLOCATE curAcctStruc" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "SELECT @level =  MAX(SORTKEYLEVEL) FROM #tempMOPartsDetail" & vbCrLf
SQL = SQL & "--set @level = 7" & vbCrLf
SQL = SQL & "WHILE (@level >= 0 )" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "SET @PrevParent = ''" & vbCrLf
SQL = SQL & "DECLARE curAcctStruc1 CURSOR  FOR" & vbCrLf
SQL = SQL & "SELECT DISTINCT INPART, INMOPART, SortKey" & vbCrLf
SQL = SQL & "FROM #tempMOPartsDetail" & vbCrLf
SQL = SQL & "WHERE SORTKEYLEVEL = @level AND HASCHILD IS NOT NULL--GLTOPMaster = 1 AND" & vbCrLf
SQL = SQL & "order by SortKey" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "OPEN curAcctStruc1" & vbCrLf
SQL = SQL & "FETCH NEXT FROM curAcctStruc1 INTO @ChildPart, @ParentPart, @SortKey" & vbCrLf
SQL = SQL & "WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "IF (@@FETCH_STATUS <> -2)" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "if (@PrevParent <> @ChildPart)" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "--print 'Record' + @ChildPart + ':' + @ParentPart" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "SELECT TOP 1 @ChildKey = SortKeyRev,@SortKey = SortKey" & vbCrLf
SQL = SQL & "FROM #tempMOPartsDetail" & vbCrLf
SQL = SQL & "WHERE SORTKEYLEVEL > @level AND INMOPART = @ChildPart --GLTOPMaster = 1 AND" & vbCrLf
SQL = SQL & "order by SortKey desc" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "UPDATE #tempMOPartsDetail SET" & vbCrLf
SQL = SQL & "SortKeyRev = Cast(@ChildKey as varchar(256)) + char(36)+ @ParentPart" & vbCrLf
SQL = SQL & "WHERE INPART = @ChildPart AND INMOPART = @ParentPart" & vbCrLf
SQL = SQL & "AND SORTKEYLEVEL = @level --GLTOPMaster = 1 AND" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "SET @PrevParent = @ChildPart" & vbCrLf
SQL = SQL & "END" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "End" & vbCrLf
SQL = SQL & "FETCH NEXT FROM curAcctStruc1 INTO @ChildPart, @ParentPart, @SortKey" & vbCrLf
SQL = SQL & "End" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "Close curAcctStruc1" & vbCrLf
SQL = SQL & "DEALLOCATE curAcctStruc1" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "SET @level = @level - 1" & vbCrLf
SQL = SQL & "End" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "SELECT @LotTotOH = ISNULL(LOTTOTOH, 0) from lohdTable where lotpartref = @MOPart  AND LOTMORUNNO = @MORun" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "--print 'LOT OH:' + Convert(varchar(10), @LotTotOH)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "SELECT @CalTotOH = SUM(ISNULL(BMTOTOH, 0)) + ISNULL(@LotTotOH, 0) FROM #tempMOPartsDetail" & vbCrLf
SQL = SQL & "WHERE SORTKEYLEVEL = 0" & vbCrLf
SQL = SQL & "--print 'GetMOOverHead: CalOH:' + convert(varchar(10), @CalTotOH)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "DROP table #tempMOPartsDetail" & vbCrLf
SQL = SQL & "END" & vbCrLf
ExecuteScript False, SQL

SQL = "DropStoredProcedureIfExists 'RptChartOfAccount'" & vbCrLf
ExecuteScript False, SQL

SQL = "CREATE PROCEDURE RptChartOfAccount" & vbCrLf
SQL = SQL & "@InclIncAcct as varchar(1)" & vbCrLf
SQL = SQL & "AS" & vbCrLf
SQL = SQL & "/*" & vbCrLf
SQL = SQL & "05/09/2018 TEL - changed 'with cte' to ';with cte'" & vbCrLf
SQL = SQL & "test" & vbCrLf
SQL = SQL & "exec RptChartOfAccount 0" & vbCrLf
SQL = SQL & "*/" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "declare @glAcctRef as varchar(10)" & vbCrLf
SQL = SQL & "declare @glMsAcct as varchar(10)" & vbCrLf
SQL = SQL & "declare @TopLevelDesc as varchar(30)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "declare @level as varchar(12)" & vbCrLf
SQL = SQL & "declare @InclInAcct as Integer" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "if (@InclIncAcct = '1')" & vbCrLf
SQL = SQL & "SET @InclInAcct = ''" & vbCrLf
SQL = SQL & "else" & vbCrLf
SQL = SQL & "SET @InclInAcct = '0'" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "CREATE TABLE #tempChartOfAcct(" & vbCrLf
SQL = SQL & "[TOPLEVEL] [varchar](12) NULL," & vbCrLf
SQL = SQL & "[TOPLEVELDESC] [varchar](30) NULL," & vbCrLf
SQL = SQL & "[GLACCTREF] [varchar](112) NULL," & vbCrLf
SQL = SQL & "[GLDESCR] [varchar](120) NULL," & vbCrLf
SQL = SQL & "[GLMASTER] [varchar](12) NULL," & vbCrLf
SQL = SQL & "[GLFSLEVEL] [INT] NULL," & vbCrLf
SQL = SQL & "[GLINACTIVE] [int] NULL," & vbCrLf
SQL = SQL & "[SORTKEYLEVEL] [int] NULL," & vbCrLf
SQL = SQL & "[GLACCSORTKEY] [varchar](512) NULL" & vbCrLf
SQL = SQL & ")" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "DECLARE balAcctStruc CURSOR  FOR" & vbCrLf
SQL = SQL & "SELECT COASSTACCT, COASSTDESC FROM GlmsTable" & vbCrLf
SQL = SQL & "UNION ALL" & vbCrLf
SQL = SQL & "SELECT COLIABACCT, COLIABDESC FROM GlmsTable" & vbCrLf
SQL = SQL & "UNION ALL" & vbCrLf
SQL = SQL & "SELECT COINCMACCT, COINCMDESC FROM GlmsTable" & vbCrLf
SQL = SQL & "UNION ALL" & vbCrLf
SQL = SQL & "SELECT COEQTYACCT, COEQTYDESC FROM GlmsTable" & vbCrLf
SQL = SQL & "UNION ALL" & vbCrLf
SQL = SQL & "SELECT COCOGSACCT, COCOGSDESC FROM GlmsTable" & vbCrLf
SQL = SQL & "UNION ALL" & vbCrLf
SQL = SQL & "SELECT COEXPNACCT, COEXPNDESC FROM GlmsTable" & vbCrLf
SQL = SQL & "UNION ALL" & vbCrLf
SQL = SQL & "SELECT COOINCACCT, COOINCDESC FROM GlmsTable" & vbCrLf
SQL = SQL & "UNION ALL" & vbCrLf
SQL = SQL & "SELECT COFDTXACCT, COFDTXDESC FROM GlmsTable" & vbCrLf
SQL = SQL & "UNION ALL" & vbCrLf
SQL = SQL & "SELECT COOEXPACCT, COOEXPDESC FROM GlmsTable" & vbCrLf
SQL = SQL & "--UNION ALL" & vbCrLf
SQL = SQL & "--SELECT COFDTXACCT, COFDTXDESC FROM GlmsTable" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "OPEN balAcctStruc" & vbCrLf
SQL = SQL & "FETCH NEXT FROM balAcctStruc INTO @level, @TopLevelDesc" & vbCrLf
SQL = SQL & "WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "IF (@@FETCH_STATUS <> -2)" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "INSERT INTO #tempChartOfAcct(TOPLEVEL, TOPLEVELDESC, GLACCTREF, GLDESCR, GLMASTER, GLFSLEVEL,GLINACTIVE, SORTKEYLEVEL,GLACCSORTKEY)" & vbCrLf
SQL = SQL & "select @level as TopLevel, @TopLevelDesc as TopLevelDesc, @level as GLACCTREF," & vbCrLf
SQL = SQL & "@TopLevelDesc as GLDESCR, '' as GLMASTER, 0 as GLFSLEVEL, 0,0 as level, @level as SortKey" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & ";with cte" & vbCrLf
SQL = SQL & "as" & vbCrLf
SQL = SQL & "(select GLACCTREF, GLDESCR, GLMASTER, GLFSLEVEL, GLINACTIVE, 0 as level," & vbCrLf
SQL = SQL & "cast(cast(@level as varchar(12))+ char(36)+ GLACCTREF as varchar(max)) as SortKey" & vbCrLf
SQL = SQL & "from GlacTable" & vbCrLf
SQL = SQL & "where GLMASTER = cast(@level as varchar(12)) AND GLINACTIVE LIKE @InclInAcct" & vbCrLf
SQL = SQL & "union all" & vbCrLf
SQL = SQL & "select a.GLACCTREF, a.GLDESCR, a.GLMASTER, a.GLFSLEVEL, a.GLINACTIVE, level + 1," & vbCrLf
SQL = SQL & "cast(COALESCE(SortKey,'') + char(36) + COALESCE(a.GLACCTREF,'') as varchar(max))as SortKey" & vbCrLf
SQL = SQL & "from cte" & vbCrLf
SQL = SQL & "inner join GlacTable a" & vbCrLf
SQL = SQL & "on cte.GLACCTREF = a.GLMASTER" & vbCrLf
SQL = SQL & "WHERE a.GLINACTIVE LIKE @InclInAcct" & vbCrLf
SQL = SQL & ")" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "INSERT INTO #tempChartOfAcct(TOPLEVEL, TOPLEVELDESC, GLACCTREF, GLDESCR, GLMASTER, GLFSLEVEL,GLINACTIVE, SORTKEYLEVEL,GLACCSORTKEY)" & vbCrLf
SQL = SQL & "select @level as TopLevel, @TopLevelDesc as TopLevelDesc," & vbCrLf
SQL = SQL & "Replicate('  ', level) + GLACCTREF as GLACCTREF," & vbCrLf
SQL = SQL & "Replicate('  ', level) + GLDESCR as GLDESCR, GLMASTER," & vbCrLf
SQL = SQL & "GLFSLEVEL, GLINACTIVE,level, SortKey" & vbCrLf
SQL = SQL & "from cte order by SortKey" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "END" & vbCrLf
SQL = SQL & "FETCH NEXT FROM balAcctStruc INTO @level, @TopLevelDesc" & vbCrLf
SQL = SQL & "END" & vbCrLf
SQL = SQL & "CLOSE balAcctStruc" & vbCrLf
SQL = SQL & "DEALLOCATE balAcctStruc" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "SELECT TOPLEVEL, TOPLEVELDESC, GLACCTREF, GLDESCR, GLMASTER," & vbCrLf
SQL = SQL & "GLFSLEVEL,GLINACTIVE, SORTKEYLEVEL,GLACCSORTKEY" & vbCrLf
SQL = SQL & "FROM #tempChartOfAcct ORDER BY GLACCSORTKEY" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "DROP table #tempChartOfAcct" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "End" & vbCrLf
SQL = SQL & "" & vbCrLf
ExecuteScript False, SQL

SQL = "DropStoredProcedureIfExists 'RptIncomeStatement'" & vbCrLf
ExecuteScript False, SQL

SQL = "CREATE PROCEDURE RptIncomeStatement" & vbCrLf
SQL = SQL & "@StartDate as varchar(12),@EndDate as varchar(12)," & vbCrLf
SQL = SQL & "@YearBeginDate as varchar(12), @InclIncAcct as varchar(1)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "--05/09/2018 TEL - changed 'with cte' to ';with cte'" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "AS" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "declare @glAcctRef as varchar(10)" & vbCrLf
SQL = SQL & "declare @glMsAcct as varchar(10)" & vbCrLf
SQL = SQL & "declare @SumCurBal decimal(15,4)" & vbCrLf
SQL = SQL & "declare @SumYTD decimal(15,4)" & vbCrLf
SQL = SQL & "declare @SumPrevBal as decimal(15,4)" & vbCrLf
SQL = SQL & "declare @level as integer" & vbCrLf
SQL = SQL & "declare @TopLevelDesc as varchar(30)" & vbCrLf
SQL = SQL & "declare @InclInAcct as Integer" & vbCrLf
SQL = SQL & "declare @TopLevAcct as varchar(20)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "declare @PrevMaster as varchar(10)" & vbCrLf
SQL = SQL & "declare @RowCount as integer" & vbCrLf
SQL = SQL & "declare @GlMasterAcc as varchar(10)" & vbCrLf
SQL = SQL & "declare @GlChildAcct as varchar(10)" & vbCrLf
SQL = SQL & "declare @ChildKey as varchar(1024)" & vbCrLf
SQL = SQL & "declare @GLSortKey as varchar(1024)" & vbCrLf
SQL = SQL & "declare @SortKey as varchar(1024)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "DELETE FROM EsReportIncStatement" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "if (@InclIncAcct = '1')" & vbCrLf
SQL = SQL & "SET @InclInAcct = ''" & vbCrLf
SQL = SQL & "Else" & vbCrLf
SQL = SQL & "SET @InclInAcct = '0'" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "DECLARE balAcctStruc CURSOR  FOR" & vbCrLf
SQL = SQL & "SELECT '4', COINCMACCT, COINCMDESC FROM GlmsTable" & vbCrLf
SQL = SQL & "Union All" & vbCrLf
SQL = SQL & "SELECT '5', COCOGSACCT, COCOGSDESC FROM GlmsTable" & vbCrLf
SQL = SQL & "Union All" & vbCrLf
SQL = SQL & "SELECT '6', COEXPNACCT, COEXPNDESC FROM GlmsTable" & vbCrLf
SQL = SQL & "Union All" & vbCrLf
SQL = SQL & "SELECT '7', COOINCACCT, COOINCDESC FROM GlmsTable" & vbCrLf
SQL = SQL & "Union All" & vbCrLf
SQL = SQL & "SELECT '8', COOEXPACCT, COOEXPDESC FROM GlmsTable" & vbCrLf
SQL = SQL & "Union All" & vbCrLf
SQL = SQL & "SELECT '9', COFDTXACCT, COFDTXDESC FROM GlmsTable" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "OPEN balAcctStruc" & vbCrLf
SQL = SQL & "FETCH NEXT FROM balAcctStruc INTO @level,@TopLevAcct, @TopLevelDesc" & vbCrLf
SQL = SQL & "WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "IF (@@FETCH_STATUS <> -2)" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & ";with cte" & vbCrLf
SQL = SQL & "as" & vbCrLf
SQL = SQL & "(select GLACCTREF, GLDESCR, GLMASTER, GLFSLEVEL, 1 as level," & vbCrLf
SQL = SQL & "cast(cast(@level as varchar(4))+ char(36)+ GLACCTREF as varchar(max)) as SortKey" & vbCrLf
SQL = SQL & "From GlacTable" & vbCrLf
SQL = SQL & "where GLMASTER = cast(@TopLevAcct as varchar(20)) AND GLINACTIVE LIKE @InclInAcct" & vbCrLf
SQL = SQL & "Union All" & vbCrLf
SQL = SQL & "select a.GLACCTREF, a.GLDESCR, a.GLMASTER, a.GLFSLEVEL, level + 1," & vbCrLf
SQL = SQL & "cast(COALESCE(SortKey,'') + char(36) + COALESCE(a.GLACCTREF,'') as varchar(max))as SortKey" & vbCrLf
SQL = SQL & "From cte" & vbCrLf
SQL = SQL & "inner join GlacTable a" & vbCrLf
SQL = SQL & "on cte.GLACCTREF = a.GLMASTER" & vbCrLf
SQL = SQL & "WHERE GLINACTIVE LIKE @InclInAcct" & vbCrLf
SQL = SQL & ")" & vbCrLf
SQL = SQL & "INSERT INTO EsReportIncStatement(GLTOPMaster, GLTOPMASTERDESC, GLACCTREF, GLDESCR, GLMASTER, GLFSLEVEL,SORTKEYLEVEL,GLACCSORTKEY)" & vbCrLf
SQL = SQL & "select @level, @TopLevelDesc, GLACCTREF, GLDESCR, GLMASTER, GLFSLEVEL, level, SortKey" & vbCrLf
SQL = SQL & "from cte order by SortKey" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "End" & vbCrLf
SQL = SQL & "FETCH NEXT FROM balAcctStruc INTO @level,@TopLevAcct, @TopLevelDesc" & vbCrLf
SQL = SQL & "End" & vbCrLf
SQL = SQL & "Close balAcctStruc" & vbCrLf
SQL = SQL & "DEALLOCATE balAcctStruc" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "UPDATE EsReportIncStatement SET CurrentBal = foo.Balance--, SUMCURBAL = foo.Balance" & vbCrLf
SQL = SQL & "From" & vbCrLf
SQL = SQL & "(SELECT SUM(GjitTable.JICRD) - SUM(GjitTable.JIDEB) as Balance, JIACCOUNT" & vbCrLf
SQL = SQL & "FROM GjhdTable INNER JOIN GjitTable ON GJNAME = JINAME" & vbCrLf
SQL = SQL & "WHERE GJPOST BETWEEN @StartDate AND @EndDate" & vbCrLf
SQL = SQL & "AND GjhdTable.GJPOSTED = 1" & vbCrLf
SQL = SQL & "GROUP BY JIACCOUNT) as foo" & vbCrLf
SQL = SQL & "Where foo.JIACCOUNT = GLACCTREF" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "UPDATE EsReportIncStatement SET YTD = foo.Balance--, SUMYTD = foo.Balance" & vbCrLf
SQL = SQL & "From" & vbCrLf
SQL = SQL & "(SELECT JIACCOUNT,SUM(GjitTable.JICRD) - SUM(GjitTable.JIDEB) AS Balance" & vbCrLf
SQL = SQL & "FROM GjhdTable INNER JOIN GjitTable ON GJNAME = JINAME" & vbCrLf
SQL = SQL & "WHERE (GJPOST BETWEEN @YearBeginDate AND @EndDate)" & vbCrLf
SQL = SQL & "AND GjhdTable.GJPOSTED = 1" & vbCrLf
SQL = SQL & "GROUP BY JIACCOUNT) as foo" & vbCrLf
SQL = SQL & "Where foo.JIACCOUNT = GLACCTREF" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "UPDATE EsReportIncStatement SET PreviousBal = foo.Balance--, SUMPREVBAL = foo.Balance" & vbCrLf
SQL = SQL & "From" & vbCrLf
SQL = SQL & "(SELECT JIACCOUNT,SUM(GjitTable.JICRD) - SUM(GjitTable.JIDEB) AS Balance" & vbCrLf
SQL = SQL & "FROM GjhdTable INNER JOIN GjitTable ON GJNAME = JINAME" & vbCrLf
SQL = SQL & "WHERE (GJPOST BETWEEN DATEADD(year, -1, @YearBeginDate) AND DATEADD(year, -1, @EndDate))" & vbCrLf
SQL = SQL & "AND GjhdTable.GJPOSTED = 1" & vbCrLf
SQL = SQL & "GROUP BY JIACCOUNT) as foo" & vbCrLf
SQL = SQL & "Where foo.JIACCOUNT = GLACCTREF" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "SELECT @level =  MAX(SORTKEYLEVEL) FROM EsReportIncStatement" & vbCrLf
SQL = SQL & "--set @level = 9" & vbCrLf
SQL = SQL & "WHILE (@level >= 1 )" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "DECLARE curAcctStruc CURSOR  FOR" & vbCrLf
SQL = SQL & "SELECT GLMASTER, SUM(ISNULL(SUMCURBAL,0) + (ISNULL(CurrentBal,0))) ," & vbCrLf
SQL = SQL & "Sum (IsNull(SUMYTD, 0) + (IsNull(YTD, 0))), Sum(IsNull(SUMPREVBAL, 0) + (IsNull(PreviousBal, 0)))" & vbCrLf
SQL = SQL & "From" & vbCrLf
SQL = SQL & "(SELECT DISTINCT GLACCTREF, GLDESCR, GLMASTER," & vbCrLf
SQL = SQL & "CurrentBal , YTD, PreviousBal, SUMCURBAL, SUMYTD, SUMPREVBAL" & vbCrLf
SQL = SQL & "FROM EsReportIncStatement WHERE SORTKEYLEVEL = @level) as foo" & vbCrLf
SQL = SQL & "group by GLMASTER" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "OPEN curAcctStruc" & vbCrLf
SQL = SQL & "FETCH NEXT FROM curAcctStruc INTO @glMsAcct, @SumCurBal, @SumYTD, @SumPrevBal" & vbCrLf
SQL = SQL & "WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "IF (@@FETCH_STATUS <> -2)" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "UPDATE EsReportIncStatement SET SUMCURBAL = @SumCurBal, SUMYTD = @SumYTD," & vbCrLf
SQL = SQL & "SUMPREVBAL = @SumPrevBal, GLDESCR = 'TOTAL ' + LTRIM(GLDESCR)," & vbCrLf
SQL = SQL & "HASCHILD = 1" & vbCrLf
SQL = SQL & "WHERE GLACCTREF = @glMsAcct" & vbCrLf
SQL = SQL & "End" & vbCrLf
SQL = SQL & "FETCH NEXT FROM curAcctStruc INTO @glMsAcct, @SumCurBal, @SumYTD, @SumPrevBal" & vbCrLf
SQL = SQL & "End" & vbCrLf
SQL = SQL & "Close curAcctStruc" & vbCrLf
SQL = SQL & "DEALLOCATE curAcctStruc" & vbCrLf
SQL = SQL & "SET @level = @level - 1" & vbCrLf
SQL = SQL & "End" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "UPDATE EsReportIncStatement SET SUMCURBAL = CurrentBal WHERE SUMCURBAL IS NULL" & vbCrLf
SQL = SQL & "UPDATE EsReportIncStatement SET SUMPREVBAL = PreviousBal WHERE SUMPREVBAL IS NULL" & vbCrLf
SQL = SQL & "UPDATE EsReportIncStatement SET SUMYTD = YTD  WHERE SUMYTD IS NULL" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "set @level = 0" & vbCrLf
SQL = SQL & "set @RowCount = 1" & vbCrLf
SQL = SQL & "SET @PrevMaster = ''" & vbCrLf
SQL = SQL & "DECLARE curAcctStruc CURSOR  FOR" & vbCrLf
SQL = SQL & "SELECT GLMASTER, GLACCSORTKEY" & vbCrLf
SQL = SQL & "FROM EsReportIncStatement" & vbCrLf
SQL = SQL & "WHERE HASCHILD IS NULL --GLFSLEVEL = 8 --AND GLMASTER ='AA10'--GLTOPMaster = 1 AND" & vbCrLf
SQL = SQL & "ORDER BY GLACCSORTKEY" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "OPEN curAcctStruc" & vbCrLf
SQL = SQL & "FETCH NEXT FROM curAcctStruc INTO @GlMasterAcc, @GLSortKey" & vbCrLf
SQL = SQL & "WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "IF (@@FETCH_STATUS <> -2)" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "if (@PrevMaster <> @GlMasterAcc)" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "UPDATE EsReportIncStatement SET" & vbCrLf
SQL = SQL & "SortKeyRev = RIGHT ('0000'+ Cast(@RowCount as varchar), 4) + char(36)+ @GlMasterAcc" & vbCrLf
SQL = SQL & "WHERE GLMASTER = @GlMasterAcc AND HASCHILD IS NULL --GLFSLEVEL = 8 --AND GLTOPMaster = 1" & vbCrLf
SQL = SQL & "SET @RowCount = @RowCount + 1" & vbCrLf
SQL = SQL & "SET @PrevMaster = @GlMasterAcc" & vbCrLf
SQL = SQL & "END" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "End" & vbCrLf
SQL = SQL & "FETCH NEXT FROM curAcctStruc INTO @GlMasterAcc, @GLSortKey" & vbCrLf
SQL = SQL & "End" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "Close curAcctStruc" & vbCrLf
SQL = SQL & "DEALLOCATE curAcctStruc" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "SELECT @level = MAX(SORTKEYLEVEL) FROM EsReportIncStatement" & vbCrLf
SQL = SQL & "--set @level = 7" & vbCrLf
SQL = SQL & "WHILE (@level >= 1 )" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "SET @PrevMaster = ''" & vbCrLf
SQL = SQL & "DECLARE curAcctStruc1 CURSOR  FOR" & vbCrLf
SQL = SQL & "SELECT DISTINCT GLACCTREF, GLMASTER, GLACCSORTKEY" & vbCrLf
SQL = SQL & "FROM EsReportIncStatement" & vbCrLf
SQL = SQL & "WHERE SORTKEYLEVEL = @level AND HASCHILD IS NOT NULL--GLTOPMaster = 1 AND" & vbCrLf
SQL = SQL & "order by GLACCSORTKEY" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "OPEN curAcctStruc1" & vbCrLf
SQL = SQL & "FETCH NEXT FROM curAcctStruc1 INTO @GlChildAcct, @GlMasterAcc, @GLSortKey" & vbCrLf
SQL = SQL & "WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "IF (@@FETCH_STATUS <> -2)" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "if (@PrevMaster <> @GlChildAcct)" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "print 'Record' + @GlChildAcct + ':' + @GlMasterAcc" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "SELECT TOP 1 @ChildKey = SortKeyRev,@SortKey = GLACCSORTKEY" & vbCrLf
SQL = SQL & "FROM EsReportIncStatement" & vbCrLf
SQL = SQL & "WHERE SORTKEYLEVEL > @level AND GLMASTER = @GlChildAcct --GLTOPMaster = 1 AND" & vbCrLf
SQL = SQL & "order by GLACCSORTKEY desc" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "UPDATE EsReportIncStatement SET" & vbCrLf
SQL = SQL & "SortKeyRev = Cast(@ChildKey as varchar(512)) + char(36)+ @GlMasterAcc" & vbCrLf
SQL = SQL & "WHERE GLACCTREF = @GlChildAcct AND GLMASTER = @GlMasterAcc" & vbCrLf
SQL = SQL & "AND SORTKEYLEVEL = @level --GLTOPMaster = 1 AND" & vbCrLf
SQL = SQL & "SET @PrevMaster = @GlChildAcct" & vbCrLf
SQL = SQL & "END" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "End" & vbCrLf
SQL = SQL & "FETCH NEXT FROM curAcctStruc1 INTO @GlChildAcct, @GlMasterAcc, @GLSortKey" & vbCrLf
SQL = SQL & "End" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "Close curAcctStruc1" & vbCrLf
SQL = SQL & "DEALLOCATE curAcctStruc1" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "SET @level = @level - 1" & vbCrLf
SQL = SQL & "End" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "SELECT GLTOPMaster, GLTOPMASTERDESC, GLACCTREF, GLACCTNO, GLDESCR, GLMASTER, GLTYPE,GLINACTIVE, GLFSLEVEL," & vbCrLf
SQL = SQL & "SUMCURBAL , CurrentBal, SUMYTD, YTD, SUMPREVBAL, PreviousBal, SORTKEYLEVEL, GLACCSORTKEY" & vbCrLf
SQL = SQL & "FROM EsReportIncStatement ORDER BY SortKeyRev --GLTOPMASTER, GLACCSORTKEY desc, SortKeyLevel" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "End" & vbCrLf
ExecuteScript False, SQL


SQL = "DropStoredProcedureIfExists 'RptMOCostDetail'" & vbCrLf
ExecuteScript False, SQL

SQL = "CREATE PROCEDURE RptMOCostDetail" & vbCrLf
SQL = SQL & "@MOPart as varchar(30),@MORun as int, @MOQty as decimal(15,4)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "--05/09/2018 TEL - changed 'with cte' to ';with cte'" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "AS" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "declare @SumTotMat decimal(15,4)" & vbCrLf
SQL = SQL & "declare @SumTotLabor decimal(15,4)" & vbCrLf
SQL = SQL & "declare @SumTotExp decimal(15,4)" & vbCrLf
SQL = SQL & "declare @SumTotOH decimal(15,4)" & vbCrLf
SQL = SQL & "declare @level as integer" & vbCrLf
SQL = SQL & "declare @Part as varchar(30)" & vbCrLf
SQL = SQL & "declare @PrevParent  as varchar(30)" & vbCrLf
SQL = SQL & "declare @RowCount as integer" & vbCrLf
SQL = SQL & "declare @ChildPart as varchar(30)" & vbCrLf
SQL = SQL & "declare @ParentPart as varchar(30)" & vbCrLf
SQL = SQL & "declare @MOPart1 as varchar(30)" & vbCrLf
SQL = SQL & "declare @MoRun1 as varchar(20)" & vbCrLf
SQL = SQL & "declare @Part1 as varchar(30)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "declare @ChildKey as varchar(1024)" & vbCrLf
SQL = SQL & "declare @GLSortKey as varchar(1024)" & vbCrLf
SQL = SQL & "declare @SortKey as varchar(1024)" & vbCrLf
SQL = SQL & "declare @ParentLotNum as varchar(15)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "declare @Maxlevel as int" & vbCrLf
SQL = SQL & "declare @LotRunNo as int" & vbCrLf
SQL = SQL & "declare @LotOrgQty as decimal(15,4)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "declare @LotUSpMat decimal(15,4)" & vbCrLf
SQL = SQL & "declare @LotUSpLabor decimal(15,4)" & vbCrLf
SQL = SQL & "declare @LotUSpExp decimal(15,4)" & vbCrLf
SQL = SQL & "declare @LotUSpOH decimal(15,4)" & vbCrLf
SQL = SQL & "declare @LotMatl decimal(15,4)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "declare @MOLotNum as varchar(15)" & vbCrLf
SQL = SQL & "declare @SplitLot as varchar(15)" & vbCrLf
SQL = SQL & "declare @cnt  as int" & vbCrLf
SQL = SQL & "declare @sumQty decimal(15,4)" & vbCrLf
SQL = SQL & "declare @MOPartRunKey as Varchar(30)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "--DROP TABLE #tempMOPartsDetail" & vbCrLf
SQL = SQL & "-- DELETE FROM #tempMOPartsDetail" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "SET @MOPartRunKey = RTRIM(@MOPart) + '_' + Convert(varchar(10), @MORun)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "CREATE TABLE #tempMOPartsDetail" & vbCrLf
SQL = SQL & "(" & vbCrLf
SQL = SQL & "LOTMOPARTRUNKEY varchar(50) NULL," & vbCrLf
SQL = SQL & "INMOPART Varchar(30) NULL," & vbCrLf
SQL = SQL & "INMORUN int NULL ," & vbCrLf
SQL = SQL & "INPART varchar(30) NULL ," & vbCrLf
SQL = SQL & "LOTNUMBER varchar(15) NULL," & vbCrLf
SQL = SQL & "LOTUSERLOTID varchar(40) NULL," & vbCrLf
SQL = SQL & "INTOTMATL decimal(12,4) NULL," & vbCrLf
SQL = SQL & "INTOTLABOR decimal(12,4) NULL," & vbCrLf
SQL = SQL & "INTOTEXP decimal(12,4) NULL," & vbCrLf
SQL = SQL & "INTOTOH decimal(12,4) NULL," & vbCrLf
SQL = SQL & "LOTTOTMATL decimal(12,4) NULL," & vbCrLf
SQL = SQL & "LOTTOTLABOR decimal(12,4) NULL," & vbCrLf
SQL = SQL & "LOTTOTEXP decimal(12,4) NULL," & vbCrLf
SQL = SQL & "LOTTOTOH decimal(12,4) NULL," & vbCrLf
SQL = SQL & "SUMTOTMAL decimal(12,4) NULL," & vbCrLf
SQL = SQL & "SUMTOTLABOR decimal(12,4) NULL," & vbCrLf
SQL = SQL & "SUMTOTEXP decimal(12,4) NULL," & vbCrLf
SQL = SQL & "SUMTOTOH decimal(12,4) NULL," & vbCrLf
SQL = SQL & "LOTDATECOSTED smalldatetime NULL," & vbCrLf
SQL = SQL & "SortKey varchar(512) NULL," & vbCrLf
SQL = SQL & "HASCHILD int NULL," & vbCrLf
SQL = SQL & "SORTKEYLEVEL tinyint NULL," & vbCrLf
SQL = SQL & "SortKeyRev varchar(512)," & vbCrLf
SQL = SQL & "PARTSUM varchar(40)," & vbCrLf
SQL = SQL & "BMQTYREQD decimal(12,4) NULL," & vbCrLf
SQL = SQL & "LOTORGQTY decimal(12,4) NULL," & vbCrLf
SQL = SQL & "BMTOTOH decimal(12,4) NULL," & vbCrLf
SQL = SQL & "LOTSPLITFROMSYS varchar(15)," & vbCrLf
SQL = SQL & "INVNO int NULL," & vbCrLf
SQL = SQL & "ITPSNUMBER varchar(8) NULL," & vbCrLf
SQL = SQL & "ITPSITEM smallint NULL," & vbCrLf
SQL = SQL & "PICKQTY decimal(12,4) NULL" & vbCrLf
SQL = SQL & ")" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & ";with cte" & vbCrLf
SQL = SQL & "as" & vbCrLf
SQL = SQL & "(select BMASSYPART, BMPARTREF,  BMQTYREQD,0 as level, cast('1' + char(36)+ BMPARTREF as varchar(max)) as SortKey" & vbCrLf
SQL = SQL & "from BmplTable" & vbCrLf
SQL = SQL & "where BMASSYPART = @MOPart" & vbCrLf
SQL = SQL & "union all" & vbCrLf
SQL = SQL & "select a.BMASSYPART, a.BMPARTREF, a.BMQTYREQD, level + 1," & vbCrLf
SQL = SQL & "cast(COALESCE(SortKey,'') + char(36) + COALESCE(a.BMPARTREF,'') as varchar(max))as SortKey" & vbCrLf
SQL = SQL & "from cte" & vbCrLf
SQL = SQL & "inner join BmplTable a" & vbCrLf
SQL = SQL & "on cte.BMPARTREF = a.BMASSYPART" & vbCrLf
SQL = SQL & ")" & vbCrLf
SQL = SQL & "INSERT INTO #tempMOPartsDetail(INMOPART,INPART,BMQTYREQD,SORTKEYLEVEL,SortKey)" & vbCrLf
SQL = SQL & "select BMASSYPART, BMPARTREF,BMQTYREQD,level,SortKey" & vbCrLf
SQL = SQL & "from cte order by SortKey" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "END" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "SET @cnt = 0" & vbCrLf
SQL = SQL & "print 'Update Start:' + cast(getdate() as char(25))" & vbCrLf
SQL = SQL & "print 'Count :' + Convert(varchar(10), @cnt)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "UPDATE #tempMOPartsDetail SET INMORUN = @MORun, LOTNUMBER = b.INLOTNUMBER," & vbCrLf
SQL = SQL & "LOTSPLITFROMSYS = c.LOTSPLITFROMSYS" & vbCrLf
SQL = SQL & "FROM dbo.LohdTable AS c INNER JOIN" & vbCrLf
SQL = SQL & "dbo.InvaTable AS b ON c.LOTNUMBER = b.INLOTNUMBER AND c.LOTPARTREF = b.INPART LEFT OUTER JOIN" & vbCrLf
SQL = SQL & "dbo.#tempMOPartsDetail AS d ON b.INMOPART = d.INMOPART AND b.INPART = d.INPART" & vbCrLf
SQL = SQL & "WHERE     (b.INMOPART = @MOPart) AND (b.INMORUN = @MORun) AND (b.INTYPE = 10) AND (d.SORTKEYLEVEL = 0)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "UPDATE #tempMOPartsDetail SET PICKQTY = sumqty * -1" & vbCrLf
SQL = SQL & "FROM #tempMOPartsDetail," & vbCrLf
SQL = SQL & "(SELECT SUM(b.INAQTY) sumqty, d.INMOPART mopart, d.INMORUN morun, d.LOTNUMBER lotnum, d.INPART subpart" & vbCrLf
SQL = SQL & "FROM dbo.LohdTable AS c INNER JOIN" & vbCrLf
SQL = SQL & "dbo.InvaTable AS b ON c.LOTNUMBER = b.INLOTNUMBER AND c.LOTPARTREF = b.INPART LEFT OUTER JOIN" & vbCrLf
SQL = SQL & "dbo.#tempMOPartsDetail AS d ON b.INMOPART = d.INMOPART AND b.INPART = d.INPART" & vbCrLf
SQL = SQL & "WHERE     b.INMOPART = @MOPart AND b.INMORUN  = @MORun AND (b.INTYPE = 10) AND (d.SORTKEYLEVEL = 0)" & vbCrLf
SQL = SQL & "GROUP BY d.INMOPART, d.INMORUN, d.LOTNUMBER, d.INPART" & vbCrLf
SQL = SQL & ") as f" & vbCrLf
SQL = SQL & "WHERE INMOPART = f.mopart AND INMORUN = f.morun" & vbCrLf
SQL = SQL & "AND LOTNUMBER = lotnum AND INPART = subpart" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "--// Update the" & vbCrLf
SQL = SQL & "--// update the top level" & vbCrLf
SQL = SQL & "UPDATE #tempMOPartsDetail SET INMORUN = @MORun, LOTNUMBER = b.INLOTNUMBER," & vbCrLf
SQL = SQL & "LOTUSERLOTID = c.LOTUSERLOTID," & vbCrLf
SQL = SQL & "INTOTMATL = b.INTOTMATL, INTOTLABOR = b.INTOTLABOR," & vbCrLf
SQL = SQL & "INTOTEXP = b.INTOTEXP, INTOTOH = b.INTOTOH," & vbCrLf
SQL = SQL & "LOTTOTMATL = (c.LOTTOTMATL * PICKQTY) / c.LOTORIGINALQTY," & vbCrLf
SQL = SQL & "LOTTOTLABOR = (c.LOTTOTLABOR * PICKQTY) / c.LOTORIGINALQTY," & vbCrLf
SQL = SQL & "LOTTOTEXP = (c.LOTTOTEXP * PICKQTY) / c.LOTORIGINALQTY," & vbCrLf
SQL = SQL & "LOTTOTOH = (c.LOTTOTOH * PICKQTY) / c.LOTORIGINALQTY," & vbCrLf
SQL = SQL & "LOTDATECOSTED = c.LOTDATECOSTED, LOTORGQTY = c.LOTORIGINALQTY," & vbCrLf
SQL = SQL & "BMTOTOH = (c.LOTTOTOH * PICKQTY) / c.LOTORIGINALQTY," & vbCrLf
SQL = SQL & "LOTSPLITFROMSYS = c.LOTSPLITFROMSYS" & vbCrLf
SQL = SQL & "FROM dbo.LohdTable AS c INNER JOIN" & vbCrLf
SQL = SQL & "dbo.InvaTable AS b ON c.LOTNUMBER = b.INLOTNUMBER AND c.LOTPARTREF = b.INPART LEFT OUTER JOIN" & vbCrLf
SQL = SQL & "dbo.#tempMOPartsDetail AS d ON b.INMOPART = d.INMOPART AND b.INPART = d.INPART" & vbCrLf
SQL = SQL & "WHERE     (b.INMOPART = @MOPart) AND (b.INMORUN = @MORun) AND (b.INTYPE = 10) AND (d.SORTKEYLEVEL = 0)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "print 'Update 2:' + cast(getdate() as char(25))" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "--FROM #tempMOPartsDetail d, InvaTable b, LohdTable c" & vbCrLf
SQL = SQL & "--WHERE d.INMOPART = b.INMOPART AND d.INPART = b.INPART" & vbCrLf
SQL = SQL & "-- AND b.INLOTNUMBER = c.LOTnumber" & vbCrLf
SQL = SQL & "-- and c.lotpartref = b.INPART" & vbCrLf
SQL = SQL & "-- and b.INMOPART = @MOPart AND b.INMORUN  = @MORun" & vbCrLf
SQL = SQL & "-- AND b.INTYPE = 10 AND SORTKEYLEVEL = 0" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "--// set the totals for" & vbCrLf
SQL = SQL & "SELECT @Maxlevel =  MAX(SORTKEYLEVEL) FROM #tempMOPartsDetail" & vbCrLf
SQL = SQL & "SET @level  = 1" & vbCrLf
SQL = SQL & "WHILE (@level <= @Maxlevel )" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "DECLARE curMORun CURSOR  FOR" & vbCrLf
SQL = SQL & "SELECT DISTINCT INMOPART,INPART" & vbCrLf
SQL = SQL & "FROM #tempMOPartsDetail WHERE SORTKEYLEVEL = @level" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "OPEN curMORun" & vbCrLf
SQL = SQL & "FETCH NEXT FROM curMORun INTO @MOPart, @Part" & vbCrLf
SQL = SQL & "WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "IF (@@FETCH_STATUS <> -2)" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "SELECT @ParentLotNum = LOTNUMBER FROM #tempMOPartsDetail WHERE" & vbCrLf
SQL = SQL & "INPART = @MOPart AND SORTKEYLEVEL = @level - 1" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "SELECT @LotRunNo = LOTMORUNNO, @LotOrgQty = LOTORIGINALQTY" & vbCrLf
SQL = SQL & "FROM lohdTable where LOTNUMBER = @ParentLotNum" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "UPDATE #tempMOPartsDetail SET INMORUN = @LotRunNo, LOTNUMBER = b.INLOTNUMBER," & vbCrLf
SQL = SQL & "LOTSPLITFROMSYS = c.LOTSPLITFROMSYS" & vbCrLf
SQL = SQL & "FROM #tempMOPartsDetail d, InvaTable b, LohdTable c" & vbCrLf
SQL = SQL & "WHERE d.INMOPART = b.INMOPART AND d.INPART = b.INPART" & vbCrLf
SQL = SQL & "AND b.INLOTNUMBER = c.LOTnumber" & vbCrLf
SQL = SQL & "and c.lotpartref = b.INPART" & vbCrLf
SQL = SQL & "and b.INMOPART = @MOPart AND b.INMORUN  = @LotRunNo" & vbCrLf
SQL = SQL & "AND b.INTYPE = 10 AND SORTKEYLEVEL = @level" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "UPDATE #tempMOPartsDetail SET PICKQTY = sumqty * -1" & vbCrLf
SQL = SQL & "FROM" & vbCrLf
SQL = SQL & "(SELECT SUM(b.INAQTY) sumqty, d.INMOPART mopart, d.INMORUN morun, d.LOTNUMBER lotnum, d.INPART subpart" & vbCrLf
SQL = SQL & "FROM dbo.LohdTable AS c INNER JOIN" & vbCrLf
SQL = SQL & "dbo.InvaTable AS b ON c.LOTNUMBER = b.INLOTNUMBER AND c.LOTPARTREF = b.INPART LEFT OUTER JOIN" & vbCrLf
SQL = SQL & "dbo.#tempMOPartsDetail AS d ON b.INMOPART = d.INMOPART AND b.INPART = d.INPART" & vbCrLf
SQL = SQL & "WHERE     b.INMOPART = @MOPart AND b.INMORUN  = @LotRunNo AND (b.INTYPE = 10) AND (d.SORTKEYLEVEL = @level)" & vbCrLf
SQL = SQL & "GROUP BY d.INMOPART, d.INMORUN, d.LOTNUMBER, d.INPART" & vbCrLf
SQL = SQL & ") as f" & vbCrLf
SQL = SQL & "WHERE INMOPART = mopart AND INMORUN = morun" & vbCrLf
SQL = SQL & "AND LOTNUMBER = lotnum AND INPART = subpart" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "--// update the top level" & vbCrLf
SQL = SQL & "UPDATE #tempMOPartsDetail SET INMORUN = @LotRunNo, LOTNUMBER = b.INLOTNUMBER," & vbCrLf
SQL = SQL & "LOTUSERLOTID = c.LOTUSERLOTID," & vbCrLf
SQL = SQL & "INTOTMATL = b.INTOTMATL, INTOTLABOR = b.INTOTLABOR," & vbCrLf
SQL = SQL & "INTOTEXP = b.INTOTEXP, INTOTOH = b.INTOTOH," & vbCrLf
SQL = SQL & "LOTTOTMATL = (c.LOTTOTMATL * PICKQTY) / c.LOTORIGINALQTY," & vbCrLf
SQL = SQL & "LOTTOTLABOR = (c.LOTTOTLABOR * PICKQTY) / c.LOTORIGINALQTY," & vbCrLf
SQL = SQL & "LOTTOTEXP = (c.LOTTOTEXP * PICKQTY) / c.LOTORIGINALQTY," & vbCrLf
SQL = SQL & "LOTTOTOH = (c.LOTTOTOH * PICKQTY) / c.LOTORIGINALQTY," & vbCrLf
SQL = SQL & "LOTDATECOSTED = c.LOTDATECOSTED, LOTORGQTY = @LotOrgQty," & vbCrLf
SQL = SQL & "BMTOTOH = (c.LOTTOTOH * PICKQTY) / @LotOrgQty," & vbCrLf
SQL = SQL & "LOTSPLITFROMSYS = c.LOTSPLITFROMSYS" & vbCrLf
SQL = SQL & "FROM #tempMOPartsDetail d, InvaTable b, LohdTable c" & vbCrLf
SQL = SQL & "WHERE d.INMOPART = b.INMOPART AND d.INPART = b.INPART" & vbCrLf
SQL = SQL & "AND b.INLOTNUMBER = c.LOTnumber" & vbCrLf
SQL = SQL & "and c.lotpartref = b.INPART" & vbCrLf
SQL = SQL & "and b.INMOPART = @MOPart AND b.INMORUN  = @LotRunNo" & vbCrLf
SQL = SQL & "AND b.INTYPE = 10 AND SORTKEYLEVEL = @level" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "End" & vbCrLf
SQL = SQL & "FETCH NEXT FROM curMORun INTO @MOPart, @Part" & vbCrLf
SQL = SQL & "End" & vbCrLf
SQL = SQL & "Close curMORun" & vbCrLf
SQL = SQL & "DEALLOCATE curMORun" & vbCrLf
SQL = SQL & "SET @level = @level + 1" & vbCrLf
SQL = SQL & "End" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "print 'Update 2:'+ cast(getdate() as char(25))" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "DECLARE curMOSplit CURSOR  FOR" & vbCrLf
SQL = SQL & "SELECT DISTINCT LOTNUMBER, LOTSPLITFROMSYS, LOTTOTMATL--, LOTTOTLABOR, LOTTOTEXP, LOTTOTOH" & vbCrLf
SQL = SQL & "FROM #tempMOPartsDetail WHERE LOTSPLITFROMSYS <> ''" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "OPEN curMOSplit" & vbCrLf
SQL = SQL & "FETCH NEXT FROM curMOSplit INTO @MOLotNum, @SplitLot, @LotMatl" & vbCrLf
SQL = SQL & "WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "IF (@@FETCH_STATUS <> -2)" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "print 'LotSplit LotNum:' + @SplitLot" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "IF @LotMatl = 0" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "SELECT @LotUSpMat = (LOTTOTMATL / LOTORIGINALQTY)," & vbCrLf
SQL = SQL & "@LotUSpLabor = (LOTTOTLABOR / LOTORIGINALQTY)," & vbCrLf
SQL = SQL & "@LotUSpExp = (LOTTOTEXP / LOTORIGINALQTY)," & vbCrLf
SQL = SQL & "@LotUSpOH = (LOTTOTOH / LOTORIGINALQTY)" & vbCrLf
SQL = SQL & "FROM Lohdtable WHERE LOTNUMBER = @SplitLot" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "UPDATE #tempMOPartsDetail SET LOTTOTMATL = (@LotUSpMat * PICKQTY)," & vbCrLf
SQL = SQL & "LOTTOTLABOR = (@LotUSpLabor * PICKQTY)," & vbCrLf
SQL = SQL & "LOTTOTEXP = (@LotUSpExp * PICKQTY)," & vbCrLf
SQL = SQL & "LOTTOTOH = (@LotUSpOH * PICKQTY)" & vbCrLf
SQL = SQL & "WHERE LOTNUMBER = @MOLotNum AND LOTSPLITFROMSYS = @SplitLot" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "END" & vbCrLf
SQL = SQL & "End" & vbCrLf
SQL = SQL & "FETCH NEXT FROM curMOSplit INTO @MOLotNum, @SplitLot, @LotMatl" & vbCrLf
SQL = SQL & "End" & vbCrLf
SQL = SQL & "Close curMOSplit" & vbCrLf
SQL = SQL & "DEALLOCATE curMOSplit" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "SELECT @level =  MAX(SORTKEYLEVEL) FROM #tempMOPartsDetail" & vbCrLf
SQL = SQL & "WHILE (@level >= 0 )" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "DECLARE curMODet CURSOR  FOR" & vbCrLf
SQL = SQL & "--SELECT INPART, LOTTOTMATL, LOTTOTLABOR, LOTTOTEXP , LOTTOTOH FROM #tempMOPartsDetail" & vbCrLf
SQL = SQL & "-- WHERE INPART = '775345149'" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "SELECT INMOPART," & vbCrLf
SQL = SQL & "SUM(IsNull(LOTTOTMATL, 0)), SUM(ISNULL(LOTTOTLABOR,0)) ," & vbCrLf
SQL = SQL & "Sum (IsNull(LOTTOTEXP, 0)) , SUM(IsNull(BMTOTOH, 0))" & vbCrLf
SQL = SQL & "From" & vbCrLf
SQL = SQL & "(SELECT DISTINCT INMOPART,INMORUN,INPART,LOTTOTMATL,LOTTOTLABOR," & vbCrLf
SQL = SQL & "LOTTOTEXP,LOTTOTOH,SUMTOTMAL,SUMTOTLABOR, SUMTOTEXP, SUMTOTOH,BMTOTOH" & vbCrLf
SQL = SQL & "FROM #tempMOPartsDetail WHERE SORTKEYLEVEL = @level) as foo" & vbCrLf
SQL = SQL & "group by INMOPART" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "OPEN curMODet" & vbCrLf
SQL = SQL & "FETCH NEXT FROM curMODet INTO @MOPart, @SumTotMat, @SumTotLabor,@SumTotExp,@SumTotOH" & vbCrLf
SQL = SQL & "WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "IF (@@FETCH_STATUS <> -2)" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "print 'PartNum : ' + @MOPart" & vbCrLf
SQL = SQL & "print 'SumTotoh : ' + Convert(varchar(24), @SumTotOH)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "UPDATE #tempMOPartsDetail SET SUMTOTMAL = LOTTOTMATL + @SumTotMat," & vbCrLf
SQL = SQL & "SUMTOTLABOR = LOTTOTLABOR + @SumTotLabor," & vbCrLf
SQL = SQL & "SUMTOTEXP = LOTTOTEXP + @SumTotExp, SUMTOTOH = (BMTOTOH + @SumTotOH) * @MOQty ," & vbCrLf
SQL = SQL & "HASCHILD = 1,PARTSUM = 'TOTAL ' + LTRIM(INPART)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "WHERE INPART = @MOPart AND SORTKEYLEVEL = @level - 1" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "End" & vbCrLf
SQL = SQL & "FETCH NEXT FROM curMODet INTO @MOPart, @SumTotMat, @SumTotLabor,@SumTotExp,@SumTotOH" & vbCrLf
SQL = SQL & "End" & vbCrLf
SQL = SQL & "Close curMODet" & vbCrLf
SQL = SQL & "DEALLOCATE curMODet" & vbCrLf
SQL = SQL & "SET @level = @level - 1" & vbCrLf
SQL = SQL & "End" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "--// update the Lower level cost detail" & vbCrLf
SQL = SQL & "UPDATE #tempMOPartsDetail SET SUMTOTMAL = LOTTOTMATL, SUMTOTLABOR = LOTTOTLABOR," & vbCrLf
SQL = SQL & "SUMTOTEXP = LOTTOTEXP, SUMTOTOH = BMTOTOH WHERE HASCHILD IS NULL" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "SET @SumTotMat  = 0" & vbCrLf
SQL = SQL & "SET @SumTotLabor  = 0" & vbCrLf
SQL = SQL & "SET @SumTotExp  = 0" & vbCrLf
SQL = SQL & "SET @SumTotOH  = 0" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "--// Udpate the Root total" & vbCrLf
SQL = SQL & "SELECT @SumTotMat = SUM(SUMTOTMAL), @SumTotLabor = SUM(SUMTOTLABOR)," & vbCrLf
SQL = SQL & "@SumTotExp = SUM(SUMTOTEXP) ,@SumTotOH = SUM(SUMTOTOH)" & vbCrLf
SQL = SQL & "FROM #tempMOPartsDetail WHERE SORTKEYLEVEL = 0" & vbCrLf
SQL = SQL & "AND  RTRIM(INMOPART) <> RTRIM(INPART)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "UPDATE #tempMOPartsDetail SET PARTSUM = INPART" & vbCrLf
SQL = SQL & "WHERE PARTSUM IS NULL" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "----  SELECT * FROM #tempMOPartsDetail WHERE SORTKEYLEVEL = 0" & vbCrLf
SQL = SQL & "----AND  RTRIM(INMOPART) = RTRIM(INPART)" & vbCrLf
SQL = SQL & "--// Reverse the partnumbers." & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "set @level = 0" & vbCrLf
SQL = SQL & "SET @RowCount = 1" & vbCrLf
SQL = SQL & "SET @PrevParent = ''" & vbCrLf
SQL = SQL & "DECLARE curAcctStruc CURSOR  FOR" & vbCrLf
SQL = SQL & "SELECT INMOPART, SortKey" & vbCrLf
SQL = SQL & "FROM #tempMOPartsDetail" & vbCrLf
SQL = SQL & "WHERE HASCHILD IS NULL --GLFSLEVEL = 8 --AND GLMASTER ='AA10'--GLTOPMaster = 1 AND" & vbCrLf
SQL = SQL & "ORDER BY SortKey" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "OPEN curAcctStruc" & vbCrLf
SQL = SQL & "FETCH NEXT FROM curAcctStruc INTO @ParentPart, @SortKey" & vbCrLf
SQL = SQL & "WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "IF (@@FETCH_STATUS <> -2)" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "if (@PrevParent <> @ParentPart)" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "UPDATE #tempMOPartsDetail SET" & vbCrLf
SQL = SQL & "SortKeyRev = RIGHT ('0000'+ Cast(@RowCount as varchar), 4) + char(36)+ @ParentPart" & vbCrLf
SQL = SQL & "WHERE INMOPART = @ParentPart AND HASCHILD IS NULL --GLFSLEVEL = 8 --AND GLTOPMaster = 1" & vbCrLf
SQL = SQL & "SET @RowCount = @RowCount + 1" & vbCrLf
SQL = SQL & "SET @PrevParent = @ParentPart" & vbCrLf
SQL = SQL & "END" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "End" & vbCrLf
SQL = SQL & "FETCH NEXT FROM curAcctStruc INTO @ParentPart, @SortKey" & vbCrLf
SQL = SQL & "End" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "Close curAcctStruc" & vbCrLf
SQL = SQL & "DEALLOCATE curAcctStruc" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "UPDATE #tempMOPartsDetail SET LOTMOPARTRUNKEY = @MOPartRunKey" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "INSERT INTO EsMOPartsCostDetail (LOTMOPARTRUNKEY, INMOPART,INMORUN,INPART,PARTSUM,LOTNUMBER,LOTUSERLOTID," & vbCrLf
SQL = SQL & "LOTTOTMATL,SUMTOTMAL, LOTTOTLABOR,SUMTOTLABOR, LOTTOTEXP, SUMTOTEXP, LOTTOTOH,SUMTOTOH,BMTOTOH," & vbCrLf
SQL = SQL & "LOTDATECOSTED, BMQTYREQD, LOTORGQTY, SORTKEYLEVEL,SortKey,SortKeyRev,HASCHILD, PICKQTY)" & vbCrLf
SQL = SQL & "SELECT LOTMOPARTRUNKEY,INMOPART,INMORUN,INPART,PARTSUM,LOTNUMBER,LOTUSERLOTID," & vbCrLf
SQL = SQL & "LOTTOTMATL,SUMTOTMAL, LOTTOTLABOR,SUMTOTLABOR, LOTTOTEXP, SUMTOTEXP, LOTTOTOH,SUMTOTOH,BMTOTOH," & vbCrLf
SQL = SQL & "LOTDATECOSTED, BMQTYREQD, LOTORGQTY, SORTKEYLEVEL,SortKey,SortKeyRev,HASCHILD, PICKQTY" & vbCrLf
SQL = SQL & "FROM #tempMOPartsDetail--WHERE SORTKEYLEVEL = 1" & vbCrLf
SQL = SQL & "order by SortKey--SortKeyRev" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "DROP table #tempMOPartsDetail" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "END" & vbCrLf
ExecuteScript False, SQL

SQL = "DropStoredProcedureIfExists 'RptMRPMOQtyShortage'" & vbCrLf
ExecuteScript False, SQL

SQL = "create PROCEDURE RptMRPMOQtyShortage" & vbCrLf
SQL = SQL & "@InMOPart as varchar(30), @StartDate as datetime, @EndDate as datetime" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "--05/09/2018 TEL - changed 'with cte' to ';with cte'" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "AS" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "declare @ChildKey as varchar(1024)" & vbCrLf
SQL = SQL & "declare @GLSortKey as varchar(1024)" & vbCrLf
SQL = SQL & "declare @SortKey as varchar(1024)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "declare @MOPart as varchar(30)" & vbCrLf
SQL = SQL & "declare @MORun as Integer" & vbCrLf
SQL = SQL & "declare @MOQtyRqd as decimal(12,4)" & vbCrLf
SQL = SQL & "declare @MOPartRqDt as datetime" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "declare @Part as varchar(30)" & vbCrLf
SQL = SQL & "declare @PAQOH as decimal(12,4)" & vbCrLf
SQL = SQL & "declare @RunTot as decimal(12,4)" & vbCrLf
SQL = SQL & "declare @AssyPart as varchar(30)" & vbCrLf
SQL = SQL & "declare @BMQtyReq as decimal(12,4)" & vbCrLf
SQL = SQL & "declare @RunQtyReq as decimal (12, 4)" & vbCrLf
SQL = SQL & "declare @PartDateQrd as datetime" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "--DROP TABLE #tempMOPartsDetail" & vbCrLf
SQL = SQL & "DELETE FROM tempMrplPartShort" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "IF (@InMOPart = '')" & vbCrLf
SQL = SQL & "SET @InMOPart = @InMOPart + '%'" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "DECLARE curMrpExp CURSOR  FOR" & vbCrLf
SQL = SQL & "SELECT MRP_PARTREF,0 as RUNNO, MRP_PARTQTYRQD, MRP_ACTIONDATE" & vbCrLf
SQL = SQL & "FROM MrplTable, PartTable" & vbCrLf
SQL = SQL & "WHERE MRP_PARTREF = PartRef" & vbCrLf
SQL = SQL & "AND MrplTable.MRP_PARTREF LIKE @InMOPart" & vbCrLf
SQL = SQL & "AND MrplTable.MRP_PARTPRODCODE LIKE '%'" & vbCrLf
SQL = SQL & "AND MrplTable.MRP_PARTCLASS LIKE '%'" & vbCrLf
SQL = SQL & "AND MrplTable.MRP_POBUYER LIKE '%'" & vbCrLf
SQL = SQL & "AND MrplTable.MRP_PARTDATERQD BETWEEN @StartDate AND @EndDate" & vbCrLf
SQL = SQL & "AND MrplTable.MRP_TYPE IN (6, 5)" & vbCrLf
SQL = SQL & "AND PartTable.PAMAKEBUY ='M'" & vbCrLf
SQL = SQL & "UNION" & vbCrLf
SQL = SQL & "SELECT DISTINCT RUNREF, RUNNO, RUNQTY,runpkstart  as MRP_ACTIONDATE FROM RunsTable WHERE" & vbCrLf
SQL = SQL & "RUNREF LIKE @InMOPart AND RUNSTATUS = 'SC'" & vbCrLf
SQL = SQL & "AND RUNPKSTART BETWEEN @StartDate  AND @EndDate + ' 23:00' order by MRP_ACTIONDATE" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "OPEN curMrpExp" & vbCrLf
SQL = SQL & "FETCH NEXT FROM curMrpExp INTO @MOPart, @MORun, @MOQtyRqd, @MOPartRqDt" & vbCrLf
SQL = SQL & "WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "IF (@@FETCH_STATUS <> -2)" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "--print 'MO:' + @MOPart + '; RUN:' + Convert(varchar(10), @MORun) + '; Date:' + Convert(varchar(24), @MOPartRqDt, 101);" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & ";with cte" & vbCrLf
SQL = SQL & "as (select BMASSYPART,BMPARTREF,BMPARTREV, BMQTYREQD , RTrim(BMUNITS) BMUNITS," & vbCrLf
SQL = SQL & "BMCONVERSION, BMSEQUENCE, 0 as level," & vbCrLf
SQL = SQL & "cast(LTRIM(RTrim(BMASSYPART)) + char(36)+ COALESCE(cast(BMSEQUENCE as varchar(4)), '') + LTRIM(RTrim(BMPARTREF)) as varchar(max)) as SortKey" & vbCrLf
SQL = SQL & "from BmplTable" & vbCrLf
SQL = SQL & "where BMASSYPART = @MOPart" & vbCrLf
SQL = SQL & "union all" & vbCrLf
SQL = SQL & "select a.BMASSYPART,a.BMPARTREF,a.BMPARTREV, a.BMQTYREQD , RTrim(a.BMUNITS) BMUNITS," & vbCrLf
SQL = SQL & "a.BMCONVERSION, a.BMSEQUENCE, level + 1," & vbCrLf
SQL = SQL & "cast(COALESCE(SortKey,'') + char(36) + COALESCE(cast(a.BMSEQUENCE as varchar(4)), '') + COALESCE(LTRIM(RTrim(a.BMPARTREF)) ,'') as varchar(max))as SortKey" & vbCrLf
SQL = SQL & "from cte" & vbCrLf
SQL = SQL & "inner join BmplTable a" & vbCrLf
SQL = SQL & "on cte.BMPARTREF = a.BMASSYPART" & vbCrLf
SQL = SQL & ")" & vbCrLf
SQL = SQL & "INSERT INTO tempMrplPartShort(BMASSYPART,BMPARTREF,BMQTYREQD," & vbCrLf
SQL = SQL & "SORTKEYLEVEL,BMSEQUENCE, SortKey, PAQOH, RUNNO,MRP_PARTQTYRQD, MRP_ACTIONDATE)" & vbCrLf
SQL = SQL & "select BMASSYPART, BMPARTREF,BMQTYREQD,level,BMSEQUENCE, SortKey, PAQOH, @MORun, @MOQtyRqd, @MOPartRqDt" & vbCrLf
SQL = SQL & "from cte, PartTable WHERE PARTREF = BMPARTREF  AND BMPARTREF <> 'NULL' order by SortKey,BMSEQUENCE" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "End" & vbCrLf
SQL = SQL & "FETCH NEXT FROM curMrpExp INTO @MOPart, @MORun, @MOQtyRqd, @MOPartRqDt" & vbCrLf
SQL = SQL & "End" & vbCrLf
SQL = SQL & "Close curMrpExp" & vbCrLf
SQL = SQL & "DEALLOCATE curMrpExp" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "DECLARE curRunTot CURSOR  FOR" & vbCrLf
SQL = SQL & "select DISTINCT BMPARTREF, PAQOH from tempMrplPartShort order by BMPARTREF" & vbCrLf
SQL = SQL & "OPEN curRunTot" & vbCrLf
SQL = SQL & "FETCH NEXT FROM curRunTot INTO @Part, @PAQOH" & vbCrLf
SQL = SQL & "WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "IF (@@FETCH_STATUS <> -2)" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "SET @RunTot = 0.0000" & vbCrLf
SQL = SQL & "SET @RunTot = @PAQOH" & vbCrLf
SQL = SQL & "DECLARE curRunTot1 CURSOR  FOR" & vbCrLf
SQL = SQL & "select DISTINCT BMASSYPART, BMQTYREQD, MRP_PARTQTYRQD, MRP_ACTIONDATE from tempMrplPartShort" & vbCrLf
SQL = SQL & "WHERE BMPARTREF = @Part AND sortkeylevel = 0" & vbCrLf
SQL = SQL & "order by MRP_ACTIONDATE  -- BMASSYPART," & vbCrLf
SQL = SQL & "OPEN curRunTot1" & vbCrLf
SQL = SQL & "FETCH NEXT FROM curRunTot1 INTO @AssyPart, @BMQtyReq, @RunQtyReq, @PartDateQrd" & vbCrLf
SQL = SQL & "WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "IF (@@FETCH_STATUS <> -2)" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "--Set @RunTot = ROUND(@RunTot,4)" & vbCrLf
SQL = SQL & "Set @RunTot = @RunTot -  ( @BMQtyReq * @RunQtyReq)" & vbCrLf
SQL = SQL & "UPDATE tempMrplPartShort SET PAQRUNTOT = @RunTot WHERE" & vbCrLf
SQL = SQL & "BMASSYPART = @AssyPart AND BMPARTREF = @Part AND MRP_ACTIONDATE = @PartDateQrd" & vbCrLf
SQL = SQL & "END" & vbCrLf
SQL = SQL & "FETCH NEXT FROM curRunTot1 INTO @AssyPart, @BMQtyReq, @RunQtyReq,@PartDateQrd" & vbCrLf
SQL = SQL & "End" & vbCrLf
SQL = SQL & "Close curRunTot1" & vbCrLf
SQL = SQL & "DEALLOCATE curRunTot1" & vbCrLf
SQL = SQL & "END" & vbCrLf
SQL = SQL & "FETCH NEXT FROM curRunTot INTO @Part, @PAQOH" & vbCrLf
SQL = SQL & "End" & vbCrLf
SQL = SQL & "Close curRunTot" & vbCrLf
SQL = SQL & "DEALLOCATE curRunTot" & vbCrLf
SQL = SQL & "END" & vbCrLf
SQL = SQL & "END" & vbCrLf
ExecuteScript False, SQL


SQL = "DropStoredProcedureIfExists 'RptTopIncomeStatement'" & vbCrLf
ExecuteScript False, SQL

SQL = "CREATE PROCEDURE [dbo].[RptTopIncomeStatement]" & vbCrLf
SQL = SQL & "   @StartDate as varchar(12),@EndDate as varchar(12)," & vbCrLf
SQL = SQL & "   @YearBeginDate as varchar(12), @InclIncAcct as varchar(1)" & vbCrLf
SQL = SQL & "AS " & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & " " & vbCrLf
SQL = SQL & "   declare @glAcctRef as varchar(10)" & vbCrLf
SQL = SQL & "   declare @glMsAcct as varchar(10)" & vbCrLf
SQL = SQL & "   declare @SumCurBal decimal(15,4)" & vbCrLf
SQL = SQL & "   declare @SumYTD decimal(15,4)" & vbCrLf
SQL = SQL & "   declare @SumPrevBal as decimal(15,4)" & vbCrLf
SQL = SQL & "   declare @level as integer" & vbCrLf
SQL = SQL & "   declare @TopLevelDesc as varchar(30)" & vbCrLf
SQL = SQL & "   declare @InclInAcct as Integer" & vbCrLf
SQL = SQL & "   declare @TopLevAcct as varchar(20)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "   declare @PrevMaster as varchar(10)" & vbCrLf
SQL = SQL & "   declare @RowCount as integer" & vbCrLf
SQL = SQL & "   declare @GlMasterAcc as varchar(10)" & vbCrLf
SQL = SQL & "   declare @GlChildAcct as varchar(10)" & vbCrLf
SQL = SQL & "   declare @ChildKey as varchar(1024)" & vbCrLf
SQL = SQL & "   declare @GLSortKey as varchar(1024)" & vbCrLf
SQL = SQL & "   declare @SortKey as varchar(1024)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "   DELETE FROM EsReportIncStatement" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "   if (@InclIncAcct = '1')" & vbCrLf
SQL = SQL & "      SET @InclInAcct = ''" & vbCrLf
SQL = SQL & "   Else" & vbCrLf
SQL = SQL & "      SET @InclInAcct = '0'" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "   DECLARE balAcctStruc CURSOR  FOR" & vbCrLf
SQL = SQL & "      SELECT '4', COINCMACCT, COINCMDESC FROM GlmsTopTable" & vbCrLf
SQL = SQL & "      Union All" & vbCrLf
SQL = SQL & "      SELECT '5', COCOGSACCT, COCOGSDESC FROM GlmsTopTable" & vbCrLf
SQL = SQL & "      Union All" & vbCrLf
SQL = SQL & "      SELECT '6', COEXPNACCT, COEXPNDESC FROM GlmsTopTable" & vbCrLf
SQL = SQL & "      Union All" & vbCrLf
SQL = SQL & "      SELECT '7', COOINCACCT, COOINCDESC FROM GlmsTopTable" & vbCrLf
SQL = SQL & "      Union All" & vbCrLf
SQL = SQL & "      SELECT '8', COOEXPACCT, COOEXPDESC FROM GlmsTopTable" & vbCrLf
SQL = SQL & "      Union All" & vbCrLf
SQL = SQL & "      SELECT '9', COFDTXACCT, COFDTXDESC FROM GlmsTopTable" & vbCrLf
SQL = SQL & " " & vbCrLf
SQL = SQL & "   OPEN balAcctStruc" & vbCrLf
SQL = SQL & "   FETCH NEXT FROM balAcctStruc INTO @level,@TopLevAcct, @TopLevelDesc" & vbCrLf
SQL = SQL & "   WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
SQL = SQL & "   BEGIN" & vbCrLf
SQL = SQL & "      IF (@@FETCH_STATUS <> -2)" & vbCrLf
SQL = SQL & "      BEGIN" & vbCrLf
SQL = SQL & " " & vbCrLf
SQL = SQL & "        ;with cte" & vbCrLf
SQL = SQL & "        as " & vbCrLf
SQL = SQL & "        (select GLACCTREF, GLDESCR, GLMASTER, GLFSLEVEL, 1 as level," & vbCrLf
SQL = SQL & "          cast(cast(@level as varchar(4))+ char(36)+ GLACCTREF as varchar(max)) as SortKey" & vbCrLf
SQL = SQL & "        From GlacTopTable" & vbCrLf
SQL = SQL & "        where GLMASTER = cast(@TopLevAcct as varchar(20)) AND GLINACTIVE LIKE @InclInAcct" & vbCrLf
SQL = SQL & "        Union All" & vbCrLf
SQL = SQL & "        select a.GLACCTREF, a.GLDESCR, a.GLMASTER, a.GLFSLEVEL, level + 1," & vbCrLf
SQL = SQL & "         cast(COALESCE(SortKey,'') + char(36) + COALESCE(a.GLACCTREF,'') as varchar(max))as SortKey" & vbCrLf
SQL = SQL & "        From cte" & vbCrLf
SQL = SQL & "          inner join GlacTopTable a" & vbCrLf
SQL = SQL & "            on cte.GLACCTREF = a.GLMASTER" & vbCrLf
SQL = SQL & "          WHERE GLINACTIVE LIKE @InclInAcct" & vbCrLf
SQL = SQL & "        )" & vbCrLf
SQL = SQL & "        INSERT INTO EsReportIncStatement(GLTOPMaster, GLTOPMASTERDESC, GLACCTREF, GLDESCR, GLMASTER, GLFSLEVEL,SORTKEYLEVEL,GLACCSORTKEY)" & vbCrLf
SQL = SQL & "        select @level, @TopLevelDesc, GLACCTREF, GLDESCR, GLMASTER, GLFSLEVEL, level, SortKey" & vbCrLf
SQL = SQL & "        from cte order by SortKey" & vbCrLf
SQL = SQL & " " & vbCrLf
SQL = SQL & "      End" & vbCrLf
SQL = SQL & "      FETCH NEXT FROM balAcctStruc INTO @level,@TopLevAcct, @TopLevelDesc" & vbCrLf
SQL = SQL & "   End" & vbCrLf
SQL = SQL & "   Close balAcctStruc" & vbCrLf
SQL = SQL & "   DEALLOCATE balAcctStruc" & vbCrLf
SQL = SQL & " " & vbCrLf
SQL = SQL & "   UPDATE EsReportIncStatement SET CurrentBal = foo.Balance--, SUMCURBAL = foo.Balance" & vbCrLf
SQL = SQL & "   From" & vbCrLf
SQL = SQL & "       (SELECT SUM(GjitTopTable.JICRD) - SUM(GjitTopTable.JIDEB) as Balance, JIACCOUNT" & vbCrLf
SQL = SQL & "         FROM GjhdTable INNER JOIN GjitTopTable ON GJNAME = JINAME" & vbCrLf
SQL = SQL & "      WHERE GJPOST BETWEEN @StartDate AND @EndDate" & vbCrLf
SQL = SQL & "         AND GjhdTable.GJPOSTED = 1" & vbCrLf
SQL = SQL & "      GROUP BY JIACCOUNT) as foo" & vbCrLf
SQL = SQL & "   Where foo.JIACCOUNT = GLACCTREF" & vbCrLf
SQL = SQL & " " & vbCrLf
SQL = SQL & "   UPDATE EsReportIncStatement SET YTD = foo.Balance--, SUMYTD = foo.Balance" & vbCrLf
SQL = SQL & "   From" & vbCrLf
SQL = SQL & "      (SELECT JIACCOUNT,SUM(GjitTopTable.JICRD) - SUM(GjitTopTable.JIDEB) AS Balance" & vbCrLf
SQL = SQL & "         FROM GjhdTable INNER JOIN GjitTopTable ON GJNAME = JINAME" & vbCrLf
SQL = SQL & "      WHERE (GJPOST BETWEEN @YearBeginDate AND @EndDate)" & vbCrLf
SQL = SQL & "         AND GjhdTable.GJPOSTED = 1" & vbCrLf
SQL = SQL & "      GROUP BY JIACCOUNT) as foo" & vbCrLf
SQL = SQL & "   Where foo.JIACCOUNT = GLACCTREF" & vbCrLf
SQL = SQL & " " & vbCrLf
SQL = SQL & "   UPDATE EsReportIncStatement SET PreviousBal = foo.Balance--, SUMPREVBAL = foo.Balance" & vbCrLf
SQL = SQL & "   From" & vbCrLf
SQL = SQL & "      (SELECT JIACCOUNT,SUM(GjitTopTable.JICRD) - SUM(GjitTopTable.JIDEB) AS Balance" & vbCrLf
SQL = SQL & "         FROM GjhdTable INNER JOIN GjitTopTable ON GJNAME = JINAME" & vbCrLf
SQL = SQL & "      WHERE (GJPOST BETWEEN DATEADD(year, -1, @YearBeginDate) AND DATEADD(year, -1, @EndDate))" & vbCrLf
SQL = SQL & "         AND GjhdTable.GJPOSTED = 1" & vbCrLf
SQL = SQL & "      GROUP BY JIACCOUNT) as foo" & vbCrLf
SQL = SQL & "   Where foo.JIACCOUNT = GLACCTREF" & vbCrLf
SQL = SQL & " " & vbCrLf
SQL = SQL & "   SELECT @level =  MAX(SORTKEYLEVEL) FROM EsReportIncStatement" & vbCrLf
SQL = SQL & "   --set @level = 9" & vbCrLf
SQL = SQL & "   WHILE (@level >= 1 )" & vbCrLf
SQL = SQL & "   BEGIN" & vbCrLf
SQL = SQL & " " & vbCrLf
SQL = SQL & "      DECLARE curAcctStruc CURSOR  FOR" & vbCrLf
SQL = SQL & "      SELECT GLMASTER, SUM(ISNULL(SUMCURBAL,0) + (ISNULL(CurrentBal,0))) ," & vbCrLf
SQL = SQL & "         Sum (IsNull(SUMYTD, 0) + (IsNull(YTD, 0))), Sum(IsNull(SUMPREVBAL, 0) + (IsNull(PreviousBal, 0)))" & vbCrLf
SQL = SQL & "      From" & vbCrLf
SQL = SQL & "         (SELECT DISTINCT GLACCTREF, GLDESCR, GLMASTER," & vbCrLf
SQL = SQL & "         CurrentBal , YTD, PreviousBal, SUMCURBAL, SUMYTD, SUMPREVBAL" & vbCrLf
SQL = SQL & "         FROM EsReportIncStatement WHERE SORTKEYLEVEL = @level) as foo" & vbCrLf
SQL = SQL & "      group by GLMASTER" & vbCrLf
SQL = SQL & " " & vbCrLf
SQL = SQL & "      OPEN curAcctStruc" & vbCrLf
SQL = SQL & "      FETCH NEXT FROM curAcctStruc INTO @glMsAcct, @SumCurBal, @SumYTD, @SumPrevBal" & vbCrLf
SQL = SQL & "      WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
SQL = SQL & "      BEGIN" & vbCrLf
SQL = SQL & "         IF (@@FETCH_STATUS <> -2)" & vbCrLf
SQL = SQL & "         BEGIN" & vbCrLf
SQL = SQL & "            UPDATE EsReportIncStatement SET SUMCURBAL = @SumCurBal, SUMYTD = @SumYTD," & vbCrLf
SQL = SQL & "               SUMPREVBAL = @SumPrevBal, GLDESCR = 'TOTAL ' + LTRIM(GLDESCR)," & vbCrLf
SQL = SQL & "            HASCHILD = 1" & vbCrLf
SQL = SQL & "            WHERE GLACCTREF = @glMsAcct" & vbCrLf
SQL = SQL & "         End" & vbCrLf
SQL = SQL & "         FETCH NEXT FROM curAcctStruc INTO @glMsAcct, @SumCurBal, @SumYTD, @SumPrevBal" & vbCrLf
SQL = SQL & "      End" & vbCrLf
SQL = SQL & "      Close curAcctStruc" & vbCrLf
SQL = SQL & "      DEALLOCATE curAcctStruc" & vbCrLf
SQL = SQL & "      SET @level = @level - 1" & vbCrLf
SQL = SQL & "   End" & vbCrLf
SQL = SQL & " " & vbCrLf
SQL = SQL & "   UPDATE EsReportIncStatement SET SUMCURBAL = CurrentBal WHERE SUMCURBAL IS NULL" & vbCrLf
SQL = SQL & "   UPDATE EsReportIncStatement SET SUMPREVBAL = PreviousBal WHERE SUMPREVBAL IS NULL" & vbCrLf
SQL = SQL & "   UPDATE EsReportIncStatement SET SUMYTD = YTD  WHERE SUMYTD IS NULL" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "   set @level = 0 " & vbCrLf
SQL = SQL & "   set @RowCount = 1" & vbCrLf
SQL = SQL & "   SET @PrevMaster = ''" & vbCrLf
SQL = SQL & "   DECLARE curAcctStruc CURSOR  FOR" & vbCrLf
SQL = SQL & "      SELECT GLMASTER, GLACCSORTKEY" & vbCrLf
SQL = SQL & "      FROM EsReportIncStatement " & vbCrLf
SQL = SQL & "         WHERE HASCHILD IS NULL --GLFSLEVEL = 8 --AND GLMASTER ='AA10'--GLTOPMaster = 1 AND " & vbCrLf
SQL = SQL & "      ORDER BY GLACCSORTKEY" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "   OPEN curAcctStruc" & vbCrLf
SQL = SQL & "   FETCH NEXT FROM curAcctStruc INTO @GlMasterAcc, @GLSortKey" & vbCrLf
SQL = SQL & "   WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
SQL = SQL & "   BEGIN" & vbCrLf
SQL = SQL & "    IF (@@FETCH_STATUS <> -2)" & vbCrLf
SQL = SQL & "    BEGIN" & vbCrLf
SQL = SQL & "      if (@PrevMaster <> @GlMasterAcc)" & vbCrLf
SQL = SQL & "      BEGIN" & vbCrLf
SQL = SQL & "         UPDATE EsReportIncStatement SET " & vbCrLf
SQL = SQL & "            SortKeyRev = RIGHT ('0000'+ Cast(@RowCount as varchar), 4) + char(36)+ @GlMasterAcc" & vbCrLf
SQL = SQL & "         WHERE GLMASTER = @GlMasterAcc AND HASCHILD IS NULL --GLFSLEVEL = 8 --AND GLTOPMaster = 1 " & vbCrLf
SQL = SQL & "         SET @RowCount = @RowCount + 1" & vbCrLf
SQL = SQL & "         SET @PrevMaster = @GlMasterAcc" & vbCrLf
SQL = SQL & "      END" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "    End" & vbCrLf
SQL = SQL & "    FETCH NEXT FROM curAcctStruc INTO @GlMasterAcc, @GLSortKey" & vbCrLf
SQL = SQL & "   End" & vbCrLf
SQL = SQL & "       " & vbCrLf
SQL = SQL & "   Close curAcctStruc" & vbCrLf
SQL = SQL & "   DEALLOCATE curAcctStruc" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "    SELECT @level = MAX(SORTKEYLEVEL) FROM EsReportIncStatement" & vbCrLf
SQL = SQL & "   --set @level = 7" & vbCrLf
SQL = SQL & "   WHILE (@level >= 1 )" & vbCrLf
SQL = SQL & "   BEGIN" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "      SET @PrevMaster = ''" & vbCrLf
SQL = SQL & "        DECLARE curAcctStruc1 CURSOR  FOR" & vbCrLf
SQL = SQL & "         SELECT DISTINCT GLACCTREF, GLMASTER, GLACCSORTKEY" & vbCrLf
SQL = SQL & "         FROM EsReportIncStatement " & vbCrLf
SQL = SQL & "            WHERE SORTKEYLEVEL = @level AND HASCHILD IS NOT NULL--GLTOPMaster = 1 AND " & vbCrLf
SQL = SQL & "         order by GLACCSORTKEY" & vbCrLf
SQL = SQL & "    " & vbCrLf
SQL = SQL & "        OPEN curAcctStruc1" & vbCrLf
SQL = SQL & "        FETCH NEXT FROM curAcctStruc1 INTO @GlChildAcct, @GlMasterAcc, @GLSortKey" & vbCrLf
SQL = SQL & "        WHILE (@@FETCH_STATUS <> -1)" & vbCrLf
SQL = SQL & "        BEGIN" & vbCrLf
SQL = SQL & "          IF (@@FETCH_STATUS <> -2)" & vbCrLf
SQL = SQL & "          BEGIN" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "            if (@PrevMaster <> @GlChildAcct)" & vbCrLf
SQL = SQL & "            BEGIN" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "   print 'Record' + @GlChildAcct + ':' + @GlMasterAcc" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "               SELECT TOP 1 @ChildKey = SortKeyRev,@SortKey = GLACCSORTKEY" & vbCrLf
SQL = SQL & "               FROM EsReportIncStatement " & vbCrLf
SQL = SQL & "                  WHERE SORTKEYLEVEL > @level AND GLMASTER = @GlChildAcct --GLTOPMaster = 1 AND " & vbCrLf
SQL = SQL & "               order by GLACCSORTKEY desc" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "               UPDATE EsReportIncStatement SET " & vbCrLf
SQL = SQL & "                  SortKeyRev = Cast(@ChildKey as varchar(512)) + char(36)+ @GlMasterAcc" & vbCrLf
SQL = SQL & "               WHERE GLACCTREF = @GlChildAcct AND GLMASTER = @GlMasterAcc " & vbCrLf
SQL = SQL & "                  AND SORTKEYLEVEL = @level --GLTOPMaster = 1 AND " & vbCrLf
SQL = SQL & "               SET @PrevMaster = @GlChildAcct" & vbCrLf
SQL = SQL & "            END" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "          End" & vbCrLf
SQL = SQL & "          FETCH NEXT FROM curAcctStruc1 INTO @GlChildAcct, @GlMasterAcc, @GLSortKey" & vbCrLf
SQL = SQL & "        End" & vbCrLf
SQL = SQL & "               " & vbCrLf
SQL = SQL & "        Close curAcctStruc1" & vbCrLf
SQL = SQL & "        DEALLOCATE curAcctStruc1" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "        SET @level = @level - 1" & vbCrLf
SQL = SQL & "   End" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "  SELECT GLTOPMaster, GLTOPMASTERDESC, GLACCTREF, GLACCTNO, GLDESCR, GLMASTER, GLTYPE,GLINACTIVE, GLFSLEVEL," & vbCrLf
SQL = SQL & "      SUMCURBAL , CurrentBal, SUMYTD, YTD, SUMPREVBAL, PreviousBal, SORTKEYLEVEL, GLACCSORTKEY" & vbCrLf
SQL = SQL & "   FROM EsReportIncStatement ORDER BY SortKeyRev --GLTOPMASTER, GLACCSORTKEY desc, SortKeyLevel" & vbCrLf
SQL = SQL & " " & vbCrLf
SQL = SQL & "End"
ExecuteScript False, SQL


''''''''''''''''''''''''''''''''''''''''''''''''''

      ' update the version
      ExecuteScript False, "Update Version Set Version = " & newver

   End If
End Function

Private Function UpdateDatabase103()

'update database version template
'set version at top of this file
'set version below
'add SQL updates


   Dim SQL As String
   SQL = ""

   newver = 178     ' set actual version
   If ver < newver Then

      clsADOCon.ADOErrNum = 0

''''''''''''''''''''''''''''''''''''''''''''''''''

SQL = "DropStoredProcedureIfExists 'RptCashReceipts'" & vbCrLf
ExecuteScript False, SQL
SQL = "create procedure RptCashReceipts" & vbCrLf
SQL = SQL & "@CustNickName varchar(10),      -- blank for all" & vbCrLf
SQL = SQL & "@StartDate as varchar(10),      -- 'mm/dd/yyyy'- blank for all" & vbCrLf
SQL = SQL & "@ReceiptAmount as varchar(10),  -- blank for all" & vbCrLf
SQL = SQL & "@CheckNumber as varchar(20), -- blank for all" & vbCrLf
SQL = SQL & "@ShowUninvoicedItems int     -- = 0 to not show, 1 to show" & vbCrLf
SQL = SQL & "as" & vbCrLf
SQL = SQL & "/* for View Cash Receipts Report" & vbCrLf
SQL = SQL & "test:" & vbCrLf
SQL = SQL & "exec RptCashReceipts 'BOECO','12/1/2017','','<All>',0" & vbCrLf
SQL = SQL & "exec RptCashReceipts 'BOECO','12/1/2017','5,375.01','<All>',0" & vbCrLf
SQL = SQL & "exec RptCashReceipts 'BOEWIN','12/1/2017','','',0" & vbCrLf
SQL = SQL & "exec RptCashReceipts 'hexstr','12/1/2017','','',0" & vbCrLf
SQL = SQL & "exec RptCashReceipts 'MISC','12/1/2017','','',1" & vbCrLf
SQL = SQL & "*/" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "if exists (select * from INFORMATION_SCHEMA.tables where table_name = 'RptViewCR')" & vbCrLf
SQL = SQL & "drop table RptViewCR" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- get accounts from ComnTable" & vbCrLf
SQL = SQL & "declare @CashAccount varchar(12), @ArAccount varchar(12),@TransFeeAccount varchar(12)" & vbCrLf
SQL = SQL & "select @CashAccount = COCRCASHACCT, @ArAccount = COSJARACCT, @TransFeeAccount = COTRANSFEEACCT from ComnTable" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "declare @sql varchar(1000)" & vbCrLf
SQL = SQL & "set @sql =" & vbCrLf
SQL = SQL & "'SELECT" & vbCrLf
SQL = SQL & "cash.CACUST, cash.CACHECKNO, cash.CACDATE, cash.CAINVNO, cash.CARCDATE, cash.CACRAMT, cash.CACKAMT, cash.CAENTRY," & vbCrLf
SQL = SQL & "jr.DCDEBIT, jr.DCCREDIT, jr.DCHEAD, jr.DCTRAN, jr.DCREF," & vbCrLf
SQL = SQL & "inv.INVDATE, inv.INVPRE, inv.INVTYPE," & vbCrLf
SQL = SQL & "jr.DCACCTNO," & vbCrLf
SQL = SQL & "acct.GLDESCR" & vbCrLf
SQL = SQL & "into RptViewCR" & vbCrLf
SQL = SQL & "FROM CashTable cash" & vbCrLf
SQL = SQL & "LEFT OUTER JOIN JritTable jr ON cash.CACUST=jr.DCCUST AND cash.CACHECKNO=jr.DCCHECKNO AND cash.CAINVNO = jr.DCINVNO" & vbCrLf
SQL = SQL & "INNER JOIN GlacTable acct ON jr.DCACCTNO=acct.GLACCTREF" & vbCrLf
SQL = SQL & "LEFT OUTER JOIN CihdTable inv ON cash.CAINVNO=inv.INVNO" & vbCrLf
SQL = SQL & "INNER JOIN CustTable cust ON cash.CACUST=cust.CUREF" & vbCrLf
SQL = SQL & "'" & vbCrLf
SQL = SQL & "declare @where varchar(500)" & vbCrLf
SQL = SQL & "--set @where = 'WHERE DCACCTNO not in (''' + @CashAccount + ''',''' + @ArAccount + ''')" & vbCrLf
SQL = SQL & "--'" & vbCrLf
SQL = SQL & "set @where = ''" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "if @CustNickName <> ''" & vbCrLf
SQL = SQL & "set @where = @where + 'and CACUST = ''' + @CustNickName + '''" & vbCrLf
SQL = SQL & "'" & vbCrLf
SQL = SQL & "if @StartDate <> ''" & vbCrLf
SQL = SQL & "set @where = @where + 'and CARCDATE >= ''' + @StartDate + '''" & vbCrLf
SQL = SQL & "'" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "if @ReceiptAmount <> ''" & vbCrLf
SQL = SQL & "set @where = @where + 'and CACKAMT = ' + replace(@ReceiptAmount,',','') + '" & vbCrLf
SQL = SQL & "'" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "if @Checknumber <> '' and @Checknumber <> '<All>'" & vbCrLf
SQL = SQL & "set @where = @where + 'and CACHECKNO = ''' + @Checknumber + '''" & vbCrLf
SQL = SQL & "'" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "if @ShowUninvoicedItems = 0" & vbCrLf
SQL = SQL & "set @where = @where + 'and INVDATE is not null" & vbCrLf
SQL = SQL & "'" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "if @where <> ''" & vbCrLf
SQL = SQL & "begin" & vbCrLf
SQL = SQL & "set @where = stuff(@where,1,3,'where')" & vbCrLf
SQL = SQL & "set @sql = @sql + @where" & vbCrLf
SQL = SQL & "end" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "set @sql = @sql + 'order by cash.CACHECKNO,cash.CAINVNO,DCREF'" & vbCrLf
SQL = SQL & "print @sql" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "exec (@sql)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- construct a single line for each check/invoice combination" & vbCrLf
SQL = SQL & "select CACUST as Customer, CACHECKNO as [Check #], convert(varchar(8),CACDATE,1) AS [Check Date],CACKAMT as [Check Amt]," & vbCrLf
SQL = SQL & "convert(varchar(8),CARCDATE,1) as [Receipt Date]," & vbCrLf
SQL = SQL & "CACRAMT as [Receipt Amt],CAENTRY as [Entered by]," & vbCrLf
SQL = SQL & "ISNULL(INVTYPE + ' ' + INVPRE + cast(CAINVNO as varchar(10)),'NONE') as [Invoice #],CAINVNO," & vbCrLf
SQL = SQL & "isnull(convert(varchar(8),INVDATE,1),'') AS [Inv Date],  DCDEBIT as [Cash], cast(0.00 as decimal(12,2)) as Adj," & vbCrLf
SQL = SQL & "cast(0.00 as decimal(12,2)) as [Total Applied],cast('' as varchar(50)) as [Adjustment to]" & vbCrLf
SQL = SQL & "into #temp from RptViewCR" & vbCrLf
SQL = SQL & "where DCACCTNO = @CashAccount" & vbCrLf
SQL = SQL & "order by CACUST, CARCDATE, CAINVNO" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "update tmp" & vbCrLf
SQL = SQL & "set Adj = DCDEBIT, [Adjustment to] = GLDESCR" & vbCrLf
SQL = SQL & "from #temp tmp join RptViewCr cr on cr.CACUST = tmp.Customer and cr.CACHECKNO = tmp.[Check #]" & vbCrLf
SQL = SQL & "and cr.CAINVNO = tmp.CAINVNO and DCDEBIT <> 0 AND DCACCTNO <> @CashAccount" & vbCrLf
SQL = SQL & "drop table RptViewCR" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "update #temp set [Total Applied] = [Cash] + Adj" & vbCrLf
SQL = SQL & "select * from #temp order by Customer, [Receipt Date], [Check #], CAINVNO" & vbCrLf
SQL = SQL & "drop table #temp" & vbCrLf
ExecuteScript False, SQL



''''''''''''''''''''''''''''''''''''''''''''''''''

      ' update the version
      ExecuteScript False, "Update Version Set Version = " & newver

   End If
End Function

Private Function UpdateDatabase104()

'update database version template
'set version at top of this file
'set version below
'add SQL updates


   Dim SQL As String
   SQL = ""

   newver = 179     ' set actual version
   If ver < newver Then

      clsADOCon.ADOErrNum = 0

''''''''''''''''''''''''''''''''''''''''''''''''''

SQL = "AddOrUpdateColumn 'PshdTable', 'PSCOMMENTS', 'varchar(2040)'"
ExecuteScript False, SQL

''''''''''''''''''''''''''''''''''''''''''''''''''

      ' update the version
      ExecuteScript False, "Update Version Set Version = " & newver

   End If
End Function

Private Function UpdateDatabase105()

   Dim SQL As String
   SQL = ""

   newver = 180     ' set actual version
   If ver < newver Then

      clsADOCon.ADOErrNum = 0

''''''''''''''''''''''''''''''''''''''''''''''''''

SQL = "exec DropStoredProcedureIfExists 'DropTempTableIfExists'" & vbCrLf
ExecuteScript False, SQL

SQL = "create procedure DropTempTableIfExists" & vbCrLf
SQL = SQL & "@Table_Name varchar(50)" & vbCrLf
SQL = SQL & "as" & vbCrLf
SQL = SQL & "begin" & vbCrLf
SQL = SQL & "IF OBJECT_ID('tempdb.dbo.' + @Table_Name) IS NOT NULL" & vbCrLf
SQL = SQL & "begin" & vbCrLf
SQL = SQL & "declare @sql varchar(100)" & vbCrLf
SQL = SQL & "set @sql = 'DROP TABLE ' + @Table_Name" & vbCrLf
SQL = SQL & "execute(@sql)" & vbCrLf
SQL = SQL & "end" & vbCrLf
SQL = SQL & "end" & vbCrLf
ExecuteScript False, SQL

' delete millions of POM error messages
' do it 3 times because for some reason, one delete does not get them all
SQL = "delete from SystemEvents where Event_SQL = 'select getdate() AS ServerTime'" & vbCrLf
ExecuteScript False, SQL
SQL = "delete from SystemEvents where Event_SQL = 'select getdate() AS ServerTime'" & vbCrLf
ExecuteScript False, SQL
SQL = "delete from SystemEvents where Event_SQL = 'select getdate() AS ServerTime'" & vbCrLf
ExecuteScript False, SQL


''''''''''''''''''''''''''''''''''''''''''''''''''

      ' update the version
      ExecuteScript False, "Update Version Set Version = " & newver

   End If
End Function

Private Function UpdateDatabase106()

'update database version template
'set version at top of this file
'set version below
'add SQL updates


   Dim SQL As String
   SQL = ""

   newver = 184     ' set actual version
   If ver < newver Then

      clsADOCon.ADOErrNum = 0

''''''''''''''''''''''''''''''''''''''''''''''''''

' IMAINC Auto Release
' 097% auto-release performance improvement
SQL = "CREATE NONCLUSTERED INDEX [IX_TempMrplPartShort]" & vbCrLf
SQL = SQL & "ON [dbo].[tempMrplPartShort] ([BMPARTREF],[SORTKEYLEVEL])" & vbCrLf
ExecuteScript True, SQL

SQL = "exec DropStoredProcedureIfExists 'GetScMOs'" & vbCrLf
ExecuteScript True, SQL

' for IMAINC only
' Get a list of all SC status MOs that can be auto-released
SQL = "create procedure GetScMOs" & vbCrLf
SQL = SQL & "@Parts varchar(30),    -- leading characters for MO parts to select" & vbCrLf
SQL = SQL & "@StartDate date,    -- start pick date" & vbCrLf
SQL = SQL & "@EndDate date       -- end pick date" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "as" & vbCrLf
SQL = SQL & "/* test" & vbCrLf
SQL = SQL & "exec GetScMOs '', '7/1/18','7/1/18'" & vbCrLf
SQL = SQL & "*/" & vbCrLf
SQL = SQL & "set nocount on" & vbCrLf
SQL = SQL & "declare @EndDatePlus1 date = dateadd(day,1,@EndDate)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- get list of all SC runs" & vbCrLf
SQL = SQL & "SELECT DISTINCT RUNREF as MRP_PARTREF, RUNNO, ISNULL(RUNOPCUR, 0) as RUNOPCUR, PARTNUM as MRP_PARTNUM," & vbCrLf
SQL = SQL & "RUNQTY As MRP_PARTQTYRQD, Convert(varchar(10), RUNPKSTART, 101) As MRP_PARTDATERQD," & vbCrLf
SQL = SQL & "Convert(varchar(10), RUNSCHED, 101) As MRP_ACTIONDATE, RUNSTATUS,RUNPKSTART,PABOMREV,op.OPCENTER," & vbCrLf
SQL = SQL & "ROW_NUMBER() over (ORDER BY RUNPKSTART) AS [MO#]" & vbCrLf
SQL = SQL & "into #temp" & vbCrLf
SQL = SQL & "FROM RunsTable r" & vbCrLf
SQL = SQL & "join PartTable p on PARTREF = RUNREF" & vbCrLf
SQL = SQL & "join RnopTable op on op.opref = r.RUNREF and op.OPRUN = r.RUNNO and op.OPNO = r.RUNOPCUR" & vbCrLf
SQL = SQL & "WHERE RUNREF LIKE @Parts + '%' AND RUNSTATUS = 'SC' and op.OPCENTER = '0120'" & vbCrLf
SQL = SQL & "AND RUNPKSTART >= @StartDate AND RUNPKSTART < @EndDatePlus1" & vbCrLf
SQL = SQL & "order by RUNPKSTART" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- get a list of all pick list requirements" & vbCrLf
SQL = SQL & "select t.[MO#], BMPARTREF, BMQTYREQD,MRP_PARTQTYRQD," & vbCrLf
SQL = SQL & "cast(BMQTYREQD * MRP_PARTQTYRQD as decimal(15,4)) as Qty," & vbCrLf
SQL = SQL & "CAST(-1 AS DECIMAL(15,4)) as Surplus" & vbCrLf
SQL = SQL & "into #picks" & vbCrLf
SQL = SQL & "from #temp t" & vbCrLf
SQL = SQL & "join BmplTable bm on bm.BMASSYPART = t.MRP_PARTREF and bm.BMREV = t.PABOMREV" & vbCrLf
SQL = SQL & "order by MO#, BMPARTREF" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- get a list of all part quantities on hand less open pick list quantities" & vbCrLf
SQL = SQL & "select MRP_PARTREF,sum(MRP_PARTQTYRQD) as AVAIL, sum(MRP_PARTQTYRQD) as OrigAvail" & vbCrLf
SQL = SQL & "into #parts" & vbCrLf
SQL = SQL & "from" & vbCrLf
SQL = SQL & "PartTable pt left join MrplTable mrp on mrp.MRP_PARTREF = pt.PARTREF" & vbCrLf
SQL = SQL & "where MRP_TYPE in (1,12)" & vbCrLf
SQL = SQL & "group by MRP_PARTREF" & vbCrLf
SQL = SQL & "order by MRP_PARTREF" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- insert parts not in mpr" & vbCrLf
SQL = SQL & "insert #parts" & vbCrLf
SQL = SQL & "select PARTREF,PAQOH, PAQOH" & vbCrLf
SQL = SQL & "from PartTable pt" & vbCrLf
SQL = SQL & "left join #parts p on p.MRP_PARTREF = pt.PARTREF" & vbCrLf
SQL = SQL & "where PALEVEL <= 4 and p.MRP_PARTREF is null" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- for each MO, determine if pick list quantities are available" & vbCrLf
SQL = SQL & "declare @MONO int" & vbCrLf
SQL = SQL & "DECLARE cur CURSOR FOR" & vbCrLf
SQL = SQL & "SELECT [MO#]" & vbCrLf
SQL = SQL & "FROM #temp" & vbCrLf
SQL = SQL & "order by [MO#]" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "OPEN cur" & vbCrLf
SQL = SQL & "FETCH NEXT FROM cur INTO @MONO" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "WHILE @@FETCH_STATUS = 0" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "update p set Surplus = pt.AVAIL - p.Qty" & vbCrLf
SQL = SQL & "from #picks p join #parts pt on p.BMPARTREF = pt.MRP_PARTREF" & vbCrLf
SQL = SQL & "where p.MO# = @MONO" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- if any negative quantities for pick list, delete MO" & vbCrLf
SQL = SQL & "if(select min(Surplus) from #picks where MO# = @MONO) < 0" & vbCrLf
SQL = SQL & "begin" & vbCrLf
SQL = SQL & "delete from #temp where MO# = @MONO" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- otherwise subtract from quantities available" & vbCrLf
SQL = SQL & "end" & vbCrLf
SQL = SQL & "else" & vbCrLf
SQL = SQL & "begin" & vbCrLf
SQL = SQL & "update p set AVAIL = Avail - pk.Qty" & vbCrLf
SQL = SQL & "from #parts p join #picks pk on pk.BMPARTREF = p.MRP_PARTREF" & vbCrLf
SQL = SQL & "where pk.MO# = @MONO" & vbCrLf
SQL = SQL & "end" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "FETCH NEXT FROM cur INTO @MONO" & vbCrLf
SQL = SQL & "END" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "CLOSE cur" & vbCrLf
SQL = SQL & "DEALLOCATE cur" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "select * from #temp order by MO#" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "drop table #temp" & vbCrLf
SQL = SQL & "drop table #picks" & vbCrLf
SQL = SQL & "drop table #parts" & vbCrLf
ExecuteScript True, SQL

''''''''''''''''''''''''''''''''''''''''''''''

SQL = "exec DropStoredProcedureIfExists 'RptPriorityDispatch'" & vbCrLf
ExecuteScript True, SQL

SQL = "create procedure RptPriorityDispatch" & vbCrLf
SQL = SQL & "@Shop varchar(20),  -- show WCs for this shop" & vbCrLf
SQL = SQL & "@StartDate date, -- starting OPSCHEDDATE to include" & vbCrLf
SQL = SQL & "@EndDate date    -- ending OPSCHEDDATE to include" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "as" & vbCrLf
SQL = SQL & "/* EBM Priority Dispatch Report 10/29/2018 TEL" & vbCrLf
SQL = SQL & "test" & vbCrLf
SQL = SQL & "exec RptPriorityDispatch 'IS', '1/1/2018', '9/30/2018'" & vbCrLf
SQL = SQL & "exec RptPriorityDispatch 'OS', '1/1/2018', '9/30/2018'" & vbCrLf
SQL = SQL & "exec RptPriorityDispatch '', '1/1/2018', '9/30/2018'" & vbCrLf
SQL = SQL & "*/" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "declare @EndPlus1 date = dateadd(day,1,@EndDate)  -- end date plus 1 to include all times on end datetime" & vbCrLf
SQL = SQL & "set @Shop = rtrim(@Shop)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "select wc.WCNSHOP, wc.WCNREF, wc.WCNDESC, pt.PARTNUM,pt.PADESC,run.RUNNO, op.OPNO," & vbCrLf
SQL = SQL & "CONVERT(VARCHAR(10), OPSUDATE, 101) + ' ' + CONVERT(VARCHAR(5), OPSUDATE, 108) as [Start]," & vbCrLf
SQL = SQL & "CONVERT(VARCHAR(10), OPMDATE, 101) + ' ' + CONVERT(VARCHAR(5), OPMDATE, 108) as [End]," & vbCrLf
SQL = SQL & "RUNQTY, OPSUHRS, OPRUNHRS, RUNSTATUS" & vbCrLf
SQL = SQL & "from RnopTable op" & vbCrLf
SQL = SQL & "join RunsTable run on run.RUNREF = op.OPREF and run.RUNNO = op.OPRUN" & vbCrLf
SQL = SQL & "join PartTable pt on pt.PARTREF = run.RUNREF" & vbCrLf
SQL = SQL & "join WcntTable wc on wc.WCNREF = op.OPCENTER and wc.WCNSHOP = op.OPSHOP" & vbCrLf
SQL = SQL & "where (OPSHOP = @Shop or @Shop = '')" & vbCrLf
SQL = SQL & "and OPSCHEDDATE >= @StartDate and OPSCHEDDATE < @EndPlus1" & vbCrLf
SQL = SQL & "and OPCOMPDATE IS null" & vbCrLf
SQL = SQL & "and RUNSTATUS not like 'c%'" & vbCrLf
SQL = SQL & "order by WCNSHOP, WCNREF, OPSUDATE" & vbCrLf
SQL = SQL & "" & vbCrLf
ExecuteScript True, SQL

SQL = "exec DropStoredProcedureIfExists 'RptEfficiencyByWC'" & vbCrLf
ExecuteScript True, SQL

SQL = "create procedure RptEfficiencyByWC" & vbCrLf
SQL = SQL & "@Shop varchar(20),  -- show WCs for this shop" & vbCrLf
SQL = SQL & "@StartDate date, -- starting OPCOMPDATE to include" & vbCrLf
SQL = SQL & "@EndDate date    -- ending OPCOMPDATE to include" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "as" & vbCrLf
SQL = SQL & "/* EBM Efficiency by Workcenter Report 10/29/2018 TEL" & vbCrLf
SQL = SQL & "-- hours from routing vs hours charged by employee ? individually and entire company: 4 hours" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "test" & vbCrLf
SQL = SQL & "exec RptEfficiencyByWC 'IS', '1/1/2018', '1/31/2018'" & vbCrLf
SQL = SQL & "exec RptEfficiencyByWC 'OS', '1/1/2018', '1/31/2018'" & vbCrLf
SQL = SQL & "exec RptEfficiencyByWC '', '1/1/2018', '1/31/2018'" & vbCrLf
SQL = SQL & "*/" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "declare @DatePlus1 date = dateadd(day,1, @EndDate)" & vbCrLf
SQL = SQL & "set @Shop = rtrim(@Shop)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- get all operations in date range" & vbCrLf
SQL = SQL & "select WCNSHOP as Shop, OPCENTER as WC, wc.WCNDESC as [WC Desc], pt.PARTNUM as [Part#], OPRUN as [Run#], OPNO as [Op#]," & vbCrLf
SQL = SQL & "count(*) as [Charges], max(run.RUNQTY) as Qty, CONVERT(varchar(10)," & vbCrLf
SQL = SQL & "max(OPCOMPDATE),101) AS [Completed], max(OPSUHRS) as Setup, MAX(OPUNITHRS) as Unit," & vbCrLf
SQL = SQL & "max(cast(OPSUHRS + RUNQTY * OPUNITHRS as decimal(15,4))) AS [Op Hours]," & vbCrLf
SQL = SQL & "cast(sum(TCHOURS) as decimal(15,4)) as [Emp Hours], cast(0 as decimal(15,0)) as [Eff%]" & vbCrLf
SQL = SQL & "into #temp" & vbCrLf
SQL = SQL & "from rnoptable op" & vbCrLf
SQL = SQL & "join TcitTable tc on tc.TCPARTREF = op.OPREF and tc.TCRUNNO = op.OPRUN and tc.TCOPNO = op.OPNO" & vbCrLf
SQL = SQL & "and tc.TCWC = op.OPCENTER and tc.TCSHOP = op.OPSHOP" & vbCrLf
SQL = SQL & "join WcntTable wc on wc.WCNREF = op.OPCENTER and wc.WCNSHOP = op.OPSHOP" & vbCrLf
SQL = SQL & "join PartTable pt on pt.PARTREF = op.OPREF" & vbCrLf
SQL = SQL & "join RunsTable run on run.RUNREF = op.OPREF and run.RUNNO = op.OPRUN" & vbCrLf
SQL = SQL & "where (@Shop = '' or WCNSHOP = @Shop) and OPCOMPLETE = 1" & vbCrLf
SQL = SQL & "and OPCOMPDATE >= @StartDate and OPCOMPDATE < @DatePlus1" & vbCrLf
SQL = SQL & "group by WCNSHOP, OPCENTER, WCNDESC, pt.PARTNUM, OPRUN, OPNO" & vbCrLf
SQL = SQL & "order by WCNSHOP, OPCENTER, max(OPCOMPDATE)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "update #temp set [Eff%] = 100.00 * [Op Hours] / [Emp Hours]" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "select * from #temp order by Shop, WC, Completed" & vbCrLf
SQL = SQL & "drop table #temp" & vbCrLf
ExecuteScript True, SQL

SQL = "exec DropStoredProcedureIfExists 'RptEfficiencyByEmployee'" & vbCrLf
ExecuteScript True, SQL

SQL = "create procedure RptEfficiencyByEmployee" & vbCrLf
SQL = SQL & "@Shop varchar(20),  -- show WCs for this shop" & vbCrLf
SQL = SQL & "@StartDate date, -- starting OPCOMPDATE to include" & vbCrLf
SQL = SQL & "@EndDate date    -- ending OPCOMPDATE to include" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "as" & vbCrLf
SQL = SQL & "/* EBM Efficiency by Employee Report 10/30/2018 TEL" & vbCrLf
SQL = SQL & "hours worked vs hours on jobs ? individually and entire company" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "test" & vbCrLf
SQL = SQL & "exec RptEfficiencyByEmployee 'IS', '1/1/2018', '1/31/2018'" & vbCrLf
SQL = SQL & "exec RptEfficiencyByEmployee 'OS', '1/1/2018', '1/31/2018'" & vbCrLf
SQL = SQL & "exec RptEfficiencyByEmployee '', '1/1/2018', '1/31/2018'" & vbCrLf
SQL = SQL & "*/" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- get all operations completing in date range" & vbCrLf
SQL = SQL & "declare @DatePlus1 date = dateadd(day,1, @EndDate)" & vbCrLf
SQL = SQL & "set @Shop = rtrim(@Shop)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "select TCEMP as [Emp#], rtrim(emp.PREMFSTNAME) + ' ' + rtrim(EMP.PREMLSTNAME) as [Employee Name]," & vbCrLf
SQL = SQL & "CONVERT(VARCHAR(10), TCSTARTTIME, 101) + ' ' + CONVERT(VARCHAR(5), TCSTARTTIME, 108) as [Start]," & vbCrLf
SQL = SQL & "OPCENTER as WC, pt.PARTNUM as [Part#], OPRUN as [Run#], OPNO as [Op#]," & vbCrLf
SQL = SQL & "cast(TCHOURS as decimal(15,4)) as [Op Hours]," & vbCrLf
SQL = SQL & "cast(0 as decimal(15,4)) as [Wk Hours]" & vbCrLf
SQL = SQL & "into #temp" & vbCrLf
SQL = SQL & "from rnoptable op" & vbCrLf
SQL = SQL & "join TcitTable tc on tc.TCPARTREF = op.OPREF and tc.TCRUNNO = OP.OPRUN and tc.TCOPNO = op.OPNO" & vbCrLf
SQL = SQL & "and tc.TCWC = op.OPCENTER and tc.TCSHOP = op.OPSHOP" & vbCrLf
SQL = SQL & "join PartTable pt on pt.PARTREF = op.OPREF" & vbCrLf
SQL = SQL & "join EmplTable emp on emp.PREMNUMBER = tc.TCEMP" & vbCrLf
SQL = SQL & "where TCSTARTTIME >= @StartDate and TCSTARTTIME < @DatePlus1 and (TCSHOP = @Shop or @Shop = '')" & vbCrLf
SQL = SQL & "order by TCEMP, TCSTARTTIME" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "update #temp set [Wk Hours] = (select sum(TMREGHRS + TMOVTHRS + TMDBLHRS)" & vbCrLf
SQL = SQL & "from TchdTable where TMEMP = Emp# AND TMDAY BETWEEN @StartDate AND @EndDate)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "select * from #temp order by Emp#, Start" & vbCrLf
SQL = SQL & "drop table #temp" & vbCrLf
ExecuteScript True, SQL


'''''''''''''''''''''''''''''''''''''''

SQL = "exec DropStoredProcedureIfExists 'RptApAgingBase'" & vbCrLf
ExecuteScript True, SQL


' select invoices to include
' EMB had a conversion issue where invoices prior to 7/1/12 had no debits or credits.
' this date restriction is enforced for all customers

SQL = "create procedure RptApAgingBase" & vbCrLf
SQL = SQL & "@AsOfDate date," & vbCrLf
SQL = SQL & "@Vendor varchar(20),   -- 'ALL' all" & vbCrLf
SQL = SQL & "@AgeByPostDate bit  -- = 1 to age by posting date (VIDTRECD), = 0 to post by invoice data (VIDATE)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "as" & vbCrLf
SQL = SQL & "/* test" & vbCrLf
SQL = SQL & "exec RptApAgingBase '6/30/2018', '', 1" & vbCrLf
SQL = SQL & "exec RptApAgingBase '6/30/2018', 'ALACOP', 1" & vbCrLf
SQL = SQL & "exec RptApAgingBase '6/30/2018', 'ALACOP', 0" & vbCrLf
SQL = SQL & "exec RptApAgingBase '6/30/2018', 'IRSINT', 1" & vbCrLf
SQL = SQL & "*/" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "SET NOCOUNT ON" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "IF OBJECT_ID('tempdb..##TempApAging') IS NOT NULL" & vbCrLf
SQL = SQL & "begin" & vbCrLf
SQL = SQL & "drop table ##TempApAging" & vbCrLf
SQL = SQL & "end" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "PRINT @Vendor" & vbCrLf
SQL = SQL & "select RTRIM(VIVENDOR) AS VENDOR, rtrim(VEBNAME) AS VENDORNAME, VENUMBER AS [VENDOR#] ," & vbCrLf
SQL = SQL & "RTRIM(VINO) AS VINO, VIDUE, VIPAY," & vbCrLf
SQL = SQL & "cast(VIDTRECD as date) as VIDTRECD, cast(VIDATE as date) as VIDATE," & vbCrLf
SQL = SQL & "cast(VIREVDATE as date) as VIREVDATE, VIPIF," & vbCrLf
SQL = SQL & "cast(0 as int) as PONUMBER," & vbCrLf
SQL = SQL & "cast(0 as int) as PORELEASE," & vbCrLf
SQL = SQL & "cast('' as varchar(15)) as PoRef," & vbCrLf
SQL = SQL & "case when @AgeByPostDate = 1 then VIDTRECD else VIDATE end as AgeDate," & vbCrLf
SQL = SQL & "cast(0 as int) as AgeDays," & vbCrLf
SQL = SQL & "VEDDAYS as DiscDays," & vbCrLf
SQL = SQL & "VEDISCOUNT as DiscRate," & vbCrLf
SQL = SQL & "cast(null as datetime) as DiscDate," & vbCrLf
SQL = SQL & "cast(0 as decimal(15,2)) as DiscAmt," & vbCrLf
SQL = SQL & "--cast('' as varchar(100)) as DiscMsg," & vbCrLf
SQL = SQL & "cast(0 as decimal(12,2)) AS AmtPaid," & vbCrLf
SQL = SQL & "cast(0 as decimal(15,2)) as AmtDue," & vbCrLf
SQL = SQL & "cast(0 as decimal(15,2)) as [0-30 Days]," & vbCrLf
SQL = SQL & "cast(0 as decimal(15,2)) as [31-60 Days]," & vbCrLf
SQL = SQL & "cast(0 as decimal(15,2)) as [61-90 Days]," & vbCrLf
SQL = SQL & "cast(0 as decimal(15,2)) as [91+ Days]" & vbCrLf
SQL = SQL & "into ##TempApAging" & vbCrLf
SQL = SQL & "from VihdTable inv" & vbCrLf
SQL = SQL & "left join VndrTable ven on inv.VIVENDOR = ven.VEREF" & vbCrLf
SQL = SQL & "where VIDATE >= '7/1/12' and ((@AgeByPostDate = 0 and VIDATE <= @AsOfDate)" & vbCrLf
SQL = SQL & "or (@AgeByPostDate = 1 and VIDTRECD <= @AsOfDate)) and (@Vendor = 'ALL' or VIVENDOR = @Vendor)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- update to use posting date in purchases journal.  Sometimes VIDTRECD is off by a day.  don't know why" & vbCrLf
SQL = SQL & "if @AgeByPostDate = 1" & vbCrLf
SQL = SQL & "begin" & vbCrLf
SQL = SQL & "update inv" & vbCrLf
SQL = SQL & "set INV.AgeDate = dc.DCDATE" & vbCrLf
SQL = SQL & "from ##TempApAging inv join JritTable dc on dc.DCVENDOR = inv.VENDOR and dc.DCVENDORINV = inv.VINO" & vbCrLf
SQL = SQL & "where dc.DCHEAD like 'pj%' and DCDATE <> VIDTRECD" & vbCrLf
SQL = SQL & "end" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- insert amount paid for computer checks as of that date (amount less non-voided checks as of that date)" & vbCrLf
SQL = SQL & "update ##TempApAging set AmtPaid = (select isnull(sum(DCDEBIT),0) - isnull(sum(DCCREDIT),0) from JritTable j" & vbCrLf
SQL = SQL & "join ChksTable c on c.CHKVENDOR = j.DCVENDOR and c.CHKNUMBER = j.DCCHECKNO" & vbCrLf
SQL = SQL & "join GlacTable gl on gl.GLACCTNO = j.DCACCTNO" & vbCrLf
SQL = SQL & "where j.DCVENDOR = VENDOR and j.DCVENDORINV = VINO and isnull(c.CHKVOID,0) = 0" & vbCrLf
SQL = SQL & "and (DCHEAD like 'CC%' or DCHEAD like 'XC%') and GLTYPE = 2 and DCDATE <= @AsOfDate)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- now add amounts for external checks where the check number may or may not be specified" & vbCrLf
SQL = SQL & "update ##TempApAging set AmtPaid = AmtPaid + (select isnull(sum(DCDEBIT),0) - isnull(sum(DCCREDIT),0) from JritTable j" & vbCrLf
SQL = SQL & "left join ChksTable c on c.CHKVENDOR = j.DCVENDOR and c.CHKNUMBER = j.DCCHECKNO" & vbCrLf
SQL = SQL & "join GlacTable gl on gl.GLACCTNO = j.DCACCTNO" & vbCrLf
SQL = SQL & "where j.DCVENDOR = ##TempApAging.VENDOR and j.DCVENDORINV = VINO and c.CHKNUMBER is null" & vbCrLf
SQL = SQL & "and (DCHEAD like 'CC%' or DCHEAD like 'XC%') and GLTYPE = 2 and DCDATE <= @AsOfDate)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "--delete from ##TempApAging where paid amt = invoice amt as of date requested" & vbCrLf
SQL = SQL & "delete from ##TempApAging where vidue = AmtPaid" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- delete invoices paid in full where VIDUE < 0 AND VIPAY > 0 (this is a bug)" & vbCrLf
SQL = SQL & "delete from ##TempApAging where VIDUE = - VIPAY and VIDUE < 0 and VIPIF = 1" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- delete where a credit has been overapplied (this is a bug too)" & vbCrLf
SQL = SQL & "delete from ##TempApAging where VIDUE < 0 and AmtPaid < VIDUE" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- if there is a PO, use it's payment terms.  also set PO # and release" & vbCrLf
SQL = SQL & "update t" & vbCrLf
SQL = SQL & "set DiscDays = po.PODDAYS, DiscRate = po.PODISCOUNT," & vbCrLf
SQL = SQL & "PONUMBER = po.PONUMBER, PORELEASE = po.PORELEASE" & vbCrLf
SQL = SQL & "from ##TempApAging t" & vbCrLf
SQL = SQL & "join JritTable dc on dc.DCVENDOR = t.VENDOR and dc.DCVENDORINV = t.VINO" & vbCrLf
SQL = SQL & "join PohdTable po on po.PONUMBER = dc.DCPONUMBER and po.PORELEASE = dc.DCPORELEASE and DCPONUMBER <> 0" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "update ##TempApAging set PoRef = cast(PONUMBER as varchar(6)) + '-' + cast(PORELEASE as varchar(6)) where PONUMBER <> 0" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- determine aging" & vbCrLf
SQL = SQL & "update ##TempApAging set AmtDue = VIDUE - AmtPaid" & vbCrLf
SQL = SQL & "delete from ##TempApAging where AmtDue = 0" & vbCrLf
SQL = SQL & "update ##TempApAging set AgeDays = DATEDIFF(day,AgeDate,@AsOfDate)" & vbCrLf
SQL = SQL & "update ##TempApAging set [0-30 Days] = case when AgeDays between 0 and 30 then AmtDue else 0 end" & vbCrLf
SQL = SQL & "update ##TempApAging set [31-60 Days] = case when AgeDays between 31 and 60 then AmtDue else 0 end" & vbCrLf
SQL = SQL & "update ##TempApAging set [61-90 Days] = case when AgeDays between 61 and 90 then AmtDue else 0 end" & vbCrLf
SQL = SQL & "update ##TempApAging set [91+ Days] = case when AgeDays >= 90 then AmtDue else 0 end" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- calculate discounts available" & vbCrLf
SQL = SQL & "update ##TempApAging set DiscDate = DATEADD(day,DiscDays,AgeDate)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "update ##TempApAging set DiscAmt = AmtDue * DiscRate / 100.00  where DiscDate >= @AsOfDate" & vbCrLf
ExecuteScript True, SQL




'----------------------------
'----------------------------

SQL = "exec DropStoredProcedureIfExists 'RptApAgingDetail'" & vbCrLf
ExecuteScript True, SQL

SQL = "create procedure RptApAgingDetail" & vbCrLf
SQL = SQL & "@AsOfDate date," & vbCrLf
SQL = SQL & "@Vendor varchar(20),   -- blank for all" & vbCrLf
SQL = SQL & "@AgeByPostDate bit  -- = 1 to age by posting date (VIDTRECD), = 0 to post by invoice data (VIDATE)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "as" & vbCrLf
SQL = SQL & "/* test" & vbCrLf
SQL = SQL & "exec RptApAgingDetail '6/30/2018', 'ALL', 1" & vbCrLf
SQL = SQL & "exec RptApAgingDetail '6/30/2018', 'ALACOP', 0" & vbCrLf
SQL = SQL & "exec RptApAgingDetail '6/30/2018', 'ALACOP', 1" & vbCrLf
SQL = SQL & "*/" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "exec RptApAgingBase @AsOfDate, @Vendor, @AgeByPostDate" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "select * from ##TempApAging ORDER BY VENDOR,AgeDate,VINO" & vbCrLf
SQL = SQL & "" & vbCrLf
ExecuteScript True, SQL


'------------------------------------
'------------------------------------


SQL = "exec DropStoredProcedureIfExists 'RptApAgingSummary'" & vbCrLf
ExecuteScript True, SQL

SQL = "create procedure RptApAgingSummary" & vbCrLf
SQL = SQL & "@AsOfDate date," & vbCrLf
SQL = SQL & "@Vendor varchar(20),   -- blank for all" & vbCrLf
SQL = SQL & "@AgeByPostDate bit  -- = 1 to age by posting date (VIDTRECD), = 0 to post by invoice data (VIDATE)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "as" & vbCrLf
SQL = SQL & "/* test" & vbCrLf
SQL = SQL & "exec RptApAgingSummary '6/30/2018', 'ALL', 1" & vbCrLf
SQL = SQL & "exec RptApAgingSummary '6/30/2018', 'IRSINT', 1" & vbCrLf
SQL = SQL & "*/" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "exec RptApAgingBase @AsOfDate, @Vendor, @AgeByPostDate" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "select VENDOR, VENDORNAME, VENDOR# as [VDR#], count(*) as INVOICES, sum(AmtDue) as Total, sum([0-30 Days]) as [0-30 Days],  sum([31-60 Days]) as [31-60 Days]," & vbCrLf
SQL = SQL & "sum([61-90 Days]) as [61-90 Days], sum([91+ Days]) as [91+ Days] from ##TempApAging" & vbCrLf
SQL = SQL & "group by VENDOR, VENDORNAME, VENDOR#" & vbCrLf
SQL = SQL & "order by VENDOR" & vbCrLf
SQL = SQL & "" & vbCrLf
ExecuteScript True, SQL

'---------------------------
'---------------------------


' Vendor Statement
SQL = "exec DropStoredProcedureIfExists 'RptApStatement'" & vbCrLf
ExecuteScript True, SQL

SQL = "create procedure RptApStatement" & vbCrLf
SQL = SQL & "@Vendor varchar(50),      -- blank for all" & vbCrLf
SQL = SQL & "@StartDate date," & vbCrLf
SQL = SQL & "@EndDate date," & vbCrLf
SQL = SQL & "@IncludePaidInvoices bit  -- = 1 to show paid invoices" & vbCrLf
SQL = SQL & "as" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "/* generate vendor statements" & vbCrLf
SQL = SQL & "Created 11/12/2018 TEL" & vbCrLf
SQL = SQL & "test:" & vbCrLf
SQL = SQL & "exec RptApStatement 'ALL', '9/1/2017', '11/30/2018', 0" & vbCrLf
SQL = SQL & "exec RptApStatement 'RSTAHL', '1/1/2017', '11/30/2018', 1  --RSTAHL has 3 checks for in-119255" & vbCrLf
SQL = SQL & "exec RptApStatement 'GRAYBAR', '10/1/2017', '11/30/2018', 1" & vbCrLf
SQL = SQL & "exec RptApStatement 'GRAYBAR', '10/1/2017', '10/31/2017', 1" & vbCrLf
SQL = SQL & "*/" & vbCrLf
SQL = SQL & "IF OBJECT_ID('tempdb..#temp') IS NOT NULL" & vbCrLf
SQL = SQL & "begin" & vbCrLf
SQL = SQL & "drop table #temp" & vbCrLf
SQL = SQL & "end" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- get all invoices in date range" & vbCrLf
SQL = SQL & "SELECT VEREF as Vendor, VEBNAME as [Vendor Name], VIDATE [Inv Date], VINO as [Inv #]," & vbCrLf
SQL = SQL & "VIDUE as [Inv Amt], cast('' as varchar(12)) as Journal, CHKACCT [Check Acct], CHKNUMBER as [Check #], CHKPOSTDATE as [Check Date]," & vbCrLf
SQL = SQL & "cast(0 as decimal(15,2)) as Discount," & vbCrLf
SQL = SQL & "cast(0 as decimal(15,2)) as Voucher," & vbCrLf
SQL = SQL & "cast(0 as decimal(15,2)) as ApApplied" & vbCrLf
SQL = SQL & "into #temp" & vbCrLf
SQL = SQL & "FROM VndrTable v" & vbCrLf
SQL = SQL & "JOIN VihdTable inv on v.VEREF = inv.VIVENDOR" & vbCrLf
SQL = SQL & "LEFT OUTER JOIN JritTable on inv.VIVENDOR = JritTable.DCVENDOR AND inv.VINO = JritTable.DCVENDORINV" & vbCrLf
SQL = SQL & "LEFT OUTER JOIN ChksTable on JritTable.DCCHECKNO = ChksTable.CHKNUMBER AND DCCHKACCT = CHKACCT" & vbCrLf
SQL = SQL & "WHERE VIDATE between @StartDate and @EndDate" & vbCrLf
SQL = SQL & "and (DCHEAD like 'CC%' or DCHEAD like 'XC%')" & vbCrLf
SQL = SQL & "and (RTRIM(@Vendor) = 'ALL' or VIVENDOR = @Vendor)" & vbCrLf
SQL = SQL & "and CHKVOID = 0     -- there should be a voiddate, but there is not" & vbCrLf
SQL = SQL & "and CHKPOSTDATE <= @EndDate" & vbCrLf
SQL = SQL & "group by VEREF, VEBNAME, VINO, VIDATE, VIDUE, CHKACCT, CHKNUMBER, CHKPOSTDATE" & vbCrLf
SQL = SQL & "order by VEREF,VINO" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- now add discounts taken on or before the end date" & vbCrLf
SQL = SQL & "update #temp set Discount = isnull((select sum(dccredit - dcdebit)" & vbCrLf
SQL = SQL & "from JritTable dc where dc.DCVENDOR = #temp.Vendor and dc.DCVENDORINV = #temp.[Inv #]" & vbCrLf
SQL = SQL & "and dc.DCCHKACCT = #temp.[Check Acct] and dc.DCCHECKNO = #temp.[Check #] and dc.DCREF = 3" & vbCrLf
SQL = SQL & "and DCDATE <= @EndDate),0)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- add voucher amount" & vbCrLf
SQL = SQL & "update #temp set Voucher = isnull((select sum(dccredit - dcdebit)" & vbCrLf
SQL = SQL & "from JritTable dc where dc.DCVENDOR = #temp.Vendor and dc.DCVENDORINV = #temp.[Inv #]" & vbCrLf
SQL = SQL & "and dc.DCCHKACCT = #temp.[Check Acct] and dc.DCCHECKNO = #temp.[Check #] and dc.DCREF = 2" & vbCrLf
SQL = SQL & "and DCDATE <= @EndDate),0)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- get journal ID" & vbCrLf
SQL = SQL & "update #temp set Journal = (select top 1 DCHEAD" & vbCrLf
SQL = SQL & "from JritTable dc where dc.DCVENDOR = #temp.Vendor and dc.DCVENDORINV = #temp.[Inv #]" & vbCrLf
SQL = SQL & "and dc.DCCHKACCT = #temp.[Check Acct] and dc.DCCHECKNO = #temp.[Check #] and dc.DCREF = 2" & vbCrLf
SQL = SQL & "and DCDATE <= @EndDate)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- delete paid in full invoices if not requested" & vbCrLf
SQL = SQL & "if @IncludePaidInvoices = 0" & vbCrLf
SQL = SQL & "begin" & vbCrLf
SQL = SQL & "update #temp set ApApplied = isnull((select sum(Discount + Voucher)" & vbCrLf
SQL = SQL & "from #temp t2 where t2.Vendor = #temp.Vendor and t2.[Inv #] = #temp.[Inv #]),0)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "delete from #temp where ApApplied = [Inv Amt]" & vbCrLf
SQL = SQL & "end" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "select * from #temp order by Vendor, [Inv Date], [Inv #]" & vbCrLf
SQL = SQL & "drop table #temp" & vbCrLf
ExecuteScript True, SQL


SQL = "exec DropStoredProcedureIfExists 'InsertGeneralJournal'" & vbCrLf
ExecuteScript True, SQL

SQL = "create procedure [dbo].[InsertGeneralJournal]" & vbCrLf
SQL = SQL & "@JournalName varchar(100)," & vbCrLf
SQL = SQL & "@JournlDesc varchar(30)," & vbCrLf
SQL = SQL & "@JournalDate date," & vbCrLf
SQL = SQL & "@CSV varchar(MAX),     -- ('ACCT1',AMT1,'COMMENT1'),('ACCT2',AMT2,'COMMENT2')...  (Amount is minus for a credit)" & vbCrLf
SQL = SQL & "@User varchar(3)" & vbCrLf
SQL = SQL & "as" & vbCrLf
SQL = SQL & "/* create a GL Journal" & vbCrLf
SQL = SQL & "returns blank if successful" & vbCrLf
SQL = SQL & "returns error message if unsuccessful" & vbCrLf
SQL = SQL & "*/" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "SET NOCOUNT ON      -- required to avoid an error in sp with inserts and updates" & vbCrLf
SQL = SQL & "SET ANSI_WARNINGS OFF" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "begin" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "if exists (select 1 from INFORMATION_SCHEMA.TABLES where TABLE_NAME = '_JournalTemp')" & vbCrLf
SQL = SQL & "drop table _JournalTemp" & vbCrLf
SQL = SQL & "if exists (select 1 from INFORMATION_SCHEMA.TABLES where TABLE_NAME = '_JournalTemp2')" & vbCrLf
SQL = SQL & "drop table _JournalTemp2" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- create table of raw data" & vbCrLf
SQL = SQL & "create table _JournalTemp (Account varchar(12), Debit decimal(12,2), Credit decimal(12,2), Comment varchar(1000), ID int identity(1,1))" & vbCrLf
SQL = SQL & "declare @sql varchar(max) = 'insert _JournalTemp (Account, Debit, Credit, Comment) values' + char(13) + char(10) + @csv" & vbCrLf
SQL = SQL & "exec (@sql)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- construct data to insert" & vbCrLf
SQL = SQL & "select @JournalName as JINAME, 1 as JITRAN," & vbCrLf
SQL = SQL & "ID as JIREF," & vbCrLf
SQL = SQL & "Account as JIACCOUNT," & vbCrLf
SQL = SQL & "Debit as JIDEB," & vbCrLf
SQL = SQL & "Credit as JICRD," & vbCrLf
SQL = SQL & "Comment as JIDESC" & vbCrLf
SQL = SQL & "into _JournalTemp2" & vbCrLf
SQL = SQL & "from _JournalTemp" & vbCrLf
SQL = SQL & "where DEBIT <> 0 OR CREDIT <> 0" & vbCrLf
SQL = SQL & "order by ID" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- attempt to create journal" & vbCrLf
SQL = SQL & "begin tran" & vbCrLf
SQL = SQL & "if exists (select * from GjhdTable where GJNAME = @JournalName)" & vbCrLf
SQL = SQL & "begin" & vbCrLf
SQL = SQL & "rollback tran" & vbCrLf
SQL = SQL & "select 'Journal ' + @JournalName + ' already exists.'" & vbCrLf
SQL = SQL & "end" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "else" & vbCrLf
SQL = SQL & "begin" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "INSERT INTO dbo.GjhdTable" & vbCrLf
SQL = SQL & "(" & vbCrLf
SQL = SQL & "GJNAME" & vbCrLf
SQL = SQL & ",GJDESC" & vbCrLf
SQL = SQL & ",GJOPEN" & vbCrLf
SQL = SQL & ",GJPOST" & vbCrLf
SQL = SQL & ",GJPOSTED" & vbCrLf
SQL = SQL & ",GJREVERSE" & vbCrLf
SQL = SQL & ",GJCLOSE" & vbCrLf
SQL = SQL & ",GJREVID" & vbCrLf
SQL = SQL & ",GJREVDATE" & vbCrLf
SQL = SQL & ",GJEXTDESC" & vbCrLf
SQL = SQL & ",GJTEMPLATE" & vbCrLf
SQL = SQL & ",GJYEAREND" & vbCrLf
SQL = SQL & ")" & vbCrLf
SQL = SQL & "VALUES" & vbCrLf
SQL = SQL & "(" & vbCrLf
SQL = SQL & "@JournalName" & vbCrLf
SQL = SQL & ",case when @JournlDesc = '' then @JournalName else @JournlDesc end" & vbCrLf
SQL = SQL & ",cast(getdate() as date)" & vbCrLf
SQL = SQL & ",@JournalDate" & vbCrLf
SQL = SQL & ",0" & vbCrLf
SQL = SQL & ",0" & vbCrLf
SQL = SQL & ",0" & vbCrLf
SQL = SQL & ",''" & vbCrLf
SQL = SQL & ",null" & vbCrLf
SQL = SQL & ",''" & vbCrLf
SQL = SQL & ",0" & vbCrLf
SQL = SQL & ",0" & vbCrLf
SQL = SQL & ")" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- now insert the debits and credits" & vbCrLf
SQL = SQL & "declare @now datetime = cast(convert(varchar(19),getdate(),100) as datetime)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "INSERT INTO dbo.GjitTable" & vbCrLf
SQL = SQL & "(" & vbCrLf
SQL = SQL & "JINAME" & vbCrLf
SQL = SQL & ",JIDESC" & vbCrLf
SQL = SQL & ",JITRAN" & vbCrLf
SQL = SQL & ",JIREF" & vbCrLf
SQL = SQL & ",JIACCOUNT" & vbCrLf
SQL = SQL & ",JIDEB" & vbCrLf
SQL = SQL & ",JICRD" & vbCrLf
SQL = SQL & ",JIDATE" & vbCrLf
SQL = SQL & ",JILASTREVBY" & vbCrLf
SQL = SQL & ",JICLEAR" & vbCrLf
SQL = SQL & ")" & vbCrLf
SQL = SQL & "select" & vbCrLf
SQL = SQL & "JINAME" & vbCrLf
SQL = SQL & ",JIDESC" & vbCrLf
SQL = SQL & ",JITRAN" & vbCrLf
SQL = SQL & ",JIREF" & vbCrLf
SQL = SQL & ",JIACCOUNT" & vbCrLf
SQL = SQL & ",JIDEB" & vbCrLf
SQL = SQL & ",JICRD" & vbCrLf
SQL = SQL & ",@now" & vbCrLf
SQL = SQL & ",@User" & vbCrLf
SQL = SQL & ",null" & vbCrLf
SQL = SQL & "from _JournalTemp2" & vbCrLf
SQL = SQL & "order by JITRAN, JIREF" & vbCrLf
SQL = SQL & "commit tran" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- show debits and credits" & vbCrLf
SQL = SQL & "declare @debits decimal(12,2), @credits decimal(12,2)" & vbCrLf
SQL = SQL & "select @debits = sum(jideb), @credits = sum(jicrd) from GjitTable where jiname = @JournalName" & vbCrLf
SQL = SQL & "" & vbCrLf
'SQL = SQL & "select 'Journal ' + @JournalName + ' created.  debits = ' + format(@debits,'N') + '  credits = ' + format(@credits, 'N')" & vbCrLf
SQL = SQL & "select 'Journal ' + @JournalName + ' created.  debits = ' + cast(@debits as varchar(12)) + '  credits = ' + cast(@credits as varchar(12))" & vbCrLf
SQL = SQL & "end" & vbCrLf
SQL = SQL & "end" & vbCrLf
ExecuteScript True, SQL



''''''''''''''''''''''''''''''''''''''''''''''''''


      ' update the version
      ExecuteScript True, "Update Version Set Version = " & newver

   End If
End Function

Private Function UpdateDatabase107()

'update database version template
'set version at top of this file
'set version below
'add SQL updates


   Dim SQL As String
   SQL = ""

   newver = 185     ' set actual version
   If ver < newver Then

      clsADOCon.ADOErrNum = 0

''''''''''''''''''''''''''''''''''''''''''''''''''

' IMAINC 26-week Capacity vs Load Reports
SQL = "dropfunctionifexists 'fnt_GetCapacity'" & vbCrLf
ExecuteScript True, SQL

SQL = "create function fnt_GetCapacity" & vbCrLf
SQL = SQL & "(" & vbCrLf
SQL = SQL & "@Shop varchar(12),     -- <ALL> for all" & vbCrLf
SQL = SQL & "@Workcenter varchar(12),  -- <ALL> for all" & vbCrLf
SQL = SQL & "@StartDate date," & vbCrLf
SQL = SQL & "@Weeks int" & vbCrLf
SQL = SQL & ")" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "RETURNS @Capacity TABLE (Shop varchar(12), WC varchar(12), Weekend date, Hours decimal(10,2))" & vbCrLf
SQL = SQL & "AS" & vbCrLf
SQL = SQL & "/* return capacity for a given number of weeks" & vbCrLf
SQL = SQL & "test:" & vbCrLf
SQL = SQL & "select * from dbo.fnt_GetCapacity('01', '0100', '12/1/2017',2)" & vbCrLf
SQL = SQL & "select * from dbo.fnt_GetCapacity('01', '<ALL>', '12/11/2018',26)" & vbCrLf
SQL = SQL & "*/" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "-- determine end date" & vbCrLf
SQL = SQL & "declare @EndDate date = DATEADD(day,7-datepart(WEEKDAY, @StartDate),@StartDate)" & vbCrLf
SQL = SQL & "set @EndDate = DATEADD(week, @Weeks - 1,@EndDate)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "insert @Capacity" & vbCrLf
SQL = SQL & "select X.Shop, X.WC, X.Weekend, Sum(X.DayHours) as Hours" & vbCrLf
SQL = SQL & "from" & vbCrLf
SQL = SQL & "(select" & vbCrLf
SQL = SQL & "rtrim(WCCSHOP) as Shop," & vbCrLf
SQL = SQL & "rtrim(WCCCENTER) as WC," & vbCrLf
SQL = SQL & "case when WCCSHR1 = 0 then 1 else WCCSHR1 end * WCCSHH1" & vbCrLf
SQL = SQL & "+ case when WCCSHR2 = 0 then 1 else WCCSHR2 end * WCCSHH2" & vbCrLf
SQL = SQL & "+ case when WCCSHR3 = 0 then 1 else WCCSHR3 end * WCCSHH3" & vbCrLf
SQL = SQL & "+ case when WCCSHR4 = 0 then 1 else WCCSHR4 end * WCCSHH4 as DayHours," & vbCrLf
SQL = SQL & "DATEADD(day,7-datepart(WEEKDAY, WCCDATE),WCCDATE) as WeekEnd" & vbCrLf
SQL = SQL & "FROM WcclTable WHERE (WCCSHOP=@Shop or @Shop = '<ALL>')" & vbCrLf
SQL = SQL & "AND (WCCCENTER=@Workcenter or @Workcenter = '<ALL>' or @Shop = '<ALL>')" & vbCrLf
SQL = SQL & "AND WCCDATE between @StartDate and @EndDate) as X" & vbCrLf
SQL = SQL & "group by Shop, WC, WeekEnd" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "union" & vbCrLf
SQL = SQL & "select rtrim(WC2.WCNSHOP) as SHOP, rtrim(WC2.WCNREF) as WC, dateadd(day,-1,@StartDate) as WEEKEND, 0 as Hours" & vbCrLf
SQL = SQL & "from WcntTable WC2" & vbCrLf
SQL = SQL & "WHERE (WCNSHOP=@Shop or @Shop = '<ALL>') AND (WCNREF=@Workcenter or @Workcenter = '<ALL>' or @Shop = '<ALL>')" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "order by Shop, WC, WeekEnd" & vbCrLf
SQL = SQL & "RETURN" & vbCrLf
SQL = SQL & "END" & vbCrLf
ExecuteScript True, SQL

'----------------------
'----------------------

SQL = "dropfunctionifexists 'fnt_GetLoad'" & vbCrLf
ExecuteScript True, SQL

SQL = "create function [dbo].[fnt_GetLoad]" & vbCrLf
SQL = SQL & "(" & vbCrLf
SQL = SQL & "@Shop varchar(12),     -- <ALL> for all" & vbCrLf
SQL = SQL & "@Workcenter varchar(12),  -- <ALL> for all" & vbCrLf
SQL = SQL & "@StartDate date," & vbCrLf
SQL = SQL & "@Weeks int" & vbCrLf
SQL = SQL & ")" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "RETURNS @Load TABLE (Shop varchar(12), WC varchar(12), Weekend date, Hours decimal(10,2))" & vbCrLf
SQL = SQL & "AS" & vbCrLf
SQL = SQL & "/* return capacity for a given number of weeks" & vbCrLf
SQL = SQL & "test:" & vbCrLf
SQL = SQL & "select * from dbo.fnt_GetLoad('01', '0600', '12/19/2018',26)" & vbCrLf
SQL = SQL & "select * from dbo.fnt_GetLoad('<ALL>', '<ALL>', '12/11/2017',26)" & vbCrLf
SQL = SQL & "*/" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "-- determine end date" & vbCrLf
SQL = SQL & "declare @EndDate date = DATEADD(day,7-datepart(WEEKDAY, @StartDate),@StartDate)" & vbCrLf
SQL = SQL & "set @EndDate = DATEADD(week, @Weeks - 1,@EndDate)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "insert @Load" & vbCrLf
SQL = SQL & "select X.Shop, X.WC, X.Weekend, Sum(X.Hours) as Hours" & vbCrLf
SQL = SQL & "from" & vbCrLf
SQL = SQL & "(SELECT DISTINCT OPREF,OPRUN,OPNO,rtrim(OPSHOP) as Shop,RTRIM(OPCENTER) as WC,PADESC,RUNREMAININGQTY,RUNSTATUS," & vbCrLf
SQL = SQL & "cast(OPSUHRS+OPUNITHRS*RUNREMAININGQTY as decimal(10,2)) as Hours," & vbCrLf
SQL = SQL & "cast(OPSUDATE as date) as OPSUDATE,cast(OPSCHEDDATE as date) as OPSCHEDDATE," & vbCrLf
SQL = SQL & "cast(case when OPSCHEDDATE < @StartDate then dateadd(day,-1,@StartDate) else" & vbCrLf
SQL = SQL & "DATEADD(day,7-datepart(WEEKDAY, OPSCHEDDATE),OPSCHEDDATE) end  as Date) as WeekEnd" & vbCrLf
SQL = SQL & "FROM RnopTable op" & vbCrLf
SQL = SQL & "join RunsTable run on run.RUNREF = op.OPREF and run.RUNNO = op.OPRUN" & vbCrLf
SQL = SQL & "join WcntTable wc on wc.WCNREF = op.OPCENTER and wc.WCNSHOP = op.OPSHOP" & vbCrLf
SQL = SQL & "join PartTable pt on pt.PARTREF = op.OPREF" & vbCrLf
SQL = SQL & "WHERE (OPREF=RUNREF AND OPRUN=RUNNO AND OPCENTER=WCNREF AND WCNSERVICE=0 AND OPCOMPLETE=0)" & vbCrLf
SQL = SQL & "AND OPSCHEDDATE <= @EndDate AND (OPSHOP = @Shop or @Shop = '<ALL>')" & vbCrLf
SQL = SQL & "AND (OPCENTER LIKE @Workcenter or @Workcenter = '<ALL>' or @Shop = '<ALL>') and RUNSTATUS <> 'CA') as X" & vbCrLf
SQL = SQL & "group by X.Shop, X.WC, X.WeekEnd" & vbCrLf
SQL = SQL & "order by X.Shop, X.WC, X.WeekEnd" & vbCrLf
SQL = SQL & "RETURN" & vbCrLf
SQL = SQL & "END" & vbCrLf
ExecuteScript True, SQL



'-----------------------------------
'-----------------------------------

SQL = "dropstoredprocedureifexists 'RptCapacityVsLoad'" & vbCrLf
ExecuteScript True, SQL

SQL = "create procedure RptCapacityVsLoad" & vbCrLf
SQL = SQL & "(" & vbCrLf
SQL = SQL & "@Shop varchar(12),        -- <ALL> for all" & vbCrLf
SQL = SQL & "@Workcenter varchar(12),  -- <ALL> for all" & vbCrLf
SQL = SQL & "@StartDate date," & vbCrLf
SQL = SQL & "@Weeks int" & vbCrLf
SQL = SQL & ")" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "as" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "/*" & vbCrLf
SQL = SQL & "compare capacity and load by week" & vbCrLf
SQL = SQL & "test:" & vbCrLf
SQL = SQL & "exec RptCapacityVsLoad '<ALL>','<ALL>','12/1/17',26" & vbCrLf
SQL = SQL & "exec RptCapacityVsLoad '01','0100','12/1/17',2" & vbCrLf
SQL = SQL & "*/" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "select cap.*, isnull(ld.Hours,0) as Load, cap.Hours - isnull(ld.Hours,0) as Available,rtrim(wc.WCNDESC) as WCNDESC" & vbCrLf
SQL = SQL & "from dbo.fnt_GetCapacity(@Shop,@Workcenter,@StartDate,@Weeks) cap" & vbCrLf
SQL = SQL & "left join dbo.fnt_GetLoad(@Shop,@Workcenter,@StartDate,@Weeks) ld" & vbCrLf
SQL = SQL & "on ld.Shop = cap.Shop and ld.WC = cap.WC and ld.Weekend = cap.Weekend" & vbCrLf
SQL = SQL & "left join WcntTable wc on wc.WCNREF = cap.WC" & vbCrLf
SQL = SQL & "order by cap.Shop,cap.WC,cap.Weekend" & vbCrLf
ExecuteScript True, SQL

'-------------------------------
'-------------------------------

SQL = "dropstoredprocedureifexists 'RptLoadDetails'" & vbCrLf
ExecuteScript True, SQL

SQL = "create procedure RptLoadDetails" & vbCrLf
SQL = SQL & "(" & vbCrLf
SQL = SQL & "@Shop varchar(12),        -- <ALL> for all" & vbCrLf
SQL = SQL & "@Workcenter varchar(12),  -- <ALL> for all" & vbCrLf
SQL = SQL & "@StartDate date," & vbCrLf
SQL = SQL & "@Weeks int" & vbCrLf
SQL = SQL & ")" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "as" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "/*" & vbCrLf
SQL = SQL & "WC Load Details" & vbCrLf
SQL = SQL & "test:" & vbCrLf
SQL = SQL & "exec RptLoadDetails '01','0100','12/1/17',26" & vbCrLf
SQL = SQL & "exec RptLoadDetails '01','0100','12/10/18',26" & vbCrLf
SQL = SQL & "*/" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "declare @EndDate date = DATEADD(day,7-datepart(WEEKDAY, @StartDate),@StartDate)" & vbCrLf
SQL = SQL & "set @EndDate = DATEADD(week, @Weeks - 1,@EndDate)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "SELECT DISTINCT RTRIM(OPSHOP) AS OPSHOP, RTRIM(OPCENTER) AS OPCENTER, RTRIM(OPREF) AS OPREF,OPRUN,OPNO,OPSHOP as Shop,OPCENTER as WC," & vbCrLf
SQL = SQL & "RTRIM(PADESC) AS PADESC,RUNREMAININGQTY,RTRIM(RUNSTATUS) as RUNSTATUS," & vbCrLf
SQL = SQL & "cast(OPSUHRS+OPUNITHRS*RUNREMAININGQTY as decimal(10,2)) as Hours," & vbCrLf
SQL = SQL & "cast(OPSUDATE as date) as OPSUDATE,cast(OPSCHEDDATE as date) as OPSCHEDDATE," & vbCrLf
SQL = SQL & "case when OPSCHEDDATE < @StartDate then ' PRIOR ' else" & vbCrLf
SQL = SQL & "convert(varchar(8),DATEADD(day,7-datepart(WEEKDAY, OPSCHEDDATE),OPSCHEDDATE),1) end as WeekEnd" & vbCrLf
SQL = SQL & "FROM RnopTable op" & vbCrLf
SQL = SQL & "join RunsTable run on run.RUNREF = op.OPREF and run.RUNNO = op.OPRUN" & vbCrLf
SQL = SQL & "join WcntTable wc on wc.WCNREF = op.OPCENTER and wc.WCNSHOP = op.OPSHOP" & vbCrLf
SQL = SQL & "join PartTable pt on pt.PARTREF = op.OPREF" & vbCrLf
SQL = SQL & "WHERE (OPREF=RUNREF AND OPRUN=RUNNO AND OPCENTER=WCNREF AND WCNSERVICE=0 AND OPCOMPLETE=0)" & vbCrLf
SQL = SQL & "AND OPSCHEDDATE <= @EndDate AND (OPSHOP = @Shop or @Shop = '<ALL>')" & vbCrLf
SQL = SQL & "AND (OPCENTER LIKE @Workcenter or @Workcenter = '<ALL>' or @Shop = '<ALL>') and RUNSTATUS <> 'CA'" & vbCrLf
SQL = SQL & "order by Shop, WC, OPSCHEDDATE" & vbCrLf
ExecuteScript True, SQL

SQL = "dropstoredprocedureifexists 'GetScMOs'" & vbCrLf
ExecuteScript True, SQL

SQL = "create procedure [dbo].[GetScMOs]" & vbCrLf
SQL = SQL & "@Parts varchar(30),    -- leading characters for MO parts to select" & vbCrLf
SQL = SQL & "@StartDate date,    -- start pick date" & vbCrLf
SQL = SQL & "@EndDate date       -- end pick date" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "as" & vbCrLf
SQL = SQL & "/* test" & vbCrLf
SQL = SQL & "exec GetScMOs '', '12/14/18','12/31/18'" & vbCrLf
SQL = SQL & "*/" & vbCrLf
SQL = SQL & "set nocount on" & vbCrLf
SQL = SQL & "declare @EndDatePlus1 date = dateadd(day,1,@EndDate)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- get list of all SC runs" & vbCrLf
SQL = SQL & "SELECT DISTINCT RUNREF as MRP_PARTREF, RUNNO, ISNULL(RUNOPCUR, 0) as RUNOPCUR, PARTNUM as MRP_PARTNUM," & vbCrLf
SQL = SQL & "RUNQTY As MRP_PARTQTYRQD, Convert(varchar(10), RUNPKSTART, 101) As MRP_PARTDATERQD," & vbCrLf
SQL = SQL & "Convert(varchar(10), RUNSCHED, 101) As MRP_ACTIONDATE, RUNSTATUS,RUNPKSTART,PABOMREV,op.OPCENTER," & vbCrLf
SQL = SQL & "ROW_NUMBER() over (ORDER BY RUNPKSTART) AS [MO#]" & vbCrLf
SQL = SQL & "into #temp" & vbCrLf
SQL = SQL & "FROM RunsTable r" & vbCrLf
SQL = SQL & "join PartTable p on PARTREF = RUNREF" & vbCrLf
SQL = SQL & "join RnopTable op on op.opref = r.RUNREF and op.OPRUN = r.RUNNO and op.OPNO = r.RUNOPCUR" & vbCrLf
SQL = SQL & "WHERE RUNREF LIKE @Parts + '%' AND RUNSTATUS = 'SC' and op.OPCENTER = '0120'" & vbCrLf
SQL = SQL & "AND RUNPKSTART >= @StartDate AND RUNPKSTART < @EndDatePlus1" & vbCrLf
SQL = SQL & "order by RUNPKSTART" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- get a list of all pick list requirements" & vbCrLf
SQL = SQL & "select t.[MO#], BMPARTREF, BMQTYREQD,MRP_PARTQTYRQD," & vbCrLf
SQL = SQL & "cast(BMQTYREQD * MRP_PARTQTYRQD as decimal(15,4)) as Qty," & vbCrLf
SQL = SQL & "CAST(-1 AS DECIMAL(15,4)) as Surplus" & vbCrLf
SQL = SQL & "into #picks" & vbCrLf
SQL = SQL & "from #temp t" & vbCrLf
SQL = SQL & "join BmplTable bm on bm.BMASSYPART = t.MRP_PARTREF and bm.BMREV = t.PABOMREV" & vbCrLf
SQL = SQL & "order by MO#, BMPARTREF" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- get a list of all part quantities on hand less open pick list quantities" & vbCrLf
SQL = SQL & "-- use real time quantities rather than MRP" & vbCrLf
SQL = SQL & "select PARTREF as MRP_PARTREF, Min(PAQOH) as PAQOH," & vbCrLf
SQL = SQL & "cast(0 as decimal(15,4)) as Unpicked," & vbCrLf
SQL = SQL & "cast(0 as decimal(15,4)) as Avail," & vbCrLf
SQL = SQL & "cast(0 as decimal(15,4)) as OrigAvail" & vbCrLf
SQL = SQL & "into #parts" & vbCrLf
SQL = SQL & "from" & vbCrLf
SQL = SQL & "PartTable pt" & vbCrLf
SQL = SQL & "where PALEVEL <= 4" & vbCrLf
SQL = SQL & "group by PARTREF" & vbCrLf
SQL = SQL & "order by PARTREF" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "update #parts set Unpicked = isnull((select sum(PKPQTY) from MopkTable" & vbCrLf
SQL = SQL & "where PKPARTREF = MRP_PARTREF and PKTYPE = 9),0.0000)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "update #parts set Avail = PAQOH - Unpicked, OrigAvail = PAQOH - Unpicked" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- for each MO, determine if pick list quantities are available" & vbCrLf
SQL = SQL & "declare @MONO int" & vbCrLf
SQL = SQL & "DECLARE cur CURSOR FOR" & vbCrLf
SQL = SQL & "SELECT [MO#]" & vbCrLf
SQL = SQL & "FROM #temp" & vbCrLf
SQL = SQL & "order by [MO#]" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "OPEN cur" & vbCrLf
SQL = SQL & "FETCH NEXT FROM cur INTO @MONO" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "WHILE @@FETCH_STATUS = 0" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "update p set Surplus = pt.AVAIL - p.Qty" & vbCrLf
SQL = SQL & "from #picks p join #parts pt on p.BMPARTREF = pt.MRP_PARTREF" & vbCrLf
SQL = SQL & "where p.MO# = @MONO" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- if any negative quantities for pick list, delete MO" & vbCrLf
SQL = SQL & "if(select min(Surplus) from #picks where MO# = @MONO) < 0" & vbCrLf
SQL = SQL & "begin" & vbCrLf
SQL = SQL & "delete from #temp where MO# = @MONO" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- otherwise subtract from quantities available" & vbCrLf
SQL = SQL & "end" & vbCrLf
SQL = SQL & "else" & vbCrLf
SQL = SQL & "begin" & vbCrLf
SQL = SQL & "update p set AVAIL = Avail - pk.Qty" & vbCrLf
SQL = SQL & "from #parts p join #picks pk on pk.BMPARTREF = p.MRP_PARTREF" & vbCrLf
SQL = SQL & "where pk.MO# = @MONO" & vbCrLf
SQL = SQL & "end" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "FETCH NEXT FROM cur INTO @MONO" & vbCrLf
SQL = SQL & "END" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "CLOSE cur" & vbCrLf
SQL = SQL & "DEALLOCATE cur" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "select * from #temp order by MO#" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "drop table #temp" & vbCrLf
SQL = SQL & "drop table #picks" & vbCrLf
SQL = SQL & "drop table #parts" & vbCrLf
ExecuteScript True, SQL




''''''''''''''''''''''''''''''''''''''''''''''''''

      ' update the version
      ExecuteScript False, "Update Version Set Version = " & newver

   End If
End Function


Private Function UpdateDatabase108()

'update database version template
'set version at top of this file
'set version below
'add SQL updates


   Dim SQL As String
   SQL = ""

   newver = 186     ' set actual version
   If ver < newver Then

      clsADOCon.ADOErrNum = 0

''''''''''''''''''''''''''''''''''''''''''''''''''

SQL = "dropstoredprocedureifexists 'Qry_FillInspectorsActive'" & vbCrLf
ExecuteScript True, SQL

SQL = "create procedure Qry_FillInspectorsActive" & vbCrLf
SQL = SQL & "as" & vbCrLf
SQL = SQL & "SELECT INSID FROM RinsTable WHERE INSACTIVE=1" & vbCrLf
SQL = SQL & "ORDER BY INSID" & vbCrLf
ExecuteScript True, SQL

''''''''''''''''''''''''''''''''''''''''''''''''''

      ' update the version
      ExecuteScript False, "Update Version Set Version = " & newver

   End If
End Function

Private Function UpdateDatabase109()

'update database version template
'set version at top of this file
'set version below
'add SQL updates


   Dim SQL As String
   SQL = ""

   newver = 187     ' set actual version
   If ver < newver Then

      clsADOCon.ADOErrNum = 0

''''''''''''''''''''''''''''''''''''''''''''''''''

SQL = "dropstoredprocedureifexists 'RptApStatement'" & vbCrLf
ExecuteScript True, SQL

SQL = "create procedure [dbo].[RptApStatement]" & vbCrLf
SQL = SQL & "@Vendor varchar(50),      -- blank for all" & vbCrLf
SQL = SQL & "@StartDate date," & vbCrLf
SQL = SQL & "@EndDate date," & vbCrLf
SQL = SQL & "@IncludePaidInvoices bit  -- = 1 to show paid invoices" & vbCrLf
SQL = SQL & "as" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "/* generate vendor statements" & vbCrLf
SQL = SQL & "Created 11/12/2018 TEL" & vbCrLf
SQL = SQL & "test:" & vbCrLf
SQL = SQL & "exec RptApStatement 'ALL', '9/1/2017', '11/30/2018', 0" & vbCrLf
SQL = SQL & "exec RptApStatement 'RSTAHL', '1/1/2017', '11/30/2018', 1  --RSTAHL has 3 checks for in-119255" & vbCrLf
SQL = SQL & "exec RptApStatement 'GRAYBAR', '10/1/2017', '11/30/2018', 1" & vbCrLf
SQL = SQL & "exec RptApStatement 'GRAYBAR', '6/1/18', '2/1/2019', 1" & vbCrLf
SQL = SQL & "*/" & vbCrLf
SQL = SQL & "IF OBJECT_ID('tempdb..#temp') IS NOT NULL" & vbCrLf
SQL = SQL & "begin" & vbCrLf
SQL = SQL & "drop table #temp" & vbCrLf
SQL = SQL & "end" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- get all invoices in date range" & vbCrLf
SQL = SQL & "SELECT VEREF as Vendor, VEBNAME as [Vendor Name], VIDATE [Inv Date], VINO as [Inv #]," & vbCrLf
SQL = SQL & "VIDUE as [Inv Amt], cast('' as varchar(12)) as Journal, CHKACCT [Check Acct], CHKNUMBER as [Check #], CHKPOSTDATE as [Check Date]," & vbCrLf
SQL = SQL & "cast(0 as decimal(15,2)) as Discount," & vbCrLf
SQL = SQL & "cast(0 as decimal(15,2)) as Voucher," & vbCrLf
SQL = SQL & "cast(0 as decimal(15,2)) as ApApplied" & vbCrLf
SQL = SQL & "into #temp" & vbCrLf
SQL = SQL & "FROM VndrTable v" & vbCrLf
SQL = SQL & "JOIN VihdTable inv on v.VEREF = inv.VIVENDOR" & vbCrLf
SQL = SQL & "LEFT OUTER JOIN JritTable on inv.VIVENDOR = JritTable.DCVENDOR AND inv.VINO = JritTable.DCVENDORINV" & vbCrLf
SQL = SQL & "and (DCHEAD like 'CC%' or DCHEAD like 'XC%')" & vbCrLf
SQL = SQL & "LEFT OUTER JOIN ChksTable on JritTable.DCCHECKNO = ChksTable.CHKNUMBER AND DCCHKACCT = CHKACCT" & vbCrLf
SQL = SQL & "WHERE VIDATE between @StartDate and @EndDate" & vbCrLf
SQL = SQL & "--and (DCHEAD like 'CC%' or DCHEAD like 'XC%')" & vbCrLf
SQL = SQL & "and (RTRIM(@Vendor) = 'ALL' or VIVENDOR = @Vendor)" & vbCrLf
SQL = SQL & "and isnull(CHKVOID,0) = 0     -- there should be a voiddate, but there is not" & vbCrLf
SQL = SQL & "and isnull(CHKPOSTDATE,'1/1/1900') <= @EndDate" & vbCrLf
SQL = SQL & "group by VEREF, VEBNAME, VINO, VIDATE, VIDUE, CHKACCT, CHKNUMBER, CHKPOSTDATE" & vbCrLf
SQL = SQL & "order by VEREF,VINO" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- now add discounts taken on or before the end date" & vbCrLf
SQL = SQL & "update #temp set Discount = isnull((select sum(dccredit - dcdebit)" & vbCrLf
SQL = SQL & "from JritTable dc where dc.DCVENDOR = #temp.Vendor and dc.DCVENDORINV = #temp.[Inv #]" & vbCrLf
SQL = SQL & "and dc.DCCHKACCT = #temp.[Check Acct] and dc.DCCHECKNO = #temp.[Check #] and dc.DCREF = 3" & vbCrLf
SQL = SQL & "and DCDATE <= @EndDate),0)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- add voucher amount" & vbCrLf
SQL = SQL & "update #temp set Voucher = isnull((select sum(dccredit - dcdebit)" & vbCrLf
SQL = SQL & "from JritTable dc where dc.DCVENDOR = #temp.Vendor and dc.DCVENDORINV = #temp.[Inv #]" & vbCrLf
SQL = SQL & "and dc.DCCHKACCT = #temp.[Check Acct] and dc.DCCHECKNO = #temp.[Check #] and dc.DCREF = 2" & vbCrLf
SQL = SQL & "and DCDATE <= @EndDate),0)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- get journal ID" & vbCrLf
SQL = SQL & "update #temp set Journal = (select top 1 DCHEAD" & vbCrLf
SQL = SQL & "from JritTable dc where dc.DCVENDOR = #temp.Vendor and dc.DCVENDORINV = #temp.[Inv #]" & vbCrLf
SQL = SQL & "and dc.DCCHKACCT = #temp.[Check Acct] and dc.DCCHECKNO = #temp.[Check #] and dc.DCREF = 2" & vbCrLf
SQL = SQL & "and DCDATE <= @EndDate)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- delete paid in full invoices if not requested" & vbCrLf
SQL = SQL & "if @IncludePaidInvoices = 0" & vbCrLf
SQL = SQL & "begin" & vbCrLf
SQL = SQL & "update #temp set ApApplied = isnull((select sum(Discount + Voucher)" & vbCrLf
SQL = SQL & "from #temp t2 where t2.Vendor = #temp.Vendor and t2.[Inv #] = #temp.[Inv #]),0)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "delete from #temp where ApApplied = [Inv Amt]" & vbCrLf
SQL = SQL & "end" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "select * from #temp order by Vendor, [Inv Date], [Inv #]" & vbCrLf
SQL = SQL & "drop table #temp" & vbCrLf
ExecuteScript True, SQL

SQL = "dropstoredprocedureifexists 'InsertPayrollJournal'" & vbCrLf
ExecuteScript True, SQL

SQL = "create procedure [dbo].[InsertPayrollJournal]" & vbCrLf
SQL = SQL & "@CSV varchar(MAX),     -- (''ACCT1'',AMT1),(''ACCT2'',AMT2)...  (Amount is minus for a credit)" & vbCrLf
SQL = SQL & "@User varchar(3)," & vbCrLf
SQL = SQL & "@PayrollDate datetime" & vbCrLf
SQL = SQL & "as" & vbCrLf
SQL = SQL & "/* aggregate IMAINC payroll journal data from an Excel file and create a summary GL Journal" & vbCrLf
SQL = SQL & "returns blank if successful" & vbCrLf
SQL = SQL & "returns error message if unsuccessful" & vbCrLf
SQL = SQL & "*/" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "SET NOCOUNT ON      -- required to avoid an error in sp with inserts and updates" & vbCrLf
SQL = SQL & "SET ANSI_WARNINGS OFF" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "begin" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "if exists (select 1 from INFORMATION_SCHEMA.TABLES where TABLE_NAME = '_PayrollTemp')" & vbCrLf
SQL = SQL & "drop table _PayrollTemp" & vbCrLf
SQL = SQL & "if exists (select 1 from INFORMATION_SCHEMA.TABLES where TABLE_NAME = '_PayrollTemp2')" & vbCrLf
SQL = SQL & "drop table _PayrollTemp2" & vbCrLf
SQL = SQL & "if exists (select 1 from INFORMATION_SCHEMA.TABLES where TABLE_NAME = '_PayrollTemp3')" & vbCrLf
SQL = SQL & "drop table _PayrollTemp3" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- create journal name" & vbCrLf
SQL = SQL & "declare @JournalName varchar(12)" & vbCrLf
SQL = SQL & "set @JournalName = 'PR-' + cast(year(@PayrollDate) as varchar(4)) + '-'" & vbCrLf
SQL = SQL & "+ RIGHT('0' + MONTH(@PayrollDate),2) + RIGHT('0' + DAY(@PayrollDate),2)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- create table of raw data" & vbCrLf
SQL = SQL & "-- SQL only allows 1000 rows to be added using insert ... values ... statements, so break this down into 10K chunks" & vbCrLf
SQL = SQL & "create table _PayrollTemp (Account varchar(12), Amount decimal(12,2))" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "--declare @sql varchar(max) = 'insert _PayRollTemp (Account,Amount) values' + char(13) + char(10) + @csv" & vbCrLf
SQL = SQL & "-- exec (@sql)" & vbCrLf
SQL = SQL & "declare @start int = 1" & vbCrLf
SQL = SQL & "declare @length int = len(@csv)" & vbCrLf
SQL = SQL & "declare @comma int = @length" & vbCrLf
SQL = SQL & "declare @sql varchar(max)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "while @start < @length" & vbCrLf
SQL = SQL & "begin" & vbCrLf
SQL = SQL & "if @length - @start < 6000 break;" & vbCrLf
SQL = SQL & "set @comma = charindex('),(', @csv,@start + 5000)" & vbCrLf
SQL = SQL & "set @sql = 'insert _PayRollTemp (Account,Amount) values' + char(13) + char(10) + substring(@csv,@start,@comma-@start+1)" & vbCrLf
SQL = SQL & "--print (@sql)" & vbCrLf
SQL = SQL & "exec (@sql)" & vbCrLf
SQL = SQL & "set @start = @comma + 2" & vbCrLf
SQL = SQL & "end" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "set @sql = 'insert _PayRollTemp (Account,Amount) values' + char(13) + char(10) + substring(@csv,@start,@length-@start+1)" & vbCrLf
SQL = SQL & "--print (@sql)" & vbCrLf
SQL = SQL & "exec (@sql)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- roll up into accounts" & vbCrLf
SQL = SQL & "select Account," & vbCrLf
SQL = SQL & "sum(cast(Amount as decimal(12,2))) as Total" & vbCrLf
SQL = SQL & "into _PayrollTemp2" & vbCrLf
SQL = SQL & "from _PayrollTemp" & vbCrLf
SQL = SQL & "group by [Account]" & vbCrLf
SQL = SQL & "order by Account" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- construct data to insert" & vbCrLf
SQL = SQL & "select @JournalName as JINAME, 1 as JITRAN," & vbCrLf
SQL = SQL & "ROW_NUMBER() over (ORDER BY Account) as JIREF," & vbCrLf
SQL = SQL & "Account as JIACCOUNT," & vbCrLf
SQL = SQL & "case when Total < 0 then 0.00 else Total end as JIDEB," & vbCrLf
SQL = SQL & "case when Total < 0 then -Total else 0.00 end as JICRD" & vbCrLf
SQL = SQL & "into _PayrollTemp3" & vbCrLf
SQL = SQL & "from _PayrollTemp2" & vbCrLf
SQL = SQL & "where Total <> 0" & vbCrLf
SQL = SQL & "order by Account" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- attempt to create journal" & vbCrLf
SQL = SQL & "begin tran" & vbCrLf
SQL = SQL & "if exists (select * from GjhdTable where GJNAME = @JournalName)" & vbCrLf
SQL = SQL & "begin" & vbCrLf
SQL = SQL & "rollback tran" & vbCrLf
SQL = SQL & "select 'Journal ' + @JournalName + ' already exists.'" & vbCrLf
SQL = SQL & "end" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "else" & vbCrLf
SQL = SQL & "begin" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "INSERT INTO dbo.GjhdTable" & vbCrLf
SQL = SQL & "(" & vbCrLf
SQL = SQL & "GJNAME" & vbCrLf
SQL = SQL & ",GJDESC" & vbCrLf
SQL = SQL & ",GJOPEN" & vbCrLf
SQL = SQL & ",GJPOST" & vbCrLf
SQL = SQL & ",GJPOSTED" & vbCrLf
SQL = SQL & ",GJREVERSE" & vbCrLf
SQL = SQL & ",GJCLOSE" & vbCrLf
SQL = SQL & ",GJREVID" & vbCrLf
SQL = SQL & ",GJREVDATE" & vbCrLf
SQL = SQL & ",GJEXTDESC" & vbCrLf
SQL = SQL & ",GJTEMPLATE" & vbCrLf
SQL = SQL & ",GJYEAREND" & vbCrLf
SQL = SQL & ")" & vbCrLf
SQL = SQL & "VALUES" & vbCrLf
SQL = SQL & "(" & vbCrLf
SQL = SQL & "@JournalName" & vbCrLf
SQL = SQL & ",''" & vbCrLf
SQL = SQL & ",CAST(getdate() as date)" & vbCrLf
SQL = SQL & ",null" & vbCrLf
SQL = SQL & ",0" & vbCrLf
SQL = SQL & ",0" & vbCrLf
SQL = SQL & ",0" & vbCrLf
SQL = SQL & ",''" & vbCrLf
SQL = SQL & ",null" & vbCrLf
SQL = SQL & ",'PAYROLL JOURNAL FOR PAY DATE '" & vbCrLf
SQL = SQL & "+ cast(year(@PayrollDate) as varchar(4)) + ' '" & vbCrLf
SQL = SQL & "+ right('0' + cast(month(@PayrollDate) as varchar(2)),2) + ' '" & vbCrLf
SQL = SQL & "+ right('0' + cast(DAY(@PayrollDate) as varchar(2)),2)" & vbCrLf
SQL = SQL & ",0" & vbCrLf
SQL = SQL & ",0" & vbCrLf
SQL = SQL & ")" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- now insert the items" & vbCrLf
SQL = SQL & "declare @now datetime = cast(convert(varchar(19),getdate(),100) as datetime)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "INSERT INTO dbo.GjitTable" & vbCrLf
SQL = SQL & "(" & vbCrLf
SQL = SQL & "JINAME" & vbCrLf
SQL = SQL & ",JIDESC" & vbCrLf
SQL = SQL & ",JITRAN" & vbCrLf
SQL = SQL & ",JIREF" & vbCrLf
SQL = SQL & ",JIACCOUNT" & vbCrLf
SQL = SQL & ",JIDEB" & vbCrLf
SQL = SQL & ",JICRD" & vbCrLf
SQL = SQL & ",JIDATE" & vbCrLf
SQL = SQL & ",JILASTREVBY" & vbCrLf
SQL = SQL & ",JICLEAR" & vbCrLf
SQL = SQL & ")" & vbCrLf
SQL = SQL & "select" & vbCrLf
SQL = SQL & "JINAME" & vbCrLf
SQL = SQL & ",''" & vbCrLf
SQL = SQL & ",JITRAN" & vbCrLf
SQL = SQL & ",JIREF" & vbCrLf
SQL = SQL & ",JIACCOUNT" & vbCrLf
SQL = SQL & ",JIDEB" & vbCrLf
SQL = SQL & ",JICRD" & vbCrLf
SQL = SQL & ",@now" & vbCrLf
SQL = SQL & ",@User" & vbCrLf
SQL = SQL & ",null" & vbCrLf
SQL = SQL & "from _PayrollTemp3" & vbCrLf
SQL = SQL & "order by JITRAN, JIREF" & vbCrLf
SQL = SQL & "commit tran" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- show debits and credits" & vbCrLf
SQL = SQL & "declare @debits decimal(12,2), @credits decimal(12,2)" & vbCrLf
SQL = SQL & "select @debits = sum(jideb), @credits = sum(jicrd) from GjitTable where jiname = @JournalName" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "select 'Payroll Journal ' + @JournalName + ' created.  debits = ' + format(@debits,'N') + '  credits = ' + format(@credits, 'N')" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "end" & vbCrLf
SQL = SQL & "end" & vbCrLf
ExecuteScript True, SQL

SQL = "update Preferences set PurchaseAccount = 0 where PreRecord = 1"
ExecuteScript True, SQL

SQL = "delete from LOLCTABLE where LOTEXLOCATION = ''" & vbCrLf
ExecuteScript True, SQL

SQL = "DropStoredProcedureIfExists 'UpdateMoPriorities'" & vbCrLf
ExecuteScript True, SQL

SQL = "create procedure [dbo].[UpdateMoPriorities]" & vbCrLf
SQL = SQL & "@CSV varchar(MAX),     -- (''''Part'''',Run,Pri),(''''Part'''',Run,Pri)" & vbCrLf
SQL = SQL & "@User varchar(3)" & vbCrLf
SQL = SQL & "as" & vbCrLf
SQL = SQL & "/* Update MO priorities" & vbCrLf
SQL = SQL & "returns blank if successful" & vbCrLf
SQL = SQL & "returns error message if unsuccessful" & vbCrLf
SQL = SQL & "test:" & vbCrLf
SQL = SQL & "exec UpdateMoPriorities" & vbCrLf
SQL = SQL & "'(''146U7734526'',1,10),(''452T32223'',5,10),(''284W16171'',8,20),(''344T2201118'',10,30),(''256W26361'',4,10)','    '" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "*/" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "SET NOCOUNT ON      -- required to avoid an error in sp with inserts and updates" & vbCrLf
SQL = SQL & "SET ANSI_WARNINGS OFF" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "begin" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "if exists (select 1 from INFORMATION_SCHEMA.TABLES where TABLE_NAME = '_MoPriorities')" & vbCrLf
SQL = SQL & "drop table _MoPriorities" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- create table of raw data" & vbCrLf
SQL = SQL & "-- SQL only allows 1000 rows to be added using insert ... values ... statements, so break this down into 5K chunks" & vbCrLf
SQL = SQL & "create table _MoPriorities (Part varchar(30), Run int, Pri int)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "declare @start int = 1" & vbCrLf
SQL = SQL & "declare @length int = len(@csv)" & vbCrLf
SQL = SQL & "declare @comma int = @length" & vbCrLf
SQL = SQL & "declare @sql varchar(max)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "while @start < @length" & vbCrLf
SQL = SQL & "begin" & vbCrLf
SQL = SQL & "if @length - @start < 6000 break;" & vbCrLf
SQL = SQL & "set @comma = charindex('),(', @csv,@start + 5000)" & vbCrLf
SQL = SQL & "set @sql = 'insert _MoPriorities (Part,Run,Pri) values' + char(13) + char(10) + substring(@csv,@start,@comma-@start+1)" & vbCrLf
SQL = SQL & "exec (@sql)" & vbCrLf
SQL = SQL & "set @start = @comma + 2" & vbCrLf
SQL = SQL & "end" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- insert last subset" & vbCrLf
SQL = SQL & "set @sql = 'insert _MoPriorities (Part,Run,Pri) values' + char(13) + char(10) +  substring(@csv,@start,@length-@start+1)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "exec (@sql)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- perform updates" & vbCrLf
SQL = SQL & "declare @ct int" & vbCrLf
SQL = SQL & "select @ct = count(*) from _MoPriorities" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "update r set RUNPRIORITY = p.Pri" & vbCrLf
SQL = SQL & "from RunsTable r join _MoPriorities p on p.Part = r.RUNREF and p.Run = r.RUNNO" & vbCrLf
SQL = SQL & "where p.Pri <> r.RUNPRIORITY" & vbCrLf
SQL = SQL & "end" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "select cast(@@ROWCOUNT as varchar(5)) + ' of ' + cast(@ct as varchar(6)) + ' MO priorities updated' as [Result]" & vbCrLf
ExecuteScript True, SQL

SQL = "AddOrUpdateColumn 'Preferences', 'GetNextAvailablePoNumber', 'tinyint not null default 0'"
'SQL = "alter table Preferences add GetNextAvailablePoNumber tinyint not null default 0" & vbCrLf
ExecuteScript False, SQL

SQL = "exec DropStoredProcedureIfExists 'GetScMOs'" & vbCrLf
ExecuteScript True, SQL

' for IMAINC only
' Get a list of all SC status MOs that can be auto-released
SQL = "create procedure GetScMOs" & vbCrLf
SQL = SQL & "@Parts varchar(30),    -- leading characters for MO parts to select" & vbCrLf
SQL = SQL & "@StartDate date,    -- start pick date" & vbCrLf
SQL = SQL & "@EndDate date       -- end pick date" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "as" & vbCrLf
SQL = SQL & "/* test" & vbCrLf
SQL = SQL & "exec GetScMOs '', '7/1/18','7/1/18'" & vbCrLf
SQL = SQL & "*/" & vbCrLf
SQL = SQL & "set nocount on" & vbCrLf
SQL = SQL & "declare @EndDatePlus1 date = dateadd(day,1,@EndDate)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- get list of all SC runs" & vbCrLf
SQL = SQL & "SELECT DISTINCT RUNREF as MRP_PARTREF, RUNNO, ISNULL(RUNOPCUR, 0) as RUNOPCUR, PARTNUM as MRP_PARTNUM," & vbCrLf
SQL = SQL & "RUNQTY As MRP_PARTQTYRQD, Convert(varchar(10), RUNPKSTART, 101) As MRP_PARTDATERQD," & vbCrLf
SQL = SQL & "Convert(varchar(10), RUNSCHED, 101) As MRP_ACTIONDATE, RUNSTATUS,RUNPKSTART,PABOMREV,op.OPCENTER," & vbCrLf
SQL = SQL & "ROW_NUMBER() over (ORDER BY RUNPKSTART) AS [MO#]" & vbCrLf
SQL = SQL & "into #temp" & vbCrLf
SQL = SQL & "FROM RunsTable r" & vbCrLf
SQL = SQL & "join PartTable p on PARTREF = RUNREF" & vbCrLf
SQL = SQL & "join RnopTable op on op.opref = r.RUNREF and op.OPRUN = r.RUNNO and op.OPNO = r.RUNOPCUR" & vbCrLf
SQL = SQL & "WHERE RUNREF LIKE @Parts + '%' AND RUNSTATUS = 'SC' and op.OPCENTER = '0120'" & vbCrLf
SQL = SQL & "AND RUNPKSTART >= @StartDate AND RUNPKSTART < @EndDatePlus1" & vbCrLf
SQL = SQL & "order by RUNPKSTART" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- get a list of all pick list requirements" & vbCrLf
SQL = SQL & "select t.[MO#], BMPARTREF, BMQTYREQD,MRP_PARTQTYRQD," & vbCrLf
SQL = SQL & "cast(BMQTYREQD * MRP_PARTQTYRQD as decimal(15,4)) as Qty," & vbCrLf
SQL = SQL & "CAST(-1 AS DECIMAL(15,4)) as Surplus" & vbCrLf
SQL = SQL & "into #picks" & vbCrLf
SQL = SQL & "from #temp t" & vbCrLf
SQL = SQL & "join BmplTable bm on bm.BMASSYPART = t.MRP_PARTREF and bm.BMREV = t.PABOMREV" & vbCrLf
SQL = SQL & "join PartTable pt on pt.PARTREF = BMPARTREF and pt.PALEVEL <= 4" & vbCrLf
SQL = SQL & "order by MO#, BMPARTREF" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- get a list of all part quantities on hand less open pick list quantities" & vbCrLf
SQL = SQL & "select MRP_PARTREF,sum(MRP_PARTQTYRQD) as AVAIL, sum(MRP_PARTQTYRQD) as OrigAvail" & vbCrLf
SQL = SQL & "into #parts" & vbCrLf
SQL = SQL & "from" & vbCrLf
SQL = SQL & "PartTable pt left join MrplTable mrp on mrp.MRP_PARTREF = pt.PARTREF" & vbCrLf
SQL = SQL & "where MRP_TYPE in (1,12)" & vbCrLf
SQL = SQL & "group by MRP_PARTREF" & vbCrLf
SQL = SQL & "order by MRP_PARTREF" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- insert parts not in mpr" & vbCrLf
SQL = SQL & "insert #parts" & vbCrLf
SQL = SQL & "select PARTREF,PAQOH, PAQOH" & vbCrLf
SQL = SQL & "from PartTable pt" & vbCrLf
SQL = SQL & "left join #parts p on p.MRP_PARTREF = pt.PARTREF" & vbCrLf
SQL = SQL & "where PALEVEL <= 4 and p.MRP_PARTREF is null" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- for each MO, determine if pick list quantities are available" & vbCrLf
SQL = SQL & "declare @MONO int" & vbCrLf
SQL = SQL & "DECLARE cur CURSOR FOR" & vbCrLf
SQL = SQL & "SELECT [MO#]" & vbCrLf
SQL = SQL & "FROM #temp" & vbCrLf
SQL = SQL & "order by [MO#]" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "OPEN cur" & vbCrLf
SQL = SQL & "FETCH NEXT FROM cur INTO @MONO" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "WHILE @@FETCH_STATUS = 0" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "update p set Surplus = pt.AVAIL - p.Qty" & vbCrLf
SQL = SQL & "from #picks p join #parts pt on p.BMPARTREF = pt.MRP_PARTREF" & vbCrLf
SQL = SQL & "where p.MO# = @MONO" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- if any negative quantities for pick list, delete MO" & vbCrLf
SQL = SQL & "if(select min(Surplus) from #picks where MO# = @MONO) < 0" & vbCrLf
SQL = SQL & "begin" & vbCrLf
SQL = SQL & "delete from #temp where MO# = @MONO" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- otherwise subtract from quantities available" & vbCrLf
SQL = SQL & "end" & vbCrLf
SQL = SQL & "else" & vbCrLf
SQL = SQL & "begin" & vbCrLf
SQL = SQL & "update p set AVAIL = Avail - pk.Qty" & vbCrLf
SQL = SQL & "from #parts p join #picks pk on pk.BMPARTREF = p.MRP_PARTREF" & vbCrLf
SQL = SQL & "where pk.MO# = @MONO" & vbCrLf
SQL = SQL & "end" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "FETCH NEXT FROM cur INTO @MONO" & vbCrLf
SQL = SQL & "END" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "CLOSE cur" & vbCrLf
SQL = SQL & "DEALLOCATE cur" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "select * from #temp order by MO#" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "drop table #temp" & vbCrLf
SQL = SQL & "drop table #picks" & vbCrLf
SQL = SQL & "drop table #parts" & vbCrLf
ExecuteScript True, SQL

''''''''''''''''''''''''''''''''''''''''''''''


''''''''''''''''''''''''''''''''''''''''''''''''''

      ' update the version
      ExecuteScript False, "Update Version Set Version = " & newver

   End If
End Function




Private Function UpdateDatabase110()

'update database version template
'set version at top of this file
'set version below
'add SQL updates


   Dim SQL As String
   SQL = ""

   newver = 189     ' set actual version
   If ver < newver Then

      clsADOCon.ADOErrNum = 0

''''''''''''''''''''''''''''''''''''''''''''''''''

SQL = "Dropstoredprocedureifexists 'RptEfficiencyByWC'" & vbCrLf
ExecuteScript True, SQL

SQL = "create procedure [dbo].[RptEfficiencyByWC]" & vbCrLf
SQL = SQL & "@Shop varchar(20),  -- show WCs for this shop" & vbCrLf
SQL = SQL & "@StartDate date, -- starting OPCOMPDATE to include" & vbCrLf
SQL = SQL & "@EndDate date    -- ending OPCOMPDATE to include" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "as" & vbCrLf
SQL = SQL & "/* EBM Efficiency by Workcenter Report 10/29/2018 TEL" & vbCrLf
SQL = SQL & "-- hours from routing vs hours charged by employee" & vbCrLf
SQL = SQL & "-- individually and entire company" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "test" & vbCrLf
SQL = SQL & "exec RptEfficiencyByWC 'IS', '1/1/2018', '1/31/2018'" & vbCrLf
SQL = SQL & "exec RptEfficiencyByWC 'OS', '1/1/2018', '1/31/2018'" & vbCrLf
SQL = SQL & "exec RptEfficiencyByWC '', '1/1/2018', '3/15/19'" & vbCrLf
SQL = SQL & "*/" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "declare @DatePlus1 date = dateadd(day,1, @EndDate)" & vbCrLf
SQL = SQL & "set @Shop = rtrim(@Shop)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- get all operations in date range" & vbCrLf
SQL = SQL & "select WCNSHOP as Shop, OPCENTER as WC, wc.WCNDESC as [WC Desc], pt.PARTNUM as [Part#], OPRUN as [Run#], OPNO as [Op#]," & vbCrLf
SQL = SQL & "count(*) as [Charges], max(run.RUNQTY) as Qty, CONVERT(varchar(10)," & vbCrLf
SQL = SQL & "max(OPCOMPDATE),101) AS [Completed], max(OPSUHRS) as Setup, MAX(OPUNITHRS) as Unit," & vbCrLf
SQL = SQL & "max(cast(OPSUHRS + RUNQTY * OPUNITHRS as decimal(15,4))) AS [Op Hours]," & vbCrLf
SQL = SQL & "cast(sum(TCHOURS) as decimal(15,4)) as [Emp Hours], cast(0 as decimal(15,0)) as [Eff%]" & vbCrLf
SQL = SQL & "into #temp" & vbCrLf
SQL = SQL & "from rnoptable op" & vbCrLf
SQL = SQL & "join TcitTable tc on tc.TCPARTREF = op.OPREF and tc.TCRUNNO = op.OPRUN and tc.TCOPNO = op.OPNO" & vbCrLf
SQL = SQL & "and tc.TCWC = op.OPCENTER and tc.TCSHOP = op.OPSHOP" & vbCrLf
SQL = SQL & "join WcntTable wc on wc.WCNREF = op.OPCENTER and wc.WCNSHOP = op.OPSHOP" & vbCrLf
SQL = SQL & "join PartTable pt on pt.PARTREF = op.OPREF" & vbCrLf
SQL = SQL & "join RunsTable run on run.RUNREF = op.OPREF and run.RUNNO = op.OPRUN" & vbCrLf
SQL = SQL & "where (@Shop = '' or WCNSHOP = @Shop) and OPCOMPLETE = 1" & vbCrLf
SQL = SQL & "and OPCOMPDATE >= @StartDate and OPCOMPDATE < @DatePlus1" & vbCrLf
SQL = SQL & "group by WCNSHOP, OPCENTER, WCNDESC, pt.PARTNUM, OPRUN, OPNO" & vbCrLf
SQL = SQL & "order by WCNSHOP, OPCENTER, max(OPCOMPDATE)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "delete from #temp where [Emp Hours] = 0 and [Op Hours] = 0" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "update #temp set [Eff%] = 100.00 * [Op Hours] / [Emp Hours] where [Emp Hours] > 0" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "select * from #temp order by Shop, WC, Completed" & vbCrLf
SQL = SQL & "drop table #temp" & vbCrLf
ExecuteScript True, SQL


SQL = "Dropstoredprocedureifexists 'GetScMOs'" & vbCrLf
ExecuteScript True, SQL
SQL = "create procedure [dbo].[GetScMOs]" & vbCrLf
SQL = SQL & "@Parts varchar(30),    -- leading characters for MO parts to select" & vbCrLf
SQL = SQL & "@StartDate date,    -- start pick date" & vbCrLf
SQL = SQL & "@EndDate date       -- end pick date" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "as" & vbCrLf
SQL = SQL & "/*" & vbCrLf
SQL = SQL & "rev 1: 3/20/19 add PKPARTREF and SURPLUS columns to be compatible with GetScMOsBlocked" & vbCrLf
SQL = SQL & "test" & vbCrLf
SQL = SQL & "exec GetScMOs '', '7/1/18','7/1/18'" & vbCrLf
SQL = SQL & "exec GetScMOs '34', '3/1/19','4/1/19'" & vbCrLf
SQL = SQL & "*/" & vbCrLf
SQL = SQL & "set nocount on" & vbCrLf
SQL = SQL & "declare @EndDatePlus1 date = dateadd(day,1,@EndDate)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- get list of all SC runs" & vbCrLf
SQL = SQL & "--SELECT DISTINCT RUNREF as MRP_PARTREF, RUNNO, ISNULL(RUNOPCUR, 0) as RUNOPCUR, PARTNUM as MRP_PARTNUM," & vbCrLf
SQL = SQL & "--RUNQTY As MRP_PARTQTYRQD, Convert(varchar(10), RUNPKSTART, 101) As MRP_PARTDATERQD," & vbCrLf
SQL = SQL & "--Convert(varchar(10), RUNSCHED, 101) As MRP_ACTIONDATE, RUNSTATUS,RUNPKSTART,PABOMREV,op.OPCENTER," & vbCrLf
SQL = SQL & "--cast('' as varchar(30)) as PKPARTREF, cast(0 as decimal(15,4)) as Surplus," & vbCrLf
SQL = SQL & "--ROW_NUMBER() over (ORDER BY RUNPKSTART) AS [MO#]" & vbCrLf
SQL = SQL & "--into #temp" & vbCrLf
SQL = SQL & "--FROM RunsTable r" & vbCrLf
SQL = SQL & "--join PartTable p on PARTREF = RUNREF" & vbCrLf
SQL = SQL & "--join RnopTable op on op.opref = r.RUNREF and op.OPRUN = r.RUNNO and op.OPNO = r.RUNOPCUR" & vbCrLf
SQL = SQL & "--WHERE RUNREF LIKE @Parts + '%' AND RUNSTATUS = 'SC' and op.OPCENTER = '0120'" & vbCrLf
SQL = SQL & "--AND RUNPKSTART >= @StartDate AND RUNPKSTART < @EndDatePlus1" & vbCrLf
SQL = SQL & "--order by RUNPKSTART" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "SELECT DISTINCT RUNREF as MRP_PARTREF, RUNNO, ISNULL(RUNOPCUR, 0) as RUNOPCUR, PARTNUM as MRP_PARTNUM," & vbCrLf
SQL = SQL & "cast(''as varchar(30)) AS PKPARTREF,RUNQTY As MRP_PARTQTYRQD, Convert(varchar(10), RUNPKSTART, 101) As MRP_PARTDATERQD," & vbCrLf
SQL = SQL & "Convert(varchar(10), RUNSCHED, 101) As MRP_ACTIONDATE, RUNSTATUS,RUNPKSTART,PABOMREV,op.OPCENTER," & vbCrLf
SQL = SQL & "ROW_NUMBER() over (ORDER BY RUNPKSTART) AS [MO#], cast(0 as decimal(15,4)) as SURPLUS," & vbCrLf
SQL = SQL & "cast(0 as decimal(15,4)) as PAQOH," & vbCrLf
SQL = SQL & "cast(0 as decimal(15,4)) as Unpicked" & vbCrLf
SQL = SQL & "into #temp" & vbCrLf
SQL = SQL & "FROM RunsTable r" & vbCrLf
SQL = SQL & "join PartTable p on PARTREF = RUNREF" & vbCrLf
SQL = SQL & "join RnopTable op on op.opref = r.RUNREF and op.OPRUN = r.RUNNO and op.OPNO = r.RUNOPCUR" & vbCrLf
SQL = SQL & "WHERE RUNREF LIKE @Parts + '%' AND RUNSTATUS = 'SC' and op.OPCENTER = '0120'" & vbCrLf
SQL = SQL & "AND RUNPKSTART >= @StartDate AND RUNPKSTART < @EndDatePlus1" & vbCrLf
SQL = SQL & "order by RUNPKSTART" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- get a list of all pick list requirements" & vbCrLf
SQL = SQL & "--select t.[MO#], BMPARTREF, BMQTYREQD,MRP_PARTQTYRQD," & vbCrLf
SQL = SQL & "--cast(BMQTYREQD * MRP_PARTQTYRQD as decimal(15,4)) as Qty," & vbCrLf
SQL = SQL & "--CAST(-1 AS DECIMAL(15,4)) as Surplus" & vbCrLf
SQL = SQL & "--into #picks" & vbCrLf
SQL = SQL & "--from #temp t" & vbCrLf
SQL = SQL & "--join BmplTable bm on bm.BMASSYPART = t.MRP_PARTREF and bm.BMREV = t.PABOMREV" & vbCrLf
SQL = SQL & "--join PartTable pt on pt.PARTREF = BMPARTREF and pt.PALEVEL <= 4" & vbCrLf
SQL = SQL & "--order by MO#, BMPARTREF" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "select t.[MO#], BMPARTREF, BMQTYREQD,MRP_PARTQTYRQD," & vbCrLf
SQL = SQL & "cast(BMQTYREQD * MRP_PARTQTYRQD as decimal(15,4)) as Qty," & vbCrLf
SQL = SQL & "CAST(-1 AS DECIMAL(15,4)) as Surplus, cast(0 as decimal(15,4)) as OrigAvail" & vbCrLf
SQL = SQL & "into #picks" & vbCrLf
SQL = SQL & "from #temp t" & vbCrLf
SQL = SQL & "join BmplTable bm on bm.BMASSYPART = t.MRP_PARTREF and bm.BMREV = t.PABOMREV" & vbCrLf
SQL = SQL & "join PartTable pt on pt.PARTREF = BMPARTREF and pt.PALEVEL <= 4" & vbCrLf
SQL = SQL & "order by MO#, BMPARTREF" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- get a list of all part quantities on hand less open pick list quantities" & vbCrLf
SQL = SQL & "--select MRP_PARTREF,sum(MRP_PARTQTYRQD) as AVAIL, sum(MRP_PARTQTYRQD) as OrigAvail" & vbCrLf
SQL = SQL & "--into #parts" & vbCrLf
SQL = SQL & "--from" & vbCrLf
SQL = SQL & "--PartTable pt left join MrplTable mrp on mrp.MRP_PARTREF = pt.PARTREF" & vbCrLf
SQL = SQL & "--where MRP_TYPE in (1,12)" & vbCrLf
SQL = SQL & "--group by MRP_PARTREF" & vbCrLf
SQL = SQL & "--order by MRP_PARTREF" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- get a list of all part current quantities on hand" & vbCrLf
SQL = SQL & "select PARTREF as MRP_PARTREF,PAQOH, cast(0 as decimal(15,4)) as Unpicked," & vbCrLf
SQL = SQL & "PAQOH as Available , PAQOH as OrigAvail" & vbCrLf
SQL = SQL & "into #parts" & vbCrLf
SQL = SQL & "from PartTable where PALEVEL <= 4" & vbCrLf
SQL = SQL & "order by PARTREF" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- add unpicked quantities" & vbCrLf
SQL = SQL & "update #parts set Unpicked = (select isnull(sum(PKPQTY),0)" & vbCrLf
SQL = SQL & "from MopkTable where PKPARTREF = MRP_PARTREF AND PKTYPE = 9" & vbCrLf
SQL = SQL & "and PKADATE is null)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "update #parts set Available = PAQOH - Unpicked, OrigAvail = PAQOH - Unpicked" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "---- insert parts not in mpr" & vbCrLf
SQL = SQL & "--insert #parts" & vbCrLf
SQL = SQL & "--select PARTREF,PAQOH, PAQOH" & vbCrLf
SQL = SQL & "--from PartTable pt" & vbCrLf
SQL = SQL & "--left join #parts p on p.MRP_PARTREF = pt.PARTREF" & vbCrLf
SQL = SQL & "--where PALEVEL <= 4 and p.MRP_PARTREF is null" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- for each MO, determine if pick list quantities are available" & vbCrLf
SQL = SQL & "declare @MONO int" & vbCrLf
SQL = SQL & "DECLARE cur CURSOR FOR" & vbCrLf
SQL = SQL & "SELECT [MO#]" & vbCrLf
SQL = SQL & "FROM #temp" & vbCrLf
SQL = SQL & "order by [MO#]" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "OPEN cur" & vbCrLf
SQL = SQL & "FETCH NEXT FROM cur INTO @MONO" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "WHILE @@FETCH_STATUS = 0" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "--update p set Surplus = pt.AVAIL - p.Qty" & vbCrLf
SQL = SQL & "--from #picks p join #parts pt on p.BMPARTREF = pt.MRP_PARTREF" & vbCrLf
SQL = SQL & "--where p.MO# = @MONO" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "update p set Surplus = pt.Available - p.Qty, p.OrigAvail = pt.OrigAvail" & vbCrLf
SQL = SQL & "from #picks p join #parts pt on p.BMPARTREF = pt.MRP_PARTREF" & vbCrLf
SQL = SQL & "where p.MO# = @MONO" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- if any negative quantities for pick list, delete MO" & vbCrLf
SQL = SQL & "if(select min(Surplus) from #picks where MO# = @MONO) < 0" & vbCrLf
SQL = SQL & "begin" & vbCrLf
SQL = SQL & "delete from #temp where MO# = @MONO" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- otherwise subtract from quantities available" & vbCrLf
SQL = SQL & "end" & vbCrLf
SQL = SQL & "else" & vbCrLf
SQL = SQL & "begin" & vbCrLf
SQL = SQL & "--update p set AVAIL = Avail - pk.Qty" & vbCrLf
SQL = SQL & "--from #parts p join #picks pk on pk.BMPARTREF = p.MRP_PARTREF" & vbCrLf
SQL = SQL & "--where pk.MO# = @MONO" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "update p set Available = Available - pk.Qty" & vbCrLf
SQL = SQL & "from #parts p join #picks pk on pk.BMPARTREF = p.MRP_PARTREF" & vbCrLf
SQL = SQL & "where pk.MO# = @MONO" & vbCrLf
SQL = SQL & "end" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "FETCH NEXT FROM cur INTO @MONO" & vbCrLf
SQL = SQL & "END" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "CLOSE cur" & vbCrLf
SQL = SQL & "DEALLOCATE cur" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "select * from #temp order by MO#,RUNNO,PKPARTREF" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "drop table #temp" & vbCrLf
SQL = SQL & "drop table #picks" & vbCrLf
SQL = SQL & "drop table #parts" & vbCrLf
ExecuteScript True, SQL



SQL = "dropstoredprocedureifexists 'GetScMOsBlocked'" & vbCrLf
ExecuteScript True, SQL
SQL = "create procedure [dbo].[GetScMOsBlocked]" & vbCrLf
SQL = SQL & "@Parts varchar(30), -- leading characters for MO parts to select" & vbCrLf
SQL = SQL & "@StartDate date,    -- start pick date" & vbCrLf
SQL = SQL & "@EndDate date       -- end pick date" & vbCrLf
SQL = SQL & "as" & vbCrLf
SQL = SQL & "/*" & vbCrLf
SQL = SQL & "Get SC MOs that are blocked from released by PAQOH or unpicked quantities" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "test" & vbCrLf
SQL = SQL & "exec GetScMOs '775', '7/1/18','4/1/19'" & vbCrLf
SQL = SQL & "exec GetScMOsBlocked '775', '7/1/18','4/1/19'" & vbCrLf
SQL = SQL & "exec GetScMOsBlocked '34', '3/1/19','4/1/19'" & vbCrLf
SQL = SQL & "select paqoh from parttable where partref = dbo.fncompress('SHA6013KE00.080X48.000X144.00 ')" & vbCrLf
SQL = SQL & "exec GetScMOs '7753453313', '7/1/18','4/1/19'" & vbCrLf
SQL = SQL & "exec GetScMOsBlocked '7753453313', '7/1/18','4/1/19'" & vbCrLf
SQL = SQL & "exec GetScMOs '145T190125', '7/1/18','7/1/18'" & vbCrLf
SQL = SQL & "exec GetScMOsBlocked '145T190125', '7/1/18','7/1/18'" & vbCrLf
SQL = SQL & "exec GetScMOs '287W4136204', '7/1/18','7/1/18'" & vbCrLf
SQL = SQL & "exec GetScMOsBlocked '287W4136-04', '7/1/18','7/1/18'" & vbCrLf
SQL = SQL & "*/" & vbCrLf
SQL = SQL & "declare @Details bit = 1  -- = 1 if negative pick quantities are to be included" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "set nocount on" & vbCrLf
SQL = SQL & "declare @EndDatePlus1 date = dateadd(day,1,@EndDate)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- get list of all SC runs" & vbCrLf
SQL = SQL & "SELECT DISTINCT RUNREF as MRP_PARTREF, RUNNO, ISNULL(RUNOPCUR, 0) as RUNOPCUR, PARTNUM as MRP_PARTNUM," & vbCrLf
SQL = SQL & "cast(''as varchar(30)) AS PKPARTREF,RUNQTY As MRP_PARTQTYRQD, Convert(varchar(10), RUNPKSTART, 101) As MRP_PARTDATERQD," & vbCrLf
SQL = SQL & "Convert(varchar(10), RUNSCHED, 101) As MRP_ACTIONDATE, RUNSTATUS,RUNPKSTART,PABOMREV,op.OPCENTER," & vbCrLf
SQL = SQL & "ROW_NUMBER() over (ORDER BY RUNPKSTART) AS [MO#], cast(0 as decimal(15,4)) as SURPLUS," & vbCrLf
SQL = SQL & "cast(0 as decimal(15,4)) as PAQOH," & vbCrLf
SQL = SQL & "cast(0 as decimal(15,4)) as Unpicked" & vbCrLf
SQL = SQL & "into #temp" & vbCrLf
SQL = SQL & "FROM RunsTable r" & vbCrLf
SQL = SQL & "join PartTable p on PARTREF = RUNREF" & vbCrLf
SQL = SQL & "join RnopTable op on op.opref = r.RUNREF and op.OPRUN = r.RUNNO and op.OPNO = r.RUNOPCUR" & vbCrLf
SQL = SQL & "WHERE RUNREF LIKE @Parts + '%' AND RUNSTATUS = 'SC' and op.OPCENTER = '0120'" & vbCrLf
SQL = SQL & "AND RUNPKSTART >= @StartDate AND RUNPKSTART < @EndDatePlus1" & vbCrLf
SQL = SQL & "order by RUNPKSTART" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- get a list of all pick list requirements" & vbCrLf
SQL = SQL & "select t.[MO#], BMPARTREF, BMQTYREQD,MRP_PARTQTYRQD," & vbCrLf
SQL = SQL & "cast(BMQTYREQD * MRP_PARTQTYRQD as decimal(15,4)) as Qty," & vbCrLf
SQL = SQL & "CAST(-1 AS DECIMAL(15,4)) as Surplus, cast(0 as decimal(15,4)) as OrigAvail" & vbCrLf
SQL = SQL & "into #picks" & vbCrLf
SQL = SQL & "from #temp t" & vbCrLf
SQL = SQL & "join BmplTable bm on bm.BMASSYPART = t.MRP_PARTREF and bm.BMREV = t.PABOMREV" & vbCrLf
SQL = SQL & "join PartTable pt on pt.PARTREF = BMPARTREF and pt.PALEVEL <= 4" & vbCrLf
SQL = SQL & "order by MO#, BMPARTREF" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "---- get a list of all part quantities on hand less open pick list quantities" & vbCrLf
SQL = SQL & "--select MRP_PARTREF,sum(MRP_PARTQTYRQD) as AVAIL, sum(MRP_PARTQTYRQD) as OrigAvail" & vbCrLf
SQL = SQL & "--into #parts" & vbCrLf
SQL = SQL & "--from" & vbCrLf
SQL = SQL & "--PartTable pt left join MrplTable mrp on mrp.MRP_PARTREF = pt.PARTREF" & vbCrLf
SQL = SQL & "--where MRP_TYPE in (1,12)" & vbCrLf
SQL = SQL & "--group by MRP_PARTREF" & vbCrLf
SQL = SQL & "--order by MRP_PARTREF" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- get a list of all part current quantities on hand plus open pick list quantities" & vbCrLf
SQL = SQL & "--select MRP_PARTREF,sum(MRP_PARTQTYRQD) as AVAIL, sum(MRP_PARTQTYRQD) as OrigAvail," & vbCrLf
SQL = SQL & "--sum(case when MRP_TYPE = 1 then MRP_PARTQTYRQD else 0 end) as MRP_STARTQTY," & vbCrLf
SQL = SQL & "--sum(case when MRP_TYPE = 12 then MRP_PARTQTYRQD else 0 end) as PICKQTY" & vbCrLf
SQL = SQL & "--into #parts" & vbCrLf
SQL = SQL & "--from" & vbCrLf
SQL = SQL & "--PartTable pt left join MrplTable mrp on mrp.MRP_PARTREF = pt.PARTREF" & vbCrLf
SQL = SQL & "--where MRP_TYPE in (1,12)" & vbCrLf
SQL = SQL & "--group by MRP_PARTREF" & vbCrLf
SQL = SQL & "--order by MRP_PARTREF" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- get a list of all part current quantities on hand" & vbCrLf
SQL = SQL & "select PARTREF as MRP_PARTREF,PAQOH, cast(0 as decimal(15,4)) as Unpicked," & vbCrLf
SQL = SQL & "PAQOH as Available , PAQOH as OrigAvail" & vbCrLf
SQL = SQL & "into #parts" & vbCrLf
SQL = SQL & "from PartTable where PALEVEL <= 4" & vbCrLf
SQL = SQL & "order by PARTREF" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- add unpicked quantities" & vbCrLf
SQL = SQL & "update #parts set Unpicked = (select isnull(sum(PKPQTY),0)" & vbCrLf
SQL = SQL & "from MopkTable where PKPARTREF = MRP_PARTREF AND PKTYPE = 9" & vbCrLf
SQL = SQL & "and PKADATE is null)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "update #parts set Available = PAQOH - Unpicked, OrigAvail = PAQOH - Unpicked" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- insert parts not in mrp" & vbCrLf
SQL = SQL & "--insert #parts" & vbCrLf
SQL = SQL & "--select PARTREF,pt.PAQOH as Avail, pt.PAQOH as OrigAvail, PT.PAQOH, 0" & vbCrLf
SQL = SQL & "--from PartTable pt" & vbCrLf
SQL = SQL & "--left join #parts p on p.MRP_PARTREF = pt.PARTREF" & vbCrLf
SQL = SQL & "--where PALEVEL <= 4 and p.MRP_PARTREF is null" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- for each MO, determine if pick list quantities are available" & vbCrLf
SQL = SQL & "declare @MONO int" & vbCrLf
SQL = SQL & "DECLARE cur CURSOR FOR" & vbCrLf
SQL = SQL & "SELECT [MO#]" & vbCrLf
SQL = SQL & "FROM #temp" & vbCrLf
SQL = SQL & "order by [MO#]" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "OPEN cur" & vbCrLf
SQL = SQL & "FETCH NEXT FROM cur INTO @MONO" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "WHILE @@FETCH_STATUS = 0" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "update p set Surplus = pt.Available - p.Qty, p.OrigAvail = pt.OrigAvail" & vbCrLf
SQL = SQL & "from #picks p join #parts pt on p.BMPARTREF = pt.MRP_PARTREF" & vbCrLf
SQL = SQL & "where p.MO# = @MONO" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- if any negative quantities for pick list, keep it in the list as a blocked item" & vbCrLf
SQL = SQL & "if(select min(Surplus) from #picks where MO# = @MONO) < 0" & vbCrLf
SQL = SQL & "begin" & vbCrLf
SQL = SQL & "declare @x int = 0" & vbCrLf
SQL = SQL & "end" & vbCrLf
SQL = SQL & "else" & vbCrLf
SQL = SQL & "-- this item is pickable" & vbCrLf
SQL = SQL & "-- subtract from quantities available and then delete the item since it is not blocked" & vbCrLf
SQL = SQL & "begin" & vbCrLf
SQL = SQL & "update p set Available = Available - pk.Qty" & vbCrLf
SQL = SQL & "from #parts p join #picks pk on pk.BMPARTREF = p.MRP_PARTREF" & vbCrLf
SQL = SQL & "where pk.MO# = @MONO" & vbCrLf
SQL = SQL & "delete from #temp where MO# = @MONO" & vbCrLf
SQL = SQL & "end" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "FETCH NEXT FROM cur INTO @MONO" & vbCrLf
SQL = SQL & "END" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "CLOSE cur" & vbCrLf
SQL = SQL & "DEALLOCATE cur" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- if details requested, insert all negative quantities" & vbCrLf
SQL = SQL & "if @Details = 1" & vbCrLf
SQL = SQL & "begin" & vbCrLf
SQL = SQL & "insert #temp (MRP_PARTREF,RUNNO,RUNOPCUR,MRP_PARTNUM, PKPARTREF, MRP_PARTQTYRQD," & vbCrLf
SQL = SQL & "MRP_PARTDATERQD,MRP_ACTIONDATE,RUNSTATUS,RUNPKSTART,PABOMREV,OPCENTER, SURPLUS, PAQOH, Unpicked, MO#)" & vbCrLf
SQL = SQL & "select t1.MRP_PARTREF,RUNNO,RUNOPCUR,MRP_PARTNUM, pt.PARTNUM as PKPARTREF, pk.qty as MRP_PARTQTYRQD," & vbCrLf
SQL = SQL & "MRP_PARTDATERQD,'','',RUNPKSTART,'','', pk.Surplus, pt.PAQOH, p.Unpicked, pk.MO#" & vbCrLf
SQL = SQL & "from #temp t1 join #picks pk on t1.MO# = pk.MO# and pk.Surplus < 0" & vbCrLf
SQL = SQL & "join PartTable pt on pt.PARTREF = pk.BMPARTREF" & vbCrLf
SQL = SQL & "join #parts p on p.MRP_PARTREF = pt.PARTREF" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "--update t set Unpicked = p.Unpicked" & vbCrLf
SQL = SQL & "--from #temp t join #parts p on p.MRP_PARTREF = t.PKPARTREF" & vbCrLf
SQL = SQL & "--where t.PKPARTREF <> ''" & vbCrLf
SQL = SQL & "end" & vbCrLf
SQL = SQL & "select * from #temp order by MO#,RUNNO,PKPARTREF" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "drop table #temp" & vbCrLf
SQL = SQL & "drop table #picks" & vbCrLf
SQL = SQL & "drop table #parts" & vbCrLf
ExecuteScript True, SQL



''''''''''''''''''''''''''''''''''''''''''''''''''

      ' update the version
      ExecuteScript False, "Update Version Set Version = " & newver

   End If
End Function

Private Function UpdateDatabase111()

'update database version template
'set version at top of this file
'set version below
'add SQL updates


   Dim SQL As String
   SQL = ""

   newver = 190     ' set actual version
   If ver < newver Then

      clsADOCon.ADOErrNum = 0

''''''''''''''''''''''''''''''''''''''''''''''''''

' add .EsReportUsers.UserID column where it does not exist
SQL = "begin tran" & vbCrLf
SQL = SQL & "delete from EsReportUsers -- delete any rows so can create a non-nullable column" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "if not exists(select * from INFORMATION_SCHEMA.COLUMNS where TABLE_NAME = 'EsReportUsers' and COLUMN_NAME = 'UserID')" & vbCrLf
SQL = SQL & "begin" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- drop old primary key to name" & vbCrLf
SQL = SQL & "if exists (SELECT * FROM information_schema.table_constraints" & vbCrLf
SQL = SQL & "WHERE constraint_type = 'PRIMARY KEY'" & vbCrLf
SQL = SQL & "AND table_name = 'EsReportUsers')" & vbCrLf
SQL = SQL & "begin" & vbCrLf
SQL = SQL & "ALTER TABLE [dbo].[EsReportUsers] DROP CONSTRAINT [PK_EsReportUsers]" & vbCrLf
SQL = SQL & "end" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "alter table EsReportUsers add UserID varchar(30) not null" & vbCrLf
SQL = SQL & "ALTER TABLE [EsReportUsers] ADD CONSTRAINT [PK_EsReportUsers] PRIMARY KEY CLUSTERED" & vbCrLf
SQL = SQL & "(" & vbCrLf
SQL = SQL & "[UserID] ASC" & vbCrLf
SQL = SQL & ")" & vbCrLf
SQL = SQL & "end" & vbCrLf
SQL = SQL & "commit tran" & vbCrLf
ExecuteScript True, SQL

SQL = "if exists(select * from INFORMATION_SCHEMA.COLUMNS where TABLE_NAME = 'CustTable' and COLUMN_NAME = 'CustTerms')"
SQL = SQL & "   alter table CustTable drop column CustTerms"
ExecuteScript True, SQL

SQL = "ALTER TABLE CustTable ADD CustTerms AS" & vbCrLf
SQL = SQL & "case when CUARDISC = 0 then ''" & vbCrLf
SQL = SQL & "when ROUND(CUARDISC,0) = CUARDISC then cast(cast(CUARDISC as int) as varchar(10)) + '/' + cast(CUDAYS as varchar(3)) + ' '" & vbCrLf
SQL = SQL & "when ROUND(CUARDISC,1) = CUARDISC then  cast(cast(CUARDISC as decimal(12,1)) as varchar(10)) + '/' + cast(CUDAYS as varchar(3)) + ' '" & vbCrLf
SQL = SQL & "when ROUND(CUARDISC,2) = CUARDISC then  cast(cast(CUARDISC as decimal(12,2)) as varchar(10)) + '/' + cast(CUDAYS as varchar(3)) + ' '" & vbCrLf
SQL = SQL & "else cast(CUARDISC as varchar(10)) + '/' + cast(CUDAYS as varchar(3)) + ' ' end" & vbCrLf
SQL = SQL & "+ 'NET ' + case when CUNETDAYS = 0 then '30' else cast(CUNETDAYS as varchar(10)) end" & vbCrLf
ExecuteScript True, SQL

SQL = "if exists (select * from INFORMATION_SCHEMA.VIEWS where TABLE_NAME = 'viewFAIRequired')" & vbCrLf
SQL = SQL & "drop view viewFAIRequired" & vbCrLf
ExecuteScript True, SQL

SQL = "create view viewFAIRequired as" & vbCrLf
SQL = SQL & "select RUNREF as FAIPartRef," & vbCrLf
SQL = SQL & "max(RUNCOMPLETE) AS [Last]," & vbCrLf
SQL = SQL & "cast(case when datediff(day,max(RUNCOMPLETE),getdate()) <= 730 then 0 else 1 end as int) as FAIRequired" & vbCrLf
SQL = SQL & "from RunsTable" & vbCrLf
SQL = SQL & "group by RUNREF" & vbCrLf
ExecuteScript True, SQL

' repeat the below.  There was an error in update 107
SQL = "dropfunctionifexists 'fnt_GetLoad'" & vbCrLf
ExecuteScript True, SQL

SQL = "create function [dbo].[fnt_GetLoad]" & vbCrLf
SQL = SQL & "(" & vbCrLf
SQL = SQL & "@Shop varchar(12),     -- <ALL> for all" & vbCrLf
SQL = SQL & "@Workcenter varchar(12),  -- <ALL> for all" & vbCrLf
SQL = SQL & "@StartDate date," & vbCrLf
SQL = SQL & "@Weeks int" & vbCrLf
SQL = SQL & ")" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "RETURNS @Load TABLE (Shop varchar(12), WC varchar(12), Weekend date, Hours decimal(10,2))" & vbCrLf
SQL = SQL & "AS" & vbCrLf
SQL = SQL & "/* return capacity for a given number of weeks" & vbCrLf
SQL = SQL & "test:" & vbCrLf
SQL = SQL & "select * from dbo.fnt_GetLoad('01', '0600', '12/19/2018',26)" & vbCrLf
SQL = SQL & "select * from dbo.fnt_GetLoad('<ALL>', '<ALL>', '12/11/2017',26)" & vbCrLf
SQL = SQL & "*/" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "-- determine end date" & vbCrLf
SQL = SQL & "declare @EndDate date = DATEADD(day,7-datepart(WEEKDAY, @StartDate),@StartDate)" & vbCrLf
SQL = SQL & "set @EndDate = DATEADD(week, @Weeks - 1,@EndDate)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "insert @Load" & vbCrLf
SQL = SQL & "select X.Shop, X.WC, X.Weekend, Sum(X.Hours) as Hours" & vbCrLf
SQL = SQL & "from" & vbCrLf
SQL = SQL & "(SELECT DISTINCT OPREF,OPRUN,OPNO,rtrim(OPSHOP) as Shop,RTRIM(OPCENTER) as WC,PADESC,RUNREMAININGQTY,RUNSTATUS," & vbCrLf
SQL = SQL & "cast(OPSUHRS+OPUNITHRS*RUNREMAININGQTY as decimal(10,2)) as Hours," & vbCrLf
SQL = SQL & "cast(OPSUDATE as date) as OPSUDATE,cast(OPSCHEDDATE as date) as OPSCHEDDATE," & vbCrLf
SQL = SQL & "cast(case when OPSCHEDDATE < @StartDate then dateadd(day,-1,@StartDate) else" & vbCrLf
SQL = SQL & "DATEADD(day,7-datepart(WEEKDAY, OPSCHEDDATE),OPSCHEDDATE) end  as Date) as WeekEnd" & vbCrLf
SQL = SQL & "FROM RnopTable op" & vbCrLf
SQL = SQL & "join RunsTable run on run.RUNREF = op.OPREF and run.RUNNO = op.OPRUN" & vbCrLf
SQL = SQL & "join WcntTable wc on wc.WCNREF = op.OPCENTER and wc.WCNSHOP = op.OPSHOP" & vbCrLf
SQL = SQL & "join PartTable pt on pt.PARTREF = op.OPREF" & vbCrLf
SQL = SQL & "WHERE (OPREF=RUNREF AND OPRUN=RUNNO AND OPCENTER=WCNREF AND WCNSERVICE=0 AND OPCOMPLETE=0)" & vbCrLf
SQL = SQL & "AND OPSCHEDDATE <= @EndDate AND (OPSHOP = @Shop or @Shop = '<ALL>')" & vbCrLf
SQL = SQL & "AND (OPCENTER LIKE @Workcenter or @Workcenter = '<ALL>' or @Shop = '<ALL>') and RUNSTATUS <> 'CA') as X" & vbCrLf
SQL = SQL & "group by X.Shop, X.WC, X.WeekEnd" & vbCrLf
SQL = SQL & "order by X.Shop, X.WC, X.WeekEnd" & vbCrLf
SQL = SQL & "RETURN" & vbCrLf
SQL = SQL & "END" & vbCrLf
ExecuteScript True, SQL

SQL = "exec AddOrUpdateColumn 'RunsTable', 'RunParentRunRef', 'varchar(30) not null default '''''"
ExecuteScript True, SQL

SQL = "exec AddOrUpdateColumn 'RunsTable', 'RunParentRunNo', 'int not null default 0'"
ExecuteScript True, SQL

SQL = "DropStoredProcedureIfExists 'InsertMultilevelMo'" & vbCrLf
ExecuteScript True, SQL

SQL = "create procedure [dbo].InsertMultilevelMo" & vbCrLf
SQL = SQL & "@ParentPart char(30)," & vbCrLf
SQL = SQL & "@ParentNumber int," & vbCrLf
SQL = SQL & "@ChildPart char(30)," & vbCrLf
SQL = SQL & "@ChildNumber int" & vbCrLf
SQL = SQL & "as" & vbCrLf
SQL = SQL & "/* insert child MO below parent MO" & vbCrLf
SQL = SQL & "test" & vbCrLf
SQL = SQL & "exec InsertMultilevelMo '100T14882', 1, '1003110042D02', 26" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "*/" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- check that the max of 5 levels is not exceeded." & vbCrLf
SQL = SQL & "-- also check that there is no circular reference" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- first find all children of the child" & vbCrLf
SQL = SQL & "declare @Levels table" & vbCrLf
SQL = SQL & "(" & vbCrLf
SQL = SQL & "Lev int," & vbCrLf
SQL = SQL & "MoRef char(30) ," & vbCrLf
SQL = SQL & "MoNo int" & vbCrLf
SQL = SQL & ")" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & ";WITH CTE (Lev, MoPart, MoRun)" & vbCrLf
SQL = SQL & "AS" & vbCrLf
SQL = SQL & "(" & vbCrLf
SQL = SQL & "SELECT 6 as Lev, @ChildPart as MoPart, @ChildNumber as MoRun" & vbCrLf
SQL = SQL & "UNION ALL" & vbCrLf
SQL = SQL & "SELECT Lev + 1 as Lev, RUNREF as MoPart, RUNNO as MoRun" & vbCrLf
SQL = SQL & "FROM RunsTable child" & vbCrLf
SQL = SQL & "join CTE on child.RunParentRunRef = CTE.MoPart and child.RunParentRunNo = CTE.MoRun" & vbCrLf
SQL = SQL & "where Lev < 10" & vbCrLf
SQL = SQL & ")" & vbCrLf
SQL = SQL & "insert @Levels" & vbCrLf
SQL = SQL & "SELECT * from CTE" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- now find all the parents" & vbCrLf
SQL = SQL & ";WITH CTE (Lev, MoPart, MoRun)" & vbCrLf
SQL = SQL & "AS" & vbCrLf
SQL = SQL & "(" & vbCrLf
SQL = SQL & "SELECT 5 as Lev, @ParentPart as MoPart, @ParentNumber as MoRun" & vbCrLf
SQL = SQL & "UNION ALL" & vbCrLf
SQL = SQL & "SELECT Lev - 1, parent.RUNREF, parent.RUNNO" & vbCrLf
SQL = SQL & "FROM RunsTable parent" & vbCrLf
SQL = SQL & "join RunsTable child on child.RunParentRunRef = parent.RUNREF and child.RunParentRunNo = parent.RUNNO" & vbCrLf
SQL = SQL & "join CTE on child.RUNREF = CTE.MoPart and child.RUNNO = CTE.MoRun and CTE.Lev = Lev" & vbCrLf
SQL = SQL & "where Lev > 1" & vbCrLf
SQL = SQL & ")" & vbCrLf
SQL = SQL & "insert @Levels" & vbCrLf
SQL = SQL & "SELECT * from CTE" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- if more than 5 levels do not allow insert" & vbCrLf
SQL = SQL & "if (select count(distinct Lev) from @Levels) > 5" & vbCrLf
SQL = SQL & "begin" & vbCrLf
SQL = SQL & "select 'More than 5 levels not allowed'" & vbCrLf
SQL = SQL & "return" & vbCrLf
SQL = SQL & "end" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- if same MO more than once do not allow" & vbCrLf
SQL = SQL & "declare @ct int, @dupPart varchar(30), @dupNo int" & vbCrLf
SQL = SQL & "select top 1 @ct = ct, @dupPart = MoRef, @dupNo = Mono" & vbCrLf
SQL = SQL & "from (select count(*) as ct, MoRef,  MoNo from @Levels group by MoRef, Mono having count(*) > 1) x" & vbCrLf
SQL = SQL & "if @ct is not null" & vbCrLf
SQL = SQL & "begin" & vbCrLf
SQL = SQL & "select 'MO ' + @DupPart + ' run ' + cast(@DupNo as varchar(10)) + ' cannot appear more than once'" & vbCrLf
SQL = SQL & "return" & vbCrLf
SQL = SQL & "end" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- everything is OK.  Link the MO to its parent" & vbCrLf
SQL = SQL & "update RunsTable set RunParentRunRef = @ParentPart, RunParentRunNo = @ParentNumber" & vbCrLf
SQL = SQL & "where RUNREF = @ChildPart and RUNNO = @ChildNumber" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "if @@ROWCOUNT > 0" & vbCrLf
SQL = SQL & "select '' as result    -- indicate everything is OK" & vbCrLf
SQL = SQL & "else" & vbCrLf
SQL = SQL & "select 'unable to link MOs'" & vbCrLf
ExecuteScript True, SQL

SQL = "DropStoredProcedureIfExists 'RptMultilevelMoCostAnalysis'" & vbCrLf
ExecuteScript True, SQL

SQL = "create procedure [dbo].[RptMultilevelMoCostAnalysis]" & vbCrLf
SQL = SQL & "@MoPart char(30)," & vbCrLf
SQL = SQL & "@MoNumber int" & vbCrLf
SQL = SQL & "as" & vbCrLf
SQL = SQL & "/* test" & vbCrLf
SQL = SQL & "RptMultilevelMoCostAnalysis '174570301',7976" & vbCrLf
SQL = SQL & "select top 100 * from tcittable" & vbCrLf
SQL = SQL & "*/" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- make a list of MOs at each level" & vbCrLf
SQL = SQL & ";WITH CTE (Lev, MoPart, MoRun)" & vbCrLf
SQL = SQL & "AS" & vbCrLf
SQL = SQL & "(" & vbCrLf
SQL = SQL & "SELECT 1, @MoPart, @MoNumber" & vbCrLf
SQL = SQL & "UNION ALL" & vbCrLf
SQL = SQL & "SELECT Lev + 1, RUNREF, RUNNO" & vbCrLf
SQL = SQL & "FROM RunsTable child" & vbCrLf
SQL = SQL & "join CTE on child.RunParentRunRef = CTE.MoPart and child.RunParentRunNo = CTE.MoRun" & vbCrLf
SQL = SQL & ")" & vbCrLf
SQL = SQL & "SELECT *" & vbCrLf
SQL = SQL & "into #temp" & vbCrLf
SQL = SQL & "from CTE" & vbCrLf
SQL = SQL & "order by Lev, MoPart, MoRun" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "select" & vbCrLf
SQL = SQL & "Lev as [Level]," & vbCrLf
SQL = SQL & "rtrim(pt.PARTNUM) as [MO Part]," & vbCrLf
SQL = SQL & "MoRun as [MO Run]," & vbCrLf
SQL = SQL & "'Labor' as [Type]," & vbCrLf
SQL = SQL & "cast(sum(TCHOURS) as decimal(12,2)) as [Hours]," & vbCrLf
SQL = SQL & "cast(sum(TCHOURS*TCRATE) as decimal(12,2)) as Labor," & vbCrLf
SQL = SQL & "cast(sum(TCHOURS*TCOHRATE) as decimal(12,2)) as OH," & vbCrLf
SQL = SQL & "null as Part," & vbCrLf
SQL = SQL & "null as [Part Desc]," & vbCrLf
SQL = SQL & "null as Qty," & vbCrLf
SQL = SQL & "null as [Unit Cost]," & vbCrLf
SQL = SQL & "null as [Ext Matl]," & vbCrLf
SQL = SQL & "null as [Ext Svc]," & vbCrLf
SQL = SQL & "'' as Vendor" & vbCrLf
SQL = SQL & "from TcitTable tc" & vbCrLf
SQL = SQL & "join #temp tmp on tmp.MoPart = tc.TCPARTREF and tmp.MoRun = tc.TCRUNNO" & vbCrLf
SQL = SQL & "join PartTable pt on pt.PARTREF = tc.TCPARTREF" & vbCrLf
SQL = SQL & "group by Lev,pt.PARTNUM,MoRun" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- now do parts and services" & vbCrLf
SQL = SQL & "union all" & vbCrLf
SQL = SQL & "select" & vbCrLf
SQL = SQL & "Lev as [Level]," & vbCrLf
SQL = SQL & "rtrim(mopart.PARTNUM) as [MO Part]," & vbCrLf
SQL = SQL & "MoRun as [MO Run]," & vbCrLf
SQL = SQL & "case when pt.PALEVEL = 5 then 'Svc' else 'Matl' end as [Type]," & vbCrLf
SQL = SQL & "null as [Hours]," & vbCrLf
SQL = SQL & "null as [Labor]," & vbCrLf
SQL = SQL & "null as [OH]," & vbCrLf
SQL = SQL & "rtrim(pt.PARTNUM) as Part," & vbCrLf
SQL = SQL & "rtrim(pt.PADESC) as [Part Desc]," & vbCrLf
SQL = SQL & "PKAQTY as Qty," & vbCrLf
SQL = SQL & "INAMT as [Unit Cost]," & vbCrLf
SQL = SQL & "--cast(INAMT * PKAQTY as decimal(12,2)) as [Ext Cost]," & vbCrLf
SQL = SQL & "case when pt.PALEVEL <> 5 then cast(INAMT * PKAQTY as decimal(12,2)) else null end as [Ext Matl]," & vbCrLf
SQL = SQL & "case when pt.PALEVEL = 5 then cast(INAMT * PKAQTY as decimal(12,2)) else null end as [Ext Svc]," & vbCrLf
SQL = SQL & "isnull(rtrim(POVENDOR),'') as Vendor" & vbCrLf
SQL = SQL & "from MopkTable p" & vbCrLf
SQL = SQL & "join #temp tmp on tmp.MoPart = p.PKMOPART and tmp.MoRun = p.PKMORUN" & vbCrLf
SQL = SQL & "--join RunsTable r on r.RUNREF = p.PKMOPART and r.RUNNO = p.PKMORUN and r.RUNSTATUS <> 'CA'" & vbCrLf
SQL = SQL & "join PartTable pt ON PT.PARTREF = p.PKPARTREF" & vbCrLf
SQL = SQL & "join InvaTable inv on inv.INPART = p.PKPARTREF and inv.INMOPART = p.PKMOPART and inv.INMORUN = p.PKMORUN" & vbCrLf
SQL = SQL & "left join PoitTable poi on poi.PINUMBER = inv.INPONUMBER and poi.PIITEM = inv.INPOITEM and inv.inporev = poi.PIREV" & vbCrLf
SQL = SQL & "left join PohdTable ph on ph.PONUMBER = poi.PINUMBER" & vbCrLf
SQL = SQL & "join PartTable mopart on mopart.PARTREF = tmp.MoPart" & vbCrLf
SQL = SQL & "where INTYPE = 10" & vbCrLf
SQL = SQL & "--order by Lev, MoPart, MoRun,[Type]" & vbCrLf
SQL = SQL & "order by [Level],[MO Part],[MO Run],[Type]" & vbCrLf
SQL = SQL & "" & vbCrLf
ExecuteScript True, SQL


SQL = "dropstoredprocedureifexists 'RptMORunOptDetail'" & vbCrLf
ExecuteScript True, SQL

SQL = "create PROCEDURE RptMORunOptDetail" & vbCrLf
SQL = SQL & "@MOPart as varchar(30),@cutoffDt as varchar(10)" & vbCrLf
SQL = SQL & "AS" & vbCrLf
SQL = SQL & "/*" & vbCrLf
SQL = SQL & "used by Part Info and Status Report" & vbCrLf
SQL = SQL & "rev 5/16/2019 TEL to correctly show PO info." & vbCrLf
SQL = SQL & "*/" & vbCrLf
SQL = SQL & "BEGIN" & vbCrLf
SQL = SQL & "CREATE TABLE #tempRunOpDet" & vbCrLf
SQL = SQL & "(" & vbCrLf
SQL = SQL & "RUNREF Varchar(30) NULL," & vbCrLf
SQL = SQL & "RUNNO int Null," & vbCrLf
SQL = SQL & "CUROPNO smallint NULL," & vbCrLf
SQL = SQL & "NextOPNO smallint NULL," & vbCrLf
SQL = SQL & "NextOPSHOP varchar(12) NULL," & vbCrLf
SQL = SQL & "NextOPCENTER varchar(12) NULL," & vbCrLf
SQL = SQL & "PONUMBER int NULL," & vbCrLf
SQL = SQL & "POVENDOR varchar(30) NULL" & vbCrLf
SQL = SQL & ")" & vbCrLf
SQL = SQL & "INSERT INTO #tempRunOpDet(RUNREF, RUNNO, CUROPNO,NextOPNO, NextOPSHOP, NextOPCENTER)" & vbCrLf
SQL = SQL & "select distinct runstable.Runref, runstable.runno, runstable.RUNOPCUR, f.NextOPNO, f.NextOPSHOP, f.NextOPCENTER" & vbCrLf
SQL = SQL & "from runstable,RnopTable," & vbCrLf
SQL = SQL & "(select a.runref, a.runno, b.OPNO NextOPNO, OPSHOP NextOPSHOP, OPCENTER NextOPCENTER," & vbCrLf
SQL = SQL & "ROW_NUMBER() OVER (PARTITION BY opref, oprun" & vbCrLf
SQL = SQL & "ORDER BY opref DESC, oprun) as rn" & vbCrLf
SQL = SQL & "from runstable a,rnopTable b" & vbCrLf
SQL = SQL & "where a.runref = b.opref and" & vbCrLf
SQL = SQL & "a.runno = b.oprun and b.opcompdate is null and b.opno <> a.runopcur" & vbCrLf
SQL = SQL & "--and b.opno > a.runopcur" & vbCrLf
SQL = SQL & ") as f" & vbCrLf
SQL = SQL & "where RunsTable.RUNSCHED <= @cutoffDt AND" & vbCrLf
SQL = SQL & "RunsTable.RUNSTATUS NOT IN ('CA','CL','CO') and RunsTable.runref =  @MOPart" & vbCrLf
SQL = SQL & "and RunsTable.runref =  f.runref AND RunsTable.runno = f.runno" & vbCrLf
SQL = SQL & "and f.rn = 1" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "--UPDATE a SET a.PONUMBER = poitTable.PINUMBER, a.POVENDOR = PohdTable.POVENDOR" & vbCrLf
SQL = SQL & "--FROM #tempRunOpDet a, ShopTable, poitTable,PohdTable, rnopTable WHERE SHPREF = OPSHOP" & vbCrLf
SQL = SQL & "--   AND SHPSERVICE = 1 AND PIRUNPART = RUNREF AND PIRUNNO = RUNNO" & vbCrLf
SQL = SQL & "--   and rnopTable.Opref = RUNREF AND rnopTable.OPRUN = RUNNO" & vbCrLf
SQL = SQL & "--   AND poitTable.PINUMBER = PohdTable.PONUMBER" & vbCrLf
SQL = SQL & "--   AND PIRUNOPNO = a.CUROPNO" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "--select *" & vbCrLf
SQL = SQL & "--FROM #tempRunOpDet a" & vbCrLf
SQL = SQL & "--join rnopTable on rnopTable.Opref = a.RUNREF AND rnopTable.OPRUN = a.RUNNO and RnopTable.OPNO = a.CUROPNO" & vbCrLf
SQL = SQL & "--join ShopTable on SHPREF = OPSHOP -- AND SHPSERVICE = 1" & vbCrLf
SQL = SQL & "--join poitTable on PIRUNPART = RUNREF AND PIRUNNO = RUNNO and PIRUNOPNO = a.CUROPNO" & vbCrLf
SQL = SQL & "--join PohdTable on poitTable.PINUMBER = PohdTable.PONUMBER" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "UPDATE a SET a.PONUMBER = poitTable.PINUMBER, a.POVENDOR = PohdTable.POVENDOR" & vbCrLf
SQL = SQL & "FROM #tempRunOpDet a" & vbCrLf
SQL = SQL & "join rnopTable on rnopTable.Opref = a.RUNREF AND rnopTable.OPRUN = a.RUNNO and RnopTable.OPNO = a.CUROPNO" & vbCrLf
SQL = SQL & "join ShopTable on SHPREF = OPSHOP -- AND SHPSERVICE = 1 not required" & vbCrLf
SQL = SQL & "join poitTable on PIRUNPART = RUNREF AND PIRUNNO = RUNNO and PIRUNOPNO = a.CUROPNO" & vbCrLf
SQL = SQL & "join PohdTable on poitTable.PINUMBER = PohdTable.PONUMBER" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "--select * from #tempRunOpDet" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "SELECT DISTINCT a.NextOPNO, a.NextOPSHOP, a.NextOPCENTER, a.PONUMBER, RnopTable.OPSHOP as CurOPShop," & vbCrLf
SQL = SQL & "RnopTable.OPCENTER as CurOPCenter, POVENDOR, RunsTable.*" & vbCrLf
SQL = SQL & "FROM runstable, RnopTable, #tempRunOpDet a" & vbCrLf
SQL = SQL & "WHERE a.RunRef = runstable.Runref AND a.RunNo = runstable.RunNO" & vbCrLf
SQL = SQL & "AND RnopTable.OPREF = RunsTable.runref" & vbCrLf
SQL = SQL & "AND RnopTable.OPRUN = RunsTable.runno" & vbCrLf
SQL = SQL & "and RunsTable.runopcur = RnopTable.OPNO" & vbCrLf
SQL = SQL & "AND a.RunRef = RnopTable.OPREF AND a.RunNo = RnopTable.OPRUN" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "DROP table #tempRunOpDet" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "END" & vbCrLf
ExecuteScript True, SQL



''''''''''''''''''''''''''''''''''''''''''''''''''

      ' update the version
      ExecuteScript False, "Update Version Set Version = " & newver

   End If
End Function


Private Function UpdateDatabase112()

'update database version template
'set version at top of this file
'set version below
'add SQL updates


   Dim SQL As String
   SQL = ""

   newver = 191     ' set actual version
   If ver < newver Then

      clsADOCon.ADOErrNum = 0

''''''''''''''''''''''''''''''''''''''''''''''''''


SQL = "DropStoredProcedureIfExists 'RptArAgingBase'" & vbCrLf
ExecuteScript True, SQL

SQL = "create procedure [dbo].[RptArAgingBase]" & vbCrLf
SQL = SQL & "@AsOfDate date," & vbCrLf
SQL = SQL & "@Customer varchar(20)   -- blank for all" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "as" & vbCrLf
SQL = SQL & "/* Detail AR Aging Base sp" & vbCrLf
SQL = SQL & "test" & vbCrLf
SQL = SQL & "exec RptArAgingBase '3/1/2019', 'BCA614'" & vbCrLf
SQL = SQL & "exec RptArAgingBase '3/1/2019', ''" & vbCrLf
SQL = SQL & "*/" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "SET NOCOUNT ON" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "IF OBJECT_ID('tempdb..##TempArAging') IS NOT NULL" & vbCrLf
SQL = SQL & "begin" & vbCrLf
SQL = SQL & "drop table ##TempArAging" & vbCrLf
SQL = SQL & "end" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- get all invoices existing but not fully paid on desired date" & vbCrLf
SQL = SQL & "select rtrim(cust.CUNAME) as [Customer Name], rtrim(inv.INVCUST) as Nickname, INVNO as [Inv #]," & vbCrLf
SQL = SQL & "cast(INVDATE as DATE) AS [Inv Date], INVTOTAL as [Inv Total], isnull(x.Debits,0) as [Amt Paid]," & vbCrLf
SQL = SQL & "isnull(x.ct,0) as ct, case when INVCHECKDATE is null then '' else convert(varchar(10),INVCHECKDATE,101) end as [Ck Date]," & vbCrLf
SQL = SQL & "cast(0 as int) as [Age Days]," & vbCrLf
SQL = SQL & "cast(0 as decimal(15,2)) as [Amt Due]," & vbCrLf
SQL = SQL & "cast(0 as decimal(15,2)) as [0-30 Days]," & vbCrLf
SQL = SQL & "cast(0 as decimal(15,2)) as [31-60 Days]," & vbCrLf
SQL = SQL & "cast(0 as decimal(15,2)) as [61-90 Days]," & vbCrLf
SQL = SQL & "cast(0 as decimal(15,2)) as [91-120 Days]," & vbCrLf
SQL = SQL & "cast(0 as decimal(15,2)) as [121+ Days]" & vbCrLf
SQL = SQL & "into ##TempArAging" & vbCrLf
SQL = SQL & "from CihdTable as inv" & vbCrLf
SQL = SQL & "join CustTable cust on cust.CUREF = inv.INVCUST" & vbCrLf
SQL = SQL & "left join (select DCCUST, DCINVNO, isnull(sum(DCDEBIT),0) AS Debits, COUNT(*) AS ct from JritTable" & vbCrLf
SQL = SQL & "where DCHEAD like 'cr%'" & vbCrLf
SQL = SQL & "AND DCDATE <= @AsOfDate" & vbCrLf
SQL = SQL & "--and DCCUST = inv.INVCUST" & vbCrLf
SQL = SQL & "and DCINVNO <> 0" & vbCrLf
SQL = SQL & "and DCDEBIT <> 0" & vbCrLf
SQL = SQL & "group by DCCUST, DCINVNO) x on x.DCCUST = inv.INVCUST and x.DCINVNO = inv.INVNO" & vbCrLf
SQL = SQL & "where INVDATE <= @AsOfDate" & vbCrLf
SQL = SQL & "and INVCUST like @Customer + '%'" & vbCrLf
SQL = SQL & "and INVTOTAL <> isnull(x.Debits,0)" & vbCrLf
SQL = SQL & "and (INVPIF = 0" & vbCrLf
SQL = SQL & "or isnull(INVCHECKDATE, DATEFROMPARTS(2050,1,1)) > @AsOfDate)" & vbCrLf
SQL = SQL & "ORDER by INVCUST, INVDATE, INVNO" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "update ##TempArAging set [Amt Due] = [Inv Total] - [Amt Paid]" & vbCrLf
SQL = SQL & "update ##TempArAging set [Age Days] = DATEDIFF(day,[Inv Date],@AsOfDate)" & vbCrLf
SQL = SQL & "update ##TempArAging set [0-30 Days] = case when [Age Days] between 0 and 30 then [Amt Due] else 0 end" & vbCrLf
SQL = SQL & "update ##TempArAging set [31-60 Days] = case when [Age Days] between 31 and 60 then [Amt Due] else 0 end" & vbCrLf
SQL = SQL & "update ##TempArAging set [61-90 Days] = case when [Age Days] between 61 and 90 then [Amt Due] else 0 end" & vbCrLf
SQL = SQL & "update ##TempArAging set [91-120 Days] = case when [Age Days] between 91 and 120 then [Amt Due] else 0 end" & vbCrLf
SQL = SQL & "update ##TempArAging set [121+ Days] = case when [Age Days] > 120 then [Amt Due] else 0 end" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "--select * from ##TempArAging order by [Customer Name], [Inv #]" & vbCrLf
SQL = SQL & "--select INVCUST, count(*) as ct, sum([Amt Due]) AS DUE," & vbCrLf
SQL = SQL & "--SUM([0-30 Days]) as [0-30 Days]," & vbCrLf
SQL = SQL & "--SUM([31-60 Days]) as [31-60 Days]," & vbCrLf
SQL = SQL & "--SUM([61-90 Days]) as [61-90 Days]," & vbCrLf
SQL = SQL & "--SUM([91-120 Days]) as [91-120 Days]," & vbCrLf
SQL = SQL & "--SUM([121+ Days]) as [121+ Days]" & vbCrLf
SQL = SQL & "--from ##TempArAging GROUP BY INVCUST ORDER BY INVCUST" & vbCrLf
ExecuteScript True, SQL

'----------------------------------------------
'----------------------------------------------

SQL = "DropStoredProcedureIfExists 'RptArAgingDetail'" & vbCrLf
ExecuteScript True, SQL

SQL = "create procedure [dbo].[RptArAgingDetail]" & vbCrLf
SQL = SQL & "@AsOfDate date," & vbCrLf
SQL = SQL & "@Customer varchar(20)   -- blank for all" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "as" & vbCrLf
SQL = SQL & "/* Detail AR Aging" & vbCrLf
SQL = SQL & "test" & vbCrLf
SQL = SQL & "exec RptArAgingDetail '3/1/2019', 'BCA614'" & vbCrLf
SQL = SQL & "exec RptArAgingDetail '3/1/2019', ''" & vbCrLf
SQL = SQL & "*/" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "SET NOCOUNT ON" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "exec RptArAgingBase @AsofDate, @Customer" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "--select * from ##TempArAging order by [Customer Name], [Inv #]" & vbCrLf
ExecuteScript True, SQL

'----------------------------------------------
'----------------------------------------------


SQL = "DropStoredProcedureIfExists 'RptArAgingSummary'" & vbCrLf
ExecuteScript True, SQL

SQL = "create procedure [dbo].[RptArAgingSummary]" & vbCrLf
SQL = SQL & "@AsOfDate date" & vbCrLf
SQL = SQL & "as" & vbCrLf
SQL = SQL & "/* test" & vbCrLf
SQL = SQL & "test" & vbCrLf
SQL = SQL & "exec RptArAgingSummary '3/1/2019'" & vbCrLf
SQL = SQL & "*/" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "exec RptArAgingBase @AsOfDate, ''" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "select [Customer Name], Nickname, count(*) as INVOICES, sum([Amt Due]) as Total," & vbCrLf
SQL = SQL & "sum([0-30 Days]) as [0-30 Days]," & vbCrLf
SQL = SQL & "sum([31-60 Days]) as [31-60 Days]," & vbCrLf
SQL = SQL & "sum([61-90 Days]) as [61-90 Days]," & vbCrLf
SQL = SQL & "sum([91-120 Days]) as [91-120 Days]," & vbCrLf
SQL = SQL & "sum([121+ Days]) as [121+ Days]" & vbCrLf
SQL = SQL & "from ##TempArAging" & vbCrLf
SQL = SQL & "group by [Customer Name],[NickName]" & vbCrLf
SQL = SQL & "order by [Customer Name]" & vbCrLf
ExecuteScript True, SQL

SQL = "dropstoredprocedureifexists 'InsertMultilevelMo'" & vbCrLf
ExecuteScript True, SQL

SQL = "create procedure [dbo].[InsertMultilevelMo]" & vbCrLf
SQL = SQL & "@ParentPart char(30)," & vbCrLf
SQL = SQL & "@ParentNumber int," & vbCrLf
SQL = SQL & "@ChildPart char(30)," & vbCrLf
SQL = SQL & "@ChildNumber int" & vbCrLf
SQL = SQL & "as" & vbCrLf
SQL = SQL & "/* insert child MO below parent MO" & vbCrLf
SQL = SQL & "test" & vbCrLf
SQL = SQL & "exec InsertMultilevelMo '100T14882', 1, '1003110042D02', 26" & vbCrLf
SQL = SQL & "exec InsertMultilevelMo '198040001', 9804, '198401301', 9840" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "*/" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- check that the max of 5 levels is not exceeded." & vbCrLf
SQL = SQL & "-- also check that there is no circular reference" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- first find all children of the child" & vbCrLf
SQL = SQL & "SET NOCOUNT ON" & vbCrLf
SQL = SQL & "declare @Levels table" & vbCrLf
SQL = SQL & "(" & vbCrLf
SQL = SQL & "Lev int," & vbCrLf
SQL = SQL & "MoRef char(30) ," & vbCrLf
SQL = SQL & "MoNo int" & vbCrLf
SQL = SQL & ")" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & ";WITH CTE (Lev, MoPart, MoRun)" & vbCrLf
SQL = SQL & "AS" & vbCrLf
SQL = SQL & "(" & vbCrLf
SQL = SQL & "SELECT 6 as Lev, @ChildPart as MoPart, @ChildNumber as MoRun" & vbCrLf
SQL = SQL & "UNION ALL" & vbCrLf
SQL = SQL & "SELECT Lev + 1 as Lev, RUNREF as MoPart, RUNNO as MoRun" & vbCrLf
SQL = SQL & "FROM RunsTable child" & vbCrLf
SQL = SQL & "join CTE on child.RunParentRunRef = CTE.MoPart and child.RunParentRunNo = CTE.MoRun" & vbCrLf
SQL = SQL & "where Lev < 10" & vbCrLf
SQL = SQL & ")" & vbCrLf
SQL = SQL & "insert @Levels" & vbCrLf
SQL = SQL & "SELECT * from CTE" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- now find all the parents" & vbCrLf
SQL = SQL & ";WITH CTE (Lev, MoPart, MoRun)" & vbCrLf
SQL = SQL & "AS" & vbCrLf
SQL = SQL & "(" & vbCrLf
SQL = SQL & "SELECT 5 as Lev, @ParentPart as MoPart, @ParentNumber as MoRun" & vbCrLf
SQL = SQL & "UNION ALL" & vbCrLf
SQL = SQL & "SELECT Lev - 1, parent.RUNREF, parent.RUNNO" & vbCrLf
SQL = SQL & "FROM RunsTable parent" & vbCrLf
SQL = SQL & "join RunsTable child on child.RunParentRunRef = parent.RUNREF and child.RunParentRunNo = parent.RUNNO" & vbCrLf
SQL = SQL & "join CTE on child.RUNREF = CTE.MoPart and child.RUNNO = CTE.MoRun and CTE.Lev = Lev" & vbCrLf
SQL = SQL & "where Lev > 1" & vbCrLf
SQL = SQL & ")" & vbCrLf
SQL = SQL & "insert @Levels" & vbCrLf
SQL = SQL & "SELECT * from CTE" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- if more than 5 levels do not allow insert" & vbCrLf
SQL = SQL & "if (select count(distinct Lev) from @Levels) > 5" & vbCrLf
SQL = SQL & "begin" & vbCrLf
SQL = SQL & "select 'More than 5 levels not allowed'" & vbCrLf
SQL = SQL & "return" & vbCrLf
SQL = SQL & "end" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- if same MO more than once do not allow" & vbCrLf
SQL = SQL & "declare @ct int, @dupPart varchar(30), @dupNo int" & vbCrLf
SQL = SQL & "select top 1 @ct = ct, @dupPart = rtrim(MoRef), @dupNo = Mono" & vbCrLf
SQL = SQL & "from (select count(*) as ct, MoRef,  MoNo from @Levels group by MoRef, Mono having count(*) > 1) x" & vbCrLf
SQL = SQL & "if @ct is not null" & vbCrLf
SQL = SQL & "begin" & vbCrLf
SQL = SQL & "select 'MO ' + @DupPart + ' run ' + cast(@DupNo as varchar(10)) + ' cannot appear more than once'" & vbCrLf
SQL = SQL & "return" & vbCrLf
SQL = SQL & "end" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- everything is OK.  Link the MO to its parent" & vbCrLf
SQL = SQL & "SET NOCOUNT OFF" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "update RunsTable set RunParentRunRef = @ParentPart, RunParentRunNo = @ParentNumber" & vbCrLf
SQL = SQL & "where RUNREF = @ChildPart and RUNNO = @ChildNumber" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "if @@ROWCOUNT > 0" & vbCrLf
SQL = SQL & "begin" & vbCrLf
SQL = SQL & "select '' as result    -- indicate everything is OK" & vbCrLf
SQL = SQL & "return" & vbCrLf
SQL = SQL & "end" & vbCrLf
SQL = SQL & "else" & vbCrLf
SQL = SQL & "begin" & vbCrLf
SQL = SQL & "select 'unable to link MOs' as result" & vbCrLf
SQL = SQL & "return" & vbCrLf
SQL = SQL & "end" & vbCrLf
SQL = SQL & "" & vbCrLf
ExecuteScript True, SQL


''''''''''''''''''''''''''''''''''''''''''''''''''

      ' update the version
      ExecuteScript False, "Update Version Set Version = " & newver

   End If
End Function


Private Function UpdateDatabase113()

'update database version template
'set version at top of this file
'set version below
'add SQL updates


   Dim SQL As String
   SQL = ""

   newver = 192     ' set actual version
   If ver < newver Then

      clsADOCon.ADOErrNum = 0

''''''''''''''''''''''''''''''''''''''''''''''''''

SQL = "DropStoredProcedureIfExists 'RptArAgingBase'" & vbCrLf
ExecuteScript True, SQL

SQL = "create procedure [dbo].[RptArAgingBase]" & vbCrLf
SQL = SQL & "@AsOfDate date," & vbCrLf
SQL = SQL & "@Customer varchar(20)   -- blank for all" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "as" & vbCrLf
SQL = SQL & "/* Detail AR Aging Base sp" & vbCrLf
SQL = SQL & "v2 6/17/2019" & vbCrLf
SQL = SQL & "take into account canceled invoice indicator" & vbCrLf
SQL = SQL & "Allow for invoices paid by a different customer" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "test" & vbCrLf
SQL = SQL & "exec RptArAgingBase '3/1/2019', 'BCA614'" & vbCrLf
SQL = SQL & "exec RptArAgingBase '3/1/2019', ''" & vbCrLf
SQL = SQL & "*/" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "SET NOCOUNT ON" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "IF OBJECT_ID('tempdb..##TempArAging') IS NOT NULL" & vbCrLf
SQL = SQL & "begin" & vbCrLf
SQL = SQL & "drop table ##TempArAging" & vbCrLf
SQL = SQL & "end" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- get all invoices existing but not fully paid on desired date" & vbCrLf
SQL = SQL & "select rtrim(cust.CUNAME) as [Customer Name], rtrim(inv.INVCUST) as Nickname, INVNO as [Inv #]," & vbCrLf
SQL = SQL & "cast(INVDATE as DATE) AS [Inv Date], INVTOTAL as [Inv Total], isnull(x.Debits,0) as [Amt Paid]," & vbCrLf
SQL = SQL & "isnull(x.ct,0) as ct, case when INVCHECKDATE is null then '' else convert(varchar(10),INVCHECKDATE,101) end as [Ck Date]," & vbCrLf
SQL = SQL & "cast(0 as int) as [Age Days]," & vbCrLf
SQL = SQL & "cast(0 as decimal(15,2)) as [Amt Due]," & vbCrLf
SQL = SQL & "cast(0 as decimal(15,2)) as [0-30 Days]," & vbCrLf
SQL = SQL & "cast(0 as decimal(15,2)) as [31-60 Days]," & vbCrLf
SQL = SQL & "cast(0 as decimal(15,2)) as [61-90 Days]," & vbCrLf
SQL = SQL & "cast(0 as decimal(15,2)) as [91-120 Days]," & vbCrLf
SQL = SQL & "cast(0 as decimal(15,2)) as [121+ Days]" & vbCrLf
SQL = SQL & "into ##TempArAging" & vbCrLf
SQL = SQL & "from CihdTable as inv" & vbCrLf
SQL = SQL & "join CustTable cust on cust.CUREF = inv.INVCUST" & vbCrLf
SQL = SQL & "left join (select DCINVNO, isnull(sum(DCDEBIT),0) AS Debits, COUNT(*) AS ct from JritTable" & vbCrLf
SQL = SQL & "where DCHEAD like 'cr%'" & vbCrLf
SQL = SQL & "AND DCDATE <= @AsOfDate" & vbCrLf
SQL = SQL & "and DCINVNO <> 0" & vbCrLf
SQL = SQL & "and DCDEBIT <> 0" & vbCrLf
SQL = SQL & "group by DCINVNO) x on x.DCINVNO = inv.INVNO" & vbCrLf
SQL = SQL & "where INVDATE <= @AsOfDate" & vbCrLf
SQL = SQL & "and INVCUST like @Customer + '%'" & vbCrLf
SQL = SQL & "and INVTOTAL <> isnull(x.Debits,0)" & vbCrLf
SQL = SQL & "and INVCANCELED = 0" & vbCrLf
SQL = SQL & "and (INVPIF = 0" & vbCrLf
SQL = SQL & "or isnull(INVCHECKDATE, DATEFROMPARTS(2050,1,1)) > @AsOfDate)" & vbCrLf
SQL = SQL & "ORDER by INVCUST, INVDATE, INVNO" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "update ##TempArAging set [Amt Due] = [Inv Total] - [Amt Paid]" & vbCrLf
SQL = SQL & "update ##TempArAging set [Age Days] = DATEDIFF(day,[Inv Date],@AsOfDate)" & vbCrLf
SQL = SQL & "update ##TempArAging set [0-30 Days] = case when [Age Days] between 0 and 30 then [Amt Due] else 0 end" & vbCrLf
SQL = SQL & "update ##TempArAging set [31-60 Days] = case when [Age Days] between 31 and 60 then [Amt Due] else 0 end" & vbCrLf
SQL = SQL & "update ##TempArAging set [61-90 Days] = case when [Age Days] between 61 and 90 then [Amt Due] else 0 end" & vbCrLf
SQL = SQL & "update ##TempArAging set [91-120 Days] = case when [Age Days] between 91 and 120 then [Amt Due] else 0 end" & vbCrLf
SQL = SQL & "update ##TempArAging set [121+ Days] = case when [Age Days] > 120 then [Amt Due] else 0 end" & vbCrLf
ExecuteScript True, SQL

SQL = "dropstoredprocedureifexists 'RptArAgingDetail'" & vbCrLf
ExecuteScript True, SQL

SQL = "create procedure [dbo].[RptArAgingDetail]" & vbCrLf
SQL = SQL & "@AsOfDate date," & vbCrLf
SQL = SQL & "@Customer varchar(20)   -- blank for all" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "as" & vbCrLf
SQL = SQL & "/* Detail AR Aging" & vbCrLf
SQL = SQL & "test" & vbCrLf
SQL = SQL & "exec RptArAgingDetail '6/17/2019', 'BGSSEA'" & vbCrLf
SQL = SQL & "exec RptArAgingDetail '3/1/2019', 'BCA614'" & vbCrLf
SQL = SQL & "exec RptArAgingDetail '3/1/2019', ''" & vbCrLf
SQL = SQL & "*/" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "SET NOCOUNT ON" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "exec RptArAgingBase @AsofDate, @Customer" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "select * from ##TempArAging order by [Customer Name], [Inv #]" & vbCrLf
SQL = SQL & "" & vbCrLf
ExecuteScript True, SQL

SQL = "DropStoredProcedureIfExists 'RptMultilevelMoCostAnalysis'" & vbCrLf
ExecuteScript True, SQL

SQL = "create procedure [dbo].[RptMultilevelMoCostAnalysis]" & vbCrLf
SQL = SQL & "@MoPart char(30)," & vbCrLf
SQL = SQL & "@MoNumber int" & vbCrLf
SQL = SQL & "as" & vbCrLf
SQL = SQL & "/* test" & vbCrLf
SQL = SQL & "RptMultilevelMoCostAnalysis '174570301',7976" & vbCrLf
SQL = SQL & "select top 100 * from tcittable" & vbCrLf
SQL = SQL & "*/" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- make a list of MOs at each level" & vbCrLf
SQL = SQL & ";WITH CTE (Lev, MoPart, MoRun)" & vbCrLf
SQL = SQL & "AS" & vbCrLf
SQL = SQL & "(" & vbCrLf
SQL = SQL & "SELECT 1, @MoPart, @MoNumber" & vbCrLf
SQL = SQL & "UNION ALL" & vbCrLf
SQL = SQL & "SELECT Lev + 1, RUNREF, RUNNO" & vbCrLf
SQL = SQL & "FROM RunsTable child" & vbCrLf
SQL = SQL & "join CTE on child.RunParentRunRef = CTE.MoPart and child.RunParentRunNo = CTE.MoRun" & vbCrLf
SQL = SQL & ")" & vbCrLf
SQL = SQL & "SELECT *" & vbCrLf
SQL = SQL & "into #temp" & vbCrLf
SQL = SQL & "from CTE" & vbCrLf
SQL = SQL & "order by Lev, MoPart, MoRun" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "select" & vbCrLf
SQL = SQL & "Lev as [Level]," & vbCrLf
SQL = SQL & "rtrim(pt.PARTNUM) as [MO Part]," & vbCrLf
SQL = SQL & "MoRun as [MO Run]," & vbCrLf
SQL = SQL & "'Labor' as [Type]," & vbCrLf
SQL = SQL & "cast(sum(TCHOURS) as decimal(12,2)) as [Hours]," & vbCrLf
SQL = SQL & "cast(sum(TCHOURS*TCRATE) as decimal(12,2)) as Labor," & vbCrLf
SQL = SQL & "cast(sum(TCHOURS*TCOHRATE) as decimal(12,2)) as OH," & vbCrLf
SQL = SQL & "null as Part," & vbCrLf
SQL = SQL & "null as [Part Desc]," & vbCrLf
SQL = SQL & "null as Qty," & vbCrLf
SQL = SQL & "null as [Unit Cost]," & vbCrLf
SQL = SQL & "null as [Ext Matl]," & vbCrLf
SQL = SQL & "null as [Ext Svc]," & vbCrLf
SQL = SQL & "'' as Vendor" & vbCrLf
SQL = SQL & "from TcitTable tc" & vbCrLf
SQL = SQL & "join #temp tmp on tmp.MoPart = tc.TCPARTREF and tmp.MoRun = tc.TCRUNNO" & vbCrLf
SQL = SQL & "join PartTable pt on pt.PARTREF = tc.TCPARTREF" & vbCrLf
SQL = SQL & "group by Lev,pt.PARTNUM,MoRun" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- now do parts and services" & vbCrLf
SQL = SQL & "union all" & vbCrLf
SQL = SQL & "select distinct" & vbCrLf
SQL = SQL & "Lev as [Level]," & vbCrLf
SQL = SQL & "rtrim(mopart.PARTNUM) as [MO Part]," & vbCrLf
SQL = SQL & "MoRun as [MO Run]," & vbCrLf
SQL = SQL & "case when pt.PALEVEL = 5 then 'Svc' else 'Matl' end as [Type]," & vbCrLf
SQL = SQL & "null as [Hours]," & vbCrLf
SQL = SQL & "null as [Labor]," & vbCrLf
SQL = SQL & "null as [OH]," & vbCrLf
SQL = SQL & "rtrim(pt.PARTNUM) as Part," & vbCrLf
SQL = SQL & "rtrim(pt.PADESC) as [Part Desc]," & vbCrLf
SQL = SQL & "PKAQTY as Qty," & vbCrLf

'SQL = SQL & "INAMT as [Unit Cost]," & vbCrLf
'SQL = SQL & "--cast(INAMT * PKAQTY as decimal(12,2)) as [Ext Cost]," & vbCrLf
'SQL = SQL & "case when pt.PALEVEL <> 5 then cast(INAMT * PKAQTY as decimal(12,2)) else null end as [Ext Matl]," & vbCrLf

SQL = SQL & "case when INAMT=0 then isnull(poi.PIAMT,0) else INAMT end as [Unit Cost]," & vbCrLf
SQL = SQL & "case when pt.PALEVEL <> 5 then cast(INAMT * PKAQTY as decimal(12,2)) else null end as [Ext Matl]," & vbCrLf

SQL = SQL & "case when pt.PALEVEL = 5 then cast(INAMT * PKAQTY as decimal(12,2)) else null end as [Ext Svc]," & vbCrLf
SQL = SQL & "isnull(rtrim(POVENDOR),'') + ' ' + cast(PINUMBER as varchar(8)) + ' ' + cast(PIITEM as varchar(5)) + PIREV as Vendor" & vbCrLf
SQL = SQL & "from MopkTable p" & vbCrLf
SQL = SQL & "join #temp tmp on tmp.MoPart = p.PKMOPART and tmp.MoRun = p.PKMORUN" & vbCrLf
SQL = SQL & "--join RunsTable r on r.RUNREF = p.PKMOPART and r.RUNNO = p.PKMORUN and r.RUNSTATUS <> 'CA'" & vbCrLf
SQL = SQL & "join PartTable pt ON PT.PARTREF = p.PKPARTREF" & vbCrLf
SQL = SQL & "join InvaTable inv on inv.INPART = p.PKPARTREF and inv.INMOPART = p.PKMOPART and inv.INMORUN = p.PKMORUN" & vbCrLf
SQL = SQL & "   and -inv.INAQTY = p.PKAQTY" & vbCrLf
SQL = SQL & "left join PoitTable poi on poi.PINUMBER = inv.INPONUMBER and poi.PIITEM = inv.INPOITEM and inv.inporev = poi.PIREV" & vbCrLf
SQL = SQL & "left join PohdTable ph on ph.PONUMBER = poi.PINUMBER" & vbCrLf
SQL = SQL & "join PartTable mopart on mopart.PARTREF = tmp.MoPart" & vbCrLf
SQL = SQL & "where INTYPE = 10" & vbCrLf
SQL = SQL & "--order by Lev, MoPart, MoRun,[Type]" & vbCrLf
SQL = SQL & "order by [Level],[MO Part],[MO Run],[Type]" & vbCrLf
SQL = SQL & "" & vbCrLf
ExecuteScript True, SQL

SQL = "DropStoredProcedureIfExists 'RptArAgingBase'" & vbCrLf
ExecuteScript True, SQL

SQL = "create procedure [dbo].[RptArAgingBase]" & vbCrLf
SQL = SQL & "@AsOfDate date," & vbCrLf
SQL = SQL & "@Customer varchar(20)   -- blank for all" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "as" & vbCrLf
SQL = SQL & "/* Detail AR Aging Base sp" & vbCrLf
SQL = SQL & "v2 6/17/2019" & vbCrLf
SQL = SQL & "take into account canceled invoice indicator" & vbCrLf
SQL = SQL & "Allow for invoices paid by a different customer" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "test" & vbCrLf
SQL = SQL & "exec RptArAgingBase '6/21/2019', 'ASTK'" & vbCrLf
SQL = SQL & "SELECT * from ##TempArAging" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "exec RptArAgingBase '6/21/2019', ''" & vbCrLf
SQL = SQL & "SELECT * from ##TempArAging where [amt due] <> [inv total] order by nickname" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "exec RptArAgingBase '3/1/2019', ''" & vbCrLf
SQL = SQL & "*/" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "SET NOCOUNT ON" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "declare @ArAcct varchar(12)" & vbCrLf
SQL = SQL & "select @ArAcct = COSJARACCT from ComnTable" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "IF OBJECT_ID('tempdb..##TempArAging') IS NOT NULL" & vbCrLf
SQL = SQL & "begin" & vbCrLf
SQL = SQL & "drop table ##TempArAging" & vbCrLf
SQL = SQL & "end" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "-- get all invoices existing but not fully paid on desired date" & vbCrLf
SQL = SQL & "select" & vbCrLf
SQL = SQL & "rtrim(cust.CUNAME) as [Customer Name]," & vbCrLf
SQL = SQL & "rtrim(inv.INVCUST) as Nickname," & vbCrLf
SQL = SQL & "INVNO as [Inv #]," & vbCrLf
SQL = SQL & "INVTYPE as TP," & vbCrLf
SQL = SQL & "cast(INVDATE as DATE) AS [Inv Date]," & vbCrLf
SQL = SQL & "INVTOTAL as [Inv Total]," & vbCrLf
SQL = SQL & "isnull(x.Debits,0) as Debits," & vbCrLf
SQL = SQL & "isnull(x.credits,0) as Credits," & vbCrLf
SQL = SQL & "cast(0 as decimal(15,2)) as [Amt Paid]," & vbCrLf
SQL = SQL & "--case when INVTOTAL < 0 THEN INVTOTAL + isnull(x.debits,0) else isnull(x.debits,0) end as [Amt Paid]," & vbCrLf
SQL = SQL & "isnull(x.ct,0) as ct," & vbCrLf
SQL = SQL & "case when INVCHECKDATE is null then '' else convert(varchar(10),INVCHECKDATE,101) end as [Ck Date]," & vbCrLf
SQL = SQL & "cast(0 as int) as [Age Days]," & vbCrLf
SQL = SQL & "cast(0 as decimal(15,2)) as [Amt Due]," & vbCrLf
SQL = SQL & "cast(0 as decimal(15,2)) as [0-30 Days]," & vbCrLf
SQL = SQL & "cast(0 as decimal(15,2)) as [31-60 Days]," & vbCrLf
SQL = SQL & "cast(0 as decimal(15,2)) as [61-90 Days]," & vbCrLf
SQL = SQL & "cast(0 as decimal(15,2)) as [91-120 Days]," & vbCrLf
SQL = SQL & "cast(0 as decimal(15,2)) as [121+ Days]" & vbCrLf
SQL = SQL & "into ##TempArAging" & vbCrLf
SQL = SQL & "from CihdTable as inv" & vbCrLf
SQL = SQL & "join CustTable cust on cust.CUREF = inv.INVCUST" & vbCrLf
SQL = SQL & "left join (select DCINVNO," & vbCrLf
SQL = SQL & "isnull(sum(DCDEBIT),0) AS Debits," & vbCrLf
SQL = SQL & "isnull(sum(DCCREDIT),0) AS Credits," & vbCrLf
SQL = SQL & "COUNT(*) AS ct from JritTable" & vbCrLf
SQL = SQL & "where DCHEAD like 'cr%'" & vbCrLf
SQL = SQL & "and DCACCTNO = @ArAcct" & vbCrLf
SQL = SQL & "AND DCDATE <= @AsOfDate" & vbCrLf
SQL = SQL & "and DCINVNO <> 0" & vbCrLf
SQL = SQL & "--and DCDEBIT <> 0" & vbCrLf
SQL = SQL & "group by DCINVNO) x on x.DCINVNO = inv.INVNO" & vbCrLf
SQL = SQL & "where INVDATE <= @AsOfDate" & vbCrLf
SQL = SQL & "and INVCUST like @Customer + '%'" & vbCrLf
SQL = SQL & "and INVTOTAL <> isnull(x.Debits,0)" & vbCrLf
SQL = SQL & "and INVCANCELED = 0" & vbCrLf
SQL = SQL & "and (INVPIF = 0" & vbCrLf
SQL = SQL & "or isnull(INVCHECKDATE, DATEFROMPARTS(2050,1,1)) > @AsOfDate)" & vbCrLf
SQL = SQL & "ORDER by INVCUST, INVDATE, INVNO" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "update ##TempArAging set [Amt Paid] = sign([Inv Total]) * (Credits -Debits)" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "update ##TempArAging set [Amt Due] = [Inv Total] - [Amt Paid] where [INV TOTAL] >= 0" & vbCrLf
SQL = SQL & "--update ##TempArAging set [Amt Due] = [Amt Paid] - [Inv Total] where [INV TOTAL] < 0" & vbCrLf
SQL = SQL & "update ##TempArAging set [Amt Due] = [Amt Paid] where [INV TOTAL] < 0" & vbCrLf
SQL = SQL & "update ##TempArAging set [Age Days] = DATEDIFF(day,[Inv Date],@AsOfDate)" & vbCrLf
SQL = SQL & "update ##TempArAging set [0-30 Days] = case when [Age Days] between 0 and 30 then [Amt Due] else 0 end" & vbCrLf
SQL = SQL & "update ##TempArAging set [31-60 Days] = case when [Age Days] between 31 and 60 then [Amt Due] else 0 end" & vbCrLf
SQL = SQL & "update ##TempArAging set [61-90 Days] = case when [Age Days] between 61 and 90 then [Amt Due] else 0 end" & vbCrLf
SQL = SQL & "update ##TempArAging set [91-120 Days] = case when [Age Days] between 91 and 120 then [Amt Due] else 0 end" & vbCrLf
SQL = SQL & "update ##TempArAging set [121+ Days] = case when [Age Days] > 120 then [Amt Due] else 0 end" & vbCrLf
ExecuteScript True, SQL

SQL = "dropstoredprocedureifexists 'RptArAgingDetail'" & vbCrLf
ExecuteScript True, SQL

SQL = "create procedure [dbo].[RptArAgingDetail]" & vbCrLf
SQL = SQL & "@AsOfDate date," & vbCrLf
SQL = SQL & "@Customer varchar(20)   -- blank for all" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "as" & vbCrLf
SQL = SQL & "/* Detail AR Aging" & vbCrLf
SQL = SQL & "test" & vbCrLf
SQL = SQL & "exec RptArAgingDetail '6/17/2019', 'BGSSEA'" & vbCrLf
SQL = SQL & "exec RptArAgingDetail '3/1/2019', 'BCA614'" & vbCrLf
SQL = SQL & "exec RptArAgingDetail '3/1/2019', ''" & vbCrLf
SQL = SQL & "*/" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "SET NOCOUNT ON" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "exec RptArAgingBase @AsofDate, @Customer" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "select * from ##TempArAging order by [Customer Name], Nickname, [Inv #]" & vbCrLf
SQL = SQL & "" & vbCrLf
ExecuteScript True, SQL

SQL = "dropstoredprocedureifexists 'RptArAgingSummary'" & vbCrLf
ExecuteScript True, SQL

SQL = "create procedure [dbo].[RptArAgingSummary]" & vbCrLf
SQL = SQL & "@AsOfDate date," & vbCrLf
SQL = SQL & "@Customer varchar(20)   -- blank for all" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "as" & vbCrLf
SQL = SQL & "/* test" & vbCrLf
SQL = SQL & "test" & vbCrLf
SQL = SQL & "exec RptArAgingSummary '6/21/2019', 'ASTK'" & vbCrLf
SQL = SQL & "exec RptArAgingSummary '6/21/2019', ''" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "*/" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "exec RptArAgingBase @AsOfDate, @Customer" & vbCrLf
SQL = SQL & "" & vbCrLf
SQL = SQL & "select [Customer Name], Nickname, count(*) as INVOICES, sum([Amt Due]) as Total," & vbCrLf
SQL = SQL & "sum([0-30 Days]) as [0-30 Days]," & vbCrLf
SQL = SQL & "sum([31-60 Days]) as [31-60 Days]," & vbCrLf
SQL = SQL & "sum([61-90 Days]) as [61-90 Days]," & vbCrLf
SQL = SQL & "sum([91-120 Days]) as [91-120 Days]," & vbCrLf
SQL = SQL & "sum([121+ Days]) as [121+ Days]" & vbCrLf
SQL = SQL & "from ##TempArAging" & vbCrLf
SQL = SQL & "group by [Customer Name],[NickName]" & vbCrLf
SQL = SQL & "order by [Customer Name]" & vbCrLf
ExecuteScript True, SQL




''''''''''''''''''''''''''''''''''''''''''''''''''

      ' update the version
      ExecuteScript False, "Update Version Set Version = " & newver

   End If
End Function


Private Function UpdateDatabaseXX()

'update database version template
'set version at top of this file
'set version below
'add SQL updates


   Dim SQL As String
   SQL = ""

   newver = 999     ' set actual version
   If ver < newver Then

      clsADOCon.ADOErrNum = 0

''''''''''''''''''''''''''''''''''''''''''''''''''


''''''''''''''''''''''''''''''''''''''''''''''''''

      ' update the version
      ExecuteScript False, "Update Version Set Version = " & newver

   End If
End Function











''''''''''''''''''''''''''''''''''

   
Private Function IsUpdateRequired(OldDbVersion As Integer, NewDbVersion As Integer) As Boolean
   'terminates if cannot proceed.
   'returns false if no update required
   'returns true if update required and authorized by and admin

   Err.Clear
   'Dim strFulVer As String
   clsADOCon.ADOErrNum = 0
   sSql = "select * from Updates" & vbCrLf _
      & "where UpdateID = (select max(UpdateID) from Updates)"
   On Error Resume Next
   Dim rdo As ADODB.Recordset
   If clsADOCon.GetDataSet(sSql, rdo) Then
      If clsADOCon.ADOErrNum = 0 Then
         oldRelease = rdo!newRelease
      End If
   Else
      oldRelease = 0
   End If
   
   If IsTestDatabase Then
      oldType = "Test"
   Else
      oldType = "Live"
   End If
   
'   If App.Minor < 10 Then
'    strFulVer = CStr(App.Major) & "0" & CStr(App.Minor)
'   Else
'    strFulVer = CStr(App.Major) & CStr(App.Minor)
'   End If
'
'   newRelease = CInt(strFulVer)
   
   newRelease = 10000& * App.Major + 100& * App.Minor + App.Revision
   
   If InTestMode() Then
      NewType = "Test"
   Else
      NewType = "Live"
   End If
   
   If oldType <> NewType And NewType = "Test" Then
        MsgBox "You cannot update a Live database with a Test Application", vbCritical
        End
   End If
    
   Dim msg As String
   If oldRelease < newRelease Then
      msg = "Old release (" & oldRelease & ") < New release (" & newRelease & ")" & vbCrLf
   ElseIf oldRelease > newRelease Then
      MsgBox "Old release (" & oldRelease & ") > New release (" & newRelease & ")" & vbCrLf _
         & "You cannot proceed.", vbCritical
      End
   End If
   
   If OldDbVersion < NewDbVersion Then
      msg = msg & "Old db version (" & OldDbVersion & ") < New db version (" & NewDbVersion & ")" & vbCrLf
   ElseIf OldDbVersion > NewDbVersion Then
      MsgBox "Old db version (" & OldDbVersion & ") > New db version (" & NewDbVersion & ")" & vbCrLf _
         & "You cannot proceed.", vbCritical
      End
   End If
   
   If oldType <> NewType Then
      msg = msg & "Db type (" & oldType & ") <> Application type (" & NewType & ")" & vbCrLf
   End If
   
   If msg = "" Then
      IsUpdateRequired = False
      Exit Function
   
   Else
      If Secure.UserAdmn = 0 Then
         msg = msg & "An administrator must perform an update before you can proceed."
         MsgBox msg, vbCritical
         End
      Else
         msg = msg & "Do you wish to update the database now?"
         Select Case MsgBox(msg, vbYesNo + vbQuestion + vbDefaultButton2)
         Case vbYes
            IsUpdateRequired = True
         Case Else
            End
         End Select
      End If
   End If
   
End Function



Private Function GetConstraintNme(sTableNme As String, sPartialConstraintNme As String) As String
    Dim RdoCon As ADODB.Recordset
    
    On Error GoTo GCNErr1
    sSql = "select O.name as ConstraintName from sysobjects AS O  left join sysobjects AS T on O.parent_obj = T.id " & vbCrLf _
           & "where isnull(objectproperty(O.id,'IsMSShipped'),1) = 0 and O.name not like '%dtproper%' and O.name not like 'dt[_]%'" & vbCrLf _
           & "and T.name = '" & sTableNme & "' and O.name like '" & sPartialConstraintNme & "%'"
  
   GetConstraintNme = ""
   
    bSqlRows = clsADOCon.GetDataSet(sSql, RdoCon, ES_FORWARD)
    If bSqlRows Then
        GetConstraintNme = "" & RdoCon!ConstraintName
    End If
    Set RdoCon = Nothing
    Exit Function
   
GCNErr1:
    On Error GoTo 0
    GetConstraintNme = ""

End Function

Private Function GetConstrinNameforColumn(sTableNme As String, sColName As String) As String
    Dim RdoCon As ADODB.Recordset
    
    On Error GoTo GCNErr1
  
    sSql = "SELECT c_obj.name" & vbCrLf _
           & "   FROM sysobjects t_obj, sysobjects c_obj," & vbCrLf _
           & "   syscolumns Cols" & vbCrLf _
           & "Where Cols.id = t_obj.id And c_obj.id = Cols.cdefault" & vbCrLf _
           & "   AND t_obj.name = '" & sTableNme & "' AND cols.name = '" & sColName & "'"
   
   GetConstrinNameforColumn = ""
   
    bSqlRows = clsADOCon.GetDataSet(sSql, RdoCon, ES_FORWARD)
    If bSqlRows Then
        GetConstrinNameforColumn = "" & RdoCon!Name
    End If
    Set RdoCon = Nothing
    Exit Function
   
GCNErr1:
    On Error GoTo 0
    GetConstrinNameforColumn = ""

End Function

Private Function NormalizeConstraintNme(sTableNme As String, sOldObjName As String, sNewObjName As String) As Boolean
    Dim RdoCon As ADODB.Recordset
    Dim sOldNme As String
    
    On Error GoTo NSONErr
    If GetConstraintNme(sTableNme, sNewObjName) = sNewObjName Then
        NormalizeConstraintNme = True
        Exit Function
    End If
    
    
    sOldNme = GetConstraintNme(sTableNme, sOldObjName)
    
    ExecuteScript True, "exec sp_rename '" & sOldNme & "','" & sNewObjName & "',OBJECT"
    NormalizeConstraintNme = True
    Exit Function
    
NSONErr:
    On Error GoTo 0
    NormalizeConstraintNme = False

End Function

Private Function CheckSeedDataExits(sSeedSql As String)
    
   Dim RdoCon As ADODB.Recordset
   
   On Error GoTo ERR1
      
   bSqlRows = clsADOCon.GetDataSet(sSql, RdoCon, ES_FORWARD)
   If bSqlRows Then
       CheckSeedDataExits = True
   Else
       CheckSeedDataExits = False
   End If
   Set RdoCon = Nothing
   Exit Function
   
ERR1:
    CheckSeedDataExits = False

End Function



Private Function StoredProcedureExists(sProcNme As String) As Boolean
   Dim RdoProc As ADODB.Recordset
   Dim iProcedureID As Double
   
   
   On Error GoTo modErr1
   
   StoredProcedureExists = False
   sSql = "SELECT OBJECT_ID('" & sProcNme & "') AS StoredProcID"
   bSqlRows = clsADOCon.GetDataSet(sSql, RdoProc, ES_FORWARD)
   If bSqlRows Then
    iProcedureID = Val("" & RdoProc!StoredProcID)
    If iProcedureID > 0 Then StoredProcedureExists = True
   End If
   Set RdoProc = Nothing
   Exit Function
   
modErr1:
   On Error GoTo 0
   StoredProcedureExists = False
End Function


